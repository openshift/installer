// Copyright 2023 Google LLC. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package monitoring

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl"
)

func (r *Dashboard) validate() error {

	if err := dcl.ValidateAtMostOneOfFieldsSet([]string{"GridLayout", "MosaicLayout", "RowLayout", "ColumnLayout"}, r.GridLayout, r.MosaicLayout, r.RowLayout, r.ColumnLayout); err != nil {
		return err
	}
	if err := dcl.RequiredParameter(r.Name, "Name"); err != nil {
		return err
	}
	if err := dcl.Required(r, "displayName"); err != nil {
		return err
	}
	if err := dcl.RequiredParameter(r.Project, "Project"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.GridLayout) {
		if err := r.GridLayout.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.MosaicLayout) {
		if err := r.MosaicLayout.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RowLayout) {
		if err := r.RowLayout.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ColumnLayout) {
		if err := r.ColumnLayout.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayout) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgets) validate() error {
	if err := dcl.ValidateAtMostOneOfFieldsSet([]string{"XyChart", "Scorecard", "Text", "Blank", "LogsPanel"}, r.XyChart, r.Scorecard, r.Text, r.Blank, r.LogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XyChart) {
		if err := r.XyChart.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Scorecard) {
		if err := r.Scorecard.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Text) {
		if err := r.Text.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Blank) {
		if err := r.Blank.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.LogsPanel) {
		if err := r.LogsPanel.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChart) validate() error {
	if err := dcl.Required(r, "dataSets"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XAxis) {
		if err := r.XAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.YAxis) {
		if err := r.YAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ChartOptions) {
		if err := r.ChartOptions.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSets) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartThresholds) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartXAxis) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartYAxis) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsXyChartChartOptions) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecard) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.GaugeView) {
		if err := r.GaugeView.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SparkChartView) {
		if err := r.SparkChartView.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardGaugeView) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardSparkChartView) validate() error {
	if err := dcl.Required(r, "sparkChartType"); err != nil {
		return err
	}
	return nil
}
func (r *DashboardGridLayoutWidgetsScorecardThresholds) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsText) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsBlank) validate() error {
	return nil
}
func (r *DashboardGridLayoutWidgetsLogsPanel) validate() error {
	return nil
}
func (r *DashboardMosaicLayout) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTiles) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Widget) {
		if err := r.Widget.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidget) validate() error {
	if err := dcl.ValidateAtMostOneOfFieldsSet([]string{"XyChart", "Scorecard", "Text", "Blank", "LogsPanel"}, r.XyChart, r.Scorecard, r.Text, r.Blank, r.LogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XyChart) {
		if err := r.XyChart.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Scorecard) {
		if err := r.Scorecard.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Text) {
		if err := r.Text.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Blank) {
		if err := r.Blank.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.LogsPanel) {
		if err := r.LogsPanel.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChart) validate() error {
	if err := dcl.Required(r, "dataSets"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XAxis) {
		if err := r.XAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.YAxis) {
		if err := r.YAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ChartOptions) {
		if err := r.ChartOptions.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSets) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartThresholds) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartXAxis) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartYAxis) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetXyChartChartOptions) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecard) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.GaugeView) {
		if err := r.GaugeView.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SparkChartView) {
		if err := r.SparkChartView.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardGaugeView) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView) validate() error {
	if err := dcl.Required(r, "sparkChartType"); err != nil {
		return err
	}
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetScorecardThresholds) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetText) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetBlank) validate() error {
	return nil
}
func (r *DashboardMosaicLayoutTilesWidgetLogsPanel) validate() error {
	return nil
}
func (r *DashboardRowLayout) validate() error {
	return nil
}
func (r *DashboardRowLayoutRows) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgets) validate() error {
	if err := dcl.ValidateAtMostOneOfFieldsSet([]string{"XyChart", "Scorecard", "Text", "Blank", "LogsPanel"}, r.XyChart, r.Scorecard, r.Text, r.Blank, r.LogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XyChart) {
		if err := r.XyChart.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Scorecard) {
		if err := r.Scorecard.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Text) {
		if err := r.Text.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Blank) {
		if err := r.Blank.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.LogsPanel) {
		if err := r.LogsPanel.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChart) validate() error {
	if err := dcl.Required(r, "dataSets"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XAxis) {
		if err := r.XAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.YAxis) {
		if err := r.YAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ChartOptions) {
		if err := r.ChartOptions.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSets) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartThresholds) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartXAxis) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartYAxis) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsXyChartChartOptions) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecard) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.GaugeView) {
		if err := r.GaugeView.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SparkChartView) {
		if err := r.SparkChartView.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardGaugeView) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardSparkChartView) validate() error {
	if err := dcl.Required(r, "sparkChartType"); err != nil {
		return err
	}
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsScorecardThresholds) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsText) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsBlank) validate() error {
	return nil
}
func (r *DashboardRowLayoutRowsWidgetsLogsPanel) validate() error {
	return nil
}
func (r *DashboardColumnLayout) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumns) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgets) validate() error {
	if err := dcl.ValidateAtMostOneOfFieldsSet([]string{"XyChart", "Scorecard", "Text", "Blank", "LogsPanel"}, r.XyChart, r.Scorecard, r.Text, r.Blank, r.LogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XyChart) {
		if err := r.XyChart.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Scorecard) {
		if err := r.Scorecard.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Text) {
		if err := r.Text.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Blank) {
		if err := r.Blank.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.LogsPanel) {
		if err := r.LogsPanel.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChart) validate() error {
	if err := dcl.Required(r, "dataSets"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.XAxis) {
		if err := r.XAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.YAxis) {
		if err := r.YAxis.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ChartOptions) {
		if err := r.ChartOptions.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSets) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartThresholds) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartXAxis) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartYAxis) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecard) validate() error {
	if err := dcl.Required(r, "timeSeriesQuery"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesQuery) {
		if err := r.TimeSeriesQuery.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.GaugeView) {
		if err := r.GaugeView.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SparkChartView) {
		if err := r.SparkChartView.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery) validate() error {
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilter) {
		if err := r.TimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.TimeSeriesFilterRatio) {
		if err := r.TimeSeriesFilterRatio.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Numerator) {
		if err := r.Numerator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.Denominator) {
		if err := r.Denominator.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.SecondaryAggregation) {
		if err := r.SecondaryAggregation.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PickTimeSeriesFilter) {
		if err := r.PickTimeSeriesFilter.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) validate() error {
	if err := dcl.Required(r, "filter"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Aggregation) {
		if err := r.Aggregation.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView) validate() error {
	if err := dcl.Required(r, "sparkChartType"); err != nil {
		return err
	}
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsScorecardThresholds) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsText) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsBlank) validate() error {
	return nil
}
func (r *DashboardColumnLayoutColumnsWidgetsLogsPanel) validate() error {
	return nil
}
func (r *Dashboard) basePath() string {
	params := map[string]interface{}{}
	return dcl.Nprintf("https://monitoring.googleapis.com/v1/", params)
}

func (r *Dashboard) getURL(userBasePath string) (string, error) {
	nr := r.urlNormalized()
	params := map[string]interface{}{
		"project": dcl.ValueOrEmptyString(nr.Project),
		"name":    dcl.ValueOrEmptyString(nr.Name),
	}
	return dcl.URL("projects/{{project}}/dashboards/{{name}}", nr.basePath(), userBasePath, params), nil
}

func (r *Dashboard) listURL(userBasePath string) (string, error) {
	nr := r.urlNormalized()
	params := map[string]interface{}{
		"project": dcl.ValueOrEmptyString(nr.Project),
	}
	return dcl.URL("projects/{{project}}/dashboards", nr.basePath(), userBasePath, params), nil

}

func (r *Dashboard) createURL(userBasePath string) (string, error) {
	nr := r.urlNormalized()
	params := map[string]interface{}{
		"project": dcl.ValueOrEmptyString(nr.Project),
	}
	return dcl.URL("projects/{{project}}/dashboards", nr.basePath(), userBasePath, params), nil

}

func (r *Dashboard) deleteURL(userBasePath string) (string, error) {
	nr := r.urlNormalized()
	params := map[string]interface{}{
		"project": dcl.ValueOrEmptyString(nr.Project),
		"name":    dcl.ValueOrEmptyString(nr.Name),
	}
	return dcl.URL("projects/{{project}}/dashboards/{{name}}", nr.basePath(), userBasePath, params), nil
}

// dashboardApiOperation represents a mutable operation in the underlying REST
// API such as Create, Update, or Delete.
type dashboardApiOperation interface {
	do(context.Context, *Dashboard, *Client) error
}

// newUpdateDashboardUpdateDashboardRequest creates a request for an
// Dashboard resource's UpdateDashboard update type by filling in the update
// fields based on the intended state of the resource.
func newUpdateDashboardUpdateDashboardRequest(ctx context.Context, f *Dashboard, c *Client) (map[string]interface{}, error) {
	req := map[string]interface{}{}
	res := f
	_ = res

	if v := f.DisplayName; !dcl.IsEmptyValueIndirect(v) {
		req["displayName"] = v
	}
	if v, err := expandDashboardGridLayout(c, f.GridLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding GridLayout into gridLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["gridLayout"] = v
	}
	if v, err := expandDashboardMosaicLayout(c, f.MosaicLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding MosaicLayout into mosaicLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["mosaicLayout"] = v
	}
	if v, err := expandDashboardRowLayout(c, f.RowLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding RowLayout into rowLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["rowLayout"] = v
	}
	if v, err := expandDashboardColumnLayout(c, f.ColumnLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding ColumnLayout into columnLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["columnLayout"] = v
	}
	b, err := c.getDashboardRaw(ctx, f)
	if err != nil {
		return nil, err
	}
	var m map[string]interface{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	rawEtag, err := dcl.GetMapEntry(
		m,
		[]string{"etag"},
	)
	if err != nil {
		c.Config.Logger.WarningWithContextf(ctx, "Failed to fetch from JSON Path: %v", err)
	} else {
		req["etag"] = rawEtag.(string)
	}
	req["name"] = fmt.Sprintf("projects/%s/dashboards/%s", *f.Project, *f.Name)

	return req, nil
}

// marshalUpdateDashboardUpdateDashboardRequest converts the update into
// the final JSON request body.
func marshalUpdateDashboardUpdateDashboardRequest(c *Client, m map[string]interface{}) ([]byte, error) {

	return json.Marshal(m)
}

type updateDashboardUpdateDashboardOperation struct {
	// If the update operation has the REQUIRES_APPLY_OPTIONS trait, this will be populated.
	// Usually it will be nil - this is to prevent us from accidentally depending on apply
	// options, which should usually be unnecessary.
	ApplyOptions []dcl.ApplyOption
	FieldDiffs   []*dcl.FieldDiff
}

// do creates a request and sends it to the appropriate URL. In most operations,
// do will transcribe a subset of the resource into a request object and send a
// PUT request to a single URL.

func (op *updateDashboardUpdateDashboardOperation) do(ctx context.Context, r *Dashboard, c *Client) error {
	_, err := c.GetDashboard(ctx, r)
	if err != nil {
		return err
	}

	u, err := r.updateURL(c.Config.BasePath, "UpdateDashboard")
	if err != nil {
		return err
	}

	req, err := newUpdateDashboardUpdateDashboardRequest(ctx, r, c)
	if err != nil {
		return err
	}

	c.Config.Logger.InfoWithContextf(ctx, "Created update: %#v", req)
	body, err := marshalUpdateDashboardUpdateDashboardRequest(c, req)
	if err != nil {
		return err
	}
	_, err = dcl.SendRequest(ctx, c.Config, "PATCH", u, bytes.NewBuffer(body), c.Config.RetryProvider)
	if err != nil {
		return err
	}

	return nil
}

func (c *Client) listDashboardRaw(ctx context.Context, r *Dashboard, pageToken string, pageSize int32) ([]byte, error) {
	u, err := r.urlNormalized().listURL(c.Config.BasePath)
	if err != nil {
		return nil, err
	}

	m := make(map[string]string)
	if pageToken != "" {
		m["pageToken"] = pageToken
	}

	if pageSize != DashboardMaxPage {
		m["pageSize"] = fmt.Sprintf("%v", pageSize)
	}

	u, err = dcl.AddQueryParams(u, m)
	if err != nil {
		return nil, err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "GET", u, &bytes.Buffer{}, c.Config.RetryProvider)
	if err != nil {
		return nil, err
	}
	defer resp.Response.Body.Close()
	return ioutil.ReadAll(resp.Response.Body)
}

type listDashboardOperation struct {
	Dashboards []map[string]interface{} `json:"dashboards"`
	Token      string                   `json:"nextPageToken"`
}

func (c *Client) listDashboard(ctx context.Context, r *Dashboard, pageToken string, pageSize int32) ([]*Dashboard, string, error) {
	b, err := c.listDashboardRaw(ctx, r, pageToken, pageSize)
	if err != nil {
		return nil, "", err
	}

	var m listDashboardOperation
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, "", err
	}

	var l []*Dashboard
	for _, v := range m.Dashboards {
		res, err := unmarshalMapDashboard(v, c, r)
		if err != nil {
			return nil, m.Token, err
		}
		res.Project = r.Project
		l = append(l, res)
	}

	return l, m.Token, nil
}

func (c *Client) deleteAllDashboard(ctx context.Context, f func(*Dashboard) bool, resources []*Dashboard) error {
	var errors []string
	for _, res := range resources {
		if f(res) {
			// We do not want deleteAll to fail on a deletion or else it will stop deleting other resources.
			err := c.DeleteDashboard(ctx, res)
			if err != nil {
				errors = append(errors, err.Error())
			}
		}
	}
	if len(errors) > 0 {
		return fmt.Errorf("%v", strings.Join(errors, "\n"))
	} else {
		return nil
	}
}

type deleteDashboardOperation struct{}

func (op *deleteDashboardOperation) do(ctx context.Context, r *Dashboard, c *Client) error {
	r, err := c.GetDashboard(ctx, r)
	if err != nil {
		if dcl.IsNotFound(err) {
			c.Config.Logger.InfoWithContextf(ctx, "Dashboard not found, returning. Original error: %v", err)
			return nil
		}
		c.Config.Logger.WarningWithContextf(ctx, "GetDashboard checking for existence. error: %v", err)
		return err
	}

	u, err := r.deleteURL(c.Config.BasePath)
	if err != nil {
		return err
	}

	// Delete should never have a body
	body := &bytes.Buffer{}
	_, err = dcl.SendRequest(ctx, c.Config, "DELETE", u, body, c.Config.RetryProvider)
	if err != nil {
		return fmt.Errorf("failed to delete Dashboard: %w", err)
	}

	// We saw a race condition where for some successful delete operation, the Get calls returned resources for a short duration.
	// This is the reason we are adding retry to handle that case.
	retriesRemaining := 10
	dcl.Do(ctx, func(ctx context.Context) (*dcl.RetryDetails, error) {
		_, err := c.GetDashboard(ctx, r)
		if dcl.IsNotFound(err) {
			return nil, nil
		}
		if retriesRemaining > 0 {
			retriesRemaining--
			return &dcl.RetryDetails{}, dcl.OperationNotDone{}
		}
		return nil, dcl.NotDeletedError{ExistingResource: r}
	}, c.Config.RetryProvider)
	return nil
}

// Create operations are similar to Update operations, although they do not have
// specific request objects. The Create request object is the json encoding of
// the resource, which is modified by res.marshal to form the base request body.
type createDashboardOperation struct {
	response map[string]interface{}
}

func (op *createDashboardOperation) FirstResponse() (map[string]interface{}, bool) {
	return op.response, len(op.response) > 0
}

func (op *createDashboardOperation) do(ctx context.Context, r *Dashboard, c *Client) error {
	c.Config.Logger.InfoWithContextf(ctx, "Attempting to create %v", r)
	u, err := r.createURL(c.Config.BasePath)
	if err != nil {
		return err
	}

	req, err := r.marshal(c)
	if err != nil {
		return err
	}
	var m map[string]interface{}
	if err := json.Unmarshal(req, &m); err != nil {
		return err
	}
	normalized := r.urlNormalized()
	m["name"] = fmt.Sprintf("projects/%s/dashboards/%s", *normalized.Project, *normalized.Name)

	req, err = json.Marshal(m)
	if err != nil {
		return err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "POST", u, bytes.NewBuffer(req), c.Config.RetryProvider)
	if err != nil {
		return err
	}

	o, err := dcl.ResponseBodyAsJSON(resp)
	if err != nil {
		return fmt.Errorf("error decoding response body into JSON: %w", err)
	}
	op.response = o

	if _, err := c.GetDashboard(ctx, r); err != nil {
		c.Config.Logger.WarningWithContextf(ctx, "get returned error: %v", err)
		return err
	}

	return nil
}

func (c *Client) getDashboardRaw(ctx context.Context, r *Dashboard) ([]byte, error) {

	u, err := r.getURL(c.Config.BasePath)
	if err != nil {
		return nil, err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "GET", u, &bytes.Buffer{}, c.Config.RetryProvider)
	if err != nil {
		return nil, err
	}
	defer resp.Response.Body.Close()
	b, err := ioutil.ReadAll(resp.Response.Body)
	if err != nil {
		return nil, err
	}

	return b, nil
}

func (c *Client) dashboardDiffsForRawDesired(ctx context.Context, rawDesired *Dashboard, opts ...dcl.ApplyOption) (initial, desired *Dashboard, diffs []*dcl.FieldDiff, err error) {
	c.Config.Logger.InfoWithContext(ctx, "Fetching initial state...")
	// First, let us see if the user provided a state hint.  If they did, we will start fetching based on that.
	var fetchState *Dashboard
	if sh := dcl.FetchStateHint(opts); sh != nil {
		if r, ok := sh.(*Dashboard); !ok {
			c.Config.Logger.WarningWithContextf(ctx, "Initial state hint was of the wrong type; expected Dashboard, got %T", sh)
		} else {
			fetchState = r
		}
	}
	if fetchState == nil {
		fetchState = rawDesired
	}

	// 1.2: Retrieval of raw initial state from API
	rawInitial, err := c.GetDashboard(ctx, fetchState)
	if rawInitial == nil {
		if !dcl.IsNotFound(err) {
			c.Config.Logger.WarningWithContextf(ctx, "Failed to retrieve whether a Dashboard resource already exists: %s", err)
			return nil, nil, nil, fmt.Errorf("failed to retrieve Dashboard resource: %v", err)
		}
		c.Config.Logger.InfoWithContext(ctx, "Found that Dashboard resource did not exist.")
		// Perform canonicalization to pick up defaults.
		desired, err = canonicalizeDashboardDesiredState(rawDesired, rawInitial)
		return nil, desired, nil, err
	}
	c.Config.Logger.InfoWithContextf(ctx, "Found initial state for Dashboard: %v", rawInitial)
	c.Config.Logger.InfoWithContextf(ctx, "Initial desired state for Dashboard: %v", rawDesired)

	// The Get call applies postReadExtract and so the result may contain fields that are not part of API version.
	if err := extractDashboardFields(rawInitial); err != nil {
		return nil, nil, nil, err
	}

	// 1.3: Canonicalize raw initial state into initial state.
	initial, err = canonicalizeDashboardInitialState(rawInitial, rawDesired)
	if err != nil {
		return nil, nil, nil, err
	}
	c.Config.Logger.InfoWithContextf(ctx, "Canonicalized initial state for Dashboard: %v", initial)

	// 1.4: Canonicalize raw desired state into desired state.
	desired, err = canonicalizeDashboardDesiredState(rawDesired, rawInitial, opts...)
	if err != nil {
		return nil, nil, nil, err
	}
	c.Config.Logger.InfoWithContextf(ctx, "Canonicalized desired state for Dashboard: %v", desired)

	// 2.1: Comparison of initial and desired state.
	diffs, err = diffDashboard(c, desired, initial, opts...)
	return initial, desired, diffs, err
}

func canonicalizeDashboardInitialState(rawInitial, rawDesired *Dashboard) (*Dashboard, error) {
	// TODO(magic-modules-eng): write canonicalizer once relevant traits are added.

	if !dcl.IsZeroValue(rawInitial.GridLayout) {
		// Check if anything else is set.
		if dcl.AnySet(rawInitial.MosaicLayout, rawInitial.RowLayout, rawInitial.ColumnLayout) {
			rawInitial.GridLayout = EmptyDashboardGridLayout
		}
	}

	if !dcl.IsZeroValue(rawInitial.MosaicLayout) {
		// Check if anything else is set.
		if dcl.AnySet(rawInitial.GridLayout, rawInitial.RowLayout, rawInitial.ColumnLayout) {
			rawInitial.MosaicLayout = EmptyDashboardMosaicLayout
		}
	}

	if !dcl.IsZeroValue(rawInitial.RowLayout) {
		// Check if anything else is set.
		if dcl.AnySet(rawInitial.GridLayout, rawInitial.MosaicLayout, rawInitial.ColumnLayout) {
			rawInitial.RowLayout = EmptyDashboardRowLayout
		}
	}

	if !dcl.IsZeroValue(rawInitial.ColumnLayout) {
		// Check if anything else is set.
		if dcl.AnySet(rawInitial.GridLayout, rawInitial.MosaicLayout, rawInitial.RowLayout) {
			rawInitial.ColumnLayout = EmptyDashboardColumnLayout
		}
	}

	return rawInitial, nil
}

/*
* Canonicalizers
*
* These are responsible for converting either a user-specified config or a
* GCP API response to a standard format that can be used for difference checking.
* */

func canonicalizeDashboardDesiredState(rawDesired, rawInitial *Dashboard, opts ...dcl.ApplyOption) (*Dashboard, error) {

	if rawInitial == nil {
		// Since the initial state is empty, the desired state is all we have.
		// We canonicalize the remaining nested objects with nil to pick up defaults.
		rawDesired.GridLayout = canonicalizeDashboardGridLayout(rawDesired.GridLayout, nil, opts...)
		rawDesired.MosaicLayout = canonicalizeDashboardMosaicLayout(rawDesired.MosaicLayout, nil, opts...)
		rawDesired.RowLayout = canonicalizeDashboardRowLayout(rawDesired.RowLayout, nil, opts...)
		rawDesired.ColumnLayout = canonicalizeDashboardColumnLayout(rawDesired.ColumnLayout, nil, opts...)

		return rawDesired, nil
	}
	canonicalDesired := &Dashboard{}
	if dcl.NameToSelfLink(rawDesired.Name, rawInitial.Name) {
		canonicalDesired.Name = rawInitial.Name
	} else {
		canonicalDesired.Name = rawDesired.Name
	}
	if dcl.StringCanonicalize(rawDesired.DisplayName, rawInitial.DisplayName) {
		canonicalDesired.DisplayName = rawInitial.DisplayName
	} else {
		canonicalDesired.DisplayName = rawDesired.DisplayName
	}
	canonicalDesired.GridLayout = canonicalizeDashboardGridLayout(rawDesired.GridLayout, rawInitial.GridLayout, opts...)
	canonicalDesired.MosaicLayout = canonicalizeDashboardMosaicLayout(rawDesired.MosaicLayout, rawInitial.MosaicLayout, opts...)
	canonicalDesired.RowLayout = canonicalizeDashboardRowLayout(rawDesired.RowLayout, rawInitial.RowLayout, opts...)
	canonicalDesired.ColumnLayout = canonicalizeDashboardColumnLayout(rawDesired.ColumnLayout, rawInitial.ColumnLayout, opts...)
	if dcl.NameToSelfLink(rawDesired.Project, rawInitial.Project) {
		canonicalDesired.Project = rawInitial.Project
	} else {
		canonicalDesired.Project = rawDesired.Project
	}

	if canonicalDesired.GridLayout != nil {
		// Check if anything else is set.
		if dcl.AnySet(rawDesired.MosaicLayout, rawDesired.RowLayout, rawDesired.ColumnLayout) {
			canonicalDesired.GridLayout = EmptyDashboardGridLayout
		}
	}

	if canonicalDesired.MosaicLayout != nil {
		// Check if anything else is set.
		if dcl.AnySet(rawDesired.GridLayout, rawDesired.RowLayout, rawDesired.ColumnLayout) {
			canonicalDesired.MosaicLayout = EmptyDashboardMosaicLayout
		}
	}

	if canonicalDesired.RowLayout != nil {
		// Check if anything else is set.
		if dcl.AnySet(rawDesired.GridLayout, rawDesired.MosaicLayout, rawDesired.ColumnLayout) {
			canonicalDesired.RowLayout = EmptyDashboardRowLayout
		}
	}

	if canonicalDesired.ColumnLayout != nil {
		// Check if anything else is set.
		if dcl.AnySet(rawDesired.GridLayout, rawDesired.MosaicLayout, rawDesired.RowLayout) {
			canonicalDesired.ColumnLayout = EmptyDashboardColumnLayout
		}
	}

	return canonicalDesired, nil
}

func canonicalizeDashboardNewState(c *Client, rawNew, rawDesired *Dashboard) (*Dashboard, error) {

	rawNew.Name = rawDesired.Name

	if dcl.IsEmptyValueIndirect(rawNew.DisplayName) && dcl.IsEmptyValueIndirect(rawDesired.DisplayName) {
		rawNew.DisplayName = rawDesired.DisplayName
	} else {
		if dcl.StringCanonicalize(rawDesired.DisplayName, rawNew.DisplayName) {
			rawNew.DisplayName = rawDesired.DisplayName
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.GridLayout) && dcl.IsEmptyValueIndirect(rawDesired.GridLayout) {
		rawNew.GridLayout = rawDesired.GridLayout
	} else {
		rawNew.GridLayout = canonicalizeNewDashboardGridLayout(c, rawDesired.GridLayout, rawNew.GridLayout)
	}

	if dcl.IsEmptyValueIndirect(rawNew.MosaicLayout) && dcl.IsEmptyValueIndirect(rawDesired.MosaicLayout) {
		rawNew.MosaicLayout = rawDesired.MosaicLayout
	} else {
		rawNew.MosaicLayout = canonicalizeNewDashboardMosaicLayout(c, rawDesired.MosaicLayout, rawNew.MosaicLayout)
	}

	if dcl.IsEmptyValueIndirect(rawNew.RowLayout) && dcl.IsEmptyValueIndirect(rawDesired.RowLayout) {
		rawNew.RowLayout = rawDesired.RowLayout
	} else {
		rawNew.RowLayout = canonicalizeNewDashboardRowLayout(c, rawDesired.RowLayout, rawNew.RowLayout)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ColumnLayout) && dcl.IsEmptyValueIndirect(rawDesired.ColumnLayout) {
		rawNew.ColumnLayout = rawDesired.ColumnLayout
	} else {
		rawNew.ColumnLayout = canonicalizeNewDashboardColumnLayout(c, rawDesired.ColumnLayout, rawNew.ColumnLayout)
	}

	rawNew.Project = rawDesired.Project

	if dcl.IsEmptyValueIndirect(rawNew.Etag) && dcl.IsEmptyValueIndirect(rawDesired.Etag) {
		rawNew.Etag = rawDesired.Etag
	} else {
		if dcl.StringCanonicalize(rawDesired.Etag, rawNew.Etag) {
			rawNew.Etag = rawDesired.Etag
		}
	}

	return rawNew, nil
}

func canonicalizeDashboardGridLayout(des, initial *DashboardGridLayout, opts ...dcl.ApplyOption) *DashboardGridLayout {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayout{}

	if dcl.IsZeroValue(des.Columns) || (dcl.IsEmptyValueIndirect(des.Columns) && dcl.IsEmptyValueIndirect(initial.Columns)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Columns = initial.Columns
	} else {
		cDes.Columns = des.Columns
	}
	cDes.Widgets = canonicalizeDashboardGridLayoutWidgetsSlice(des.Widgets, initial.Widgets, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutSlice(des, initial []DashboardGridLayout, opts ...dcl.ApplyOption) []DashboardGridLayout {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayout, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayout(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayout, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayout(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayout(c *Client, des, nw *DashboardGridLayout) *DashboardGridLayout {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayout while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Widgets = canonicalizeNewDashboardGridLayoutWidgetsSlice(c, des.Widgets, nw.Widgets)

	return nw
}

func canonicalizeNewDashboardGridLayoutSet(c *Client, des, nw []DashboardGridLayout) []DashboardGridLayout {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayout
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayout(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutSlice(c *Client, des, nw []DashboardGridLayout) []DashboardGridLayout {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayout
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayout(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgets(des, initial *DashboardGridLayoutWidgets, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if des.XyChart != nil || (initial != nil && initial.XyChart != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.Scorecard, des.Text, des.Blank, des.LogsPanel) {
			des.XyChart = nil
			if initial != nil {
				initial.XyChart = nil
			}
		}
	}

	if des.Scorecard != nil || (initial != nil && initial.Scorecard != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Text, des.Blank, des.LogsPanel) {
			des.Scorecard = nil
			if initial != nil {
				initial.Scorecard = nil
			}
		}
	}

	if des.Text != nil || (initial != nil && initial.Text != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Blank, des.LogsPanel) {
			des.Text = nil
			if initial != nil {
				initial.Text = nil
			}
		}
	}

	if des.Blank != nil || (initial != nil && initial.Blank != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.LogsPanel) {
			des.Blank = nil
			if initial != nil {
				initial.Blank = nil
			}
		}
	}

	if des.LogsPanel != nil || (initial != nil && initial.LogsPanel != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.Blank) {
			des.LogsPanel = nil
			if initial != nil {
				initial.LogsPanel = nil
			}
		}
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgets{}

	if dcl.StringCanonicalize(des.Title, initial.Title) || dcl.IsZeroValue(des.Title) {
		cDes.Title = initial.Title
	} else {
		cDes.Title = des.Title
	}
	cDes.XyChart = canonicalizeDashboardGridLayoutWidgetsXyChart(des.XyChart, initial.XyChart, opts...)
	cDes.Scorecard = canonicalizeDashboardGridLayoutWidgetsScorecard(des.Scorecard, initial.Scorecard, opts...)
	cDes.Text = canonicalizeDashboardGridLayoutWidgetsText(des.Text, initial.Text, opts...)
	cDes.Blank = canonicalizeDashboardGridLayoutWidgetsBlank(des.Blank, initial.Blank, opts...)
	cDes.LogsPanel = canonicalizeDashboardGridLayoutWidgetsLogsPanel(des.LogsPanel, initial.LogsPanel, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsSlice(des, initial []DashboardGridLayoutWidgets, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgets(c *Client, des, nw *DashboardGridLayoutWidgets) *DashboardGridLayoutWidgets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Title, nw.Title) {
		nw.Title = des.Title
	}
	nw.XyChart = canonicalizeNewDashboardGridLayoutWidgetsXyChart(c, des.XyChart, nw.XyChart)
	nw.Scorecard = canonicalizeNewDashboardGridLayoutWidgetsScorecard(c, des.Scorecard, nw.Scorecard)
	nw.Text = canonicalizeNewDashboardGridLayoutWidgetsText(c, des.Text, nw.Text)
	nw.Blank = canonicalizeNewDashboardGridLayoutWidgetsBlank(c, des.Blank, nw.Blank)
	nw.LogsPanel = canonicalizeNewDashboardGridLayoutWidgetsLogsPanel(c, des.LogsPanel, nw.LogsPanel)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsSet(c *Client, des, nw []DashboardGridLayoutWidgets) []DashboardGridLayoutWidgets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsSlice(c *Client, des, nw []DashboardGridLayoutWidgets) []DashboardGridLayoutWidgets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChart(des, initial *DashboardGridLayoutWidgetsXyChart, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChart {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChart{}

	cDes.DataSets = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsSlice(des.DataSets, initial.DataSets, opts...)
	if dcl.StringCanonicalize(des.TimeshiftDuration, initial.TimeshiftDuration) || dcl.IsZeroValue(des.TimeshiftDuration) {
		cDes.TimeshiftDuration = initial.TimeshiftDuration
	} else {
		cDes.TimeshiftDuration = des.TimeshiftDuration
	}
	cDes.Thresholds = canonicalizeDashboardGridLayoutWidgetsXyChartThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)
	cDes.XAxis = canonicalizeDashboardGridLayoutWidgetsXyChartXAxis(des.XAxis, initial.XAxis, opts...)
	cDes.YAxis = canonicalizeDashboardGridLayoutWidgetsXyChartYAxis(des.YAxis, initial.YAxis, opts...)
	cDes.ChartOptions = canonicalizeDashboardGridLayoutWidgetsXyChartChartOptions(des.ChartOptions, initial.ChartOptions, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartSlice(des, initial []DashboardGridLayoutWidgetsXyChart, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChart {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChart, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChart(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChart, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChart(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChart(c *Client, des, nw *DashboardGridLayoutWidgetsXyChart) *DashboardGridLayoutWidgetsXyChart {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChart while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.DataSets = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsSlice(c, des.DataSets, nw.DataSets)
	if dcl.StringCanonicalize(des.TimeshiftDuration, nw.TimeshiftDuration) {
		nw.TimeshiftDuration = des.TimeshiftDuration
	}
	nw.Thresholds = canonicalizeNewDashboardGridLayoutWidgetsXyChartThresholdsSlice(c, des.Thresholds, nw.Thresholds)
	nw.XAxis = canonicalizeNewDashboardGridLayoutWidgetsXyChartXAxis(c, des.XAxis, nw.XAxis)
	nw.YAxis = canonicalizeNewDashboardGridLayoutWidgetsXyChartYAxis(c, des.YAxis, nw.YAxis)
	nw.ChartOptions = canonicalizeNewDashboardGridLayoutWidgetsXyChartChartOptions(c, des.ChartOptions, nw.ChartOptions)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChart) []DashboardGridLayoutWidgetsXyChart {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChart
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChart(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChart) []DashboardGridLayoutWidgetsXyChart {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChart
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChart(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSets(des, initial *DashboardGridLayoutWidgetsXyChartDataSets, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSets{}

	cDes.TimeSeriesQuery = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	if dcl.IsZeroValue(des.PlotType) || (dcl.IsEmptyValueIndirect(des.PlotType) && dcl.IsEmptyValueIndirect(initial.PlotType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PlotType = initial.PlotType
	} else {
		cDes.PlotType = des.PlotType
	}
	if dcl.StringCanonicalize(des.LegendTemplate, initial.LegendTemplate) || dcl.IsZeroValue(des.LegendTemplate) {
		cDes.LegendTemplate = initial.LegendTemplate
	} else {
		cDes.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSets, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSets(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSets) *DashboardGridLayoutWidgetsXyChartDataSets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	if dcl.StringCanonicalize(des.LegendTemplate, nw.LegendTemplate) {
		nw.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSets) []DashboardGridLayoutWidgetsXyChartDataSets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSets) []DashboardGridLayoutWidgetsXyChartDataSets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartThresholds(des, initial *DashboardGridLayoutWidgetsXyChartThresholds, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartThresholdsSlice(des, initial []DashboardGridLayoutWidgetsXyChartThresholds, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartThresholds(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartThresholds) *DashboardGridLayoutWidgetsXyChartThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartThresholdsSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartThresholds) []DashboardGridLayoutWidgetsXyChartThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartThresholdsSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartThresholds) []DashboardGridLayoutWidgetsXyChartThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartXAxis(des, initial *DashboardGridLayoutWidgetsXyChartXAxis, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartXAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartXAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartXAxisSlice(des, initial []DashboardGridLayoutWidgetsXyChartXAxis, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartXAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartXAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartXAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartXAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartXAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartXAxis(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartXAxis) *DashboardGridLayoutWidgetsXyChartXAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartXAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartXAxisSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartXAxis) []DashboardGridLayoutWidgetsXyChartXAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartXAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartXAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartXAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartXAxisSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartXAxis) []DashboardGridLayoutWidgetsXyChartXAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartXAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartXAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartYAxis(des, initial *DashboardGridLayoutWidgetsXyChartYAxis, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartYAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartYAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartYAxisSlice(des, initial []DashboardGridLayoutWidgetsXyChartYAxis, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartYAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartYAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartYAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartYAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartYAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartYAxis(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartYAxis) *DashboardGridLayoutWidgetsXyChartYAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartYAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartYAxisSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartYAxis) []DashboardGridLayoutWidgetsXyChartYAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartYAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartYAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartYAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartYAxisSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartYAxis) []DashboardGridLayoutWidgetsXyChartYAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartYAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartYAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsXyChartChartOptions(des, initial *DashboardGridLayoutWidgetsXyChartChartOptions, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsXyChartChartOptions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsXyChartChartOptions{}

	if dcl.IsZeroValue(des.Mode) || (dcl.IsEmptyValueIndirect(des.Mode) && dcl.IsEmptyValueIndirect(initial.Mode)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Mode = initial.Mode
	} else {
		cDes.Mode = des.Mode
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsXyChartChartOptionsSlice(des, initial []DashboardGridLayoutWidgetsXyChartChartOptions, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsXyChartChartOptions {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsXyChartChartOptions, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsXyChartChartOptions(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsXyChartChartOptions, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsXyChartChartOptions(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartChartOptions(c *Client, des, nw *DashboardGridLayoutWidgetsXyChartChartOptions) *DashboardGridLayoutWidgetsXyChartChartOptions {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsXyChartChartOptions while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartChartOptionsSet(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartChartOptions) []DashboardGridLayoutWidgetsXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsXyChartChartOptions
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsXyChartChartOptionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartChartOptions(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsXyChartChartOptionsSlice(c *Client, des, nw []DashboardGridLayoutWidgetsXyChartChartOptions) []DashboardGridLayoutWidgetsXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsXyChartChartOptions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsXyChartChartOptions(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecard(des, initial *DashboardGridLayoutWidgetsScorecard, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecard {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecard{}

	cDes.TimeSeriesQuery = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	cDes.GaugeView = canonicalizeDashboardGridLayoutWidgetsScorecardGaugeView(des.GaugeView, initial.GaugeView, opts...)
	cDes.SparkChartView = canonicalizeDashboardGridLayoutWidgetsScorecardSparkChartView(des.SparkChartView, initial.SparkChartView, opts...)
	cDes.Thresholds = canonicalizeDashboardGridLayoutWidgetsScorecardThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardSlice(des, initial []DashboardGridLayoutWidgetsScorecard, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecard {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecard, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecard(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecard, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecard(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecard(c *Client, des, nw *DashboardGridLayoutWidgetsScorecard) *DashboardGridLayoutWidgetsScorecard {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecard while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	nw.GaugeView = canonicalizeNewDashboardGridLayoutWidgetsScorecardGaugeView(c, des.GaugeView, nw.GaugeView)
	nw.SparkChartView = canonicalizeNewDashboardGridLayoutWidgetsScorecardSparkChartView(c, des.SparkChartView, nw.SparkChartView)
	nw.Thresholds = canonicalizeNewDashboardGridLayoutWidgetsScorecardThresholdsSlice(c, des.Thresholds, nw.Thresholds)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecard) []DashboardGridLayoutWidgetsScorecard {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecard
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecard(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecard) []DashboardGridLayoutWidgetsScorecard {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecard
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecard(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery) *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery) []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery) []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardGaugeView(des, initial *DashboardGridLayoutWidgetsScorecardGaugeView, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardGaugeView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardGaugeView{}

	if dcl.IsZeroValue(des.LowerBound) || (dcl.IsEmptyValueIndirect(des.LowerBound) && dcl.IsEmptyValueIndirect(initial.LowerBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.LowerBound = initial.LowerBound
	} else {
		cDes.LowerBound = des.LowerBound
	}
	if dcl.IsZeroValue(des.UpperBound) || (dcl.IsEmptyValueIndirect(des.UpperBound) && dcl.IsEmptyValueIndirect(initial.UpperBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.UpperBound = initial.UpperBound
	} else {
		cDes.UpperBound = des.UpperBound
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardGaugeViewSlice(des, initial []DashboardGridLayoutWidgetsScorecardGaugeView, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardGaugeView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardGaugeView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardGaugeView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardGaugeView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardGaugeView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardGaugeView(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardGaugeView) *DashboardGridLayoutWidgetsScorecardGaugeView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardGaugeView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardGaugeViewSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardGaugeView) []DashboardGridLayoutWidgetsScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardGaugeView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardGaugeViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardGaugeView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardGaugeViewSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardGaugeView) []DashboardGridLayoutWidgetsScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardGaugeView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardGaugeView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardSparkChartView(des, initial *DashboardGridLayoutWidgetsScorecardSparkChartView, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardSparkChartView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardSparkChartView{}

	if dcl.IsZeroValue(des.SparkChartType) || (dcl.IsEmptyValueIndirect(des.SparkChartType) && dcl.IsEmptyValueIndirect(initial.SparkChartType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.SparkChartType = initial.SparkChartType
	} else {
		cDes.SparkChartType = des.SparkChartType
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardSparkChartViewSlice(des, initial []DashboardGridLayoutWidgetsScorecardSparkChartView, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardSparkChartView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardSparkChartView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardSparkChartView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardSparkChartView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardSparkChartView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardSparkChartView(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardSparkChartView) *DashboardGridLayoutWidgetsScorecardSparkChartView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardSparkChartView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardSparkChartViewSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardSparkChartView) []DashboardGridLayoutWidgetsScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardSparkChartView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardSparkChartViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardSparkChartView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardSparkChartViewSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardSparkChartView) []DashboardGridLayoutWidgetsScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardSparkChartView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardSparkChartView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsScorecardThresholds(des, initial *DashboardGridLayoutWidgetsScorecardThresholds, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsScorecardThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsScorecardThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsScorecardThresholdsSlice(des, initial []DashboardGridLayoutWidgetsScorecardThresholds, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsScorecardThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsScorecardThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsScorecardThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsScorecardThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsScorecardThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardThresholds(c *Client, des, nw *DashboardGridLayoutWidgetsScorecardThresholds) *DashboardGridLayoutWidgetsScorecardThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsScorecardThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardThresholdsSet(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardThresholds) []DashboardGridLayoutWidgetsScorecardThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsScorecardThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsScorecardThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsScorecardThresholdsSlice(c *Client, des, nw []DashboardGridLayoutWidgetsScorecardThresholds) []DashboardGridLayoutWidgetsScorecardThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsScorecardThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsScorecardThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsText(des, initial *DashboardGridLayoutWidgetsText, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsText {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsText{}

	if dcl.StringCanonicalize(des.Content, initial.Content) || dcl.IsZeroValue(des.Content) {
		cDes.Content = initial.Content
	} else {
		cDes.Content = des.Content
	}
	if dcl.IsZeroValue(des.Format) || (dcl.IsEmptyValueIndirect(des.Format) && dcl.IsEmptyValueIndirect(initial.Format)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Format = initial.Format
	} else {
		cDes.Format = des.Format
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsTextSlice(des, initial []DashboardGridLayoutWidgetsText, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsText {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsText, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsText(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsText, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsText(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsText(c *Client, des, nw *DashboardGridLayoutWidgetsText) *DashboardGridLayoutWidgetsText {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsText while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Content, nw.Content) {
		nw.Content = des.Content
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsTextSet(c *Client, des, nw []DashboardGridLayoutWidgetsText) []DashboardGridLayoutWidgetsText {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsText
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsTextNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsText(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsTextSlice(c *Client, des, nw []DashboardGridLayoutWidgetsText) []DashboardGridLayoutWidgetsText {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsText
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsText(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsBlank(des, initial *DashboardGridLayoutWidgetsBlank, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsBlank {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}
	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsBlank{}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsBlankSlice(des, initial []DashboardGridLayoutWidgetsBlank, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsBlank {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsBlank, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsBlank(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsBlank, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsBlank(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsBlank(c *Client, des, nw *DashboardGridLayoutWidgetsBlank) *DashboardGridLayoutWidgetsBlank {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsBlank while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsBlankSet(c *Client, des, nw []DashboardGridLayoutWidgetsBlank) []DashboardGridLayoutWidgetsBlank {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsBlank
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsBlankNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsBlank(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsBlankSlice(c *Client, des, nw []DashboardGridLayoutWidgetsBlank) []DashboardGridLayoutWidgetsBlank {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsBlank
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsBlank(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardGridLayoutWidgetsLogsPanel(des, initial *DashboardGridLayoutWidgetsLogsPanel, opts ...dcl.ApplyOption) *DashboardGridLayoutWidgetsLogsPanel {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardGridLayoutWidgetsLogsPanel{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, initial.ResourceNames) {
		cDes.ResourceNames = initial.ResourceNames
	} else {
		cDes.ResourceNames = des.ResourceNames
	}

	return cDes
}

func canonicalizeDashboardGridLayoutWidgetsLogsPanelSlice(des, initial []DashboardGridLayoutWidgetsLogsPanel, opts ...dcl.ApplyOption) []DashboardGridLayoutWidgetsLogsPanel {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardGridLayoutWidgetsLogsPanel, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardGridLayoutWidgetsLogsPanel(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardGridLayoutWidgetsLogsPanel, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardGridLayoutWidgetsLogsPanel(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardGridLayoutWidgetsLogsPanel(c *Client, des, nw *DashboardGridLayoutWidgetsLogsPanel) *DashboardGridLayoutWidgetsLogsPanel {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardGridLayoutWidgetsLogsPanel while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, nw.ResourceNames) {
		nw.ResourceNames = des.ResourceNames
	}

	return nw
}

func canonicalizeNewDashboardGridLayoutWidgetsLogsPanelSet(c *Client, des, nw []DashboardGridLayoutWidgetsLogsPanel) []DashboardGridLayoutWidgetsLogsPanel {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardGridLayoutWidgetsLogsPanel
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardGridLayoutWidgetsLogsPanelNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsLogsPanel(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardGridLayoutWidgetsLogsPanelSlice(c *Client, des, nw []DashboardGridLayoutWidgetsLogsPanel) []DashboardGridLayoutWidgetsLogsPanel {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardGridLayoutWidgetsLogsPanel
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardGridLayoutWidgetsLogsPanel(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayout(des, initial *DashboardMosaicLayout, opts ...dcl.ApplyOption) *DashboardMosaicLayout {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayout{}

	if dcl.IsZeroValue(des.Columns) || (dcl.IsEmptyValueIndirect(des.Columns) && dcl.IsEmptyValueIndirect(initial.Columns)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Columns = initial.Columns
	} else {
		cDes.Columns = des.Columns
	}
	cDes.Tiles = canonicalizeDashboardMosaicLayoutTilesSlice(des.Tiles, initial.Tiles, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutSlice(des, initial []DashboardMosaicLayout, opts ...dcl.ApplyOption) []DashboardMosaicLayout {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayout, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayout(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayout, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayout(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayout(c *Client, des, nw *DashboardMosaicLayout) *DashboardMosaicLayout {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayout while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Tiles = canonicalizeNewDashboardMosaicLayoutTilesSlice(c, des.Tiles, nw.Tiles)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutSet(c *Client, des, nw []DashboardMosaicLayout) []DashboardMosaicLayout {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayout
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayout(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutSlice(c *Client, des, nw []DashboardMosaicLayout) []DashboardMosaicLayout {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayout
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayout(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTiles(des, initial *DashboardMosaicLayoutTiles, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTiles {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTiles{}

	if dcl.IsZeroValue(des.XPos) || (dcl.IsEmptyValueIndirect(des.XPos) && dcl.IsEmptyValueIndirect(initial.XPos)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.XPos = initial.XPos
	} else {
		cDes.XPos = des.XPos
	}
	if dcl.IsZeroValue(des.YPos) || (dcl.IsEmptyValueIndirect(des.YPos) && dcl.IsEmptyValueIndirect(initial.YPos)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.YPos = initial.YPos
	} else {
		cDes.YPos = des.YPos
	}
	if dcl.IsZeroValue(des.Width) || (dcl.IsEmptyValueIndirect(des.Width) && dcl.IsEmptyValueIndirect(initial.Width)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Width = initial.Width
	} else {
		cDes.Width = des.Width
	}
	if dcl.IsZeroValue(des.Height) || (dcl.IsEmptyValueIndirect(des.Height) && dcl.IsEmptyValueIndirect(initial.Height)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Height = initial.Height
	} else {
		cDes.Height = des.Height
	}
	cDes.Widget = canonicalizeDashboardMosaicLayoutTilesWidget(des.Widget, initial.Widget, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesSlice(des, initial []DashboardMosaicLayoutTiles, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTiles {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTiles, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTiles(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTiles, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTiles(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTiles(c *Client, des, nw *DashboardMosaicLayoutTiles) *DashboardMosaicLayoutTiles {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTiles while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Widget = canonicalizeNewDashboardMosaicLayoutTilesWidget(c, des.Widget, nw.Widget)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesSet(c *Client, des, nw []DashboardMosaicLayoutTiles) []DashboardMosaicLayoutTiles {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTiles
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTiles(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesSlice(c *Client, des, nw []DashboardMosaicLayoutTiles) []DashboardMosaicLayoutTiles {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTiles
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTiles(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidget(des, initial *DashboardMosaicLayoutTilesWidget, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidget {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if des.XyChart != nil || (initial != nil && initial.XyChart != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.Scorecard, des.Text, des.Blank, des.LogsPanel) {
			des.XyChart = nil
			if initial != nil {
				initial.XyChart = nil
			}
		}
	}

	if des.Scorecard != nil || (initial != nil && initial.Scorecard != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Text, des.Blank, des.LogsPanel) {
			des.Scorecard = nil
			if initial != nil {
				initial.Scorecard = nil
			}
		}
	}

	if des.Text != nil || (initial != nil && initial.Text != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Blank, des.LogsPanel) {
			des.Text = nil
			if initial != nil {
				initial.Text = nil
			}
		}
	}

	if des.Blank != nil || (initial != nil && initial.Blank != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.LogsPanel) {
			des.Blank = nil
			if initial != nil {
				initial.Blank = nil
			}
		}
	}

	if des.LogsPanel != nil || (initial != nil && initial.LogsPanel != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.Blank) {
			des.LogsPanel = nil
			if initial != nil {
				initial.LogsPanel = nil
			}
		}
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidget{}

	if dcl.StringCanonicalize(des.Title, initial.Title) || dcl.IsZeroValue(des.Title) {
		cDes.Title = initial.Title
	} else {
		cDes.Title = des.Title
	}
	cDes.XyChart = canonicalizeDashboardMosaicLayoutTilesWidgetXyChart(des.XyChart, initial.XyChart, opts...)
	cDes.Scorecard = canonicalizeDashboardMosaicLayoutTilesWidgetScorecard(des.Scorecard, initial.Scorecard, opts...)
	cDes.Text = canonicalizeDashboardMosaicLayoutTilesWidgetText(des.Text, initial.Text, opts...)
	cDes.Blank = canonicalizeDashboardMosaicLayoutTilesWidgetBlank(des.Blank, initial.Blank, opts...)
	cDes.LogsPanel = canonicalizeDashboardMosaicLayoutTilesWidgetLogsPanel(des.LogsPanel, initial.LogsPanel, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetSlice(des, initial []DashboardMosaicLayoutTilesWidget, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidget {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidget, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidget(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidget, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidget(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidget(c *Client, des, nw *DashboardMosaicLayoutTilesWidget) *DashboardMosaicLayoutTilesWidget {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidget while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Title, nw.Title) {
		nw.Title = des.Title
	}
	nw.XyChart = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChart(c, des.XyChart, nw.XyChart)
	nw.Scorecard = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecard(c, des.Scorecard, nw.Scorecard)
	nw.Text = canonicalizeNewDashboardMosaicLayoutTilesWidgetText(c, des.Text, nw.Text)
	nw.Blank = canonicalizeNewDashboardMosaicLayoutTilesWidgetBlank(c, des.Blank, nw.Blank)
	nw.LogsPanel = canonicalizeNewDashboardMosaicLayoutTilesWidgetLogsPanel(c, des.LogsPanel, nw.LogsPanel)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidget) []DashboardMosaicLayoutTilesWidget {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidget
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidget(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidget) []DashboardMosaicLayoutTilesWidget {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidget
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidget(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChart(des, initial *DashboardMosaicLayoutTilesWidgetXyChart, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChart {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChart{}

	cDes.DataSets = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(des.DataSets, initial.DataSets, opts...)
	if dcl.StringCanonicalize(des.TimeshiftDuration, initial.TimeshiftDuration) || dcl.IsZeroValue(des.TimeshiftDuration) {
		cDes.TimeshiftDuration = initial.TimeshiftDuration
	} else {
		cDes.TimeshiftDuration = des.TimeshiftDuration
	}
	cDes.Thresholds = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)
	cDes.XAxis = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartXAxis(des.XAxis, initial.XAxis, opts...)
	cDes.YAxis = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartYAxis(des.YAxis, initial.YAxis, opts...)
	cDes.ChartOptions = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartChartOptions(des.ChartOptions, initial.ChartOptions, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChart, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChart {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChart, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChart(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChart, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChart(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChart(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChart) *DashboardMosaicLayoutTilesWidgetXyChart {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChart while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.DataSets = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(c, des.DataSets, nw.DataSets)
	if dcl.StringCanonicalize(des.TimeshiftDuration, nw.TimeshiftDuration) {
		nw.TimeshiftDuration = des.TimeshiftDuration
	}
	nw.Thresholds = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(c, des.Thresholds, nw.Thresholds)
	nw.XAxis = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, des.XAxis, nw.XAxis)
	nw.YAxis = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, des.YAxis, nw.YAxis)
	nw.ChartOptions = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, des.ChartOptions, nw.ChartOptions)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChart) []DashboardMosaicLayoutTilesWidgetXyChart {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChart
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChart(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChart) []DashboardMosaicLayoutTilesWidgetXyChart {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChart
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChart(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSets(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSets, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSets{}

	cDes.TimeSeriesQuery = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	if dcl.IsZeroValue(des.PlotType) || (dcl.IsEmptyValueIndirect(des.PlotType) && dcl.IsEmptyValueIndirect(initial.PlotType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PlotType = initial.PlotType
	} else {
		cDes.PlotType = des.PlotType
	}
	if dcl.StringCanonicalize(des.LegendTemplate, initial.LegendTemplate) || dcl.IsZeroValue(des.LegendTemplate) {
		cDes.LegendTemplate = initial.LegendTemplate
	} else {
		cDes.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSets, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSets(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSets) *DashboardMosaicLayoutTilesWidgetXyChartDataSets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	if dcl.StringCanonicalize(des.LegendTemplate, nw.LegendTemplate) {
		nw.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSets) []DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSets) []DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartThresholds(des, initial *DashboardMosaicLayoutTilesWidgetXyChartThresholds, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartThresholds, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartThresholds(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartThresholds) *DashboardMosaicLayoutTilesWidgetXyChartThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartThresholdsSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartThresholds) []DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartThresholds) []DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartXAxis(des, initial *DashboardMosaicLayoutTilesWidgetXyChartXAxis, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartXAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartXAxisSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartXAxis, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartXAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartXAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartXAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartXAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartXAxis(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartXAxis) *DashboardMosaicLayoutTilesWidgetXyChartXAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartXAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartXAxisSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartXAxis) []DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartXAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartXAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartXAxisSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartXAxis) []DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartXAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartYAxis(des, initial *DashboardMosaicLayoutTilesWidgetXyChartYAxis, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartYAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartYAxisSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartYAxis, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartYAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartYAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartYAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartYAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartYAxis(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartYAxis) *DashboardMosaicLayoutTilesWidgetXyChartYAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartYAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartYAxisSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartYAxis) []DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartYAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartYAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartYAxisSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartYAxis) []DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartYAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartChartOptions(des, initial *DashboardMosaicLayoutTilesWidgetXyChartChartOptions, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}

	if dcl.IsZeroValue(des.Mode) || (dcl.IsEmptyValueIndirect(des.Mode) && dcl.IsEmptyValueIndirect(initial.Mode)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Mode = initial.Mode
	} else {
		cDes.Mode = des.Mode
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSlice(des, initial []DashboardMosaicLayoutTilesWidgetXyChartChartOptions, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetXyChartChartOptions, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartChartOptions(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartChartOptions, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetXyChartChartOptions(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetXyChartChartOptions) *DashboardMosaicLayoutTilesWidgetXyChartChartOptions {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetXyChartChartOptions while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartChartOptions) []DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetXyChartChartOptions
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetXyChartChartOptionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetXyChartChartOptions) []DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetXyChartChartOptions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecard(des, initial *DashboardMosaicLayoutTilesWidgetScorecard, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecard {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecard{}

	cDes.TimeSeriesQuery = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	cDes.GaugeView = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardGaugeView(des.GaugeView, initial.GaugeView, opts...)
	cDes.SparkChartView = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(des.SparkChartView, initial.SparkChartView, opts...)
	cDes.Thresholds = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecard, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecard {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecard, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecard(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecard, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecard(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecard(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecard) *DashboardMosaicLayoutTilesWidgetScorecard {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecard while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	nw.GaugeView = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, des.GaugeView, nw.GaugeView)
	nw.SparkChartView = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, des.SparkChartView, nw.SparkChartView)
	nw.Thresholds = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(c, des.Thresholds, nw.Thresholds)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecard) []DashboardMosaicLayoutTilesWidgetScorecard {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecard
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecard(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecard) []DashboardMosaicLayoutTilesWidgetScorecard {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecard
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecard(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardGaugeView(des, initial *DashboardMosaicLayoutTilesWidgetScorecardGaugeView, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}

	if dcl.IsZeroValue(des.LowerBound) || (dcl.IsEmptyValueIndirect(des.LowerBound) && dcl.IsEmptyValueIndirect(initial.LowerBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.LowerBound = initial.LowerBound
	} else {
		cDes.LowerBound = des.LowerBound
	}
	if dcl.IsZeroValue(des.UpperBound) || (dcl.IsEmptyValueIndirect(des.UpperBound) && dcl.IsEmptyValueIndirect(initial.UpperBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.UpperBound = initial.UpperBound
	} else {
		cDes.UpperBound = des.UpperBound
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardGaugeView, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardGaugeView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardGaugeView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardGaugeView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardGaugeView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardGaugeView) *DashboardMosaicLayoutTilesWidgetScorecardGaugeView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardGaugeView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardGaugeView) []DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardGaugeView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardGaugeViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardGaugeView) []DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardGaugeView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(des, initial *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}

	if dcl.IsZeroValue(des.SparkChartType) || (dcl.IsEmptyValueIndirect(des.SparkChartType) && dcl.IsEmptyValueIndirect(initial.SparkChartType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.SparkChartType = initial.SparkChartType
	} else {
		cDes.SparkChartType = des.SparkChartType
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView) *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardSparkChartView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView) []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView) []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardThresholds(des, initial *DashboardMosaicLayoutTilesWidgetScorecardThresholds, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetScorecardThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(des, initial []DashboardMosaicLayoutTilesWidgetScorecardThresholds, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetScorecardThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetScorecardThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardThresholds(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetScorecardThresholds) *DashboardMosaicLayoutTilesWidgetScorecardThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetScorecardThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardThresholdsSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardThresholds) []DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetScorecardThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetScorecardThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetScorecardThresholds) []DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetScorecardThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetScorecardThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetText(des, initial *DashboardMosaicLayoutTilesWidgetText, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetText {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetText{}

	if dcl.StringCanonicalize(des.Content, initial.Content) || dcl.IsZeroValue(des.Content) {
		cDes.Content = initial.Content
	} else {
		cDes.Content = des.Content
	}
	if dcl.IsZeroValue(des.Format) || (dcl.IsEmptyValueIndirect(des.Format) && dcl.IsEmptyValueIndirect(initial.Format)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Format = initial.Format
	} else {
		cDes.Format = des.Format
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetTextSlice(des, initial []DashboardMosaicLayoutTilesWidgetText, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetText {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetText, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetText(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetText, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetText(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetText(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetText) *DashboardMosaicLayoutTilesWidgetText {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetText while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Content, nw.Content) {
		nw.Content = des.Content
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetTextSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetText) []DashboardMosaicLayoutTilesWidgetText {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetText
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetTextNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetText(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetTextSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetText) []DashboardMosaicLayoutTilesWidgetText {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetText
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetText(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetBlank(des, initial *DashboardMosaicLayoutTilesWidgetBlank, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetBlank {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}
	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetBlank{}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetBlankSlice(des, initial []DashboardMosaicLayoutTilesWidgetBlank, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetBlank {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetBlank, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetBlank(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetBlank, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetBlank(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetBlank(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetBlank) *DashboardMosaicLayoutTilesWidgetBlank {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetBlank while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetBlankSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetBlank) []DashboardMosaicLayoutTilesWidgetBlank {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetBlank
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetBlankNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetBlank(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetBlankSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetBlank) []DashboardMosaicLayoutTilesWidgetBlank {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetBlank
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetBlank(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardMosaicLayoutTilesWidgetLogsPanel(des, initial *DashboardMosaicLayoutTilesWidgetLogsPanel, opts ...dcl.ApplyOption) *DashboardMosaicLayoutTilesWidgetLogsPanel {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardMosaicLayoutTilesWidgetLogsPanel{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, initial.ResourceNames) {
		cDes.ResourceNames = initial.ResourceNames
	} else {
		cDes.ResourceNames = des.ResourceNames
	}

	return cDes
}

func canonicalizeDashboardMosaicLayoutTilesWidgetLogsPanelSlice(des, initial []DashboardMosaicLayoutTilesWidgetLogsPanel, opts ...dcl.ApplyOption) []DashboardMosaicLayoutTilesWidgetLogsPanel {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardMosaicLayoutTilesWidgetLogsPanel, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardMosaicLayoutTilesWidgetLogsPanel(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardMosaicLayoutTilesWidgetLogsPanel, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardMosaicLayoutTilesWidgetLogsPanel(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetLogsPanel(c *Client, des, nw *DashboardMosaicLayoutTilesWidgetLogsPanel) *DashboardMosaicLayoutTilesWidgetLogsPanel {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardMosaicLayoutTilesWidgetLogsPanel while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, nw.ResourceNames) {
		nw.ResourceNames = des.ResourceNames
	}

	return nw
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetLogsPanelSet(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetLogsPanel) []DashboardMosaicLayoutTilesWidgetLogsPanel {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardMosaicLayoutTilesWidgetLogsPanel
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardMosaicLayoutTilesWidgetLogsPanelNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetLogsPanel(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardMosaicLayoutTilesWidgetLogsPanelSlice(c *Client, des, nw []DashboardMosaicLayoutTilesWidgetLogsPanel) []DashboardMosaicLayoutTilesWidgetLogsPanel {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardMosaicLayoutTilesWidgetLogsPanel
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardMosaicLayoutTilesWidgetLogsPanel(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayout(des, initial *DashboardRowLayout, opts ...dcl.ApplyOption) *DashboardRowLayout {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayout{}

	cDes.Rows = canonicalizeDashboardRowLayoutRowsSlice(des.Rows, initial.Rows, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutSlice(des, initial []DashboardRowLayout, opts ...dcl.ApplyOption) []DashboardRowLayout {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayout, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayout(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayout, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayout(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayout(c *Client, des, nw *DashboardRowLayout) *DashboardRowLayout {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayout while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Rows = canonicalizeNewDashboardRowLayoutRowsSlice(c, des.Rows, nw.Rows)

	return nw
}

func canonicalizeNewDashboardRowLayoutSet(c *Client, des, nw []DashboardRowLayout) []DashboardRowLayout {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayout
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayout(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutSlice(c *Client, des, nw []DashboardRowLayout) []DashboardRowLayout {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayout
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayout(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRows(des, initial *DashboardRowLayoutRows, opts ...dcl.ApplyOption) *DashboardRowLayoutRows {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRows{}

	if dcl.IsZeroValue(des.Weight) || (dcl.IsEmptyValueIndirect(des.Weight) && dcl.IsEmptyValueIndirect(initial.Weight)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Weight = initial.Weight
	} else {
		cDes.Weight = des.Weight
	}
	cDes.Widgets = canonicalizeDashboardRowLayoutRowsWidgetsSlice(des.Widgets, initial.Widgets, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsSlice(des, initial []DashboardRowLayoutRows, opts ...dcl.ApplyOption) []DashboardRowLayoutRows {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRows, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRows(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRows, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRows(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRows(c *Client, des, nw *DashboardRowLayoutRows) *DashboardRowLayoutRows {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRows while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Widgets = canonicalizeNewDashboardRowLayoutRowsWidgetsSlice(c, des.Widgets, nw.Widgets)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsSet(c *Client, des, nw []DashboardRowLayoutRows) []DashboardRowLayoutRows {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRows
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRows(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsSlice(c *Client, des, nw []DashboardRowLayoutRows) []DashboardRowLayoutRows {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRows
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRows(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgets(des, initial *DashboardRowLayoutRowsWidgets, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if des.XyChart != nil || (initial != nil && initial.XyChart != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.Scorecard, des.Text, des.Blank, des.LogsPanel) {
			des.XyChart = nil
			if initial != nil {
				initial.XyChart = nil
			}
		}
	}

	if des.Scorecard != nil || (initial != nil && initial.Scorecard != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Text, des.Blank, des.LogsPanel) {
			des.Scorecard = nil
			if initial != nil {
				initial.Scorecard = nil
			}
		}
	}

	if des.Text != nil || (initial != nil && initial.Text != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Blank, des.LogsPanel) {
			des.Text = nil
			if initial != nil {
				initial.Text = nil
			}
		}
	}

	if des.Blank != nil || (initial != nil && initial.Blank != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.LogsPanel) {
			des.Blank = nil
			if initial != nil {
				initial.Blank = nil
			}
		}
	}

	if des.LogsPanel != nil || (initial != nil && initial.LogsPanel != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.Blank) {
			des.LogsPanel = nil
			if initial != nil {
				initial.LogsPanel = nil
			}
		}
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgets{}

	if dcl.StringCanonicalize(des.Title, initial.Title) || dcl.IsZeroValue(des.Title) {
		cDes.Title = initial.Title
	} else {
		cDes.Title = des.Title
	}
	cDes.XyChart = canonicalizeDashboardRowLayoutRowsWidgetsXyChart(des.XyChart, initial.XyChart, opts...)
	cDes.Scorecard = canonicalizeDashboardRowLayoutRowsWidgetsScorecard(des.Scorecard, initial.Scorecard, opts...)
	cDes.Text = canonicalizeDashboardRowLayoutRowsWidgetsText(des.Text, initial.Text, opts...)
	cDes.Blank = canonicalizeDashboardRowLayoutRowsWidgetsBlank(des.Blank, initial.Blank, opts...)
	cDes.LogsPanel = canonicalizeDashboardRowLayoutRowsWidgetsLogsPanel(des.LogsPanel, initial.LogsPanel, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsSlice(des, initial []DashboardRowLayoutRowsWidgets, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgets(c *Client, des, nw *DashboardRowLayoutRowsWidgets) *DashboardRowLayoutRowsWidgets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Title, nw.Title) {
		nw.Title = des.Title
	}
	nw.XyChart = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChart(c, des.XyChart, nw.XyChart)
	nw.Scorecard = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecard(c, des.Scorecard, nw.Scorecard)
	nw.Text = canonicalizeNewDashboardRowLayoutRowsWidgetsText(c, des.Text, nw.Text)
	nw.Blank = canonicalizeNewDashboardRowLayoutRowsWidgetsBlank(c, des.Blank, nw.Blank)
	nw.LogsPanel = canonicalizeNewDashboardRowLayoutRowsWidgetsLogsPanel(c, des.LogsPanel, nw.LogsPanel)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsSet(c *Client, des, nw []DashboardRowLayoutRowsWidgets) []DashboardRowLayoutRowsWidgets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgets) []DashboardRowLayoutRowsWidgets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChart(des, initial *DashboardRowLayoutRowsWidgetsXyChart, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChart {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChart{}

	cDes.DataSets = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(des.DataSets, initial.DataSets, opts...)
	if dcl.StringCanonicalize(des.TimeshiftDuration, initial.TimeshiftDuration) || dcl.IsZeroValue(des.TimeshiftDuration) {
		cDes.TimeshiftDuration = initial.TimeshiftDuration
	} else {
		cDes.TimeshiftDuration = des.TimeshiftDuration
	}
	cDes.Thresholds = canonicalizeDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)
	cDes.XAxis = canonicalizeDashboardRowLayoutRowsWidgetsXyChartXAxis(des.XAxis, initial.XAxis, opts...)
	cDes.YAxis = canonicalizeDashboardRowLayoutRowsWidgetsXyChartYAxis(des.YAxis, initial.YAxis, opts...)
	cDes.ChartOptions = canonicalizeDashboardRowLayoutRowsWidgetsXyChartChartOptions(des.ChartOptions, initial.ChartOptions, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChart, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChart {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChart, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChart(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChart, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChart(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChart(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChart) *DashboardRowLayoutRowsWidgetsXyChart {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChart while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.DataSets = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(c, des.DataSets, nw.DataSets)
	if dcl.StringCanonicalize(des.TimeshiftDuration, nw.TimeshiftDuration) {
		nw.TimeshiftDuration = des.TimeshiftDuration
	}
	nw.Thresholds = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(c, des.Thresholds, nw.Thresholds)
	nw.XAxis = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartXAxis(c, des.XAxis, nw.XAxis)
	nw.YAxis = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartYAxis(c, des.YAxis, nw.YAxis)
	nw.ChartOptions = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, des.ChartOptions, nw.ChartOptions)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChart) []DashboardRowLayoutRowsWidgetsXyChart {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChart
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChart(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChart) []DashboardRowLayoutRowsWidgetsXyChart {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChart
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChart(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSets(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSets, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSets{}

	cDes.TimeSeriesQuery = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	if dcl.IsZeroValue(des.PlotType) || (dcl.IsEmptyValueIndirect(des.PlotType) && dcl.IsEmptyValueIndirect(initial.PlotType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PlotType = initial.PlotType
	} else {
		cDes.PlotType = des.PlotType
	}
	if dcl.StringCanonicalize(des.LegendTemplate, initial.LegendTemplate) || dcl.IsZeroValue(des.LegendTemplate) {
		cDes.LegendTemplate = initial.LegendTemplate
	} else {
		cDes.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSets, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSets(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSets) *DashboardRowLayoutRowsWidgetsXyChartDataSets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	if dcl.StringCanonicalize(des.LegendTemplate, nw.LegendTemplate) {
		nw.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSets) []DashboardRowLayoutRowsWidgetsXyChartDataSets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSets) []DashboardRowLayoutRowsWidgetsXyChartDataSets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartThresholds(des, initial *DashboardRowLayoutRowsWidgetsXyChartThresholds, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartThresholds, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartThresholds(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartThresholds) *DashboardRowLayoutRowsWidgetsXyChartThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartThresholdsSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartThresholds) []DashboardRowLayoutRowsWidgetsXyChartThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartThresholds) []DashboardRowLayoutRowsWidgetsXyChartThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartXAxis(des, initial *DashboardRowLayoutRowsWidgetsXyChartXAxis, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartXAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartXAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartXAxisSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartXAxis, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartXAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartXAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartXAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartXAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartXAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartXAxis(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartXAxis) *DashboardRowLayoutRowsWidgetsXyChartXAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartXAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartXAxisSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartXAxis) []DashboardRowLayoutRowsWidgetsXyChartXAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartXAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartXAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartXAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartXAxisSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartXAxis) []DashboardRowLayoutRowsWidgetsXyChartXAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartXAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartXAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartYAxis(des, initial *DashboardRowLayoutRowsWidgetsXyChartYAxis, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartYAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartYAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartYAxisSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartYAxis, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartYAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartYAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartYAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartYAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartYAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartYAxis(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartYAxis) *DashboardRowLayoutRowsWidgetsXyChartYAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartYAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartYAxisSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartYAxis) []DashboardRowLayoutRowsWidgetsXyChartYAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartYAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartYAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartYAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartYAxisSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartYAxis) []DashboardRowLayoutRowsWidgetsXyChartYAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartYAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartYAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartChartOptions(des, initial *DashboardRowLayoutRowsWidgetsXyChartChartOptions, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsXyChartChartOptions{}

	if dcl.IsZeroValue(des.Mode) || (dcl.IsEmptyValueIndirect(des.Mode) && dcl.IsEmptyValueIndirect(initial.Mode)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Mode = initial.Mode
	} else {
		cDes.Mode = des.Mode
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsXyChartChartOptionsSlice(des, initial []DashboardRowLayoutRowsWidgetsXyChartChartOptions, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsXyChartChartOptions, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartChartOptions(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartChartOptions, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsXyChartChartOptions(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartChartOptions(c *Client, des, nw *DashboardRowLayoutRowsWidgetsXyChartChartOptions) *DashboardRowLayoutRowsWidgetsXyChartChartOptions {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsXyChartChartOptions while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartChartOptionsSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartChartOptions) []DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsXyChartChartOptions
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsXyChartChartOptionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartChartOptionsSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsXyChartChartOptions) []DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsXyChartChartOptions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecard(des, initial *DashboardRowLayoutRowsWidgetsScorecard, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecard {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecard{}

	cDes.TimeSeriesQuery = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	cDes.GaugeView = canonicalizeDashboardRowLayoutRowsWidgetsScorecardGaugeView(des.GaugeView, initial.GaugeView, opts...)
	cDes.SparkChartView = canonicalizeDashboardRowLayoutRowsWidgetsScorecardSparkChartView(des.SparkChartView, initial.SparkChartView, opts...)
	cDes.Thresholds = canonicalizeDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecard, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecard {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecard, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecard(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecard, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecard(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecard(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecard) *DashboardRowLayoutRowsWidgetsScorecard {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecard while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	nw.GaugeView = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, des.GaugeView, nw.GaugeView)
	nw.SparkChartView = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, des.SparkChartView, nw.SparkChartView)
	nw.Thresholds = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(c, des.Thresholds, nw.Thresholds)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecard) []DashboardRowLayoutRowsWidgetsScorecard {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecard
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecard(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecard) []DashboardRowLayoutRowsWidgetsScorecard {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecard
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecard(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardGaugeView(des, initial *DashboardRowLayoutRowsWidgetsScorecardGaugeView, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardGaugeView{}

	if dcl.IsZeroValue(des.LowerBound) || (dcl.IsEmptyValueIndirect(des.LowerBound) && dcl.IsEmptyValueIndirect(initial.LowerBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.LowerBound = initial.LowerBound
	} else {
		cDes.LowerBound = des.LowerBound
	}
	if dcl.IsZeroValue(des.UpperBound) || (dcl.IsEmptyValueIndirect(des.UpperBound) && dcl.IsEmptyValueIndirect(initial.UpperBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.UpperBound = initial.UpperBound
	} else {
		cDes.UpperBound = des.UpperBound
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardGaugeViewSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardGaugeView, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardGaugeView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardGaugeView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardGaugeView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardGaugeView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardGaugeView(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardGaugeView) *DashboardRowLayoutRowsWidgetsScorecardGaugeView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardGaugeView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardGaugeViewSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardGaugeView) []DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardGaugeView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardGaugeViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardGaugeViewSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardGaugeView) []DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardGaugeView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardSparkChartView(des, initial *DashboardRowLayoutRowsWidgetsScorecardSparkChartView, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}

	if dcl.IsZeroValue(des.SparkChartType) || (dcl.IsEmptyValueIndirect(des.SparkChartType) && dcl.IsEmptyValueIndirect(initial.SparkChartType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.SparkChartType = initial.SparkChartType
	} else {
		cDes.SparkChartType = des.SparkChartType
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardSparkChartView, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardSparkChartView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardSparkChartView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardSparkChartView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardSparkChartView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardSparkChartView) *DashboardRowLayoutRowsWidgetsScorecardSparkChartView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardSparkChartView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardSparkChartView) []DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardSparkChartView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardSparkChartViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardSparkChartView) []DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardSparkChartView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardThresholds(des, initial *DashboardRowLayoutRowsWidgetsScorecardThresholds, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsScorecardThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsScorecardThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(des, initial []DashboardRowLayoutRowsWidgetsScorecardThresholds, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsScorecardThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsScorecardThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsScorecardThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardThresholds(c *Client, des, nw *DashboardRowLayoutRowsWidgetsScorecardThresholds) *DashboardRowLayoutRowsWidgetsScorecardThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsScorecardThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardThresholdsSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardThresholds) []DashboardRowLayoutRowsWidgetsScorecardThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsScorecardThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsScorecardThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsScorecardThresholds) []DashboardRowLayoutRowsWidgetsScorecardThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsScorecardThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsScorecardThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsText(des, initial *DashboardRowLayoutRowsWidgetsText, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsText {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsText{}

	if dcl.StringCanonicalize(des.Content, initial.Content) || dcl.IsZeroValue(des.Content) {
		cDes.Content = initial.Content
	} else {
		cDes.Content = des.Content
	}
	if dcl.IsZeroValue(des.Format) || (dcl.IsEmptyValueIndirect(des.Format) && dcl.IsEmptyValueIndirect(initial.Format)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Format = initial.Format
	} else {
		cDes.Format = des.Format
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsTextSlice(des, initial []DashboardRowLayoutRowsWidgetsText, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsText {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsText, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsText(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsText, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsText(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsText(c *Client, des, nw *DashboardRowLayoutRowsWidgetsText) *DashboardRowLayoutRowsWidgetsText {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsText while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Content, nw.Content) {
		nw.Content = des.Content
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsTextSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsText) []DashboardRowLayoutRowsWidgetsText {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsText
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsTextNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsText(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsTextSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsText) []DashboardRowLayoutRowsWidgetsText {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsText
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsText(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsBlank(des, initial *DashboardRowLayoutRowsWidgetsBlank, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsBlank {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}
	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsBlank{}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsBlankSlice(des, initial []DashboardRowLayoutRowsWidgetsBlank, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsBlank {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsBlank, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsBlank(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsBlank, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsBlank(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsBlank(c *Client, des, nw *DashboardRowLayoutRowsWidgetsBlank) *DashboardRowLayoutRowsWidgetsBlank {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsBlank while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsBlankSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsBlank) []DashboardRowLayoutRowsWidgetsBlank {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsBlank
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsBlankNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsBlank(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsBlankSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsBlank) []DashboardRowLayoutRowsWidgetsBlank {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsBlank
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsBlank(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardRowLayoutRowsWidgetsLogsPanel(des, initial *DashboardRowLayoutRowsWidgetsLogsPanel, opts ...dcl.ApplyOption) *DashboardRowLayoutRowsWidgetsLogsPanel {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardRowLayoutRowsWidgetsLogsPanel{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, initial.ResourceNames) {
		cDes.ResourceNames = initial.ResourceNames
	} else {
		cDes.ResourceNames = des.ResourceNames
	}

	return cDes
}

func canonicalizeDashboardRowLayoutRowsWidgetsLogsPanelSlice(des, initial []DashboardRowLayoutRowsWidgetsLogsPanel, opts ...dcl.ApplyOption) []DashboardRowLayoutRowsWidgetsLogsPanel {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardRowLayoutRowsWidgetsLogsPanel, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardRowLayoutRowsWidgetsLogsPanel(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardRowLayoutRowsWidgetsLogsPanel, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardRowLayoutRowsWidgetsLogsPanel(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardRowLayoutRowsWidgetsLogsPanel(c *Client, des, nw *DashboardRowLayoutRowsWidgetsLogsPanel) *DashboardRowLayoutRowsWidgetsLogsPanel {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardRowLayoutRowsWidgetsLogsPanel while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, nw.ResourceNames) {
		nw.ResourceNames = des.ResourceNames
	}

	return nw
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsLogsPanelSet(c *Client, des, nw []DashboardRowLayoutRowsWidgetsLogsPanel) []DashboardRowLayoutRowsWidgetsLogsPanel {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardRowLayoutRowsWidgetsLogsPanel
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardRowLayoutRowsWidgetsLogsPanelNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsLogsPanel(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardRowLayoutRowsWidgetsLogsPanelSlice(c *Client, des, nw []DashboardRowLayoutRowsWidgetsLogsPanel) []DashboardRowLayoutRowsWidgetsLogsPanel {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardRowLayoutRowsWidgetsLogsPanel
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardRowLayoutRowsWidgetsLogsPanel(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayout(des, initial *DashboardColumnLayout, opts ...dcl.ApplyOption) *DashboardColumnLayout {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayout{}

	cDes.Columns = canonicalizeDashboardColumnLayoutColumnsSlice(des.Columns, initial.Columns, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutSlice(des, initial []DashboardColumnLayout, opts ...dcl.ApplyOption) []DashboardColumnLayout {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayout, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayout(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayout, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayout(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayout(c *Client, des, nw *DashboardColumnLayout) *DashboardColumnLayout {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayout while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Columns = canonicalizeNewDashboardColumnLayoutColumnsSlice(c, des.Columns, nw.Columns)

	return nw
}

func canonicalizeNewDashboardColumnLayoutSet(c *Client, des, nw []DashboardColumnLayout) []DashboardColumnLayout {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayout
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayout(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutSlice(c *Client, des, nw []DashboardColumnLayout) []DashboardColumnLayout {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayout
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayout(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumns(des, initial *DashboardColumnLayoutColumns, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumns {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumns{}

	if dcl.IsZeroValue(des.Weight) || (dcl.IsEmptyValueIndirect(des.Weight) && dcl.IsEmptyValueIndirect(initial.Weight)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Weight = initial.Weight
	} else {
		cDes.Weight = des.Weight
	}
	cDes.Widgets = canonicalizeDashboardColumnLayoutColumnsWidgetsSlice(des.Widgets, initial.Widgets, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsSlice(des, initial []DashboardColumnLayoutColumns, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumns {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumns, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumns(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumns, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumns(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumns(c *Client, des, nw *DashboardColumnLayoutColumns) *DashboardColumnLayoutColumns {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumns while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Widgets = canonicalizeNewDashboardColumnLayoutColumnsWidgetsSlice(c, des.Widgets, nw.Widgets)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsSet(c *Client, des, nw []DashboardColumnLayoutColumns) []DashboardColumnLayoutColumns {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumns
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumns(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsSlice(c *Client, des, nw []DashboardColumnLayoutColumns) []DashboardColumnLayoutColumns {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumns
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumns(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgets(des, initial *DashboardColumnLayoutColumnsWidgets, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if des.XyChart != nil || (initial != nil && initial.XyChart != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.Scorecard, des.Text, des.Blank, des.LogsPanel) {
			des.XyChart = nil
			if initial != nil {
				initial.XyChart = nil
			}
		}
	}

	if des.Scorecard != nil || (initial != nil && initial.Scorecard != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Text, des.Blank, des.LogsPanel) {
			des.Scorecard = nil
			if initial != nil {
				initial.Scorecard = nil
			}
		}
	}

	if des.Text != nil || (initial != nil && initial.Text != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Blank, des.LogsPanel) {
			des.Text = nil
			if initial != nil {
				initial.Text = nil
			}
		}
	}

	if des.Blank != nil || (initial != nil && initial.Blank != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.LogsPanel) {
			des.Blank = nil
			if initial != nil {
				initial.Blank = nil
			}
		}
	}

	if des.LogsPanel != nil || (initial != nil && initial.LogsPanel != nil) {
		// Check if anything else is set.
		if dcl.AnySet(des.XyChart, des.Scorecard, des.Text, des.Blank) {
			des.LogsPanel = nil
			if initial != nil {
				initial.LogsPanel = nil
			}
		}
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgets{}

	if dcl.StringCanonicalize(des.Title, initial.Title) || dcl.IsZeroValue(des.Title) {
		cDes.Title = initial.Title
	} else {
		cDes.Title = des.Title
	}
	cDes.XyChart = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChart(des.XyChart, initial.XyChart, opts...)
	cDes.Scorecard = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecard(des.Scorecard, initial.Scorecard, opts...)
	cDes.Text = canonicalizeDashboardColumnLayoutColumnsWidgetsText(des.Text, initial.Text, opts...)
	cDes.Blank = canonicalizeDashboardColumnLayoutColumnsWidgetsBlank(des.Blank, initial.Blank, opts...)
	cDes.LogsPanel = canonicalizeDashboardColumnLayoutColumnsWidgetsLogsPanel(des.LogsPanel, initial.LogsPanel, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsSlice(des, initial []DashboardColumnLayoutColumnsWidgets, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgets(c *Client, des, nw *DashboardColumnLayoutColumnsWidgets) *DashboardColumnLayoutColumnsWidgets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Title, nw.Title) {
		nw.Title = des.Title
	}
	nw.XyChart = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChart(c, des.XyChart, nw.XyChart)
	nw.Scorecard = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecard(c, des.Scorecard, nw.Scorecard)
	nw.Text = canonicalizeNewDashboardColumnLayoutColumnsWidgetsText(c, des.Text, nw.Text)
	nw.Blank = canonicalizeNewDashboardColumnLayoutColumnsWidgetsBlank(c, des.Blank, nw.Blank)
	nw.LogsPanel = canonicalizeNewDashboardColumnLayoutColumnsWidgetsLogsPanel(c, des.LogsPanel, nw.LogsPanel)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgets) []DashboardColumnLayoutColumnsWidgets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgets) []DashboardColumnLayoutColumnsWidgets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChart(des, initial *DashboardColumnLayoutColumnsWidgetsXyChart, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChart {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChart{}

	cDes.DataSets = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(des.DataSets, initial.DataSets, opts...)
	if dcl.StringCanonicalize(des.TimeshiftDuration, initial.TimeshiftDuration) || dcl.IsZeroValue(des.TimeshiftDuration) {
		cDes.TimeshiftDuration = initial.TimeshiftDuration
	} else {
		cDes.TimeshiftDuration = des.TimeshiftDuration
	}
	cDes.Thresholds = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)
	cDes.XAxis = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartXAxis(des.XAxis, initial.XAxis, opts...)
	cDes.YAxis = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartYAxis(des.YAxis, initial.YAxis, opts...)
	cDes.ChartOptions = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(des.ChartOptions, initial.ChartOptions, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChart, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChart {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChart, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChart(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChart, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChart(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChart(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChart) *DashboardColumnLayoutColumnsWidgetsXyChart {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChart while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.DataSets = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(c, des.DataSets, nw.DataSets)
	if dcl.StringCanonicalize(des.TimeshiftDuration, nw.TimeshiftDuration) {
		nw.TimeshiftDuration = des.TimeshiftDuration
	}
	nw.Thresholds = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(c, des.Thresholds, nw.Thresholds)
	nw.XAxis = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, des.XAxis, nw.XAxis)
	nw.YAxis = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, des.YAxis, nw.YAxis)
	nw.ChartOptions = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, des.ChartOptions, nw.ChartOptions)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChart) []DashboardColumnLayoutColumnsWidgetsXyChart {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChart
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChart(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChart) []DashboardColumnLayoutColumnsWidgetsXyChart {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChart
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChart(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSets(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSets, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSets{}

	cDes.TimeSeriesQuery = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	if dcl.IsZeroValue(des.PlotType) || (dcl.IsEmptyValueIndirect(des.PlotType) && dcl.IsEmptyValueIndirect(initial.PlotType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PlotType = initial.PlotType
	} else {
		cDes.PlotType = des.PlotType
	}
	if dcl.StringCanonicalize(des.LegendTemplate, initial.LegendTemplate) || dcl.IsZeroValue(des.LegendTemplate) {
		cDes.LegendTemplate = initial.LegendTemplate
	} else {
		cDes.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSets, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSets, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSets(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSets, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSets(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSets) *DashboardColumnLayoutColumnsWidgetsXyChartDataSets {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSets while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	if dcl.StringCanonicalize(des.LegendTemplate, nw.LegendTemplate) {
		nw.LegendTemplate = des.LegendTemplate
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSets) []DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSets
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSets) []DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSets
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartThresholds(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartThresholds, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartThresholds, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartThresholds) *DashboardColumnLayoutColumnsWidgetsXyChartThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartThresholds) []DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartThresholds) []DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartXAxis(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartXAxis, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartXAxisSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartXAxis, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartXAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartXAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartXAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartXAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartXAxis) *DashboardColumnLayoutColumnsWidgetsXyChartXAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartXAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartXAxisSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartXAxis) []DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartXAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartXAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartXAxisSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartXAxis) []DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartXAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartYAxis(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartYAxis, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Scale) || (dcl.IsEmptyValueIndirect(des.Scale) && dcl.IsEmptyValueIndirect(initial.Scale)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Scale = initial.Scale
	} else {
		cDes.Scale = des.Scale
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartYAxisSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartYAxis, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartYAxis, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartYAxis(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartYAxis, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartYAxis(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartYAxis) *DashboardColumnLayoutColumnsWidgetsXyChartYAxis {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartYAxis while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartYAxisSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartYAxis) []DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartYAxis
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartYAxisNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartYAxisSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartYAxis) []DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartYAxis
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(des, initial *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}

	if dcl.IsZeroValue(des.Mode) || (dcl.IsEmptyValueIndirect(des.Mode) && dcl.IsEmptyValueIndirect(initial.Mode)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Mode = initial.Mode
	} else {
		cDes.Mode = des.Mode
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSlice(des, initial []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions) *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsXyChartChartOptions while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions) []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions) []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecard(des, initial *DashboardColumnLayoutColumnsWidgetsScorecard, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecard {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecard{}

	cDes.TimeSeriesQuery = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(des.TimeSeriesQuery, initial.TimeSeriesQuery, opts...)
	cDes.GaugeView = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(des.GaugeView, initial.GaugeView, opts...)
	cDes.SparkChartView = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(des.SparkChartView, initial.SparkChartView, opts...)
	cDes.Thresholds = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(des.Thresholds, initial.Thresholds, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecard, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecard {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecard, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecard(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecard, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecard(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecard(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecard) *DashboardColumnLayoutColumnsWidgetsScorecard {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecard while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesQuery = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, des.TimeSeriesQuery, nw.TimeSeriesQuery)
	nw.GaugeView = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, des.GaugeView, nw.GaugeView)
	nw.SparkChartView = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, des.SparkChartView, nw.SparkChartView)
	nw.Thresholds = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(c, des.Thresholds, nw.Thresholds)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecard) []DashboardColumnLayoutColumnsWidgetsScorecard {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecard
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecard(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecard) []DashboardColumnLayoutColumnsWidgetsScorecard {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecard
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecard(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}

	cDes.TimeSeriesFilter = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(des.TimeSeriesFilter, initial.TimeSeriesFilter, opts...)
	cDes.TimeSeriesFilterRatio = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(des.TimeSeriesFilterRatio, initial.TimeSeriesFilterRatio, opts...)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, initial.TimeSeriesQueryLanguage) || dcl.IsZeroValue(des.TimeSeriesQueryLanguage) {
		cDes.TimeSeriesQueryLanguage = initial.TimeSeriesQueryLanguage
	} else {
		cDes.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, initial.UnitOverride) || dcl.IsZeroValue(des.UnitOverride) {
		cDes.UnitOverride = initial.UnitOverride
	} else {
		cDes.UnitOverride = des.UnitOverride
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.TimeSeriesFilter = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, des.TimeSeriesFilter, nw.TimeSeriesFilter)
	nw.TimeSeriesFilterRatio = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, des.TimeSeriesFilterRatio, nw.TimeSeriesFilterRatio)
	if dcl.StringCanonicalize(des.TimeSeriesQueryLanguage, nw.TimeSeriesQueryLanguage) {
		nw.TimeSeriesQueryLanguage = des.TimeSeriesQueryLanguage
	}
	if dcl.StringCanonicalize(des.UnitOverride, nw.UnitOverride) {
		nw.UnitOverride = des.UnitOverride
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des.Aggregation, initial.Aggregation, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, des.Aggregation, nw.Aggregation)
	nw.SecondaryAggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	cDes.Numerator = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des.Numerator, initial.Numerator, opts...)
	cDes.Denominator = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des.Denominator, initial.Denominator, opts...)
	cDes.SecondaryAggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des.SecondaryAggregation, initial.SecondaryAggregation, opts...)
	cDes.PickTimeSeriesFilter = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des.PickTimeSeriesFilter, initial.PickTimeSeriesFilter, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	nw.Numerator = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, des.Numerator, nw.Numerator)
	nw.Denominator = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, des.Denominator, nw.Denominator)
	nw.SecondaryAggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, des.SecondaryAggregation, nw.SecondaryAggregation)
	nw.PickTimeSeriesFilter = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, des.PickTimeSeriesFilter, nw.PickTimeSeriesFilter)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	cDes.Aggregation = canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des.Aggregation, initial.Aggregation, opts...)

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	nw.Aggregation = canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, des.Aggregation, nw.Aggregation)

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.StringCanonicalize(des.AlignmentPeriod, initial.AlignmentPeriod) || dcl.IsZeroValue(des.AlignmentPeriod) {
		cDes.AlignmentPeriod = initial.AlignmentPeriod
	} else {
		cDes.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.IsZeroValue(des.PerSeriesAligner) || (dcl.IsEmptyValueIndirect(des.PerSeriesAligner) && dcl.IsEmptyValueIndirect(initial.PerSeriesAligner)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.PerSeriesAligner = initial.PerSeriesAligner
	} else {
		cDes.PerSeriesAligner = des.PerSeriesAligner
	}
	if dcl.IsZeroValue(des.CrossSeriesReducer) || (dcl.IsEmptyValueIndirect(des.CrossSeriesReducer) && dcl.IsEmptyValueIndirect(initial.CrossSeriesReducer)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.CrossSeriesReducer = initial.CrossSeriesReducer
	} else {
		cDes.CrossSeriesReducer = des.CrossSeriesReducer
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, initial.GroupByFields) {
		cDes.GroupByFields = initial.GroupByFields
	} else {
		cDes.GroupByFields = des.GroupByFields
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.AlignmentPeriod, nw.AlignmentPeriod) {
		nw.AlignmentPeriod = des.AlignmentPeriod
	}
	if dcl.StringArrayCanonicalize(des.GroupByFields, nw.GroupByFields) {
		nw.GroupByFields = des.GroupByFields
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsZeroValue(des.RankingMethod) || (dcl.IsEmptyValueIndirect(des.RankingMethod) && dcl.IsEmptyValueIndirect(initial.RankingMethod)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.RankingMethod = initial.RankingMethod
	} else {
		cDes.RankingMethod = des.RankingMethod
	}
	if dcl.IsZeroValue(des.NumTimeSeries) || (dcl.IsEmptyValueIndirect(des.NumTimeSeries) && dcl.IsEmptyValueIndirect(initial.NumTimeSeries)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.NumTimeSeries = initial.NumTimeSeries
	} else {
		cDes.NumTimeSeries = des.NumTimeSeries
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}

	if dcl.IsZeroValue(des.LowerBound) || (dcl.IsEmptyValueIndirect(des.LowerBound) && dcl.IsEmptyValueIndirect(initial.LowerBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.LowerBound = initial.LowerBound
	} else {
		cDes.LowerBound = des.LowerBound
	}
	if dcl.IsZeroValue(des.UpperBound) || (dcl.IsEmptyValueIndirect(des.UpperBound) && dcl.IsEmptyValueIndirect(initial.UpperBound)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.UpperBound = initial.UpperBound
	} else {
		cDes.UpperBound = des.UpperBound
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView) *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardGaugeView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView) []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView) []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}

	if dcl.IsZeroValue(des.SparkChartType) || (dcl.IsEmptyValueIndirect(des.SparkChartType) && dcl.IsEmptyValueIndirect(initial.SparkChartType)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.SparkChartType = initial.SparkChartType
	} else {
		cDes.SparkChartType = des.SparkChartType
	}
	if dcl.StringCanonicalize(des.MinAlignmentPeriod, initial.MinAlignmentPeriod) || dcl.IsZeroValue(des.MinAlignmentPeriod) {
		cDes.MinAlignmentPeriod = initial.MinAlignmentPeriod
	} else {
		cDes.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView) *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.MinAlignmentPeriod, nw.MinAlignmentPeriod) {
		nw.MinAlignmentPeriod = des.MinAlignmentPeriod
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView) []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView) []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardThresholds(des, initial *DashboardColumnLayoutColumnsWidgetsScorecardThresholds, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsScorecardThresholds{}

	if dcl.StringCanonicalize(des.Label, initial.Label) || dcl.IsZeroValue(des.Label) {
		cDes.Label = initial.Label
	} else {
		cDes.Label = des.Label
	}
	if dcl.IsZeroValue(des.Value) || (dcl.IsEmptyValueIndirect(des.Value) && dcl.IsEmptyValueIndirect(initial.Value)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Value = initial.Value
	} else {
		cDes.Value = des.Value
	}
	if dcl.IsZeroValue(des.Color) || (dcl.IsEmptyValueIndirect(des.Color) && dcl.IsEmptyValueIndirect(initial.Color)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Color = initial.Color
	} else {
		cDes.Color = des.Color
	}
	if dcl.IsZeroValue(des.Direction) || (dcl.IsEmptyValueIndirect(des.Direction) && dcl.IsEmptyValueIndirect(initial.Direction)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Direction = initial.Direction
	} else {
		cDes.Direction = des.Direction
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(des, initial []DashboardColumnLayoutColumnsWidgetsScorecardThresholds, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	if des == nil {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsScorecardThresholds, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardThresholds(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardThresholds, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsScorecardThresholds(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsScorecardThresholds) *DashboardColumnLayoutColumnsWidgetsScorecardThresholds {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsScorecardThresholds while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Label, nw.Label) {
		nw.Label = des.Label
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardThresholds) []DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsScorecardThresholds
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsScorecardThresholdsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsScorecardThresholds) []DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsScorecardThresholds
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsText(des, initial *DashboardColumnLayoutColumnsWidgetsText, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsText {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsText{}

	if dcl.StringCanonicalize(des.Content, initial.Content) || dcl.IsZeroValue(des.Content) {
		cDes.Content = initial.Content
	} else {
		cDes.Content = des.Content
	}
	if dcl.IsZeroValue(des.Format) || (dcl.IsEmptyValueIndirect(des.Format) && dcl.IsEmptyValueIndirect(initial.Format)) {
		// Desired and initial values are equivalent, so set canonical desired value to initial value.
		cDes.Format = initial.Format
	} else {
		cDes.Format = des.Format
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsTextSlice(des, initial []DashboardColumnLayoutColumnsWidgetsText, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsText {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsText, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsText(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsText, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsText(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsText(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsText) *DashboardColumnLayoutColumnsWidgetsText {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsText while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Content, nw.Content) {
		nw.Content = des.Content
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsTextSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsText) []DashboardColumnLayoutColumnsWidgetsText {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsText
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsTextNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsText(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsTextSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsText) []DashboardColumnLayoutColumnsWidgetsText {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsText
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsText(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsBlank(des, initial *DashboardColumnLayoutColumnsWidgetsBlank, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsBlank {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}
	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsBlank{}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsBlankSlice(des, initial []DashboardColumnLayoutColumnsWidgetsBlank, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsBlank {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsBlank, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsBlank(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsBlank, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsBlank(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsBlank(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsBlank) *DashboardColumnLayoutColumnsWidgetsBlank {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsBlank while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsBlankSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsBlank) []DashboardColumnLayoutColumnsWidgetsBlank {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsBlank
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsBlankNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsBlank(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsBlankSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsBlank) []DashboardColumnLayoutColumnsWidgetsBlank {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsBlank
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsBlank(c, &d, &n))
	}

	return items
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsLogsPanel(des, initial *DashboardColumnLayoutColumnsWidgetsLogsPanel, opts ...dcl.ApplyOption) *DashboardColumnLayoutColumnsWidgetsLogsPanel {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	cDes := &DashboardColumnLayoutColumnsWidgetsLogsPanel{}

	if dcl.StringCanonicalize(des.Filter, initial.Filter) || dcl.IsZeroValue(des.Filter) {
		cDes.Filter = initial.Filter
	} else {
		cDes.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, initial.ResourceNames) {
		cDes.ResourceNames = initial.ResourceNames
	} else {
		cDes.ResourceNames = des.ResourceNames
	}

	return cDes
}

func canonicalizeDashboardColumnLayoutColumnsWidgetsLogsPanelSlice(des, initial []DashboardColumnLayoutColumnsWidgetsLogsPanel, opts ...dcl.ApplyOption) []DashboardColumnLayoutColumnsWidgetsLogsPanel {
	if dcl.IsEmptyValueIndirect(des) {
		return initial
	}

	if len(des) != len(initial) {

		items := make([]DashboardColumnLayoutColumnsWidgetsLogsPanel, 0, len(des))
		for _, d := range des {
			cd := canonicalizeDashboardColumnLayoutColumnsWidgetsLogsPanel(&d, nil, opts...)
			if cd != nil {
				items = append(items, *cd)
			}
		}
		return items
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsLogsPanel, 0, len(des))
	for i, d := range des {
		cd := canonicalizeDashboardColumnLayoutColumnsWidgetsLogsPanel(&d, &initial[i], opts...)
		if cd != nil {
			items = append(items, *cd)
		}
	}
	return items

}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsLogsPanel(c *Client, des, nw *DashboardColumnLayoutColumnsWidgetsLogsPanel) *DashboardColumnLayoutColumnsWidgetsLogsPanel {

	if des == nil {
		return nw
	}

	if nw == nil {
		if dcl.IsEmptyValueIndirect(des) {
			c.Config.Logger.Info("Found explicitly empty value for DashboardColumnLayoutColumnsWidgetsLogsPanel while comparing non-nil desired to nil actual.  Returning desired object.")
			return des
		}
		return nil
	}

	if dcl.StringCanonicalize(des.Filter, nw.Filter) {
		nw.Filter = des.Filter
	}
	if dcl.StringArrayCanonicalize(des.ResourceNames, nw.ResourceNames) {
		nw.ResourceNames = des.ResourceNames
	}

	return nw
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsLogsPanelSet(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsLogsPanel) []DashboardColumnLayoutColumnsWidgetsLogsPanel {
	if des == nil {
		return nw
	}

	// Find the elements in des that are also in nw and canonicalize them. Remove matched elements from nw.
	var items []DashboardColumnLayoutColumnsWidgetsLogsPanel
	for _, d := range des {
		matchedIndex := -1
		for i, n := range nw {
			if diffs, _ := compareDashboardColumnLayoutColumnsWidgetsLogsPanelNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedIndex = i
				break
			}
		}
		if matchedIndex != -1 {
			items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsLogsPanel(c, &d, &nw[matchedIndex]))
			nw = append(nw[:matchedIndex], nw[matchedIndex+1:]...)
		}
	}
	// Also include elements in nw that are not matched in des.
	items = append(items, nw...)

	return items
}

func canonicalizeNewDashboardColumnLayoutColumnsWidgetsLogsPanelSlice(c *Client, des, nw []DashboardColumnLayoutColumnsWidgetsLogsPanel) []DashboardColumnLayoutColumnsWidgetsLogsPanel {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []DashboardColumnLayoutColumnsWidgetsLogsPanel
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewDashboardColumnLayoutColumnsWidgetsLogsPanel(c, &d, &n))
	}

	return items
}

// The differ returns a list of diffs, along with a list of operations that should be taken
// to remedy them. Right now, it does not attempt to consolidate operations - if several
// fields can be fixed with a patch update, it will perform the patch several times.
// Diffs on some fields will be ignored if the `desired` state has an empty (nil)
// value. This empty value indicates that the user does not care about the state for
// the field. Empty fields on the actual object will cause diffs.
// TODO(magic-modules-eng): for efficiency in some resources, add batching.
func diffDashboard(c *Client, desired, actual *Dashboard, opts ...dcl.ApplyOption) ([]*dcl.FieldDiff, error) {
	if desired == nil || actual == nil {
		return nil, fmt.Errorf("nil resource passed to diff - always a programming error: %#v, %#v", desired, actual)
	}

	c.Config.Logger.Infof("Diff function called with desired state: %v", desired)
	c.Config.Logger.Infof("Diff function called with actual state: %v", actual)

	var fn dcl.FieldName
	var newDiffs []*dcl.FieldDiff
	// New style diffs.
	if ds, err := dcl.Diff(desired.Name, actual.Name, dcl.DiffInfo{OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Name")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DisplayName, actual.DisplayName, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("DisplayName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GridLayout, actual.GridLayout, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutNewStyle, EmptyObject: EmptyDashboardGridLayout, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GridLayout")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MosaicLayout, actual.MosaicLayout, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutNewStyle, EmptyObject: EmptyDashboardMosaicLayout, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MosaicLayout")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RowLayout, actual.RowLayout, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutNewStyle, EmptyObject: EmptyDashboardRowLayout, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RowLayout")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ColumnLayout, actual.ColumnLayout, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutNewStyle, EmptyObject: EmptyDashboardColumnLayout, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ColumnLayout")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Project, actual.Project, dcl.DiffInfo{Type: "ReferenceType", OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Project")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Etag, actual.Etag, dcl.DiffInfo{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Etag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if len(newDiffs) > 0 {
		c.Config.Logger.Infof("Diff function found diffs: %v", newDiffs)
	}
	return newDiffs, nil
}
func compareDashboardGridLayoutNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayout)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayout or *DashboardGridLayout", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayout)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayout", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Columns, actual.Columns, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Columns")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Widgets, actual.Widgets, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Widgets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgets or *DashboardGridLayoutWidgets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgets)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Title, actual.Title, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Title")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XyChart, actual.XyChart, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChart, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XyChart")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scorecard, actual.Scorecard, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecard, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scorecard")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Text, actual.Text, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsTextNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsText, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Text")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Blank, actual.Blank, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsBlankNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsBlank, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Blank")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LogsPanel, actual.LogsPanel, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsLogsPanelNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsLogsPanel, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("LogsPanel")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChart)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChart or *DashboardGridLayoutWidgetsXyChart", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChart)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChart", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataSets, actual.DataSets, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("DataSets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeshiftDuration, actual.TimeshiftDuration, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeshiftDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartThresholdsNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XAxis, actual.XAxis, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartXAxisNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartXAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.YAxis, actual.YAxis, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartYAxisNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartYAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("YAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ChartOptions, actual.ChartOptions, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartChartOptionsNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartChartOptions, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ChartOptions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSets or *DashboardGridLayoutWidgetsXyChartDataSets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSets)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PlotType, actual.PlotType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PlotType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LegendTemplate, actual.LegendTemplate, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LegendTemplate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartThresholds or *DashboardGridLayoutWidgetsXyChartThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartXAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartXAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartXAxis or *DashboardGridLayoutWidgetsXyChartXAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartXAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartXAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartYAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartYAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartYAxis or *DashboardGridLayoutWidgetsXyChartYAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartYAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartYAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsXyChartChartOptionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsXyChartChartOptions)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartChartOptions or *DashboardGridLayoutWidgetsXyChartChartOptions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsXyChartChartOptions)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsXyChartChartOptions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Mode, actual.Mode, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Mode")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecard)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecard or *DashboardGridLayoutWidgetsScorecard", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecard)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecard", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GaugeView, actual.GaugeView, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardGaugeViewNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardGaugeView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GaugeView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SparkChartView, actual.SparkChartView, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardSparkChartViewNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardSparkChartView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardThresholdsNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQuery or *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardGaugeViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardGaugeView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardGaugeView or *DashboardGridLayoutWidgetsScorecardGaugeView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardGaugeView)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardGaugeView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LowerBound, actual.LowerBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LowerBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpperBound, actual.UpperBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UpperBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardSparkChartViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardSparkChartView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardSparkChartView or *DashboardGridLayoutWidgetsScorecardSparkChartView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardSparkChartView)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardSparkChartView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.SparkChartType, actual.SparkChartType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsScorecardThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsScorecardThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardThresholds or *DashboardGridLayoutWidgetsScorecardThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsScorecardThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsScorecardThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsTextNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsText)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsText or *DashboardGridLayoutWidgetsText", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsText)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsText", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Content, actual.Content, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Content")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Format, actual.Format, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Format")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardGridLayoutWidgetsBlankNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareDashboardGridLayoutWidgetsLogsPanelNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardGridLayoutWidgetsLogsPanel)
	if !ok {
		desiredNotPointer, ok := d.(DashboardGridLayoutWidgetsLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsLogsPanel or *DashboardGridLayoutWidgetsLogsPanel", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardGridLayoutWidgetsLogsPanel)
	if !ok {
		actualNotPointer, ok := a.(DashboardGridLayoutWidgetsLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardGridLayoutWidgetsLogsPanel", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNames, actual.ResourceNames, dcl.DiffInfo{Type: "ReferenceType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ResourceNames")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayout)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayout or *DashboardMosaicLayout", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayout)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayout", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Columns, actual.Columns, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Columns")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Tiles, actual.Tiles, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTiles, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Tiles")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTiles)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTiles)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTiles or *DashboardMosaicLayoutTiles", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTiles)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTiles)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTiles", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.XPos, actual.XPos, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XPos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.YPos, actual.YPos, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("YPos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Width, actual.Width, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Width")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Height, actual.Height, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Height")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Widget, actual.Widget, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidget, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Widget")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidget)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidget)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidget or *DashboardMosaicLayoutTilesWidget", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidget)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidget)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidget", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Title, actual.Title, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Title")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XyChart, actual.XyChart, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChart, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XyChart")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scorecard, actual.Scorecard, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecard, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scorecard")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Text, actual.Text, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetTextNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetText, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Text")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Blank, actual.Blank, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetBlankNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetBlank, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Blank")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LogsPanel, actual.LogsPanel, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetLogsPanelNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetLogsPanel, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("LogsPanel")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChart)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChart or *DashboardMosaicLayoutTilesWidgetXyChart", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChart)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChart", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataSets, actual.DataSets, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("DataSets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeshiftDuration, actual.TimeshiftDuration, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeshiftDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartThresholdsNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XAxis, actual.XAxis, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartXAxisNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartXAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.YAxis, actual.YAxis, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartYAxisNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartYAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("YAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ChartOptions, actual.ChartOptions, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartChartOptionsNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartChartOptions, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ChartOptions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSets or *DashboardMosaicLayoutTilesWidgetXyChartDataSets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSets)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PlotType, actual.PlotType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PlotType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LegendTemplate, actual.LegendTemplate, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LegendTemplate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartThresholds or *DashboardMosaicLayoutTilesWidgetXyChartThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartXAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartXAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartXAxis or *DashboardMosaicLayoutTilesWidgetXyChartXAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartXAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartXAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartYAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartYAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartYAxis or *DashboardMosaicLayoutTilesWidgetXyChartYAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartYAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartYAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetXyChartChartOptionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetXyChartChartOptions)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartChartOptions or *DashboardMosaicLayoutTilesWidgetXyChartChartOptions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetXyChartChartOptions)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetXyChartChartOptions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Mode, actual.Mode, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Mode")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecard)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecard or *DashboardMosaicLayoutTilesWidgetScorecard", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecard)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecard", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GaugeView, actual.GaugeView, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardGaugeViewNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardGaugeView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GaugeView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SparkChartView, actual.SparkChartView, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardSparkChartView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardThresholdsNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardGaugeViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardGaugeView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardGaugeView or *DashboardMosaicLayoutTilesWidgetScorecardGaugeView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardGaugeView)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardGaugeView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LowerBound, actual.LowerBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LowerBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpperBound, actual.UpperBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UpperBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardSparkChartView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardSparkChartView or *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardSparkChartView)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardSparkChartView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.SparkChartType, actual.SparkChartType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetScorecardThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetScorecardThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardThresholds or *DashboardMosaicLayoutTilesWidgetScorecardThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetScorecardThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetScorecardThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetTextNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetText)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetText or *DashboardMosaicLayoutTilesWidgetText", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetText)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetText", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Content, actual.Content, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Content")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Format, actual.Format, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Format")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetBlankNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareDashboardMosaicLayoutTilesWidgetLogsPanelNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardMosaicLayoutTilesWidgetLogsPanel)
	if !ok {
		desiredNotPointer, ok := d.(DashboardMosaicLayoutTilesWidgetLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetLogsPanel or *DashboardMosaicLayoutTilesWidgetLogsPanel", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardMosaicLayoutTilesWidgetLogsPanel)
	if !ok {
		actualNotPointer, ok := a.(DashboardMosaicLayoutTilesWidgetLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardMosaicLayoutTilesWidgetLogsPanel", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNames, actual.ResourceNames, dcl.DiffInfo{Type: "ReferenceType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ResourceNames")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayout)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayout or *DashboardRowLayout", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayout)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayout", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Rows, actual.Rows, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsNewStyle, EmptyObject: EmptyDashboardRowLayoutRows, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Rows")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRows)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRows)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRows or *DashboardRowLayoutRows", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRows)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRows)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRows", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Weight, actual.Weight, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Weight")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Widgets, actual.Widgets, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Widgets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgets or *DashboardRowLayoutRowsWidgets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgets)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Title, actual.Title, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Title")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XyChart, actual.XyChart, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChart, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XyChart")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scorecard, actual.Scorecard, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecard, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scorecard")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Text, actual.Text, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsTextNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsText, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Text")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Blank, actual.Blank, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsBlankNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsBlank, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Blank")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LogsPanel, actual.LogsPanel, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsLogsPanelNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsLogsPanel, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("LogsPanel")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChart)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChart or *DashboardRowLayoutRowsWidgetsXyChart", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChart)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChart", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataSets, actual.DataSets, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("DataSets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeshiftDuration, actual.TimeshiftDuration, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeshiftDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartThresholdsNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XAxis, actual.XAxis, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartXAxisNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartXAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.YAxis, actual.YAxis, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartYAxisNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartYAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("YAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ChartOptions, actual.ChartOptions, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartChartOptionsNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartChartOptions, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ChartOptions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSets or *DashboardRowLayoutRowsWidgetsXyChartDataSets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSets)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PlotType, actual.PlotType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PlotType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LegendTemplate, actual.LegendTemplate, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LegendTemplate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartThresholds or *DashboardRowLayoutRowsWidgetsXyChartThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartXAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartXAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartXAxis or *DashboardRowLayoutRowsWidgetsXyChartXAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartXAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartXAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartYAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartYAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartYAxis or *DashboardRowLayoutRowsWidgetsXyChartYAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartYAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartYAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsXyChartChartOptionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsXyChartChartOptions)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartChartOptions or *DashboardRowLayoutRowsWidgetsXyChartChartOptions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsXyChartChartOptions)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsXyChartChartOptions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Mode, actual.Mode, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Mode")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecard)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecard or *DashboardRowLayoutRowsWidgetsScorecard", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecard)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecard", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GaugeView, actual.GaugeView, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardGaugeViewNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardGaugeView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GaugeView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SparkChartView, actual.SparkChartView, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardSparkChartViewNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardSparkChartView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardThresholdsNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardGaugeViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardGaugeView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardGaugeView or *DashboardRowLayoutRowsWidgetsScorecardGaugeView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardGaugeView)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardGaugeView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LowerBound, actual.LowerBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LowerBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpperBound, actual.UpperBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UpperBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardSparkChartViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardSparkChartView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardSparkChartView or *DashboardRowLayoutRowsWidgetsScorecardSparkChartView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardSparkChartView)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardSparkChartView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.SparkChartType, actual.SparkChartType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsScorecardThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsScorecardThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardThresholds or *DashboardRowLayoutRowsWidgetsScorecardThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsScorecardThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsScorecardThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsTextNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsText)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsText or *DashboardRowLayoutRowsWidgetsText", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsText)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsText", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Content, actual.Content, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Content")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Format, actual.Format, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Format")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsBlankNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareDashboardRowLayoutRowsWidgetsLogsPanelNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardRowLayoutRowsWidgetsLogsPanel)
	if !ok {
		desiredNotPointer, ok := d.(DashboardRowLayoutRowsWidgetsLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsLogsPanel or *DashboardRowLayoutRowsWidgetsLogsPanel", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardRowLayoutRowsWidgetsLogsPanel)
	if !ok {
		actualNotPointer, ok := a.(DashboardRowLayoutRowsWidgetsLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardRowLayoutRowsWidgetsLogsPanel", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNames, actual.ResourceNames, dcl.DiffInfo{Type: "ReferenceType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ResourceNames")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayout)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayout or *DashboardColumnLayout", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayout)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayout)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayout", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Columns, actual.Columns, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumns, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Columns")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumns)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumns)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumns or *DashboardColumnLayoutColumns", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumns)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumns)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumns", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Weight, actual.Weight, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Weight")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Widgets, actual.Widgets, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Widgets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgets or *DashboardColumnLayoutColumnsWidgets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgets)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Title, actual.Title, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Title")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XyChart, actual.XyChart, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChart, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XyChart")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scorecard, actual.Scorecard, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecard, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scorecard")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Text, actual.Text, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsTextNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsText, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Text")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Blank, actual.Blank, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsBlankNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsBlank, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Blank")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LogsPanel, actual.LogsPanel, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsLogsPanelNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsLogsPanel, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("LogsPanel")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChart)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChart or *DashboardColumnLayoutColumnsWidgetsXyChart", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChart)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChart)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChart", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataSets, actual.DataSets, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSets, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("DataSets")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeshiftDuration, actual.TimeshiftDuration, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeshiftDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartThresholdsNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.XAxis, actual.XAxis, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartXAxisNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartXAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("XAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.YAxis, actual.YAxis, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartYAxisNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartYAxis, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("YAxis")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ChartOptions, actual.ChartOptions, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartChartOptions, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ChartOptions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSets)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSets or *DashboardColumnLayoutColumnsWidgetsXyChartDataSets", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSets)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSets)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSets", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PlotType, actual.PlotType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PlotType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.LegendTemplate, actual.LegendTemplate, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LegendTemplate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartThresholds or *DashboardColumnLayoutColumnsWidgetsXyChartThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartXAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartXAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartXAxis or *DashboardColumnLayoutColumnsWidgetsXyChartXAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartXAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartXAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartXAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartYAxisNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartYAxis)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartYAxis or *DashboardColumnLayoutColumnsWidgetsXyChartYAxis", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartYAxis)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartYAxis)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartYAxis", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scale, actual.Scale, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Scale")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsXyChartChartOptions)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartChartOptions or *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsXyChartChartOptions)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsXyChartChartOptions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsXyChartChartOptions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Mode, actual.Mode, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Mode")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecard)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecard or *DashboardColumnLayoutColumnsWidgetsScorecard", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecard)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecard)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecard", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQuery, actual.TimeSeriesQuery, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQuery")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GaugeView, actual.GaugeView, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardGaugeView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GaugeView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SparkChartView, actual.SparkChartView, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartView")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Thresholds, actual.Thresholds, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardThresholdsNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardThresholds, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Thresholds")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilter, actual.TimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesFilterRatio, actual.TimeSeriesFilterRatio, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesFilterRatio")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TimeSeriesQueryLanguage, actual.TimeSeriesQueryLanguage, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("TimeSeriesQueryLanguage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnitOverride, actual.UnitOverride, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UnitOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Numerator, actual.Numerator, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Numerator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Denominator, actual.Denominator, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Denominator")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SecondaryAggregation, actual.SecondaryAggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SecondaryAggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PickTimeSeriesFilter, actual.PickTimeSeriesFilter, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PickTimeSeriesFilter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Aggregation, actual.Aggregation, dcl.DiffInfo{ObjectFunction: compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle, EmptyObject: EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Aggregation")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.AlignmentPeriod, actual.AlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("AlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PerSeriesAligner, actual.PerSeriesAligner, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("PerSeriesAligner")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CrossSeriesReducer, actual.CrossSeriesReducer, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("CrossSeriesReducer")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.GroupByFields, actual.GroupByFields, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("GroupByFields")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter or *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RankingMethod, actual.RankingMethod, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("RankingMethod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NumTimeSeries, actual.NumTimeSeries, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("NumTimeSeries")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardGaugeView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardGaugeView or *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardGaugeView)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardGaugeView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardGaugeView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LowerBound, actual.LowerBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("LowerBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpperBound, actual.UpperBound, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("UpperBound")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView or *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.SparkChartType, actual.SparkChartType, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("SparkChartType")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MinAlignmentPeriod, actual.MinAlignmentPeriod, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("MinAlignmentPeriod")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsScorecardThresholdsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsScorecardThresholds)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardThresholds or *DashboardColumnLayoutColumnsWidgetsScorecardThresholds", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsScorecardThresholds)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsScorecardThresholds)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsScorecardThresholds", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Label, actual.Label, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Label")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Color, actual.Color, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Color")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Direction, actual.Direction, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Direction")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsTextNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsText)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsText or *DashboardColumnLayoutColumnsWidgetsText", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsText)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsText)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsText", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Content, actual.Content, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Content")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Format, actual.Format, dcl.DiffInfo{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Format")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsBlankNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareDashboardColumnLayoutColumnsWidgetsLogsPanelNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*DashboardColumnLayoutColumnsWidgetsLogsPanel)
	if !ok {
		desiredNotPointer, ok := d.(DashboardColumnLayoutColumnsWidgetsLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsLogsPanel or *DashboardColumnLayoutColumnsWidgetsLogsPanel", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*DashboardColumnLayoutColumnsWidgetsLogsPanel)
	if !ok {
		actualNotPointer, ok := a.(DashboardColumnLayoutColumnsWidgetsLogsPanel)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a DashboardColumnLayoutColumnsWidgetsLogsPanel", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Filter, actual.Filter, dcl.DiffInfo{OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("Filter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNames, actual.ResourceNames, dcl.DiffInfo{Type: "ReferenceType", OperationSelector: dcl.TriggersOperation("updateDashboardUpdateDashboardOperation")}, fn.AddNest("ResourceNames")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

// urlNormalized returns a copy of the resource struct with values normalized
// for URL substitutions. For instance, it converts long-form self-links to
// short-form so they can be substituted in.
func (r *Dashboard) urlNormalized() *Dashboard {
	normalized := dcl.Copy(*r).(Dashboard)
	normalized.Name = dcl.SelfLinkToName(r.Name)
	normalized.DisplayName = dcl.SelfLinkToName(r.DisplayName)
	normalized.Project = dcl.SelfLinkToName(r.Project)
	normalized.Etag = dcl.SelfLinkToName(r.Etag)
	return &normalized
}

func (r *Dashboard) updateURL(userBasePath, updateName string) (string, error) {
	nr := r.urlNormalized()
	if updateName == "UpdateDashboard" {
		fields := map[string]interface{}{
			"project": dcl.ValueOrEmptyString(nr.Project),
			"name":    dcl.ValueOrEmptyString(nr.Name),
		}
		return dcl.URL("projects/{{project}}/dashboards/{{name}}", nr.basePath(), userBasePath, fields), nil

	}

	return "", fmt.Errorf("unknown update name: %s", updateName)
}

// marshal encodes the Dashboard resource into JSON for a Create request, and
// performs transformations from the resource schema to the API schema if
// necessary.
func (r *Dashboard) marshal(c *Client) ([]byte, error) {
	m, err := expandDashboard(c, r)
	if err != nil {
		return nil, fmt.Errorf("error marshalling Dashboard: %w", err)
	}

	return json.Marshal(m)
}

// unmarshalDashboard decodes JSON responses into the Dashboard resource schema.
func unmarshalDashboard(b []byte, c *Client, res *Dashboard) (*Dashboard, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return unmarshalMapDashboard(m, c, res)
}

func unmarshalMapDashboard(m map[string]interface{}, c *Client, res *Dashboard) (*Dashboard, error) {

	flattened := flattenDashboard(c, m, res)
	if flattened == nil {
		return nil, fmt.Errorf("attempted to flatten empty json object")
	}
	return flattened, nil
}

// expandDashboard expands Dashboard into a JSON request object.
func expandDashboard(c *Client, f *Dashboard) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	res := f
	_ = res
	if v, err := dcl.EmptyValue(); err != nil {
		return nil, fmt.Errorf("error expanding Name into name: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["name"] = v
	}
	if v := f.DisplayName; dcl.ValueShouldBeSent(v) {
		m["displayName"] = v
	}
	if v, err := expandDashboardGridLayout(c, f.GridLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding GridLayout into gridLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["gridLayout"] = v
	}
	if v, err := expandDashboardMosaicLayout(c, f.MosaicLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding MosaicLayout into mosaicLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["mosaicLayout"] = v
	}
	if v, err := expandDashboardRowLayout(c, f.RowLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding RowLayout into rowLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["rowLayout"] = v
	}
	if v, err := expandDashboardColumnLayout(c, f.ColumnLayout, res); err != nil {
		return nil, fmt.Errorf("error expanding ColumnLayout into columnLayout: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["columnLayout"] = v
	}
	if v, err := dcl.EmptyValue(); err != nil {
		return nil, fmt.Errorf("error expanding Project into project: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["project"] = v
	}

	return m, nil
}

// flattenDashboard flattens Dashboard from a JSON request object into the
// Dashboard type.
func flattenDashboard(c *Client, i interface{}, res *Dashboard) *Dashboard {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}
	if len(m) == 0 {
		return nil
	}

	resultRes := &Dashboard{}
	resultRes.Name = dcl.FlattenString(m["name"])
	resultRes.DisplayName = dcl.FlattenString(m["displayName"])
	resultRes.GridLayout = flattenDashboardGridLayout(c, m["gridLayout"], res)
	resultRes.MosaicLayout = flattenDashboardMosaicLayout(c, m["mosaicLayout"], res)
	resultRes.RowLayout = flattenDashboardRowLayout(c, m["rowLayout"], res)
	resultRes.ColumnLayout = flattenDashboardColumnLayout(c, m["columnLayout"], res)
	resultRes.Project = dcl.FlattenString(m["project"])
	resultRes.Etag = dcl.FlattenString(m["etag"])

	return resultRes
}

// expandDashboardGridLayoutMap expands the contents of DashboardGridLayout into a JSON
// request object.
func expandDashboardGridLayoutMap(c *Client, f map[string]DashboardGridLayout, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayout(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutSlice expands the contents of DashboardGridLayout into a JSON
// request object.
func expandDashboardGridLayoutSlice(c *Client, f []DashboardGridLayout, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayout(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutMap flattens the contents of DashboardGridLayout from a JSON
// response object.
func flattenDashboardGridLayoutMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayout {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayout{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayout{}
	}

	items := make(map[string]DashboardGridLayout)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayout(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutSlice flattens the contents of DashboardGridLayout from a JSON
// response object.
func flattenDashboardGridLayoutSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayout {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayout{}
	}

	if len(a) == 0 {
		return []DashboardGridLayout{}
	}

	items := make([]DashboardGridLayout, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayout(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayout expands an instance of DashboardGridLayout into a JSON
// request object.
func expandDashboardGridLayout(c *Client, f *DashboardGridLayout, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Columns; !dcl.IsEmptyValueIndirect(v) {
		m["columns"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsSlice(c, f.Widgets, res); err != nil {
		return nil, fmt.Errorf("error expanding Widgets into widgets: %w", err)
	} else if v != nil {
		m["widgets"] = v
	}

	return m, nil
}

// flattenDashboardGridLayout flattens an instance of DashboardGridLayout from a JSON
// response object.
func flattenDashboardGridLayout(c *Client, i interface{}, res *Dashboard) *DashboardGridLayout {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayout{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayout
	}
	r.Columns = dcl.FlattenInteger(m["columns"])
	r.Widgets = flattenDashboardGridLayoutWidgetsSlice(c, m["widgets"], res)

	return r
}

// expandDashboardGridLayoutWidgetsMap expands the contents of DashboardGridLayoutWidgets into a JSON
// request object.
func expandDashboardGridLayoutWidgetsMap(c *Client, f map[string]DashboardGridLayoutWidgets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsSlice expands the contents of DashboardGridLayoutWidgets into a JSON
// request object.
func expandDashboardGridLayoutWidgetsSlice(c *Client, f []DashboardGridLayoutWidgets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsMap flattens the contents of DashboardGridLayoutWidgets from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgets{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgets{}
	}

	items := make(map[string]DashboardGridLayoutWidgets)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsSlice flattens the contents of DashboardGridLayoutWidgets from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgets{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgets{}
	}

	items := make([]DashboardGridLayoutWidgets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgets expands an instance of DashboardGridLayoutWidgets into a JSON
// request object.
func expandDashboardGridLayoutWidgets(c *Client, f *DashboardGridLayoutWidgets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Title; !dcl.IsEmptyValueIndirect(v) {
		m["title"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChart(c, f.XyChart, res); err != nil {
		return nil, fmt.Errorf("error expanding XyChart into xyChart: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xyChart"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecard(c, f.Scorecard, res); err != nil {
		return nil, fmt.Errorf("error expanding Scorecard into scorecard: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["scorecard"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsText(c, f.Text, res); err != nil {
		return nil, fmt.Errorf("error expanding Text into text: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["text"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsBlank(c, f.Blank, res); err != nil {
		return nil, fmt.Errorf("error expanding Blank into blank: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["blank"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsLogsPanel(c, f.LogsPanel, res); err != nil {
		return nil, fmt.Errorf("error expanding LogsPanel into logsPanel: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["logsPanel"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgets flattens an instance of DashboardGridLayoutWidgets from a JSON
// response object.
func flattenDashboardGridLayoutWidgets(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgets
	}
	r.Title = dcl.FlattenString(m["title"])
	r.XyChart = flattenDashboardGridLayoutWidgetsXyChart(c, m["xyChart"], res)
	r.Scorecard = flattenDashboardGridLayoutWidgetsScorecard(c, m["scorecard"], res)
	r.Text = flattenDashboardGridLayoutWidgetsText(c, m["text"], res)
	r.Blank = flattenDashboardGridLayoutWidgetsBlank(c, m["blank"], res)
	r.LogsPanel = flattenDashboardGridLayoutWidgetsLogsPanel(c, m["logsPanel"], res)

	return r
}

// expandDashboardGridLayoutWidgetsXyChartMap expands the contents of DashboardGridLayoutWidgetsXyChart into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChart, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartSlice expands the contents of DashboardGridLayoutWidgetsXyChart into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartSlice(c *Client, f []DashboardGridLayoutWidgetsXyChart, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartMap flattens the contents of DashboardGridLayoutWidgetsXyChart from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChart {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChart{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChart{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChart)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChart(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartSlice flattens the contents of DashboardGridLayoutWidgetsXyChart from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChart {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChart{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChart{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChart, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChart(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChart expands an instance of DashboardGridLayoutWidgetsXyChart into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChart(c *Client, f *DashboardGridLayoutWidgetsXyChart, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsSlice(c, f.DataSets, res); err != nil {
		return nil, fmt.Errorf("error expanding DataSets into dataSets: %w", err)
	} else if v != nil {
		m["dataSets"] = v
	}
	if v := f.TimeshiftDuration; !dcl.IsEmptyValueIndirect(v) {
		m["timeshiftDuration"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartXAxis(c, f.XAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding XAxis into xAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xAxis"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartYAxis(c, f.YAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding YAxis into yAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["yAxis"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartChartOptions(c, f.ChartOptions, res); err != nil {
		return nil, fmt.Errorf("error expanding ChartOptions into chartOptions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["chartOptions"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChart flattens an instance of DashboardGridLayoutWidgetsXyChart from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChart(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChart {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChart{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChart
	}
	r.DataSets = flattenDashboardGridLayoutWidgetsXyChartDataSetsSlice(c, m["dataSets"], res)
	r.TimeshiftDuration = dcl.FlattenString(m["timeshiftDuration"])
	r.Thresholds = flattenDashboardGridLayoutWidgetsXyChartThresholdsSlice(c, m["thresholds"], res)
	r.XAxis = flattenDashboardGridLayoutWidgetsXyChartXAxis(c, m["xAxis"], res)
	r.YAxis = flattenDashboardGridLayoutWidgetsXyChartYAxis(c, m["yAxis"], res)
	r.ChartOptions = flattenDashboardGridLayoutWidgetsXyChartChartOptions(c, m["chartOptions"], res)

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSets{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSets{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSets)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSets{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSets{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSets expands an instance of DashboardGridLayoutWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSets(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v := f.PlotType; !dcl.IsEmptyValueIndirect(v) {
		m["plotType"] = v
	}
	if v := f.LegendTemplate; !dcl.IsEmptyValueIndirect(v) {
		m["legendTemplate"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSets flattens an instance of DashboardGridLayoutWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSets(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSets
	}
	r.TimeSeriesQuery = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.PlotType = flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum(m["plotType"])
	r.LegendTemplate = dcl.FlattenString(m["legendTemplate"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartThresholdsMap expands the contents of DashboardGridLayoutWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartThresholdsMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartThresholdsSlice expands the contents of DashboardGridLayoutWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartThresholdsSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsMap flattens the contents of DashboardGridLayoutWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartThresholds{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsSlice flattens the contents of DashboardGridLayoutWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartThresholds{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartThresholds{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartThresholds expands an instance of DashboardGridLayoutWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartThresholds(c *Client, f *DashboardGridLayoutWidgetsXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartThresholds flattens an instance of DashboardGridLayoutWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholds(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartXAxisMap expands the contents of DashboardGridLayoutWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartXAxisMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartXAxisSlice expands the contents of DashboardGridLayoutWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartXAxisSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartXAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartXAxisMap flattens the contents of DashboardGridLayoutWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartXAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartXAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartXAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartXAxis{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartXAxis)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartXAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartXAxisSlice flattens the contents of DashboardGridLayoutWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartXAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartXAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartXAxis{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartXAxis{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartXAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartXAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartXAxis expands an instance of DashboardGridLayoutWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartXAxis(c *Client, f *DashboardGridLayoutWidgetsXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartXAxis flattens an instance of DashboardGridLayoutWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartXAxis(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartXAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartXAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartXAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartYAxisMap expands the contents of DashboardGridLayoutWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartYAxisMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartYAxisSlice expands the contents of DashboardGridLayoutWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartYAxisSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartYAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartYAxisMap flattens the contents of DashboardGridLayoutWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartYAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartYAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartYAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartYAxis{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartYAxis)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartYAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartYAxisSlice flattens the contents of DashboardGridLayoutWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartYAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartYAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartYAxis{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartYAxis{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartYAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartYAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartYAxis expands an instance of DashboardGridLayoutWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartYAxis(c *Client, f *DashboardGridLayoutWidgetsXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartYAxis flattens an instance of DashboardGridLayoutWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartYAxis(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartYAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartYAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartYAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardGridLayoutWidgetsXyChartChartOptionsMap expands the contents of DashboardGridLayoutWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartChartOptionsMap(c *Client, f map[string]DashboardGridLayoutWidgetsXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsXyChartChartOptionsSlice expands the contents of DashboardGridLayoutWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartChartOptionsSlice(c *Client, f []DashboardGridLayoutWidgetsXyChartChartOptions, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsXyChartChartOptionsMap flattens the contents of DashboardGridLayoutWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartChartOptionsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartChartOptions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartChartOptions{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartChartOptions{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartChartOptions)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartChartOptions(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartChartOptionsSlice flattens the contents of DashboardGridLayoutWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartChartOptionsSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartChartOptions {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartChartOptions{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartChartOptions{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartChartOptions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartChartOptions(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsXyChartChartOptions expands an instance of DashboardGridLayoutWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardGridLayoutWidgetsXyChartChartOptions(c *Client, f *DashboardGridLayoutWidgetsXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Mode; !dcl.IsEmptyValueIndirect(v) {
		m["mode"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsXyChartChartOptions flattens an instance of DashboardGridLayoutWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartChartOptions(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsXyChartChartOptions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsXyChartChartOptions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsXyChartChartOptions
	}
	r.Mode = flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnum(m["mode"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardMap expands the contents of DashboardGridLayoutWidgetsScorecard into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecard, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardSlice expands the contents of DashboardGridLayoutWidgetsScorecard into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardSlice(c *Client, f []DashboardGridLayoutWidgetsScorecard, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardMap flattens the contents of DashboardGridLayoutWidgetsScorecard from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecard {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecard{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecard{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecard)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecard(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardSlice flattens the contents of DashboardGridLayoutWidgetsScorecard from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecard {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecard{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecard{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecard, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecard(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecard expands an instance of DashboardGridLayoutWidgetsScorecard into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecard(c *Client, f *DashboardGridLayoutWidgetsScorecard, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardGaugeView(c, f.GaugeView, res); err != nil {
		return nil, fmt.Errorf("error expanding GaugeView into gaugeView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["gaugeView"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardSparkChartView(c, f.SparkChartView, res); err != nil {
		return nil, fmt.Errorf("error expanding SparkChartView into sparkChartView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartView"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecard flattens an instance of DashboardGridLayoutWidgetsScorecard from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecard(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecard {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecard{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecard
	}
	r.TimeSeriesQuery = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.GaugeView = flattenDashboardGridLayoutWidgetsScorecardGaugeView(c, m["gaugeView"], res)
	r.SparkChartView = flattenDashboardGridLayoutWidgetsScorecardSparkChartView(c, m["sparkChartView"], res)
	r.Thresholds = flattenDashboardGridLayoutWidgetsScorecardThresholdsSlice(c, m["thresholds"], res)

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuery expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuery flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardGaugeViewMap expands the contents of DashboardGridLayoutWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardGaugeViewMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardGaugeViewSlice expands the contents of DashboardGridLayoutWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardGaugeViewSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardGaugeView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardGaugeViewMap flattens the contents of DashboardGridLayoutWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardGaugeViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardGaugeView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardGaugeView{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardGaugeView{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardGaugeView)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardGaugeView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardGaugeViewSlice flattens the contents of DashboardGridLayoutWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardGaugeViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardGaugeView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardGaugeView{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardGaugeView{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardGaugeView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardGaugeView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardGaugeView expands an instance of DashboardGridLayoutWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardGaugeView(c *Client, f *DashboardGridLayoutWidgetsScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LowerBound; !dcl.IsEmptyValueIndirect(v) {
		m["lowerBound"] = v
	}
	if v := f.UpperBound; !dcl.IsEmptyValueIndirect(v) {
		m["upperBound"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardGaugeView flattens an instance of DashboardGridLayoutWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardGaugeView(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardGaugeView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardGaugeView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardGaugeView
	}
	r.LowerBound = dcl.FlattenDouble(m["lowerBound"])
	r.UpperBound = dcl.FlattenDouble(m["upperBound"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardSparkChartViewMap expands the contents of DashboardGridLayoutWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardSparkChartViewMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardSparkChartViewSlice expands the contents of DashboardGridLayoutWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardSparkChartViewSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardSparkChartView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardSparkChartViewMap flattens the contents of DashboardGridLayoutWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardSparkChartViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardSparkChartView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardSparkChartView{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardSparkChartView)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardSparkChartView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSlice flattens the contents of DashboardGridLayoutWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardSparkChartView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardSparkChartView{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardSparkChartView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardSparkChartView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardSparkChartView expands an instance of DashboardGridLayoutWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardSparkChartView(c *Client, f *DashboardGridLayoutWidgetsScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.SparkChartType; !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartType"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardSparkChartView flattens an instance of DashboardGridLayoutWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardSparkChartView(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardSparkChartView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardSparkChartView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardSparkChartView
	}
	r.SparkChartType = flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum(m["sparkChartType"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardGridLayoutWidgetsScorecardThresholdsMap expands the contents of DashboardGridLayoutWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardThresholdsMap(c *Client, f map[string]DashboardGridLayoutWidgetsScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsScorecardThresholdsSlice expands the contents of DashboardGridLayoutWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardThresholdsSlice(c *Client, f []DashboardGridLayoutWidgetsScorecardThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsMap flattens the contents of DashboardGridLayoutWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardThresholds{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsSlice flattens the contents of DashboardGridLayoutWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardThresholds{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardThresholds{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsScorecardThresholds expands an instance of DashboardGridLayoutWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardGridLayoutWidgetsScorecardThresholds(c *Client, f *DashboardGridLayoutWidgetsScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsScorecardThresholds flattens an instance of DashboardGridLayoutWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholds(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsScorecardThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsScorecardThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsScorecardThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardGridLayoutWidgetsTextMap expands the contents of DashboardGridLayoutWidgetsText into a JSON
// request object.
func expandDashboardGridLayoutWidgetsTextMap(c *Client, f map[string]DashboardGridLayoutWidgetsText, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsText(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsTextSlice expands the contents of DashboardGridLayoutWidgetsText into a JSON
// request object.
func expandDashboardGridLayoutWidgetsTextSlice(c *Client, f []DashboardGridLayoutWidgetsText, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsText(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsTextMap flattens the contents of DashboardGridLayoutWidgetsText from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsTextMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsText {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsText{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsText{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsText)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsText(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsTextSlice flattens the contents of DashboardGridLayoutWidgetsText from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsTextSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsText {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsText{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsText{}
	}

	items := make([]DashboardGridLayoutWidgetsText, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsText(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsText expands an instance of DashboardGridLayoutWidgetsText into a JSON
// request object.
func expandDashboardGridLayoutWidgetsText(c *Client, f *DashboardGridLayoutWidgetsText, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Content; !dcl.IsEmptyValueIndirect(v) {
		m["content"] = v
	}
	if v := f.Format; !dcl.IsEmptyValueIndirect(v) {
		m["format"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsText flattens an instance of DashboardGridLayoutWidgetsText from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsText(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsText {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsText{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsText
	}
	r.Content = dcl.FlattenString(m["content"])
	r.Format = flattenDashboardGridLayoutWidgetsTextFormatEnum(m["format"])

	return r
}

// expandDashboardGridLayoutWidgetsBlankMap expands the contents of DashboardGridLayoutWidgetsBlank into a JSON
// request object.
func expandDashboardGridLayoutWidgetsBlankMap(c *Client, f map[string]DashboardGridLayoutWidgetsBlank, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsBlank(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsBlankSlice expands the contents of DashboardGridLayoutWidgetsBlank into a JSON
// request object.
func expandDashboardGridLayoutWidgetsBlankSlice(c *Client, f []DashboardGridLayoutWidgetsBlank, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsBlank(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsBlankMap flattens the contents of DashboardGridLayoutWidgetsBlank from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsBlankMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsBlank {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsBlank{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsBlank{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsBlank)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsBlank(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsBlankSlice flattens the contents of DashboardGridLayoutWidgetsBlank from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsBlankSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsBlank {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsBlank{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsBlank{}
	}

	items := make([]DashboardGridLayoutWidgetsBlank, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsBlank(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsBlank expands an instance of DashboardGridLayoutWidgetsBlank into a JSON
// request object.
func expandDashboardGridLayoutWidgetsBlank(c *Client, f *DashboardGridLayoutWidgetsBlank, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})

	return m, nil
}

// flattenDashboardGridLayoutWidgetsBlank flattens an instance of DashboardGridLayoutWidgetsBlank from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsBlank(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsBlank {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsBlank{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsBlank
	}

	return r
}

// expandDashboardGridLayoutWidgetsLogsPanelMap expands the contents of DashboardGridLayoutWidgetsLogsPanel into a JSON
// request object.
func expandDashboardGridLayoutWidgetsLogsPanelMap(c *Client, f map[string]DashboardGridLayoutWidgetsLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardGridLayoutWidgetsLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardGridLayoutWidgetsLogsPanelSlice expands the contents of DashboardGridLayoutWidgetsLogsPanel into a JSON
// request object.
func expandDashboardGridLayoutWidgetsLogsPanelSlice(c *Client, f []DashboardGridLayoutWidgetsLogsPanel, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardGridLayoutWidgetsLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardGridLayoutWidgetsLogsPanelMap flattens the contents of DashboardGridLayoutWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsLogsPanelMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsLogsPanel {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsLogsPanel{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsLogsPanel{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsLogsPanel)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsLogsPanel(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardGridLayoutWidgetsLogsPanelSlice flattens the contents of DashboardGridLayoutWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsLogsPanelSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsLogsPanel {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsLogsPanel{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsLogsPanel{}
	}

	items := make([]DashboardGridLayoutWidgetsLogsPanel, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsLogsPanel(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardGridLayoutWidgetsLogsPanel expands an instance of DashboardGridLayoutWidgetsLogsPanel into a JSON
// request object.
func expandDashboardGridLayoutWidgetsLogsPanel(c *Client, f *DashboardGridLayoutWidgetsLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v := f.ResourceNames; v != nil {
		m["resourceNames"] = v
	}

	return m, nil
}

// flattenDashboardGridLayoutWidgetsLogsPanel flattens an instance of DashboardGridLayoutWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsLogsPanel(c *Client, i interface{}, res *Dashboard) *DashboardGridLayoutWidgetsLogsPanel {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardGridLayoutWidgetsLogsPanel{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardGridLayoutWidgetsLogsPanel
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.ResourceNames = dcl.FlattenStringSlice(m["resourceNames"])

	return r
}

// expandDashboardMosaicLayoutMap expands the contents of DashboardMosaicLayout into a JSON
// request object.
func expandDashboardMosaicLayoutMap(c *Client, f map[string]DashboardMosaicLayout, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayout(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutSlice expands the contents of DashboardMosaicLayout into a JSON
// request object.
func expandDashboardMosaicLayoutSlice(c *Client, f []DashboardMosaicLayout, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayout(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutMap flattens the contents of DashboardMosaicLayout from a JSON
// response object.
func flattenDashboardMosaicLayoutMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayout {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayout{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayout{}
	}

	items := make(map[string]DashboardMosaicLayout)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayout(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutSlice flattens the contents of DashboardMosaicLayout from a JSON
// response object.
func flattenDashboardMosaicLayoutSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayout {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayout{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayout{}
	}

	items := make([]DashboardMosaicLayout, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayout(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayout expands an instance of DashboardMosaicLayout into a JSON
// request object.
func expandDashboardMosaicLayout(c *Client, f *DashboardMosaicLayout, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Columns; !dcl.IsEmptyValueIndirect(v) {
		m["columns"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesSlice(c, f.Tiles, res); err != nil {
		return nil, fmt.Errorf("error expanding Tiles into tiles: %w", err)
	} else if v != nil {
		m["tiles"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayout flattens an instance of DashboardMosaicLayout from a JSON
// response object.
func flattenDashboardMosaicLayout(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayout {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayout{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayout
	}
	r.Columns = dcl.FlattenInteger(m["columns"])
	r.Tiles = flattenDashboardMosaicLayoutTilesSlice(c, m["tiles"], res)

	return r
}

// expandDashboardMosaicLayoutTilesMap expands the contents of DashboardMosaicLayoutTiles into a JSON
// request object.
func expandDashboardMosaicLayoutTilesMap(c *Client, f map[string]DashboardMosaicLayoutTiles, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTiles(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesSlice expands the contents of DashboardMosaicLayoutTiles into a JSON
// request object.
func expandDashboardMosaicLayoutTilesSlice(c *Client, f []DashboardMosaicLayoutTiles, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTiles(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesMap flattens the contents of DashboardMosaicLayoutTiles from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTiles {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTiles{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTiles{}
	}

	items := make(map[string]DashboardMosaicLayoutTiles)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTiles(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesSlice flattens the contents of DashboardMosaicLayoutTiles from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTiles {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTiles{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTiles{}
	}

	items := make([]DashboardMosaicLayoutTiles, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTiles(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTiles expands an instance of DashboardMosaicLayoutTiles into a JSON
// request object.
func expandDashboardMosaicLayoutTiles(c *Client, f *DashboardMosaicLayoutTiles, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.XPos; !dcl.IsEmptyValueIndirect(v) {
		m["xPos"] = v
	}
	if v := f.YPos; !dcl.IsEmptyValueIndirect(v) {
		m["yPos"] = v
	}
	if v := f.Width; !dcl.IsEmptyValueIndirect(v) {
		m["width"] = v
	}
	if v := f.Height; !dcl.IsEmptyValueIndirect(v) {
		m["height"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidget(c, f.Widget, res); err != nil {
		return nil, fmt.Errorf("error expanding Widget into widget: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["widget"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTiles flattens an instance of DashboardMosaicLayoutTiles from a JSON
// response object.
func flattenDashboardMosaicLayoutTiles(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTiles {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTiles{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTiles
	}
	r.XPos = dcl.FlattenInteger(m["xPos"])
	r.YPos = dcl.FlattenInteger(m["yPos"])
	r.Width = dcl.FlattenInteger(m["width"])
	r.Height = dcl.FlattenInteger(m["height"])
	r.Widget = flattenDashboardMosaicLayoutTilesWidget(c, m["widget"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetMap expands the contents of DashboardMosaicLayoutTilesWidget into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidget, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidget(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetSlice expands the contents of DashboardMosaicLayoutTilesWidget into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetSlice(c *Client, f []DashboardMosaicLayoutTilesWidget, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidget(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetMap flattens the contents of DashboardMosaicLayoutTilesWidget from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidget {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidget{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidget{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidget)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidget(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetSlice flattens the contents of DashboardMosaicLayoutTilesWidget from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidget {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidget{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidget{}
	}

	items := make([]DashboardMosaicLayoutTilesWidget, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidget(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidget expands an instance of DashboardMosaicLayoutTilesWidget into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidget(c *Client, f *DashboardMosaicLayoutTilesWidget, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Title; !dcl.IsEmptyValueIndirect(v) {
		m["title"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChart(c, f.XyChart, res); err != nil {
		return nil, fmt.Errorf("error expanding XyChart into xyChart: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xyChart"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecard(c, f.Scorecard, res); err != nil {
		return nil, fmt.Errorf("error expanding Scorecard into scorecard: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["scorecard"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetText(c, f.Text, res); err != nil {
		return nil, fmt.Errorf("error expanding Text into text: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["text"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetBlank(c, f.Blank, res); err != nil {
		return nil, fmt.Errorf("error expanding Blank into blank: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["blank"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetLogsPanel(c, f.LogsPanel, res); err != nil {
		return nil, fmt.Errorf("error expanding LogsPanel into logsPanel: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["logsPanel"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidget flattens an instance of DashboardMosaicLayoutTilesWidget from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidget(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidget {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidget{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidget
	}
	r.Title = dcl.FlattenString(m["title"])
	r.XyChart = flattenDashboardMosaicLayoutTilesWidgetXyChart(c, m["xyChart"], res)
	r.Scorecard = flattenDashboardMosaicLayoutTilesWidgetScorecard(c, m["scorecard"], res)
	r.Text = flattenDashboardMosaicLayoutTilesWidgetText(c, m["text"], res)
	r.Blank = flattenDashboardMosaicLayoutTilesWidgetBlank(c, m["blank"], res)
	r.LogsPanel = flattenDashboardMosaicLayoutTilesWidgetLogsPanel(c, m["logsPanel"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChart into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChart, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChart into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChart, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChart from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChart {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChart{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChart{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChart)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChart(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChart from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChart {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChart{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChart{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChart, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChart(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChart expands an instance of DashboardMosaicLayoutTilesWidgetXyChart into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChart(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChart, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(c, f.DataSets, res); err != nil {
		return nil, fmt.Errorf("error expanding DataSets into dataSets: %w", err)
	} else if v != nil {
		m["dataSets"] = v
	}
	if v := f.TimeshiftDuration; !dcl.IsEmptyValueIndirect(v) {
		m["timeshiftDuration"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, f.XAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding XAxis into xAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xAxis"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, f.YAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding YAxis into yAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["yAxis"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, f.ChartOptions, res); err != nil {
		return nil, fmt.Errorf("error expanding ChartOptions into chartOptions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["chartOptions"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChart flattens an instance of DashboardMosaicLayoutTilesWidgetXyChart from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChart(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChart {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChart{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChart
	}
	r.DataSets = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(c, m["dataSets"], res)
	r.TimeshiftDuration = dcl.FlattenString(m["timeshiftDuration"])
	r.Thresholds = flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(c, m["thresholds"], res)
	r.XAxis = flattenDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, m["xAxis"], res)
	r.YAxis = flattenDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, m["yAxis"], res)
	r.ChartOptions = flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, m["chartOptions"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSets into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSets into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSets from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSets{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSets{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSets)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSets from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSets{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSets{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSets expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSets into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSets(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v := f.PlotType; !dcl.IsEmptyValueIndirect(v) {
		m["plotType"] = v
	}
	if v := f.LegendTemplate; !dcl.IsEmptyValueIndirect(v) {
		m["legendTemplate"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSets flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSets from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSets(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSets
	}
	r.TimeSeriesQuery = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.PlotType = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum(m["plotType"])
	r.LegendTemplate = dcl.FlattenString(m["legendTemplate"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartThresholdsMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholds into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartThresholdsMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholds into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholds from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholds{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholds from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartThresholds{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartThresholds{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartThresholds expands an instance of DashboardMosaicLayoutTilesWidgetXyChartThresholds into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartThresholds(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholds flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartThresholds from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholds(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartXAxisMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartXAxis into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartXAxisMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartXAxisSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartXAxis into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartXAxisSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartXAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartXAxis from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxis{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxis)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartXAxis from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartXAxis{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartXAxis{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartXAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartXAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartXAxis expands an instance of DashboardMosaicLayoutTilesWidgetXyChartXAxis into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartXAxis(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartXAxis flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartXAxis from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartXAxis(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartXAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartXAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartXAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartYAxisMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartYAxis into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartYAxisMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartYAxisSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartYAxis into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartYAxisSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartYAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartYAxis from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxis{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxis)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartYAxis from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartYAxis{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartYAxis{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartYAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartYAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartYAxis expands an instance of DashboardMosaicLayoutTilesWidgetXyChartYAxis into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartYAxis(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartYAxis flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartYAxis from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartYAxis(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartYAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartYAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartYAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetXyChartChartOptionsMap expands the contents of DashboardMosaicLayoutTilesWidgetXyChartChartOptions into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartChartOptionsMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSlice expands the contents of DashboardMosaicLayoutTilesWidgetXyChartChartOptions into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetXyChartChartOptions, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartChartOptions from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptions)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartChartOptions from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartChartOptions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetXyChartChartOptions expands an instance of DashboardMosaicLayoutTilesWidgetXyChartChartOptions into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c *Client, f *DashboardMosaicLayoutTilesWidgetXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Mode; !dcl.IsEmptyValueIndirect(v) {
		m["mode"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptions flattens an instance of DashboardMosaicLayoutTilesWidgetXyChartChartOptions from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptions(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetXyChartChartOptions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetXyChartChartOptions
	}
	r.Mode = flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum(m["mode"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecard into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecard, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecard into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecard, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecard from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecard {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecard{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecard{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecard)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecard(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecard from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecard {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecard{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecard{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecard, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecard(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecard expands an instance of DashboardMosaicLayoutTilesWidgetScorecard into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecard(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecard, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, f.GaugeView, res); err != nil {
		return nil, fmt.Errorf("error expanding GaugeView into gaugeView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["gaugeView"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, f.SparkChartView, res); err != nil {
		return nil, fmt.Errorf("error expanding SparkChartView into sparkChartView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartView"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecard flattens an instance of DashboardMosaicLayoutTilesWidgetScorecard from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecard(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecard {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecard{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecard
	}
	r.TimeSeriesQuery = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.GaugeView = flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, m["gaugeView"], res)
	r.SparkChartView = flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, m["sparkChartView"], res)
	r.Thresholds = flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(c, m["thresholds"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardGaugeViewMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardGaugeView into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardGaugeViewMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardGaugeView into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardGaugeView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeViewMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardGaugeView from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardGaugeView)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardGaugeView from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardGaugeView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardGaugeView expands an instance of DashboardMosaicLayoutTilesWidgetScorecardGaugeView into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LowerBound; !dcl.IsEmptyValueIndirect(v) {
		m["lowerBound"] = v
	}
	if v := f.UpperBound; !dcl.IsEmptyValueIndirect(v) {
		m["upperBound"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeView flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardGaugeView from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardGaugeView(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardGaugeView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardGaugeView
	}
	r.LowerBound = dcl.FlattenDouble(m["lowerBound"])
	r.UpperBound = dcl.FlattenDouble(m["upperBound"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardSparkChartView into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardSparkChartView into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardSparkChartView from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardSparkChartView from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartView expands an instance of DashboardMosaicLayoutTilesWidgetScorecardSparkChartView into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.SparkChartType; !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartType"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartView flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardSparkChartView from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartView(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardSparkChartView
	}
	r.SparkChartType = flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum(m["sparkChartType"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetScorecardThresholdsMap expands the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholds into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardThresholdsMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice expands the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholds into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetScorecardThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholds from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholds{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholds from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardThresholds{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardThresholds{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetScorecardThresholds expands an instance of DashboardMosaicLayoutTilesWidgetScorecardThresholds into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetScorecardThresholds(c *Client, f *DashboardMosaicLayoutTilesWidgetScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholds flattens an instance of DashboardMosaicLayoutTilesWidgetScorecardThresholds from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholds(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetScorecardThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetScorecardThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetScorecardThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetTextMap expands the contents of DashboardMosaicLayoutTilesWidgetText into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetTextMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetText, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetText(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetTextSlice expands the contents of DashboardMosaicLayoutTilesWidgetText into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetTextSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetText, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetText(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetTextMap flattens the contents of DashboardMosaicLayoutTilesWidgetText from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetTextMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetText {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetText{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetText{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetText)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetText(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetTextSlice flattens the contents of DashboardMosaicLayoutTilesWidgetText from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetTextSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetText {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetText{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetText{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetText, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetText(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetText expands an instance of DashboardMosaicLayoutTilesWidgetText into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetText(c *Client, f *DashboardMosaicLayoutTilesWidgetText, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Content; !dcl.IsEmptyValueIndirect(v) {
		m["content"] = v
	}
	if v := f.Format; !dcl.IsEmptyValueIndirect(v) {
		m["format"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetText flattens an instance of DashboardMosaicLayoutTilesWidgetText from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetText(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetText {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetText{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetText
	}
	r.Content = dcl.FlattenString(m["content"])
	r.Format = flattenDashboardMosaicLayoutTilesWidgetTextFormatEnum(m["format"])

	return r
}

// expandDashboardMosaicLayoutTilesWidgetBlankMap expands the contents of DashboardMosaicLayoutTilesWidgetBlank into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetBlankMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetBlank, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetBlank(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetBlankSlice expands the contents of DashboardMosaicLayoutTilesWidgetBlank into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetBlankSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetBlank, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetBlank(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetBlankMap flattens the contents of DashboardMosaicLayoutTilesWidgetBlank from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetBlankMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetBlank {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetBlank{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetBlank{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetBlank)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetBlank(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetBlankSlice flattens the contents of DashboardMosaicLayoutTilesWidgetBlank from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetBlankSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetBlank {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetBlank{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetBlank{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetBlank, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetBlank(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetBlank expands an instance of DashboardMosaicLayoutTilesWidgetBlank into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetBlank(c *Client, f *DashboardMosaicLayoutTilesWidgetBlank, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetBlank flattens an instance of DashboardMosaicLayoutTilesWidgetBlank from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetBlank(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetBlank {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetBlank{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetBlank
	}

	return r
}

// expandDashboardMosaicLayoutTilesWidgetLogsPanelMap expands the contents of DashboardMosaicLayoutTilesWidgetLogsPanel into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetLogsPanelMap(c *Client, f map[string]DashboardMosaicLayoutTilesWidgetLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardMosaicLayoutTilesWidgetLogsPanelSlice expands the contents of DashboardMosaicLayoutTilesWidgetLogsPanel into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetLogsPanelSlice(c *Client, f []DashboardMosaicLayoutTilesWidgetLogsPanel, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardMosaicLayoutTilesWidgetLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardMosaicLayoutTilesWidgetLogsPanelMap flattens the contents of DashboardMosaicLayoutTilesWidgetLogsPanel from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetLogsPanelMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetLogsPanel {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetLogsPanel{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetLogsPanel{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetLogsPanel)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetLogsPanel(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetLogsPanelSlice flattens the contents of DashboardMosaicLayoutTilesWidgetLogsPanel from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetLogsPanelSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetLogsPanel {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetLogsPanel{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetLogsPanel{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetLogsPanel, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetLogsPanel(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardMosaicLayoutTilesWidgetLogsPanel expands an instance of DashboardMosaicLayoutTilesWidgetLogsPanel into a JSON
// request object.
func expandDashboardMosaicLayoutTilesWidgetLogsPanel(c *Client, f *DashboardMosaicLayoutTilesWidgetLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v := f.ResourceNames; v != nil {
		m["resourceNames"] = v
	}

	return m, nil
}

// flattenDashboardMosaicLayoutTilesWidgetLogsPanel flattens an instance of DashboardMosaicLayoutTilesWidgetLogsPanel from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetLogsPanel(c *Client, i interface{}, res *Dashboard) *DashboardMosaicLayoutTilesWidgetLogsPanel {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardMosaicLayoutTilesWidgetLogsPanel{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardMosaicLayoutTilesWidgetLogsPanel
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.ResourceNames = dcl.FlattenStringSlice(m["resourceNames"])

	return r
}

// expandDashboardRowLayoutMap expands the contents of DashboardRowLayout into a JSON
// request object.
func expandDashboardRowLayoutMap(c *Client, f map[string]DashboardRowLayout, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayout(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutSlice expands the contents of DashboardRowLayout into a JSON
// request object.
func expandDashboardRowLayoutSlice(c *Client, f []DashboardRowLayout, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayout(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutMap flattens the contents of DashboardRowLayout from a JSON
// response object.
func flattenDashboardRowLayoutMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayout {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayout{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayout{}
	}

	items := make(map[string]DashboardRowLayout)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayout(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutSlice flattens the contents of DashboardRowLayout from a JSON
// response object.
func flattenDashboardRowLayoutSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayout {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayout{}
	}

	if len(a) == 0 {
		return []DashboardRowLayout{}
	}

	items := make([]DashboardRowLayout, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayout(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayout expands an instance of DashboardRowLayout into a JSON
// request object.
func expandDashboardRowLayout(c *Client, f *DashboardRowLayout, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsSlice(c, f.Rows, res); err != nil {
		return nil, fmt.Errorf("error expanding Rows into rows: %w", err)
	} else if v != nil {
		m["rows"] = v
	}

	return m, nil
}

// flattenDashboardRowLayout flattens an instance of DashboardRowLayout from a JSON
// response object.
func flattenDashboardRowLayout(c *Client, i interface{}, res *Dashboard) *DashboardRowLayout {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayout{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayout
	}
	r.Rows = flattenDashboardRowLayoutRowsSlice(c, m["rows"], res)

	return r
}

// expandDashboardRowLayoutRowsMap expands the contents of DashboardRowLayoutRows into a JSON
// request object.
func expandDashboardRowLayoutRowsMap(c *Client, f map[string]DashboardRowLayoutRows, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRows(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsSlice expands the contents of DashboardRowLayoutRows into a JSON
// request object.
func expandDashboardRowLayoutRowsSlice(c *Client, f []DashboardRowLayoutRows, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRows(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsMap flattens the contents of DashboardRowLayoutRows from a JSON
// response object.
func flattenDashboardRowLayoutRowsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRows {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRows{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRows{}
	}

	items := make(map[string]DashboardRowLayoutRows)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRows(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsSlice flattens the contents of DashboardRowLayoutRows from a JSON
// response object.
func flattenDashboardRowLayoutRowsSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRows {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRows{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRows{}
	}

	items := make([]DashboardRowLayoutRows, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRows(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRows expands an instance of DashboardRowLayoutRows into a JSON
// request object.
func expandDashboardRowLayoutRows(c *Client, f *DashboardRowLayoutRows, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Weight; !dcl.IsEmptyValueIndirect(v) {
		m["weight"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsSlice(c, f.Widgets, res); err != nil {
		return nil, fmt.Errorf("error expanding Widgets into widgets: %w", err)
	} else if v != nil {
		m["widgets"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRows flattens an instance of DashboardRowLayoutRows from a JSON
// response object.
func flattenDashboardRowLayoutRows(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRows {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRows{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRows
	}
	r.Weight = dcl.FlattenInteger(m["weight"])
	r.Widgets = flattenDashboardRowLayoutRowsWidgetsSlice(c, m["widgets"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsMap expands the contents of DashboardRowLayoutRowsWidgets into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsMap(c *Client, f map[string]DashboardRowLayoutRowsWidgets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsSlice expands the contents of DashboardRowLayoutRowsWidgets into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsSlice(c *Client, f []DashboardRowLayoutRowsWidgets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsMap flattens the contents of DashboardRowLayoutRowsWidgets from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgets{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgets{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgets)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsSlice flattens the contents of DashboardRowLayoutRowsWidgets from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgets{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgets{}
	}

	items := make([]DashboardRowLayoutRowsWidgets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgets expands an instance of DashboardRowLayoutRowsWidgets into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgets(c *Client, f *DashboardRowLayoutRowsWidgets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Title; !dcl.IsEmptyValueIndirect(v) {
		m["title"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChart(c, f.XyChart, res); err != nil {
		return nil, fmt.Errorf("error expanding XyChart into xyChart: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xyChart"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecard(c, f.Scorecard, res); err != nil {
		return nil, fmt.Errorf("error expanding Scorecard into scorecard: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["scorecard"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsText(c, f.Text, res); err != nil {
		return nil, fmt.Errorf("error expanding Text into text: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["text"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsBlank(c, f.Blank, res); err != nil {
		return nil, fmt.Errorf("error expanding Blank into blank: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["blank"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsLogsPanel(c, f.LogsPanel, res); err != nil {
		return nil, fmt.Errorf("error expanding LogsPanel into logsPanel: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["logsPanel"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgets flattens an instance of DashboardRowLayoutRowsWidgets from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgets(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgets
	}
	r.Title = dcl.FlattenString(m["title"])
	r.XyChart = flattenDashboardRowLayoutRowsWidgetsXyChart(c, m["xyChart"], res)
	r.Scorecard = flattenDashboardRowLayoutRowsWidgetsScorecard(c, m["scorecard"], res)
	r.Text = flattenDashboardRowLayoutRowsWidgetsText(c, m["text"], res)
	r.Blank = flattenDashboardRowLayoutRowsWidgetsBlank(c, m["blank"], res)
	r.LogsPanel = flattenDashboardRowLayoutRowsWidgetsLogsPanel(c, m["logsPanel"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartMap expands the contents of DashboardRowLayoutRowsWidgetsXyChart into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChart, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChart into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChart, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChart from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChart {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChart{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChart{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChart)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChart(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChart from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChart {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChart{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChart{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChart, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChart(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChart expands an instance of DashboardRowLayoutRowsWidgetsXyChart into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChart(c *Client, f *DashboardRowLayoutRowsWidgetsXyChart, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(c, f.DataSets, res); err != nil {
		return nil, fmt.Errorf("error expanding DataSets into dataSets: %w", err)
	} else if v != nil {
		m["dataSets"] = v
	}
	if v := f.TimeshiftDuration; !dcl.IsEmptyValueIndirect(v) {
		m["timeshiftDuration"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartXAxis(c, f.XAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding XAxis into xAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xAxis"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartYAxis(c, f.YAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding YAxis into yAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["yAxis"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, f.ChartOptions, res); err != nil {
		return nil, fmt.Errorf("error expanding ChartOptions into chartOptions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["chartOptions"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChart flattens an instance of DashboardRowLayoutRowsWidgetsXyChart from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChart(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChart {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChart{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChart
	}
	r.DataSets = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(c, m["dataSets"], res)
	r.TimeshiftDuration = dcl.FlattenString(m["timeshiftDuration"])
	r.Thresholds = flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(c, m["thresholds"], res)
	r.XAxis = flattenDashboardRowLayoutRowsWidgetsXyChartXAxis(c, m["xAxis"], res)
	r.YAxis = flattenDashboardRowLayoutRowsWidgetsXyChartYAxis(c, m["yAxis"], res)
	r.ChartOptions = flattenDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, m["chartOptions"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSets{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSets{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSets)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSets{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSets{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSets expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSets(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v := f.PlotType; !dcl.IsEmptyValueIndirect(v) {
		m["plotType"] = v
	}
	if v := f.LegendTemplate; !dcl.IsEmptyValueIndirect(v) {
		m["legendTemplate"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSets flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSets(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSets
	}
	r.TimeSeriesQuery = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.PlotType = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum(m["plotType"])
	r.LegendTemplate = dcl.FlattenString(m["legendTemplate"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartThresholdsMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartThresholdsMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartThresholds{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartThresholds{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartThresholds{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartThresholds expands an instance of DashboardRowLayoutRowsWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartThresholds(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholds flattens an instance of DashboardRowLayoutRowsWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholds(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartXAxisMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartXAxisMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartXAxisSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartXAxisSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartXAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartXAxisMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartXAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartXAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartXAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartXAxis{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartXAxis)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartXAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartXAxisSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartXAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartXAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartXAxis{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartXAxis{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartXAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartXAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartXAxis expands an instance of DashboardRowLayoutRowsWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartXAxis(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartXAxis flattens an instance of DashboardRowLayoutRowsWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartXAxis(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartXAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartXAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartXAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartYAxisMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartYAxisMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartYAxisSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartYAxisSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartYAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartYAxisMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartYAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartYAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartYAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartYAxis{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartYAxis)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartYAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartYAxisSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartYAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartYAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartYAxis{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartYAxis{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartYAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartYAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartYAxis expands an instance of DashboardRowLayoutRowsWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartYAxis(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartYAxis flattens an instance of DashboardRowLayoutRowsWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartYAxis(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartYAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartYAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartYAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsXyChartChartOptionsMap expands the contents of DashboardRowLayoutRowsWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartChartOptionsMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsXyChartChartOptionsSlice expands the contents of DashboardRowLayoutRowsWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartChartOptionsSlice(c *Client, f []DashboardRowLayoutRowsWidgetsXyChartChartOptions, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptions{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptions{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptions)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartChartOptions{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartChartOptions{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartChartOptions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartChartOptions(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsXyChartChartOptions expands an instance of DashboardRowLayoutRowsWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsXyChartChartOptions(c *Client, f *DashboardRowLayoutRowsWidgetsXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Mode; !dcl.IsEmptyValueIndirect(v) {
		m["mode"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsXyChartChartOptions flattens an instance of DashboardRowLayoutRowsWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartChartOptions(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsXyChartChartOptions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsXyChartChartOptions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsXyChartChartOptions
	}
	r.Mode = flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum(m["mode"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardMap expands the contents of DashboardRowLayoutRowsWidgetsScorecard into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecard, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecard into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecard, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecard from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecard {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecard{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecard{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecard)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecard(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecard from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecard {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecard{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecard{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecard, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecard(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecard expands an instance of DashboardRowLayoutRowsWidgetsScorecard into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecard(c *Client, f *DashboardRowLayoutRowsWidgetsScorecard, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, f.GaugeView, res); err != nil {
		return nil, fmt.Errorf("error expanding GaugeView into gaugeView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["gaugeView"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, f.SparkChartView, res); err != nil {
		return nil, fmt.Errorf("error expanding SparkChartView into sparkChartView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartView"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecard flattens an instance of DashboardRowLayoutRowsWidgetsScorecard from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecard(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecard {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecard{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecard
	}
	r.TimeSeriesQuery = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.GaugeView = flattenDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, m["gaugeView"], res)
	r.SparkChartView = flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, m["sparkChartView"], res)
	r.Thresholds = flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(c, m["thresholds"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardGaugeViewMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardGaugeViewMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardGaugeViewSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardGaugeViewSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardGaugeView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardGaugeViewMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardGaugeViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardGaugeView{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardGaugeView{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardGaugeView)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardGaugeViewSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardGaugeViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardGaugeView{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardGaugeView{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardGaugeView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardGaugeView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardGaugeView expands an instance of DashboardRowLayoutRowsWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardGaugeView(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LowerBound; !dcl.IsEmptyValueIndirect(v) {
		m["lowerBound"] = v
	}
	if v := f.UpperBound; !dcl.IsEmptyValueIndirect(v) {
		m["upperBound"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardGaugeView flattens an instance of DashboardRowLayoutRowsWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardGaugeView(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardGaugeView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardGaugeView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardGaugeView
	}
	r.LowerBound = dcl.FlattenDouble(m["lowerBound"])
	r.UpperBound = dcl.FlattenDouble(m["upperBound"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardSparkChartViewMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardSparkChartViewMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardSparkChartView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartView)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardSparkChartView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardSparkChartView expands an instance of DashboardRowLayoutRowsWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.SparkChartType; !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartType"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartView flattens an instance of DashboardRowLayoutRowsWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartView(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardSparkChartView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardSparkChartView
	}
	r.SparkChartType = flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum(m["sparkChartType"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsScorecardThresholdsMap expands the contents of DashboardRowLayoutRowsWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardThresholdsMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice expands the contents of DashboardRowLayoutRowsWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(c *Client, f []DashboardRowLayoutRowsWidgetsScorecardThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardThresholds{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardThresholds{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardThresholds{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsScorecardThresholds expands an instance of DashboardRowLayoutRowsWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsScorecardThresholds(c *Client, f *DashboardRowLayoutRowsWidgetsScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholds flattens an instance of DashboardRowLayoutRowsWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholds(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsScorecardThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsScorecardThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsScorecardThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsTextMap expands the contents of DashboardRowLayoutRowsWidgetsText into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsTextMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsText, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsText(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsTextSlice expands the contents of DashboardRowLayoutRowsWidgetsText into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsTextSlice(c *Client, f []DashboardRowLayoutRowsWidgetsText, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsText(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsTextMap flattens the contents of DashboardRowLayoutRowsWidgetsText from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsTextMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsText {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsText{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsText{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsText)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsText(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsTextSlice flattens the contents of DashboardRowLayoutRowsWidgetsText from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsTextSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsText {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsText{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsText{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsText, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsText(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsText expands an instance of DashboardRowLayoutRowsWidgetsText into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsText(c *Client, f *DashboardRowLayoutRowsWidgetsText, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Content; !dcl.IsEmptyValueIndirect(v) {
		m["content"] = v
	}
	if v := f.Format; !dcl.IsEmptyValueIndirect(v) {
		m["format"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsText flattens an instance of DashboardRowLayoutRowsWidgetsText from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsText(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsText {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsText{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsText
	}
	r.Content = dcl.FlattenString(m["content"])
	r.Format = flattenDashboardRowLayoutRowsWidgetsTextFormatEnum(m["format"])

	return r
}

// expandDashboardRowLayoutRowsWidgetsBlankMap expands the contents of DashboardRowLayoutRowsWidgetsBlank into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsBlankMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsBlank, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsBlank(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsBlankSlice expands the contents of DashboardRowLayoutRowsWidgetsBlank into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsBlankSlice(c *Client, f []DashboardRowLayoutRowsWidgetsBlank, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsBlank(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsBlankMap flattens the contents of DashboardRowLayoutRowsWidgetsBlank from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsBlankMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsBlank {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsBlank{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsBlank{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsBlank)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsBlank(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsBlankSlice flattens the contents of DashboardRowLayoutRowsWidgetsBlank from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsBlankSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsBlank {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsBlank{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsBlank{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsBlank, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsBlank(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsBlank expands an instance of DashboardRowLayoutRowsWidgetsBlank into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsBlank(c *Client, f *DashboardRowLayoutRowsWidgetsBlank, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsBlank flattens an instance of DashboardRowLayoutRowsWidgetsBlank from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsBlank(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsBlank {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsBlank{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsBlank
	}

	return r
}

// expandDashboardRowLayoutRowsWidgetsLogsPanelMap expands the contents of DashboardRowLayoutRowsWidgetsLogsPanel into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsLogsPanelMap(c *Client, f map[string]DashboardRowLayoutRowsWidgetsLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardRowLayoutRowsWidgetsLogsPanelSlice expands the contents of DashboardRowLayoutRowsWidgetsLogsPanel into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsLogsPanelSlice(c *Client, f []DashboardRowLayoutRowsWidgetsLogsPanel, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardRowLayoutRowsWidgetsLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardRowLayoutRowsWidgetsLogsPanelMap flattens the contents of DashboardRowLayoutRowsWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsLogsPanelMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsLogsPanel {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsLogsPanel{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsLogsPanel{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsLogsPanel)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsLogsPanel(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsLogsPanelSlice flattens the contents of DashboardRowLayoutRowsWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsLogsPanelSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsLogsPanel {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsLogsPanel{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsLogsPanel{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsLogsPanel, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsLogsPanel(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardRowLayoutRowsWidgetsLogsPanel expands an instance of DashboardRowLayoutRowsWidgetsLogsPanel into a JSON
// request object.
func expandDashboardRowLayoutRowsWidgetsLogsPanel(c *Client, f *DashboardRowLayoutRowsWidgetsLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v := f.ResourceNames; v != nil {
		m["resourceNames"] = v
	}

	return m, nil
}

// flattenDashboardRowLayoutRowsWidgetsLogsPanel flattens an instance of DashboardRowLayoutRowsWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsLogsPanel(c *Client, i interface{}, res *Dashboard) *DashboardRowLayoutRowsWidgetsLogsPanel {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardRowLayoutRowsWidgetsLogsPanel{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardRowLayoutRowsWidgetsLogsPanel
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.ResourceNames = dcl.FlattenStringSlice(m["resourceNames"])

	return r
}

// expandDashboardColumnLayoutMap expands the contents of DashboardColumnLayout into a JSON
// request object.
func expandDashboardColumnLayoutMap(c *Client, f map[string]DashboardColumnLayout, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayout(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutSlice expands the contents of DashboardColumnLayout into a JSON
// request object.
func expandDashboardColumnLayoutSlice(c *Client, f []DashboardColumnLayout, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayout(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutMap flattens the contents of DashboardColumnLayout from a JSON
// response object.
func flattenDashboardColumnLayoutMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayout {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayout{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayout{}
	}

	items := make(map[string]DashboardColumnLayout)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayout(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutSlice flattens the contents of DashboardColumnLayout from a JSON
// response object.
func flattenDashboardColumnLayoutSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayout {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayout{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayout{}
	}

	items := make([]DashboardColumnLayout, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayout(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayout expands an instance of DashboardColumnLayout into a JSON
// request object.
func expandDashboardColumnLayout(c *Client, f *DashboardColumnLayout, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsSlice(c, f.Columns, res); err != nil {
		return nil, fmt.Errorf("error expanding Columns into columns: %w", err)
	} else if v != nil {
		m["columns"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayout flattens an instance of DashboardColumnLayout from a JSON
// response object.
func flattenDashboardColumnLayout(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayout {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayout{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayout
	}
	r.Columns = flattenDashboardColumnLayoutColumnsSlice(c, m["columns"], res)

	return r
}

// expandDashboardColumnLayoutColumnsMap expands the contents of DashboardColumnLayoutColumns into a JSON
// request object.
func expandDashboardColumnLayoutColumnsMap(c *Client, f map[string]DashboardColumnLayoutColumns, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumns(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsSlice expands the contents of DashboardColumnLayoutColumns into a JSON
// request object.
func expandDashboardColumnLayoutColumnsSlice(c *Client, f []DashboardColumnLayoutColumns, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumns(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsMap flattens the contents of DashboardColumnLayoutColumns from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumns {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumns{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumns{}
	}

	items := make(map[string]DashboardColumnLayoutColumns)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumns(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsSlice flattens the contents of DashboardColumnLayoutColumns from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumns {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumns{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumns{}
	}

	items := make([]DashboardColumnLayoutColumns, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumns(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumns expands an instance of DashboardColumnLayoutColumns into a JSON
// request object.
func expandDashboardColumnLayoutColumns(c *Client, f *DashboardColumnLayoutColumns, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Weight; !dcl.IsEmptyValueIndirect(v) {
		m["weight"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsSlice(c, f.Widgets, res); err != nil {
		return nil, fmt.Errorf("error expanding Widgets into widgets: %w", err)
	} else if v != nil {
		m["widgets"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumns flattens an instance of DashboardColumnLayoutColumns from a JSON
// response object.
func flattenDashboardColumnLayoutColumns(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumns {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumns{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumns
	}
	r.Weight = dcl.FlattenInteger(m["weight"])
	r.Widgets = flattenDashboardColumnLayoutColumnsWidgetsSlice(c, m["widgets"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsMap expands the contents of DashboardColumnLayoutColumnsWidgets into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsSlice expands the contents of DashboardColumnLayoutColumnsWidgets into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsSlice(c *Client, f []DashboardColumnLayoutColumnsWidgets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsMap flattens the contents of DashboardColumnLayoutColumnsWidgets from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgets{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgets{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgets)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsSlice flattens the contents of DashboardColumnLayoutColumnsWidgets from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgets{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgets{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgets expands an instance of DashboardColumnLayoutColumnsWidgets into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgets(c *Client, f *DashboardColumnLayoutColumnsWidgets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Title; !dcl.IsEmptyValueIndirect(v) {
		m["title"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChart(c, f.XyChart, res); err != nil {
		return nil, fmt.Errorf("error expanding XyChart into xyChart: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xyChart"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecard(c, f.Scorecard, res); err != nil {
		return nil, fmt.Errorf("error expanding Scorecard into scorecard: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["scorecard"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsText(c, f.Text, res); err != nil {
		return nil, fmt.Errorf("error expanding Text into text: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["text"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsBlank(c, f.Blank, res); err != nil {
		return nil, fmt.Errorf("error expanding Blank into blank: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["blank"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsLogsPanel(c, f.LogsPanel, res); err != nil {
		return nil, fmt.Errorf("error expanding LogsPanel into logsPanel: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["logsPanel"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgets flattens an instance of DashboardColumnLayoutColumnsWidgets from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgets(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgets
	}
	r.Title = dcl.FlattenString(m["title"])
	r.XyChart = flattenDashboardColumnLayoutColumnsWidgetsXyChart(c, m["xyChart"], res)
	r.Scorecard = flattenDashboardColumnLayoutColumnsWidgetsScorecard(c, m["scorecard"], res)
	r.Text = flattenDashboardColumnLayoutColumnsWidgetsText(c, m["text"], res)
	r.Blank = flattenDashboardColumnLayoutColumnsWidgetsBlank(c, m["blank"], res)
	r.LogsPanel = flattenDashboardColumnLayoutColumnsWidgetsLogsPanel(c, m["logsPanel"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChart into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChart, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChart into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChart, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChart(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChart from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChart {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChart{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChart{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChart)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChart(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChart from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChart {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChart{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChart{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChart, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChart(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChart expands an instance of DashboardColumnLayoutColumnsWidgetsXyChart into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChart(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChart, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(c, f.DataSets, res); err != nil {
		return nil, fmt.Errorf("error expanding DataSets into dataSets: %w", err)
	} else if v != nil {
		m["dataSets"] = v
	}
	if v := f.TimeshiftDuration; !dcl.IsEmptyValueIndirect(v) {
		m["timeshiftDuration"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, f.XAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding XAxis into xAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["xAxis"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, f.YAxis, res); err != nil {
		return nil, fmt.Errorf("error expanding YAxis into yAxis: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["yAxis"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, f.ChartOptions, res); err != nil {
		return nil, fmt.Errorf("error expanding ChartOptions into chartOptions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["chartOptions"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChart flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChart from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChart(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChart {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChart{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChart
	}
	r.DataSets = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(c, m["dataSets"], res)
	r.TimeshiftDuration = dcl.FlattenString(m["timeshiftDuration"])
	r.Thresholds = flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(c, m["thresholds"], res)
	r.XAxis = flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, m["xAxis"], res)
	r.YAxis = flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, m["yAxis"], res)
	r.ChartOptions = flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, m["chartOptions"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSets, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSets{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSets{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSets)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSets{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSets{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSets, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSets expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSets into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSets, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v := f.PlotType; !dcl.IsEmptyValueIndirect(v) {
		m["plotType"] = v
	}
	if v := f.LegendTemplate; !dcl.IsEmptyValueIndirect(v) {
		m["legendTemplate"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSets flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSets from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSets(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSets {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSets{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSets
	}
	r.TimeSeriesQuery = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.PlotType = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum(m["plotType"])
	r.LegendTemplate = dcl.FlattenString(m["legendTemplate"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartThresholdsMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartThresholdsMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholds{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartThresholds{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartThresholds{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartThresholds expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartThresholds into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholds flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartThresholds from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholds(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartXAxisMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartXAxisMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartXAxisSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartXAxisSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartXAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxis)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartXAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartXAxis expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartXAxis into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartXAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxis flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartXAxis from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxis(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartXAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartXAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartYAxisMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartYAxisMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartYAxisSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartYAxisSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartYAxis, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxis)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartYAxis, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartYAxis expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartYAxis into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartYAxis, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Scale; !dcl.IsEmptyValueIndirect(v) {
		m["scale"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxis flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartYAxis from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxis(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartYAxis {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartYAxis
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Scale = flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum(m["scale"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsMap expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSlice expands the contents of DashboardColumnLayoutColumnsWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptions expands an instance of DashboardColumnLayoutColumnsWidgetsXyChartChartOptions into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c *Client, f *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Mode; !dcl.IsEmptyValueIndirect(v) {
		m["mode"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptions flattens an instance of DashboardColumnLayoutColumnsWidgetsXyChartChartOptions from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptions(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsXyChartChartOptions
	}
	r.Mode = flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum(m["mode"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecard into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecard, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecard into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecard, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecard(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecard from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecard {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecard{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecard{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecard)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecard(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecard from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecard {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecard{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecard{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecard, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecard(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecard expands an instance of DashboardColumnLayoutColumnsWidgetsScorecard into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecard(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecard, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, f.TimeSeriesQuery, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesQuery into timeSeriesQuery: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQuery"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, f.GaugeView, res); err != nil {
		return nil, fmt.Errorf("error expanding GaugeView into gaugeView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["gaugeView"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, f.SparkChartView, res); err != nil {
		return nil, fmt.Errorf("error expanding SparkChartView into sparkChartView: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartView"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(c, f.Thresholds, res); err != nil {
		return nil, fmt.Errorf("error expanding Thresholds into thresholds: %w", err)
	} else if v != nil {
		m["thresholds"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecard flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecard from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecard(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecard {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecard{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecard
	}
	r.TimeSeriesQuery = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, m["timeSeriesQuery"], res)
	r.GaugeView = flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, m["gaugeView"], res)
	r.SparkChartView = flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, m["sparkChartView"], res)
	r.Thresholds = flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(c, m["thresholds"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuerySlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, f.TimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilter into timeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, f.TimeSeriesFilterRatio, res); err != nil {
		return nil, fmt.Errorf("error expanding TimeSeriesFilterRatio into timeSeriesFilterRatio: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesFilterRatio"] = v
	}
	if v := f.TimeSeriesQueryLanguage; !dcl.IsEmptyValueIndirect(v) {
		m["timeSeriesQueryLanguage"] = v
	}
	if v := f.UnitOverride; !dcl.IsEmptyValueIndirect(v) {
		m["unitOverride"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery
	}
	r.TimeSeriesFilter = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, m["timeSeriesFilter"], res)
	r.TimeSeriesFilterRatio = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, m["timeSeriesFilterRatio"], res)
	r.TimeSeriesQueryLanguage = dcl.FlattenString(m["timeSeriesQueryLanguage"])
	r.UnitOverride = dcl.FlattenString(m["unitOverride"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, m["aggregation"], res)
	r.SecondaryAggregation = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, f.Numerator, res); err != nil {
		return nil, fmt.Errorf("error expanding Numerator into numerator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["numerator"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, f.Denominator, res); err != nil {
		return nil, fmt.Errorf("error expanding Denominator into denominator: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["denominator"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, f.SecondaryAggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding SecondaryAggregation into secondaryAggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["secondaryAggregation"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, f.PickTimeSeriesFilter, res); err != nil {
		return nil, fmt.Errorf("error expanding PickTimeSeriesFilter into pickTimeSeriesFilter: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["pickTimeSeriesFilter"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
	}
	r.Numerator = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, m["numerator"], res)
	r.Denominator = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, m["denominator"], res)
	r.SecondaryAggregation = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, m["secondaryAggregation"], res)
	r.PickTimeSeriesFilter = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, m["pickTimeSeriesFilter"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, f.Aggregation, res); err != nil {
		return nil, fmt.Errorf("error expanding Aggregation into aggregation: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["aggregation"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.Aggregation = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, m["aggregation"], res)

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.AlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["alignmentPeriod"] = v
	}
	if v := f.PerSeriesAligner; !dcl.IsEmptyValueIndirect(v) {
		m["perSeriesAligner"] = v
	}
	if v := f.CrossSeriesReducer; !dcl.IsEmptyValueIndirect(v) {
		m["crossSeriesReducer"] = v
	}
	if v := f.GroupByFields; v != nil {
		m["groupByFields"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
	}
	r.AlignmentPeriod = dcl.FlattenString(m["alignmentPeriod"])
	r.PerSeriesAligner = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(m["perSeriesAligner"])
	r.CrossSeriesReducer = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(m["crossSeriesReducer"])
	r.GroupByFields = dcl.FlattenStringSlice(m["groupByFields"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RankingMethod; !dcl.IsEmptyValueIndirect(v) {
		m["rankingMethod"] = v
	}
	if v := f.NumTimeSeries; !dcl.IsEmptyValueIndirect(v) {
		m["numTimeSeries"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
	}
	r.RankingMethod = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(m["rankingMethod"])
	r.NumTimeSeries = dcl.FlattenInteger(m["numTimeSeries"])
	r.Direction = flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(m["direction"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeView expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardGaugeView into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LowerBound; !dcl.IsEmptyValueIndirect(v) {
		m["lowerBound"] = v
	}
	if v := f.UpperBound; !dcl.IsEmptyValueIndirect(v) {
		m["upperBound"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeView flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardGaugeView from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardGaugeView(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardGaugeView
	}
	r.LowerBound = dcl.FlattenDouble(m["lowerBound"])
	r.UpperBound = dcl.FlattenDouble(m["upperBound"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.SparkChartType; !dcl.IsEmptyValueIndirect(v) {
		m["sparkChartType"] = v
	}
	if v := f.MinAlignmentPeriod; !dcl.IsEmptyValueIndirect(v) {
		m["minAlignmentPeriod"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardSparkChartView
	}
	r.SparkChartType = flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum(m["sparkChartType"])
	r.MinAlignmentPeriod = dcl.FlattenString(m["minAlignmentPeriod"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardThresholdsMap expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardThresholdsMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice expands the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsScorecardThresholds, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholds{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholds{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholds)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardThresholds{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardThresholds{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardThresholds, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsScorecardThresholds expands an instance of DashboardColumnLayoutColumnsWidgetsScorecardThresholds into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c *Client, f *DashboardColumnLayoutColumnsWidgetsScorecardThresholds, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Label; !dcl.IsEmptyValueIndirect(v) {
		m["label"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}
	if v := f.Color; !dcl.IsEmptyValueIndirect(v) {
		m["color"] = v
	}
	if v := f.Direction; !dcl.IsEmptyValueIndirect(v) {
		m["direction"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholds flattens an instance of DashboardColumnLayoutColumnsWidgetsScorecardThresholds from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholds(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsScorecardThresholds {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsScorecardThresholds{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsScorecardThresholds
	}
	r.Label = dcl.FlattenString(m["label"])
	r.Value = dcl.FlattenDouble(m["value"])
	r.Color = flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum(m["color"])
	r.Direction = flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum(m["direction"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsTextMap expands the contents of DashboardColumnLayoutColumnsWidgetsText into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsTextMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsText, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsText(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsTextSlice expands the contents of DashboardColumnLayoutColumnsWidgetsText into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsTextSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsText, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsText(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsTextMap flattens the contents of DashboardColumnLayoutColumnsWidgetsText from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsTextMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsText {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsText{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsText{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsText)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsText(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsTextSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsText from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsTextSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsText {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsText{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsText{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsText, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsText(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsText expands an instance of DashboardColumnLayoutColumnsWidgetsText into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsText(c *Client, f *DashboardColumnLayoutColumnsWidgetsText, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Content; !dcl.IsEmptyValueIndirect(v) {
		m["content"] = v
	}
	if v := f.Format; !dcl.IsEmptyValueIndirect(v) {
		m["format"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsText flattens an instance of DashboardColumnLayoutColumnsWidgetsText from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsText(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsText {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsText{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsText
	}
	r.Content = dcl.FlattenString(m["content"])
	r.Format = flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnum(m["format"])

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsBlankMap expands the contents of DashboardColumnLayoutColumnsWidgetsBlank into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsBlankMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsBlank, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsBlank(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsBlankSlice expands the contents of DashboardColumnLayoutColumnsWidgetsBlank into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsBlankSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsBlank, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsBlank(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsBlankMap flattens the contents of DashboardColumnLayoutColumnsWidgetsBlank from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsBlankMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsBlank {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsBlank{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsBlank{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsBlank)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsBlank(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsBlankSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsBlank from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsBlankSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsBlank {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsBlank{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsBlank{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsBlank, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsBlank(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsBlank expands an instance of DashboardColumnLayoutColumnsWidgetsBlank into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsBlank(c *Client, f *DashboardColumnLayoutColumnsWidgetsBlank, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsBlank flattens an instance of DashboardColumnLayoutColumnsWidgetsBlank from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsBlank(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsBlank {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsBlank{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsBlank
	}

	return r
}

// expandDashboardColumnLayoutColumnsWidgetsLogsPanelMap expands the contents of DashboardColumnLayoutColumnsWidgetsLogsPanel into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsLogsPanelMap(c *Client, f map[string]DashboardColumnLayoutColumnsWidgetsLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandDashboardColumnLayoutColumnsWidgetsLogsPanelSlice expands the contents of DashboardColumnLayoutColumnsWidgetsLogsPanel into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsLogsPanelSlice(c *Client, f []DashboardColumnLayoutColumnsWidgetsLogsPanel, res *Dashboard) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandDashboardColumnLayoutColumnsWidgetsLogsPanel(c, &item, res)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsLogsPanelMap flattens the contents of DashboardColumnLayoutColumnsWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsLogsPanelMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsLogsPanel {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsLogsPanel{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsLogsPanel{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsLogsPanel)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsLogsPanel(c, item.(map[string]interface{}), res)
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsLogsPanelSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsLogsPanelSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsLogsPanel {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsLogsPanel{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsLogsPanel{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsLogsPanel, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsLogsPanel(c, item.(map[string]interface{}), res))
	}

	return items
}

// expandDashboardColumnLayoutColumnsWidgetsLogsPanel expands an instance of DashboardColumnLayoutColumnsWidgetsLogsPanel into a JSON
// request object.
func expandDashboardColumnLayoutColumnsWidgetsLogsPanel(c *Client, f *DashboardColumnLayoutColumnsWidgetsLogsPanel, res *Dashboard) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Filter; !dcl.IsEmptyValueIndirect(v) {
		m["filter"] = v
	}
	if v := f.ResourceNames; v != nil {
		m["resourceNames"] = v
	}

	return m, nil
}

// flattenDashboardColumnLayoutColumnsWidgetsLogsPanel flattens an instance of DashboardColumnLayoutColumnsWidgetsLogsPanel from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsLogsPanel(c *Client, i interface{}, res *Dashboard) *DashboardColumnLayoutColumnsWidgetsLogsPanel {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &DashboardColumnLayoutColumnsWidgetsLogsPanel{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyDashboardColumnLayoutColumnsWidgetsLogsPanel
	}
	r.Filter = dcl.FlattenString(m["filter"])
	r.ResourceNames = dcl.FlattenStringSlice(m["resourceNames"])

	return r
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartDataSetsPlotTypeEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartThresholdsColorEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartThresholdsColorEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartThresholdsColorEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsColorEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartThresholdsColorEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartThresholdsDirectionEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartXAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartXAxisScaleEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartXAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartXAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartXAxisScaleEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartXAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartXAxisScaleEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartXAxisScaleEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartXAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartXAxisScaleEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartYAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartYAxisScaleEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartYAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartYAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartYAxisScaleEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartYAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartYAxisScaleEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartYAxisScaleEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartYAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartYAxisScaleEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnumMap flattens the contents of DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnumSlice flattens the contents of DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsXyChartChartOptionsModeEnum(i interface{}) *DashboardGridLayoutWidgetsXyChartChartOptionsModeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsXyChartChartOptionsModeEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardSparkChartViewSparkChartTypeEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardThresholdsColorEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardThresholdsColorEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardThresholdsColorEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsColorEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardThresholdsColorEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnumMap flattens the contents of DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnumSlice flattens the contents of DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum(i interface{}) *DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsScorecardThresholdsDirectionEnumRef(s)
}

// flattenDashboardGridLayoutWidgetsTextFormatEnumMap flattens the contents of DashboardGridLayoutWidgetsTextFormatEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsTextFormatEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardGridLayoutWidgetsTextFormatEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardGridLayoutWidgetsTextFormatEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardGridLayoutWidgetsTextFormatEnum{}
	}

	items := make(map[string]DashboardGridLayoutWidgetsTextFormatEnum)
	for k, item := range a {
		items[k] = *flattenDashboardGridLayoutWidgetsTextFormatEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsTextFormatEnumSlice flattens the contents of DashboardGridLayoutWidgetsTextFormatEnum from a JSON
// response object.
func flattenDashboardGridLayoutWidgetsTextFormatEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardGridLayoutWidgetsTextFormatEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardGridLayoutWidgetsTextFormatEnum{}
	}

	if len(a) == 0 {
		return []DashboardGridLayoutWidgetsTextFormatEnum{}
	}

	items := make([]DashboardGridLayoutWidgetsTextFormatEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardGridLayoutWidgetsTextFormatEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardGridLayoutWidgetsTextFormatEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardGridLayoutWidgetsTextFormatEnum with the same value as that string.
func flattenDashboardGridLayoutWidgetsTextFormatEnum(i interface{}) *DashboardGridLayoutWidgetsTextFormatEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardGridLayoutWidgetsTextFormatEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartDataSetsPlotTypeEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartThresholdsColorEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartThresholdsDirectionEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartXAxisScaleEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartYAxisScaleEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetXyChartChartOptionsModeEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardSparkChartViewSparkChartTypeEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardThresholdsColorEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetScorecardThresholdsDirectionEnumRef(s)
}

// flattenDashboardMosaicLayoutTilesWidgetTextFormatEnumMap flattens the contents of DashboardMosaicLayoutTilesWidgetTextFormatEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetTextFormatEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardMosaicLayoutTilesWidgetTextFormatEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardMosaicLayoutTilesWidgetTextFormatEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardMosaicLayoutTilesWidgetTextFormatEnum{}
	}

	items := make(map[string]DashboardMosaicLayoutTilesWidgetTextFormatEnum)
	for k, item := range a {
		items[k] = *flattenDashboardMosaicLayoutTilesWidgetTextFormatEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetTextFormatEnumSlice flattens the contents of DashboardMosaicLayoutTilesWidgetTextFormatEnum from a JSON
// response object.
func flattenDashboardMosaicLayoutTilesWidgetTextFormatEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardMosaicLayoutTilesWidgetTextFormatEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardMosaicLayoutTilesWidgetTextFormatEnum{}
	}

	if len(a) == 0 {
		return []DashboardMosaicLayoutTilesWidgetTextFormatEnum{}
	}

	items := make([]DashboardMosaicLayoutTilesWidgetTextFormatEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardMosaicLayoutTilesWidgetTextFormatEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardMosaicLayoutTilesWidgetTextFormatEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardMosaicLayoutTilesWidgetTextFormatEnum with the same value as that string.
func flattenDashboardMosaicLayoutTilesWidgetTextFormatEnum(i interface{}) *DashboardMosaicLayoutTilesWidgetTextFormatEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardMosaicLayoutTilesWidgetTextFormatEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartDataSetsPlotTypeEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartThresholdsColorEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartThresholdsDirectionEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartXAxisScaleEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartYAxisScaleEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum(i interface{}) *DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsXyChartChartOptionsModeEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardSparkChartViewSparkChartTypeEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardThresholdsColorEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum(i interface{}) *DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsScorecardThresholdsDirectionEnumRef(s)
}

// flattenDashboardRowLayoutRowsWidgetsTextFormatEnumMap flattens the contents of DashboardRowLayoutRowsWidgetsTextFormatEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsTextFormatEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardRowLayoutRowsWidgetsTextFormatEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardRowLayoutRowsWidgetsTextFormatEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardRowLayoutRowsWidgetsTextFormatEnum{}
	}

	items := make(map[string]DashboardRowLayoutRowsWidgetsTextFormatEnum)
	for k, item := range a {
		items[k] = *flattenDashboardRowLayoutRowsWidgetsTextFormatEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsTextFormatEnumSlice flattens the contents of DashboardRowLayoutRowsWidgetsTextFormatEnum from a JSON
// response object.
func flattenDashboardRowLayoutRowsWidgetsTextFormatEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardRowLayoutRowsWidgetsTextFormatEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardRowLayoutRowsWidgetsTextFormatEnum{}
	}

	if len(a) == 0 {
		return []DashboardRowLayoutRowsWidgetsTextFormatEnum{}
	}

	items := make([]DashboardRowLayoutRowsWidgetsTextFormatEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardRowLayoutRowsWidgetsTextFormatEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardRowLayoutRowsWidgetsTextFormatEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardRowLayoutRowsWidgetsTextFormatEnum with the same value as that string.
func flattenDashboardRowLayoutRowsWidgetsTextFormatEnum(i interface{}) *DashboardRowLayoutRowsWidgetsTextFormatEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardRowLayoutRowsWidgetsTextFormatEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartDataSetsPlotTypeEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartThresholdsColorEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartThresholdsDirectionEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartXAxisScaleEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartYAxisScaleEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsXyChartChartOptionsModeEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationPerSeriesAlignerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationCrossSeriesReducerEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterRankingMethodEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterDirectionEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewSparkChartTypeEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardThresholdsColorEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsScorecardThresholdsDirectionEnumRef(s)
}

// flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnumMap flattens the contents of DashboardColumnLayoutColumnsWidgetsTextFormatEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnumMap(c *Client, i interface{}, res *Dashboard) map[string]DashboardColumnLayoutColumnsWidgetsTextFormatEnum {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]DashboardColumnLayoutColumnsWidgetsTextFormatEnum{}
	}

	if len(a) == 0 {
		return map[string]DashboardColumnLayoutColumnsWidgetsTextFormatEnum{}
	}

	items := make(map[string]DashboardColumnLayoutColumnsWidgetsTextFormatEnum)
	for k, item := range a {
		items[k] = *flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnum(item.(interface{}))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnumSlice flattens the contents of DashboardColumnLayoutColumnsWidgetsTextFormatEnum from a JSON
// response object.
func flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnumSlice(c *Client, i interface{}, res *Dashboard) []DashboardColumnLayoutColumnsWidgetsTextFormatEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []DashboardColumnLayoutColumnsWidgetsTextFormatEnum{}
	}

	if len(a) == 0 {
		return []DashboardColumnLayoutColumnsWidgetsTextFormatEnum{}
	}

	items := make([]DashboardColumnLayoutColumnsWidgetsTextFormatEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnum(item.(interface{})))
	}

	return items
}

// flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnum asserts that an interface is a string, and returns a
// pointer to a *DashboardColumnLayoutColumnsWidgetsTextFormatEnum with the same value as that string.
func flattenDashboardColumnLayoutColumnsWidgetsTextFormatEnum(i interface{}) *DashboardColumnLayoutColumnsWidgetsTextFormatEnum {
	s, ok := i.(string)
	if !ok {
		return nil
	}

	return DashboardColumnLayoutColumnsWidgetsTextFormatEnumRef(s)
}

// This function returns a matcher that checks whether a serialized resource matches this resource
// in its parameters (as defined by the fields in a Get, which definitionally define resource
// identity).  This is useful in extracting the element from a List call.
func (r *Dashboard) matcher(c *Client) func([]byte) bool {
	return func(b []byte) bool {
		cr, err := unmarshalDashboard(b, c, r)
		if err != nil {
			c.Config.Logger.Warning("failed to unmarshal provided resource in matcher.")
			return false
		}
		nr := r.urlNormalized()
		ncr := cr.urlNormalized()
		c.Config.Logger.Infof("looking for %v\nin %v", nr, ncr)

		if nr.Project == nil && ncr.Project == nil {
			c.Config.Logger.Info("Both Project fields null - considering equal.")
		} else if nr.Project == nil || ncr.Project == nil {
			c.Config.Logger.Info("Only one Project field is null - considering unequal.")
			return false
		} else if *nr.Project != *ncr.Project {
			return false
		}
		if nr.Name == nil && ncr.Name == nil {
			c.Config.Logger.Info("Both Name fields null - considering equal.")
		} else if nr.Name == nil || ncr.Name == nil {
			c.Config.Logger.Info("Only one Name field is null - considering unequal.")
			return false
		} else if *nr.Name != *ncr.Name {
			return false
		}
		return true
	}
}

type dashboardDiff struct {
	// The diff should include one or the other of RequiresRecreate or UpdateOp.
	RequiresRecreate bool
	UpdateOp         dashboardApiOperation
	FieldName        string // used for error logging
}

func convertFieldDiffsToDashboardDiffs(config *dcl.Config, fds []*dcl.FieldDiff, opts []dcl.ApplyOption) ([]dashboardDiff, error) {
	opNamesToFieldDiffs := make(map[string][]*dcl.FieldDiff)
	// Map each operation name to the field diffs associated with it.
	for _, fd := range fds {
		for _, ro := range fd.ResultingOperation {
			if fieldDiffs, ok := opNamesToFieldDiffs[ro]; ok {
				fieldDiffs = append(fieldDiffs, fd)
				opNamesToFieldDiffs[ro] = fieldDiffs
			} else {
				config.Logger.Infof("%s required due to diff: %v", ro, fd)
				opNamesToFieldDiffs[ro] = []*dcl.FieldDiff{fd}
			}
		}
	}
	var diffs []dashboardDiff
	// For each operation name, create a dashboardDiff which contains the operation.
	for opName, fieldDiffs := range opNamesToFieldDiffs {
		// Use the first field diff's field name for logging required recreate error.
		diff := dashboardDiff{FieldName: fieldDiffs[0].FieldName}
		if opName == "Recreate" {
			diff.RequiresRecreate = true
		} else {
			apiOp, err := convertOpNameToDashboardApiOperation(opName, fieldDiffs, opts...)
			if err != nil {
				return diffs, err
			}
			diff.UpdateOp = apiOp
		}
		diffs = append(diffs, diff)
	}
	return diffs, nil
}

func convertOpNameToDashboardApiOperation(opName string, fieldDiffs []*dcl.FieldDiff, opts ...dcl.ApplyOption) (dashboardApiOperation, error) {
	switch opName {

	case "updateDashboardUpdateDashboardOperation":
		return &updateDashboardUpdateDashboardOperation{FieldDiffs: fieldDiffs}, nil

	default:
		return nil, fmt.Errorf("no such operation with name: %v", opName)
	}
}

func extractDashboardFields(r *Dashboard) error {
	vGridLayout := r.GridLayout
	if vGridLayout == nil {
		// note: explicitly not the empty object.
		vGridLayout = &DashboardGridLayout{}
	}
	if err := extractDashboardGridLayoutFields(r, vGridLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGridLayout) {
		r.GridLayout = vGridLayout
	}
	vMosaicLayout := r.MosaicLayout
	if vMosaicLayout == nil {
		// note: explicitly not the empty object.
		vMosaicLayout = &DashboardMosaicLayout{}
	}
	if err := extractDashboardMosaicLayoutFields(r, vMosaicLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vMosaicLayout) {
		r.MosaicLayout = vMosaicLayout
	}
	vRowLayout := r.RowLayout
	if vRowLayout == nil {
		// note: explicitly not the empty object.
		vRowLayout = &DashboardRowLayout{}
	}
	if err := extractDashboardRowLayoutFields(r, vRowLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vRowLayout) {
		r.RowLayout = vRowLayout
	}
	vColumnLayout := r.ColumnLayout
	if vColumnLayout == nil {
		// note: explicitly not the empty object.
		vColumnLayout = &DashboardColumnLayout{}
	}
	if err := extractDashboardColumnLayoutFields(r, vColumnLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vColumnLayout) {
		r.ColumnLayout = vColumnLayout
	}
	return nil
}
func extractDashboardGridLayoutFields(r *Dashboard, o *DashboardGridLayout) error {
	return nil
}
func extractDashboardGridLayoutWidgetsFields(r *Dashboard, o *DashboardGridLayoutWidgets) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardGridLayoutWidgetsXyChart{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardGridLayoutWidgetsScorecard{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardGridLayoutWidgetsText{}
	}
	if err := extractDashboardGridLayoutWidgetsTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardGridLayoutWidgetsBlank{}
	}
	if err := extractDashboardGridLayoutWidgetsBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardGridLayoutWidgetsLogsPanel{}
	}
	if err := extractDashboardGridLayoutWidgetsLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardGridLayoutWidgetsXyChartXAxis{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardGridLayoutWidgetsXyChartYAxis{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardGridLayoutWidgetsXyChartChartOptions{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartThresholdsFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartThresholds) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartXAxisFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartXAxis) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartYAxisFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartYAxis) error {
	return nil
}
func extractDashboardGridLayoutWidgetsXyChartChartOptionsFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartChartOptions) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardGridLayoutWidgetsScorecardGaugeView{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardGridLayoutWidgetsScorecardSparkChartView{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardGaugeViewFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardGaugeView) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardSparkChartViewFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardSparkChartView) error {
	return nil
}
func extractDashboardGridLayoutWidgetsScorecardThresholdsFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardThresholds) error {
	return nil
}
func extractDashboardGridLayoutWidgetsTextFields(r *Dashboard, o *DashboardGridLayoutWidgetsText) error {
	return nil
}
func extractDashboardGridLayoutWidgetsBlankFields(r *Dashboard, o *DashboardGridLayoutWidgetsBlank) error {
	return nil
}
func extractDashboardGridLayoutWidgetsLogsPanelFields(r *Dashboard, o *DashboardGridLayoutWidgetsLogsPanel) error {
	return nil
}
func extractDashboardMosaicLayoutFields(r *Dashboard, o *DashboardMosaicLayout) error {
	return nil
}
func extractDashboardMosaicLayoutTilesFields(r *Dashboard, o *DashboardMosaicLayoutTiles) error {
	vWidget := o.Widget
	if vWidget == nil {
		// note: explicitly not the empty object.
		vWidget = &DashboardMosaicLayoutTilesWidget{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetFields(r, vWidget); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vWidget) {
		o.Widget = vWidget
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidget) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardMosaicLayoutTilesWidgetXyChart{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardMosaicLayoutTilesWidgetScorecard{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardMosaicLayoutTilesWidgetText{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardMosaicLayoutTilesWidgetBlank{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardMosaicLayoutTilesWidgetLogsPanel{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardMosaicLayoutTilesWidgetXyChartXAxis{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardMosaicLayoutTilesWidgetXyChartYAxis{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartThresholdsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartThresholds) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartXAxisFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartXAxis) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartYAxisFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartYAxis) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetXyChartChartOptionsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartChartOptions) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardGaugeViewFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardGaugeView) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetScorecardThresholdsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardThresholds) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetTextFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetText) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetBlankFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetBlank) error {
	return nil
}
func extractDashboardMosaicLayoutTilesWidgetLogsPanelFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetLogsPanel) error {
	return nil
}
func extractDashboardRowLayoutFields(r *Dashboard, o *DashboardRowLayout) error {
	return nil
}
func extractDashboardRowLayoutRowsFields(r *Dashboard, o *DashboardRowLayoutRows) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgets) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardRowLayoutRowsWidgetsXyChart{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardRowLayoutRowsWidgetsScorecard{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardRowLayoutRowsWidgetsText{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardRowLayoutRowsWidgetsBlank{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardRowLayoutRowsWidgetsLogsPanel{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardRowLayoutRowsWidgetsXyChartXAxis{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardRowLayoutRowsWidgetsXyChartYAxis{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardRowLayoutRowsWidgetsXyChartChartOptions{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartThresholdsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartThresholds) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartXAxisFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartXAxis) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartYAxisFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartYAxis) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsXyChartChartOptionsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartChartOptions) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardRowLayoutRowsWidgetsScorecardGaugeView{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardGaugeViewFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardGaugeView) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardSparkChartViewFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardSparkChartView) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsScorecardThresholdsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardThresholds) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsTextFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsText) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsBlankFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsBlank) error {
	return nil
}
func extractDashboardRowLayoutRowsWidgetsLogsPanelFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsLogsPanel) error {
	return nil
}
func extractDashboardColumnLayoutFields(r *Dashboard, o *DashboardColumnLayout) error {
	return nil
}
func extractDashboardColumnLayoutColumnsFields(r *Dashboard, o *DashboardColumnLayoutColumns) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgets) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardColumnLayoutColumnsWidgetsXyChart{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardColumnLayoutColumnsWidgetsScorecard{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardColumnLayoutColumnsWidgetsText{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardColumnLayoutColumnsWidgetsBlank{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardColumnLayoutColumnsWidgetsLogsPanel{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartThresholdsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartThresholds) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartXAxisFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartXAxis) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartYAxisFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartYAxis) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsScorecardThresholdsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardThresholds) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsTextFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsText) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsBlankFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsBlank) error {
	return nil
}
func extractDashboardColumnLayoutColumnsWidgetsLogsPanelFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsLogsPanel) error {
	return nil
}

func postReadExtractDashboardFields(r *Dashboard) error {
	vGridLayout := r.GridLayout
	if vGridLayout == nil {
		// note: explicitly not the empty object.
		vGridLayout = &DashboardGridLayout{}
	}
	if err := postReadExtractDashboardGridLayoutFields(r, vGridLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGridLayout) {
		r.GridLayout = vGridLayout
	}
	vMosaicLayout := r.MosaicLayout
	if vMosaicLayout == nil {
		// note: explicitly not the empty object.
		vMosaicLayout = &DashboardMosaicLayout{}
	}
	if err := postReadExtractDashboardMosaicLayoutFields(r, vMosaicLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vMosaicLayout) {
		r.MosaicLayout = vMosaicLayout
	}
	vRowLayout := r.RowLayout
	if vRowLayout == nil {
		// note: explicitly not the empty object.
		vRowLayout = &DashboardRowLayout{}
	}
	if err := postReadExtractDashboardRowLayoutFields(r, vRowLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vRowLayout) {
		r.RowLayout = vRowLayout
	}
	vColumnLayout := r.ColumnLayout
	if vColumnLayout == nil {
		// note: explicitly not the empty object.
		vColumnLayout = &DashboardColumnLayout{}
	}
	if err := postReadExtractDashboardColumnLayoutFields(r, vColumnLayout); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vColumnLayout) {
		r.ColumnLayout = vColumnLayout
	}
	return nil
}
func postReadExtractDashboardGridLayoutFields(r *Dashboard, o *DashboardGridLayout) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsFields(r *Dashboard, o *DashboardGridLayoutWidgets) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardGridLayoutWidgetsXyChart{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardGridLayoutWidgetsScorecard{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardGridLayoutWidgetsText{}
	}
	if err := extractDashboardGridLayoutWidgetsTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardGridLayoutWidgetsBlank{}
	}
	if err := extractDashboardGridLayoutWidgetsBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardGridLayoutWidgetsLogsPanel{}
	}
	if err := extractDashboardGridLayoutWidgetsLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardGridLayoutWidgetsXyChartXAxis{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardGridLayoutWidgetsXyChartYAxis{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardGridLayoutWidgetsXyChartChartOptions{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartThresholdsFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartThresholds) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartXAxisFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartXAxis) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartYAxisFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartYAxis) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsXyChartChartOptionsFields(r *Dashboard, o *DashboardGridLayoutWidgetsXyChartChartOptions) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardGridLayoutWidgetsScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardGridLayoutWidgetsScorecardGaugeView{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardGridLayoutWidgetsScorecardSparkChartView{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardGaugeViewFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardGaugeView) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardSparkChartViewFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardSparkChartView) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsScorecardThresholdsFields(r *Dashboard, o *DashboardGridLayoutWidgetsScorecardThresholds) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsTextFields(r *Dashboard, o *DashboardGridLayoutWidgetsText) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsBlankFields(r *Dashboard, o *DashboardGridLayoutWidgetsBlank) error {
	return nil
}
func postReadExtractDashboardGridLayoutWidgetsLogsPanelFields(r *Dashboard, o *DashboardGridLayoutWidgetsLogsPanel) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutFields(r *Dashboard, o *DashboardMosaicLayout) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesFields(r *Dashboard, o *DashboardMosaicLayoutTiles) error {
	vWidget := o.Widget
	if vWidget == nil {
		// note: explicitly not the empty object.
		vWidget = &DashboardMosaicLayoutTilesWidget{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetFields(r, vWidget); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vWidget) {
		o.Widget = vWidget
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidget) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardMosaicLayoutTilesWidgetXyChart{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardMosaicLayoutTilesWidgetScorecard{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardMosaicLayoutTilesWidgetText{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardMosaicLayoutTilesWidgetBlank{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardMosaicLayoutTilesWidgetLogsPanel{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardMosaicLayoutTilesWidgetXyChartXAxis{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardMosaicLayoutTilesWidgetXyChartYAxis{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardMosaicLayoutTilesWidgetXyChartChartOptions{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartThresholdsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartThresholds) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartXAxisFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartXAxis) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartYAxisFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartYAxis) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetXyChartChartOptionsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetXyChartChartOptions) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardMosaicLayoutTilesWidgetScorecardGaugeView{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardMosaicLayoutTilesWidgetScorecardSparkChartView{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardGaugeViewFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardGaugeView) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardSparkChartViewFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardSparkChartView) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetScorecardThresholdsFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetScorecardThresholds) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetTextFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetText) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetBlankFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetBlank) error {
	return nil
}
func postReadExtractDashboardMosaicLayoutTilesWidgetLogsPanelFields(r *Dashboard, o *DashboardMosaicLayoutTilesWidgetLogsPanel) error {
	return nil
}
func postReadExtractDashboardRowLayoutFields(r *Dashboard, o *DashboardRowLayout) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsFields(r *Dashboard, o *DashboardRowLayoutRows) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgets) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardRowLayoutRowsWidgetsXyChart{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardRowLayoutRowsWidgetsScorecard{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardRowLayoutRowsWidgetsText{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardRowLayoutRowsWidgetsBlank{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardRowLayoutRowsWidgetsLogsPanel{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardRowLayoutRowsWidgetsXyChartXAxis{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardRowLayoutRowsWidgetsXyChartYAxis{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardRowLayoutRowsWidgetsXyChartChartOptions{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartThresholdsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartThresholds) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartXAxisFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartXAxis) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartYAxisFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartYAxis) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsXyChartChartOptionsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsXyChartChartOptions) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardRowLayoutRowsWidgetsScorecardGaugeView{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardRowLayoutRowsWidgetsScorecardSparkChartView{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardGaugeViewFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardGaugeView) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardSparkChartViewFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardSparkChartView) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsScorecardThresholdsFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsScorecardThresholds) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsTextFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsText) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsBlankFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsBlank) error {
	return nil
}
func postReadExtractDashboardRowLayoutRowsWidgetsLogsPanelFields(r *Dashboard, o *DashboardRowLayoutRowsWidgetsLogsPanel) error {
	return nil
}
func postReadExtractDashboardColumnLayoutFields(r *Dashboard, o *DashboardColumnLayout) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsFields(r *Dashboard, o *DashboardColumnLayoutColumns) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgets) error {
	vXyChart := o.XyChart
	if vXyChart == nil {
		// note: explicitly not the empty object.
		vXyChart = &DashboardColumnLayoutColumnsWidgetsXyChart{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartFields(r, vXyChart); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXyChart) {
		o.XyChart = vXyChart
	}
	vScorecard := o.Scorecard
	if vScorecard == nil {
		// note: explicitly not the empty object.
		vScorecard = &DashboardColumnLayoutColumnsWidgetsScorecard{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardFields(r, vScorecard); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vScorecard) {
		o.Scorecard = vScorecard
	}
	vText := o.Text
	if vText == nil {
		// note: explicitly not the empty object.
		vText = &DashboardColumnLayoutColumnsWidgetsText{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsTextFields(r, vText); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vText) {
		o.Text = vText
	}
	vBlank := o.Blank
	if vBlank == nil {
		// note: explicitly not the empty object.
		vBlank = &DashboardColumnLayoutColumnsWidgetsBlank{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsBlankFields(r, vBlank); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vBlank) {
		o.Blank = vBlank
	}
	vLogsPanel := o.LogsPanel
	if vLogsPanel == nil {
		// note: explicitly not the empty object.
		vLogsPanel = &DashboardColumnLayoutColumnsWidgetsLogsPanel{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsLogsPanelFields(r, vLogsPanel); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vLogsPanel) {
		o.LogsPanel = vLogsPanel
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChart) error {
	vXAxis := o.XAxis
	if vXAxis == nil {
		// note: explicitly not the empty object.
		vXAxis = &DashboardColumnLayoutColumnsWidgetsXyChartXAxis{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartXAxisFields(r, vXAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vXAxis) {
		o.XAxis = vXAxis
	}
	vYAxis := o.YAxis
	if vYAxis == nil {
		// note: explicitly not the empty object.
		vYAxis = &DashboardColumnLayoutColumnsWidgetsXyChartYAxis{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartYAxisFields(r, vYAxis); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vYAxis) {
		o.YAxis = vYAxis
	}
	vChartOptions := o.ChartOptions
	if vChartOptions == nil {
		// note: explicitly not the empty object.
		vChartOptions = &DashboardColumnLayoutColumnsWidgetsXyChartChartOptions{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsFields(r, vChartOptions); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vChartOptions) {
		o.ChartOptions = vChartOptions
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSets) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartThresholdsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartThresholds) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartXAxisFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartXAxis) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartYAxisFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartYAxis) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsXyChartChartOptionsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsXyChartChartOptions) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecard) error {
	vTimeSeriesQuery := o.TimeSeriesQuery
	if vTimeSeriesQuery == nil {
		// note: explicitly not the empty object.
		vTimeSeriesQuery = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryFields(r, vTimeSeriesQuery); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesQuery) {
		o.TimeSeriesQuery = vTimeSeriesQuery
	}
	vGaugeView := o.GaugeView
	if vGaugeView == nil {
		// note: explicitly not the empty object.
		vGaugeView = &DashboardColumnLayoutColumnsWidgetsScorecardGaugeView{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewFields(r, vGaugeView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vGaugeView) {
		o.GaugeView = vGaugeView
	}
	vSparkChartView := o.SparkChartView
	if vSparkChartView == nil {
		// note: explicitly not the empty object.
		vSparkChartView = &DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewFields(r, vSparkChartView); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSparkChartView) {
		o.SparkChartView = vSparkChartView
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery) error {
	vTimeSeriesFilter := o.TimeSeriesFilter
	if vTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r, vTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilter) {
		o.TimeSeriesFilter = vTimeSeriesFilter
	}
	vTimeSeriesFilterRatio := o.TimeSeriesFilterRatio
	if vTimeSeriesFilterRatio == nil {
		// note: explicitly not the empty object.
		vTimeSeriesFilterRatio = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r, vTimeSeriesFilterRatio); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vTimeSeriesFilterRatio) {
		o.TimeSeriesFilterRatio = vTimeSeriesFilterRatio
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio) error {
	vNumerator := o.Numerator
	if vNumerator == nil {
		// note: explicitly not the empty object.
		vNumerator = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r, vNumerator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vNumerator) {
		o.Numerator = vNumerator
	}
	vDenominator := o.Denominator
	if vDenominator == nil {
		// note: explicitly not the empty object.
		vDenominator = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r, vDenominator); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vDenominator) {
		o.Denominator = vDenominator
	}
	vSecondaryAggregation := o.SecondaryAggregation
	if vSecondaryAggregation == nil {
		// note: explicitly not the empty object.
		vSecondaryAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r, vSecondaryAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vSecondaryAggregation) {
		o.SecondaryAggregation = vSecondaryAggregation
	}
	vPickTimeSeriesFilter := o.PickTimeSeriesFilter
	if vPickTimeSeriesFilter == nil {
		// note: explicitly not the empty object.
		vPickTimeSeriesFilter = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r, vPickTimeSeriesFilter); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vPickTimeSeriesFilter) {
		o.PickTimeSeriesFilter = vPickTimeSeriesFilter
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator) error {
	vAggregation := o.Aggregation
	if vAggregation == nil {
		// note: explicitly not the empty object.
		vAggregation = &DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation{}
	}
	if err := extractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r, vAggregation); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(vAggregation) {
		o.Aggregation = vAggregation
	}
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregationFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilterFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardGaugeViewFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardGaugeView) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardSparkChartViewFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardSparkChartView) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsScorecardThresholdsFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsScorecardThresholds) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsTextFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsText) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsBlankFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsBlank) error {
	return nil
}
func postReadExtractDashboardColumnLayoutColumnsWidgetsLogsPanelFields(r *Dashboard, o *DashboardColumnLayoutColumnsWidgetsLogsPanel) error {
	return nil
}
