// Copyright IBM Corp. 2021 All Rights Reserved.
// Licensed under the Mozilla Public License v2.0

package eventnotification

import (
	"context"
	"fmt"
	"log"

	"github.com/IBM-Cloud/terraform-provider-ibm/ibm/conns"
	"github.com/IBM-Cloud/terraform-provider-ibm/ibm/flex"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	en "github.com/IBM/event-notifications-go-admin-sdk/eventnotificationsv1"
)

func DataSourceIBMEnTopic() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceIBMEnTopicRead,

		Schema: map[string]*schema.Schema{
			"instance_guid": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Unique identifier for IBM Cloud Event Notifications instance.",
			},
			"topic_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Unique identifier for Topic.",
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Name of the topic.",
			},
			"description": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Description of the topic.",
			},
			"source_count": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Number of sources.",
			},
			"sources": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "List of sources.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of the source.",
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Name of the source.",
						},
						"rules": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "List of rules.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: "Whether the rule is enabled or not.",
									},
									"event_type_filter": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Event type filter.",
									},
									"notification_filter": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Notification filter.",
									},
									"event_schedule_filter": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "Event schedule filter attributes.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"starts_at": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "event schedule start time.",
												},
												"ends_at": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "event schedule end time.",
												},
												"expression": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "cron schedule expression.",
												},
											},
										},
									},
									"updated_at": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Last time the topic was updated.",
									},
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Autogenerated rule ID.",
									},
								},
							},
						},
					},
				},
			},
			"subscription_count": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Number of subscriptions.",
			},
			"subscriptions": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "List of subscriptions.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Subscription ID.",
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Subscription name.",
						},
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Subscription description.",
						},
						"destination_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The type of destination.",
						},
						"destination_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The destination ID.",
						},
						"topic_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Topic ID.",
						},
						"updated_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Last updated time.",
						},
					},
				},
			},
			"updated_at": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Last time the topic was updated.",
			},
		},
	}
}

func dataSourceIBMEnTopicRead(context context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	enClient, err := meta.(conns.ClientSession).EventNotificationsApiV1()
	if err != nil {
		tfErr := flex.TerraformErrorf(err, err.Error(), "(Data) ibm_en_topic", "read")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	options := &en.GetTopicOptions{}

	options.SetInstanceID(d.Get("instance_guid").(string))
	options.SetID(d.Get("topic_id").(string))

	result, _, err := enClient.GetTopicWithContext(context, options)

	if err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("GetTopicWithContext failed: %s", err.Error()), "(Data) ibm_en_topic", "read")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	d.SetId(fmt.Sprintf("%s/%s", *options.InstanceID, *options.ID))

	d.Set("topic_id", options.ID)

	if err = d.Set("name", result.Name); err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Error setting name: %s", err), "(Data) ibm_en_topic", "read")
		return tfErr.GetDiag()
	}

	if result.Description != nil {
		if err = d.Set("description", result.Description); err != nil {
			tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Error setting description: %s", err), "(Data) ibm_en_topic", "read")
			return tfErr.GetDiag()
		}
	}

	if err = d.Set("updated_at", result.UpdatedAt); err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Error setting updated_at: %s", err), "(Data) ibm_en_topic", "read")
		return tfErr.GetDiag()
	}

	if err = d.Set("source_count", flex.IntValue(result.SourceCount)); err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Error setting source_count: %s", err), "(Data) ibm_en_topic", "read")
		return tfErr.GetDiag()
	}

	if err = d.Set("subscription_count", flex.IntValue(result.SubscriptionCount)); err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Error setting subscription_count: %s", err), "(Data) ibm_en_topic", "read")
		return tfErr.GetDiag()
	}

	if result.Sources != nil {
		err = d.Set("sources", dataSourceTopicFlattenSources(result.Sources))
		if err != nil {
			return diag.FromErr(fmt.Errorf("[ERROR] Error setting sources %s", err))
		}
	}

	if result.Subscriptions != nil {
		err = d.Set("subscriptions", enFlattenSubscriptions(result.Subscriptions))
		if err != nil {
			tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Error setting subscriptions: %s", err), "(Data) ibm_en_topic", "read")
			return tfErr.GetDiag()
		}
	}

	return nil
}

func dataSourceTopicFlattenSources(result []en.SourcesListItems) (sources []map[string]interface{}) {
	sources = []map[string]interface{}{}

	for _, sourcesItem := range result {
		sources = append(sources, dataSourceTopicSourcesToMap(sourcesItem))
	}

	return sources
}

func dataSourceTopicSourcesToMap(sourcesItem en.SourcesListItems) (sourcesMap map[string]interface{}) {
	sourcesMap = map[string]interface{}{}

	if sourcesItem.ID != nil {
		sourcesMap["id"] = sourcesItem.ID
	}
	if sourcesItem.Name != nil {
		sourcesMap["name"] = sourcesItem.Name
	}

	if sourcesItem.Rules != nil {
		rulesList := []map[string]interface{}{}
		for _, rulesItem := range sourcesItem.Rules {
			rulesList = append(rulesList, enRulesToMap(rulesItem))
		}
		sourcesMap["rules"] = rulesList
	}

	return sourcesMap
}

func enRulesToMap(rulesItem en.RulesGet) (rulesMap map[string]interface{}) {
	rulesMap = map[string]interface{}{}

	if rulesItem.ID != nil {
		rulesMap["id"] = rulesItem.ID
	}

	if rulesItem.Enabled != nil {
		rulesMap["enabled"] = rulesItem.Enabled
	}

	if rulesItem.EventTypeFilter != nil {
		rulesMap["event_type_filter"] = rulesItem.EventTypeFilter
	}

	if rulesItem.NotificationFilter != nil {
		rulesMap["notification_filter"] = rulesItem.NotificationFilter
	}

	if rulesItem.EventScheduleFilter != nil {
		eventScheduleFilterMap, err := dataSourceIBMEnTopicsEventScheduleFilterAttributesToMap(rulesItem.EventScheduleFilter)
		if err != nil {
			return rulesMap
		}
		rulesMap["event_schedule_filter"] = []map[string]interface{}{eventScheduleFilterMap}
	}

	if rulesItem.UpdatedAt != nil {
		rulesMap["updated_at"] = rulesItem.UpdatedAt
	}

	return rulesMap
}

func dataSourceIBMEnTopicsEventScheduleFilterAttributesToMap(model *en.EventScheduleFilterAttributes) (map[string]interface{}, error) {
	modelMap := make(map[string]interface{})
	if model.StartsAt != nil {
		modelMap["starts_at"] = model.StartsAt.String()
	}
	if model.EndsAt != nil {
		modelMap["ends_at"] = model.EndsAt.String()
	}
	if model.Expression != nil {
		modelMap["expression"] = model.Expression
	}
	return modelMap, nil
}

func enFlattenSubscriptions(subscriptionList []en.SubscriptionListItem) (subscriptions []map[string]interface{}) {
	subscriptions = []map[string]interface{}{}

	for _, subscription := range subscriptionList {
		subscriptions = append(subscriptions, enSubscriptionsToMap(subscription))
	}

	return subscriptions
}

func enSubscriptionsToMap(subscription en.SubscriptionListItem) (subscriptionsMap map[string]interface{}) {
	subscriptionsMap = map[string]interface{}{}

	if subscription.ID != nil {
		subscriptionsMap["id"] = subscription.ID
	}

	if subscription.Name != nil {
		subscriptionsMap["name"] = subscription.Name
	}

	if subscription.Description != nil {
		subscriptionsMap["description"] = subscription.Description
	}

	if subscription.UpdatedAt != nil {
		subscriptionsMap["updated_at"] = subscription.UpdatedAt.String()
	}

	if subscription.DestinationType != nil {
		subscriptionsMap["destination_type"] = subscription.DestinationType
	}

	if subscription.DestinationID != nil {
		subscriptionsMap["destination_id"] = subscription.DestinationID
	}

	if subscription.TopicID != nil {
		subscriptionsMap["topic_id"] = subscription.TopicID
	}

	return subscriptionsMap
}
