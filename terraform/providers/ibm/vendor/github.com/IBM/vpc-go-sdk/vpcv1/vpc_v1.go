/**
 * (C) Copyright IBM Corp. 2021, 2022, 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.78.0-67aec9b7-20230818-174940
 */

// Package vpcv1 : Operations and models for the VpcV1 service
package vpcv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/vpc-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// VpcV1 : The IBM Cloud Virtual Private Cloud (VPC) API can be used to programmatically provision and manage virtual
// server instances, along with subnets, volumes, load balancers, and more.
//
// API Version: 2023-10-18
type VpcV1 struct {
	Service *core.BaseService

	// The infrastructure generation. For the API behavior documented here, specify
	// `2`.
	generation *int64

	// The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between `2023-10-10`
	// and `2023-10-18`.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.iaas.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "vpc"

// VpcV1Options : Service options
type VpcV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between `2023-10-10`
	// and `2023-10-18`.
	Version *string
}

// NewVpcV1UsingExternalConfig : constructs an instance of VpcV1 with passed in options and external configuration.
func NewVpcV1UsingExternalConfig(options *VpcV1Options) (vpc *VpcV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	vpc, err = NewVpcV1(options)
	if err != nil {
		return
	}

	err = vpc.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = vpc.Service.SetServiceURL(options.URL)
	}
	return
}

// NewVpcV1 : constructs an instance of VpcV1 with passed in options.
func NewVpcV1(options *VpcV1Options) (service *VpcV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	if options.Version == nil {
		options.Version = core.StringPtr("2023-10-17")
	}

	service = &VpcV1{
		Service:    baseService,
		generation: core.Int64Ptr(2),
		Version:    options.Version,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "vpc" suitable for processing requests.
func (vpc *VpcV1) Clone() *VpcV1 {
	if core.IsNil(vpc) {
		return nil
	}
	clone := *vpc
	clone.Service = vpc.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (vpc *VpcV1) SetServiceURL(url string) error {
	return vpc.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (vpc *VpcV1) GetServiceURL() string {
	return vpc.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (vpc *VpcV1) SetDefaultHeaders(headers http.Header) {
	vpc.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (vpc *VpcV1) SetEnableGzipCompression(enableGzip bool) {
	vpc.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (vpc *VpcV1) GetEnableGzipCompression() bool {
	return vpc.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (vpc *VpcV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	vpc.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (vpc *VpcV1) DisableRetries() {
	vpc.Service.DisableRetries()
}

// ListVpcs : List all VPCs
// This request lists all VPCs in the region. A VPC is a virtual network that belongs to an account and provides logical
// isolation from other networks. A VPC is made up of resources in one or more zones. VPCs are regional, and each VPC
// can contain resources in multiple zones in a region.
func (vpc *VpcV1) ListVpcs(listVpcsOptions *ListVpcsOptions) (result *VPCCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVpcsWithContext(context.Background(), listVpcsOptions)
}

// ListVpcsWithContext is an alternate form of the ListVpcs method which supports a Context parameter
func (vpc *VpcV1) ListVpcsWithContext(ctx context.Context, listVpcsOptions *ListVpcsOptions) (result *VPCCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVpcsOptions, "listVpcsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpcsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpcs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVpcsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVpcsOptions.Start))
	}
	if listVpcsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVpcsOptions.Limit))
	}
	if listVpcsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVpcsOptions.ResourceGroupID))
	}
	if listVpcsOptions.ClassicAccess != nil {
		builder.AddQuery("classic_access", fmt.Sprint(*listVpcsOptions.ClassicAccess))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPCCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPC : Create a VPC
// This request creates a new VPC from a VPC prototype object. The prototype object is structured in the same way as a
// retrieved VPC, and contains the information necessary to create the new VPC.
func (vpc *VpcV1) CreateVPC(createVPCOptions *CreateVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	return vpc.CreateVPCWithContext(context.Background(), createVPCOptions)
}

// CreateVPCWithContext is an alternate form of the CreateVPC method which supports a Context parameter
func (vpc *VpcV1) CreateVPCWithContext(ctx context.Context, createVPCOptions *CreateVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createVPCOptions, "createVPCOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCOptions.AddressPrefixManagement != nil {
		body["address_prefix_management"] = createVPCOptions.AddressPrefixManagement
	}
	if createVPCOptions.ClassicAccess != nil {
		body["classic_access"] = createVPCOptions.ClassicAccess
	}
	if createVPCOptions.Dns != nil {
		body["dns"] = createVPCOptions.Dns
	}
	if createVPCOptions.Name != nil {
		body["name"] = createVPCOptions.Name
	}
	if createVPCOptions.ResourceGroup != nil {
		body["resource_group"] = createVPCOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPC)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPC : Delete a VPC
// This request deletes a VPC. This operation cannot be reversed.
//
// For this request to succeed:
// - Instances, subnets, public gateways, and endpoint gateways must not reside in this VPC
// - The VPC must not be providing DNS resolution for any other VPCs
// - If `dns.enable_hub` is `true`, `dns.resolution_binding_count` must be zero
//
// All security groups and network ACLs associated with the VPC are automatically deleted. All flow log collectors with
// `auto_delete` set to `true` targeting the VPC or any resource in the VPC are automatically deleted.
func (vpc *VpcV1) DeleteVPC(deleteVPCOptions *DeleteVPCOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPCWithContext(context.Background(), deleteVPCOptions)
}

// DeleteVPCWithContext is an alternate form of the DeleteVPC method which supports a Context parameter
func (vpc *VpcV1) DeleteVPCWithContext(ctx context.Context, deleteVPCOptions *DeleteVPCOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCOptions, "deleteVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCOptions, "deleteVPCOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteVPCOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteVPCOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteVPCOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPC : Retrieve a VPC
// This request retrieves a single VPC specified by the identifier in the URL.
func (vpc *VpcV1) GetVPC(getVPCOptions *GetVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	return vpc.GetVPCWithContext(context.Background(), getVPCOptions)
}

// GetVPCWithContext is an alternate form of the GetVPC method which supports a Context parameter
func (vpc *VpcV1) GetVPCWithContext(ctx context.Context, getVPCOptions *GetVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCOptions, "getVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCOptions, "getVPCOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPCOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPC)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPC : Update a VPC
// This request updates a VPC with the information provided in a VPC patch object. The patch object is structured in the
// same way as a retrieved VPC and needs to contain only the information to be updated.
func (vpc *VpcV1) UpdateVPC(updateVPCOptions *UpdateVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPCWithContext(context.Background(), updateVPCOptions)
}

// UpdateVPCWithContext is an alternate form of the UpdateVPC method which supports a Context parameter
func (vpc *VpcV1) UpdateVPCWithContext(ctx context.Context, updateVPCOptions *UpdateVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCOptions, "updateVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCOptions, "updateVPCOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateVPCOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateVPCOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateVPCOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPCOptions.VPCPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPC)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetVPCDefaultNetworkACL : Retrieve a VPC's default network ACL
// This request retrieves the default network ACL for the VPC specified by the identifier in the URL. The default
// network ACL is applied to any new subnets in the VPC which do not specify a network ACL.
func (vpc *VpcV1) GetVPCDefaultNetworkACL(getVPCDefaultNetworkACLOptions *GetVPCDefaultNetworkACLOptions) (result *DefaultNetworkACL, response *core.DetailedResponse, err error) {
	return vpc.GetVPCDefaultNetworkACLWithContext(context.Background(), getVPCDefaultNetworkACLOptions)
}

// GetVPCDefaultNetworkACLWithContext is an alternate form of the GetVPCDefaultNetworkACL method which supports a Context parameter
func (vpc *VpcV1) GetVPCDefaultNetworkACLWithContext(ctx context.Context, getVPCDefaultNetworkACLOptions *GetVPCDefaultNetworkACLOptions) (result *DefaultNetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDefaultNetworkACLOptions, "getVPCDefaultNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDefaultNetworkACLOptions, "getVPCDefaultNetworkACLOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPCDefaultNetworkACLOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{id}/default_network_acl`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDefaultNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDefaultNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultNetworkACL)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetVPCDefaultRoutingTable : Retrieve a VPC's default routing table
// This request retrieves the default routing table for the VPC specified by the identifier in the URL. The default
// routing table is associated with any subnets in the VPC which have not been explicitly associated with another
// routing table.
func (vpc *VpcV1) GetVPCDefaultRoutingTable(getVPCDefaultRoutingTableOptions *GetVPCDefaultRoutingTableOptions) (result *DefaultRoutingTable, response *core.DetailedResponse, err error) {
	return vpc.GetVPCDefaultRoutingTableWithContext(context.Background(), getVPCDefaultRoutingTableOptions)
}

// GetVPCDefaultRoutingTableWithContext is an alternate form of the GetVPCDefaultRoutingTable method which supports a Context parameter
func (vpc *VpcV1) GetVPCDefaultRoutingTableWithContext(ctx context.Context, getVPCDefaultRoutingTableOptions *GetVPCDefaultRoutingTableOptions) (result *DefaultRoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDefaultRoutingTableOptions, "getVPCDefaultRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDefaultRoutingTableOptions, "getVPCDefaultRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPCDefaultRoutingTableOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{id}/default_routing_table`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDefaultRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDefaultRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultRoutingTable)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetVPCDefaultSecurityGroup : Retrieve a VPC's default security group
// This request retrieves the default security group for the VPC specified by the identifier in the URL. Resources
// created in this VPC that allow a security group to be optionally specified will use this security group by default.
func (vpc *VpcV1) GetVPCDefaultSecurityGroup(getVPCDefaultSecurityGroupOptions *GetVPCDefaultSecurityGroupOptions) (result *DefaultSecurityGroup, response *core.DetailedResponse, err error) {
	return vpc.GetVPCDefaultSecurityGroupWithContext(context.Background(), getVPCDefaultSecurityGroupOptions)
}

// GetVPCDefaultSecurityGroupWithContext is an alternate form of the GetVPCDefaultSecurityGroup method which supports a Context parameter
func (vpc *VpcV1) GetVPCDefaultSecurityGroupWithContext(ctx context.Context, getVPCDefaultSecurityGroupOptions *GetVPCDefaultSecurityGroupOptions) (result *DefaultSecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDefaultSecurityGroupOptions, "getVPCDefaultSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDefaultSecurityGroupOptions, "getVPCDefaultSecurityGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPCDefaultSecurityGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{id}/default_security_group`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDefaultSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDefaultSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultSecurityGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPCAddressPrefixes : List all address prefixes for a VPC
// This request lists all address pool prefixes for a VPC.
func (vpc *VpcV1) ListVPCAddressPrefixes(listVPCAddressPrefixesOptions *ListVPCAddressPrefixesOptions) (result *AddressPrefixCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPCAddressPrefixesWithContext(context.Background(), listVPCAddressPrefixesOptions)
}

// ListVPCAddressPrefixesWithContext is an alternate form of the ListVPCAddressPrefixes method which supports a Context parameter
func (vpc *VpcV1) ListVPCAddressPrefixesWithContext(ctx context.Context, listVPCAddressPrefixesOptions *ListVPCAddressPrefixesOptions) (result *AddressPrefixCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCAddressPrefixesOptions, "listVPCAddressPrefixesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCAddressPrefixesOptions, "listVPCAddressPrefixesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *listVPCAddressPrefixesOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/address_prefixes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCAddressPrefixesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCAddressPrefixes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCAddressPrefixesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCAddressPrefixesOptions.Start))
	}
	if listVPCAddressPrefixesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCAddressPrefixesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefixCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPCAddressPrefix : Create an address prefix for a VPC
// This request creates a new prefix from a prefix prototype object. The prototype object is structured in the same way
// as a retrieved prefix, and contains the information necessary to create the new prefix.
func (vpc *VpcV1) CreateVPCAddressPrefix(createVPCAddressPrefixOptions *CreateVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	return vpc.CreateVPCAddressPrefixWithContext(context.Background(), createVPCAddressPrefixOptions)
}

// CreateVPCAddressPrefixWithContext is an alternate form of the CreateVPCAddressPrefix method which supports a Context parameter
func (vpc *VpcV1) CreateVPCAddressPrefixWithContext(ctx context.Context, createVPCAddressPrefixOptions *CreateVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCAddressPrefixOptions, "createVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCAddressPrefixOptions, "createVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *createVPCAddressPrefixOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/address_prefixes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCAddressPrefixOptions.CIDR != nil {
		body["cidr"] = createVPCAddressPrefixOptions.CIDR
	}
	if createVPCAddressPrefixOptions.Zone != nil {
		body["zone"] = createVPCAddressPrefixOptions.Zone
	}
	if createVPCAddressPrefixOptions.IsDefault != nil {
		body["is_default"] = createVPCAddressPrefixOptions.IsDefault
	}
	if createVPCAddressPrefixOptions.Name != nil {
		body["name"] = createVPCAddressPrefixOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefix)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPCAddressPrefix : Delete an address prefix
// This request deletes a prefix. This operation cannot be reversed. The request will fail if any subnets use addresses
// from this prefix.
func (vpc *VpcV1) DeleteVPCAddressPrefix(deleteVPCAddressPrefixOptions *DeleteVPCAddressPrefixOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPCAddressPrefixWithContext(context.Background(), deleteVPCAddressPrefixOptions)
}

// DeleteVPCAddressPrefixWithContext is an alternate form of the DeleteVPCAddressPrefix method which supports a Context parameter
func (vpc *VpcV1) DeleteVPCAddressPrefixWithContext(ctx context.Context, deleteVPCAddressPrefixOptions *DeleteVPCAddressPrefixOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCAddressPrefixOptions, "deleteVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCAddressPrefixOptions, "deleteVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *deleteVPCAddressPrefixOptions.VPCID,
		"id":     *deleteVPCAddressPrefixOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/address_prefixes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCAddressPrefix : Retrieve an address prefix
// This request retrieves a single prefix specified by the identifier in the URL.
func (vpc *VpcV1) GetVPCAddressPrefix(getVPCAddressPrefixOptions *GetVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	return vpc.GetVPCAddressPrefixWithContext(context.Background(), getVPCAddressPrefixOptions)
}

// GetVPCAddressPrefixWithContext is an alternate form of the GetVPCAddressPrefix method which supports a Context parameter
func (vpc *VpcV1) GetVPCAddressPrefixWithContext(ctx context.Context, getVPCAddressPrefixOptions *GetVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCAddressPrefixOptions, "getVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCAddressPrefixOptions, "getVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *getVPCAddressPrefixOptions.VPCID,
		"id":     *getVPCAddressPrefixOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/address_prefixes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefix)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPCAddressPrefix : Update an address prefix
// This request updates a prefix with the information in a provided prefix patch. The prefix patch object is structured
// in the same way as a retrieved prefix and contains only the information to be updated.
func (vpc *VpcV1) UpdateVPCAddressPrefix(updateVPCAddressPrefixOptions *UpdateVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPCAddressPrefixWithContext(context.Background(), updateVPCAddressPrefixOptions)
}

// UpdateVPCAddressPrefixWithContext is an alternate form of the UpdateVPCAddressPrefix method which supports a Context parameter
func (vpc *VpcV1) UpdateVPCAddressPrefixWithContext(ctx context.Context, updateVPCAddressPrefixOptions *UpdateVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCAddressPrefixOptions, "updateVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCAddressPrefixOptions, "updateVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *updateVPCAddressPrefixOptions.VPCID,
		"id":     *updateVPCAddressPrefixOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/address_prefixes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPCAddressPrefixOptions.AddressPrefixPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefix)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPCDnsResolutionBindings : List all DNS resolution bindings for a VPC
// This request lists all DNS resolution bindings for a VPC. A DNS resolution binding represents an association with
// another VPC for centralizing DNS name resolution.
//
// If the VPC specified by the identifier in the URL is a DNS hub VPC (has `dns.enable_hub` set to `true`) then there is
// one binding for each VPC bound to the hub VPC. The endpoint gateways in the bound VPCs can allow (using
// `allow_dns_resolution_binding`) the hub VPC to centralize resolution of their DNS names.
//
// If the VPC specified by the identifier in the URL is not a DNS hub VPC, then there is at most one binding (to a hub
// VPC). The endpoint gateways in the VPC specified by the identifier in the URL can allow (using
// `allow_dns_resolution_binding`) its hub VPC to centralize resolution of their DNS names.
//
// To make use of centralized DNS resolution, a VPC bound to a DNS hub VPC must delegate DNS resolution to its hub VPC
// by setting `dns.resolver.type` to `delegate`.
//
// The bindings will be sorted by their `created_at` property values, with newest bindings first. Bindings with
// identical `created_at` property values will in turn be sorted by ascending `name` property values.
func (vpc *VpcV1) ListVPCDnsResolutionBindings(listVPCDnsResolutionBindingsOptions *ListVPCDnsResolutionBindingsOptions) (result *VpcdnsResolutionBindingCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPCDnsResolutionBindingsWithContext(context.Background(), listVPCDnsResolutionBindingsOptions)
}

// ListVPCDnsResolutionBindingsWithContext is an alternate form of the ListVPCDnsResolutionBindings method which supports a Context parameter
func (vpc *VpcV1) ListVPCDnsResolutionBindingsWithContext(ctx context.Context, listVPCDnsResolutionBindingsOptions *ListVPCDnsResolutionBindingsOptions) (result *VpcdnsResolutionBindingCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCDnsResolutionBindingsOptions, "listVPCDnsResolutionBindingsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCDnsResolutionBindingsOptions, "listVPCDnsResolutionBindingsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *listVPCDnsResolutionBindingsOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/dns_resolution_bindings`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCDnsResolutionBindingsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCDnsResolutionBindings")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCDnsResolutionBindingsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.Sort))
	}
	if listVPCDnsResolutionBindingsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.Start))
	}
	if listVPCDnsResolutionBindingsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.Limit))
	}
	if listVPCDnsResolutionBindingsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.Name))
	}
	if listVPCDnsResolutionBindingsOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.VPCCRN))
	}
	if listVPCDnsResolutionBindingsOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.VPCName))
	}
	if listVPCDnsResolutionBindingsOptions.AccountID != nil {
		builder.AddQuery("account.id", fmt.Sprint(*listVPCDnsResolutionBindingsOptions.AccountID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVpcdnsResolutionBindingCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPCDnsResolutionBinding : Create a DNS resolution binding
// This request creates a new DNS resolution binding from a DNS resolution binding prototype object. The prototype
// object is structured in the same way as a retrieved DNS resolution binding, and contains the information necessary to
// create the new DNS resolution binding.
//
// For this request to succeed, `dns.enable_hub` must be `false` for the VPC specified by the identifier in the URL, and
// the VPC must not already have a DNS resolution binding.
//
// See [About DNS sharing for VPE gateways](/docs/vpc?topic=vpc-hub-spoke-model) for more information.
func (vpc *VpcV1) CreateVPCDnsResolutionBinding(createVPCDnsResolutionBindingOptions *CreateVPCDnsResolutionBindingOptions) (result *VpcdnsResolutionBinding, response *core.DetailedResponse, err error) {
	return vpc.CreateVPCDnsResolutionBindingWithContext(context.Background(), createVPCDnsResolutionBindingOptions)
}

// CreateVPCDnsResolutionBindingWithContext is an alternate form of the CreateVPCDnsResolutionBinding method which supports a Context parameter
func (vpc *VpcV1) CreateVPCDnsResolutionBindingWithContext(ctx context.Context, createVPCDnsResolutionBindingOptions *CreateVPCDnsResolutionBindingOptions) (result *VpcdnsResolutionBinding, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCDnsResolutionBindingOptions, "createVPCDnsResolutionBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCDnsResolutionBindingOptions, "createVPCDnsResolutionBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *createVPCDnsResolutionBindingOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/dns_resolution_bindings`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCDnsResolutionBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCDnsResolutionBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCDnsResolutionBindingOptions.VPC != nil {
		body["vpc"] = createVPCDnsResolutionBindingOptions.VPC
	}
	if createVPCDnsResolutionBindingOptions.Name != nil {
		body["name"] = createVPCDnsResolutionBindingOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVpcdnsResolutionBinding)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPCDnsResolutionBinding : Delete a DNS resolution binding
// This request deletes a DNS resolution binding. This operation cannot be reversed.
//
// A DNS resolution binding for a VPC with `dns.enable_hub` set to `true` cannot be deleted.
func (vpc *VpcV1) DeleteVPCDnsResolutionBinding(deleteVPCDnsResolutionBindingOptions *DeleteVPCDnsResolutionBindingOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPCDnsResolutionBindingWithContext(context.Background(), deleteVPCDnsResolutionBindingOptions)
}

// DeleteVPCDnsResolutionBindingWithContext is an alternate form of the DeleteVPCDnsResolutionBinding method which supports a Context parameter
func (vpc *VpcV1) DeleteVPCDnsResolutionBindingWithContext(ctx context.Context, deleteVPCDnsResolutionBindingOptions *DeleteVPCDnsResolutionBindingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCDnsResolutionBindingOptions, "deleteVPCDnsResolutionBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCDnsResolutionBindingOptions, "deleteVPCDnsResolutionBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *deleteVPCDnsResolutionBindingOptions.VPCID,
		"id":     *deleteVPCDnsResolutionBindingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/dns_resolution_bindings/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCDnsResolutionBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCDnsResolutionBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCDnsResolutionBinding : Retrieve a DNS resolution binding
// This request retrieves a single DNS resolution binding specified by the identifier in the URL.
func (vpc *VpcV1) GetVPCDnsResolutionBinding(getVPCDnsResolutionBindingOptions *GetVPCDnsResolutionBindingOptions) (result *VpcdnsResolutionBinding, response *core.DetailedResponse, err error) {
	return vpc.GetVPCDnsResolutionBindingWithContext(context.Background(), getVPCDnsResolutionBindingOptions)
}

// GetVPCDnsResolutionBindingWithContext is an alternate form of the GetVPCDnsResolutionBinding method which supports a Context parameter
func (vpc *VpcV1) GetVPCDnsResolutionBindingWithContext(ctx context.Context, getVPCDnsResolutionBindingOptions *GetVPCDnsResolutionBindingOptions) (result *VpcdnsResolutionBinding, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDnsResolutionBindingOptions, "getVPCDnsResolutionBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDnsResolutionBindingOptions, "getVPCDnsResolutionBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *getVPCDnsResolutionBindingOptions.VPCID,
		"id":     *getVPCDnsResolutionBindingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/dns_resolution_bindings/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDnsResolutionBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDnsResolutionBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVpcdnsResolutionBinding)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPCDnsResolutionBinding : Update a DNS resolution binding
// This request updates a DNS resolution binding with the information in a provided DNS resolution binding patch. The
// DNS resolution binding patch object is structured in the same way as a retrieved DNS resolution binding and contains
// only the information to be updated.
func (vpc *VpcV1) UpdateVPCDnsResolutionBinding(updateVPCDnsResolutionBindingOptions *UpdateVPCDnsResolutionBindingOptions) (result *VpcdnsResolutionBinding, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPCDnsResolutionBindingWithContext(context.Background(), updateVPCDnsResolutionBindingOptions)
}

// UpdateVPCDnsResolutionBindingWithContext is an alternate form of the UpdateVPCDnsResolutionBinding method which supports a Context parameter
func (vpc *VpcV1) UpdateVPCDnsResolutionBindingWithContext(ctx context.Context, updateVPCDnsResolutionBindingOptions *UpdateVPCDnsResolutionBindingOptions) (result *VpcdnsResolutionBinding, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCDnsResolutionBindingOptions, "updateVPCDnsResolutionBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCDnsResolutionBindingOptions, "updateVPCDnsResolutionBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *updateVPCDnsResolutionBindingOptions.VPCID,
		"id":     *updateVPCDnsResolutionBindingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/dns_resolution_bindings/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCDnsResolutionBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCDnsResolutionBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPCDnsResolutionBindingOptions.VpcdnsResolutionBindingPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVpcdnsResolutionBinding)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPCRoutes : List all routes in a VPC's default routing table
// This request lists all routes in the VPC's default routing table. Each route is zone-specific and directs any packets
// matching its destination CIDR block to a `next_hop` IP address. The most specific route matching a packet's
// destination will be used. If multiple equally-specific routes exist, traffic will be distributed across them.
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) ListVPCRoutes(listVPCRoutesOptions *ListVPCRoutesOptions) (result *RouteCollectionVPCContext, response *core.DetailedResponse, err error) {
	return vpc.ListVPCRoutesWithContext(context.Background(), listVPCRoutesOptions)
}

// ListVPCRoutesWithContext is an alternate form of the ListVPCRoutes method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) ListVPCRoutesWithContext(ctx context.Context, listVPCRoutesOptions *ListVPCRoutesOptions) (result *RouteCollectionVPCContext, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: ListVPCRoutes")
	err = core.ValidateNotNil(listVPCRoutesOptions, "listVPCRoutesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCRoutesOptions, "listVPCRoutesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *listVPCRoutesOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCRoutesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCRoutes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCRoutesOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listVPCRoutesOptions.ZoneName))
	}
	if listVPCRoutesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCRoutesOptions.Start))
	}
	if listVPCRoutesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCRoutesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteCollectionVPCContext)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPCRoute : Create a route in a VPC's default routing table
// This request creates a new route in the VPC's default routing table. The route prototype object is structured in the
// same way as a retrieved route, and contains the information necessary to create the new route. The request will fail
// if the new route will cause a loop.
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) CreateVPCRoute(createVPCRouteOptions *CreateVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	return vpc.CreateVPCRouteWithContext(context.Background(), createVPCRouteOptions)
}

// CreateVPCRouteWithContext is an alternate form of the CreateVPCRoute method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) CreateVPCRouteWithContext(ctx context.Context, createVPCRouteOptions *CreateVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: CreateVPCRoute")
	err = core.ValidateNotNil(createVPCRouteOptions, "createVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCRouteOptions, "createVPCRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *createVPCRouteOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCRouteOptions.Destination != nil {
		body["destination"] = createVPCRouteOptions.Destination
	}
	if createVPCRouteOptions.Zone != nil {
		body["zone"] = createVPCRouteOptions.Zone
	}
	if createVPCRouteOptions.Action != nil {
		body["action"] = createVPCRouteOptions.Action
	}
	if createVPCRouteOptions.Name != nil {
		body["name"] = createVPCRouteOptions.Name
	}
	if createVPCRouteOptions.NextHop != nil {
		body["next_hop"] = createVPCRouteOptions.NextHop
	}
	if createVPCRouteOptions.Priority != nil {
		body["priority"] = createVPCRouteOptions.Priority
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPCRoute : Delete a VPC route
// This request deletes a route. This operation cannot be reversed.
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) DeleteVPCRoute(deleteVPCRouteOptions *DeleteVPCRouteOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPCRouteWithContext(context.Background(), deleteVPCRouteOptions)
}

// DeleteVPCRouteWithContext is an alternate form of the DeleteVPCRoute method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) DeleteVPCRouteWithContext(ctx context.Context, deleteVPCRouteOptions *DeleteVPCRouteOptions) (response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: DeleteVPCRoute")
	err = core.ValidateNotNil(deleteVPCRouteOptions, "deleteVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCRouteOptions, "deleteVPCRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *deleteVPCRouteOptions.VPCID,
		"id":     *deleteVPCRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCRoute : Retrieve a VPC route
// This request retrieves a single route specified by the identifier in the URL.
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) GetVPCRoute(getVPCRouteOptions *GetVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	return vpc.GetVPCRouteWithContext(context.Background(), getVPCRouteOptions)
}

// GetVPCRouteWithContext is an alternate form of the GetVPCRoute method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) GetVPCRouteWithContext(ctx context.Context, getVPCRouteOptions *GetVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: GetVPCRoute")
	err = core.ValidateNotNil(getVPCRouteOptions, "getVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCRouteOptions, "getVPCRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *getVPCRouteOptions.VPCID,
		"id":     *getVPCRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPCRoute : Update a VPC route
// This request updates a route with the information in a provided route patch. The route patch object is structured in
// the same way as a retrieved route and contains only the information to be updated.
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) UpdateVPCRoute(updateVPCRouteOptions *UpdateVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPCRouteWithContext(context.Background(), updateVPCRouteOptions)
}

// UpdateVPCRouteWithContext is an alternate form of the UpdateVPCRoute method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (vpc *VpcV1) UpdateVPCRouteWithContext(ctx context.Context, updateVPCRouteOptions *UpdateVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: UpdateVPCRoute")
	err = core.ValidateNotNil(updateVPCRouteOptions, "updateVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCRouteOptions, "updateVPCRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *updateVPCRouteOptions.VPCID,
		"id":     *updateVPCRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPCRouteOptions.RoutePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPCRoutingTables : List all routing tables for a VPC
// This request lists all routing tables for a VPC. Each subnet in a VPC is associated with a routing table, which
// controls delivery of packets sent on that subnet according to the action of the most specific matching route in the
// table. If multiple equally-specific routes exist, traffic will be distributed across them. If no routes match,
// delivery will be controlled by the system's built-in routes.
func (vpc *VpcV1) ListVPCRoutingTables(listVPCRoutingTablesOptions *ListVPCRoutingTablesOptions) (result *RoutingTableCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPCRoutingTablesWithContext(context.Background(), listVPCRoutingTablesOptions)
}

// ListVPCRoutingTablesWithContext is an alternate form of the ListVPCRoutingTables method which supports a Context parameter
func (vpc *VpcV1) ListVPCRoutingTablesWithContext(ctx context.Context, listVPCRoutingTablesOptions *ListVPCRoutingTablesOptions) (result *RoutingTableCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCRoutingTablesOptions, "listVPCRoutingTablesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCRoutingTablesOptions, "listVPCRoutingTablesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *listVPCRoutingTablesOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCRoutingTablesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCRoutingTables")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCRoutingTablesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCRoutingTablesOptions.Start))
	}
	if listVPCRoutingTablesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCRoutingTablesOptions.Limit))
	}
	if listVPCRoutingTablesOptions.IsDefault != nil {
		builder.AddQuery("is_default", fmt.Sprint(*listVPCRoutingTablesOptions.IsDefault))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTableCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPCRoutingTable : Create a routing table for a VPC
// This request creates a routing table from a routing table prototype object. The prototype object is structured in the
// same way as a retrieved routing table, and contains the information necessary to create the new routing table.
func (vpc *VpcV1) CreateVPCRoutingTable(createVPCRoutingTableOptions *CreateVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	return vpc.CreateVPCRoutingTableWithContext(context.Background(), createVPCRoutingTableOptions)
}

// CreateVPCRoutingTableWithContext is an alternate form of the CreateVPCRoutingTable method which supports a Context parameter
func (vpc *VpcV1) CreateVPCRoutingTableWithContext(ctx context.Context, createVPCRoutingTableOptions *CreateVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCRoutingTableOptions, "createVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCRoutingTableOptions, "createVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *createVPCRoutingTableOptions.VPCID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCRoutingTableOptions.AcceptRoutesFrom != nil {
		body["accept_routes_from"] = createVPCRoutingTableOptions.AcceptRoutesFrom
	}
	if createVPCRoutingTableOptions.Name != nil {
		body["name"] = createVPCRoutingTableOptions.Name
	}
	if createVPCRoutingTableOptions.RouteDirectLinkIngress != nil {
		body["route_direct_link_ingress"] = createVPCRoutingTableOptions.RouteDirectLinkIngress
	}
	if createVPCRoutingTableOptions.RouteInternetIngress != nil {
		body["route_internet_ingress"] = createVPCRoutingTableOptions.RouteInternetIngress
	}
	if createVPCRoutingTableOptions.RouteTransitGatewayIngress != nil {
		body["route_transit_gateway_ingress"] = createVPCRoutingTableOptions.RouteTransitGatewayIngress
	}
	if createVPCRoutingTableOptions.RouteVPCZoneIngress != nil {
		body["route_vpc_zone_ingress"] = createVPCRoutingTableOptions.RouteVPCZoneIngress
	}
	if createVPCRoutingTableOptions.Routes != nil {
		body["routes"] = createVPCRoutingTableOptions.Routes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPCRoutingTable : Delete a VPC routing table
// This request deletes a routing table.  A routing table cannot be deleted if it is associated with any subnets in the
// VPC. Additionally, a VPC's default routing table cannot be deleted. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPCRoutingTable(deleteVPCRoutingTableOptions *DeleteVPCRoutingTableOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPCRoutingTableWithContext(context.Background(), deleteVPCRoutingTableOptions)
}

// DeleteVPCRoutingTableWithContext is an alternate form of the DeleteVPCRoutingTable method which supports a Context parameter
func (vpc *VpcV1) DeleteVPCRoutingTableWithContext(ctx context.Context, deleteVPCRoutingTableOptions *DeleteVPCRoutingTableOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCRoutingTableOptions, "deleteVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCRoutingTableOptions, "deleteVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *deleteVPCRoutingTableOptions.VPCID,
		"id":     *deleteVPCRoutingTableOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteVPCRoutingTableOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteVPCRoutingTableOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCRoutingTable : Retrieve a VPC routing table
// This request retrieves a single routing table specified by the identifier in the URL.
func (vpc *VpcV1) GetVPCRoutingTable(getVPCRoutingTableOptions *GetVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	return vpc.GetVPCRoutingTableWithContext(context.Background(), getVPCRoutingTableOptions)
}

// GetVPCRoutingTableWithContext is an alternate form of the GetVPCRoutingTable method which supports a Context parameter
func (vpc *VpcV1) GetVPCRoutingTableWithContext(ctx context.Context, getVPCRoutingTableOptions *GetVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCRoutingTableOptions, "getVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCRoutingTableOptions, "getVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *getVPCRoutingTableOptions.VPCID,
		"id":     *getVPCRoutingTableOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPCRoutingTable : Update a VPC routing table
// This request updates a routing table with the information in a provided routing table patch. The patch object is
// structured in the same way as a retrieved table and contains only the information to be updated.
func (vpc *VpcV1) UpdateVPCRoutingTable(updateVPCRoutingTableOptions *UpdateVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPCRoutingTableWithContext(context.Background(), updateVPCRoutingTableOptions)
}

// UpdateVPCRoutingTableWithContext is an alternate form of the UpdateVPCRoutingTable method which supports a Context parameter
func (vpc *VpcV1) UpdateVPCRoutingTableWithContext(ctx context.Context, updateVPCRoutingTableOptions *UpdateVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCRoutingTableOptions, "updateVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCRoutingTableOptions, "updateVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id": *updateVPCRoutingTableOptions.VPCID,
		"id":     *updateVPCRoutingTableOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateVPCRoutingTableOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateVPCRoutingTableOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPCRoutingTableOptions.RoutingTablePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPCRoutingTableRoutes : List all routes in a VPC routing table
// This request lists all routes in a VPC routing table. If subnets are associated with this routing table, delivery of
// packets sent on a subnet is performed according to the action of the most specific matching route in the table
// (provided the subnet and route are in the same zone). If multiple equally-specific routes exist, the route with the
// highest priority will be used. If two matching routes have the same destination and priority, traffic will be
// distributed between them. If no routes match, delivery will be controlled by the system's built-in routes.
func (vpc *VpcV1) ListVPCRoutingTableRoutes(listVPCRoutingTableRoutesOptions *ListVPCRoutingTableRoutesOptions) (result *RouteCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPCRoutingTableRoutesWithContext(context.Background(), listVPCRoutingTableRoutesOptions)
}

// ListVPCRoutingTableRoutesWithContext is an alternate form of the ListVPCRoutingTableRoutes method which supports a Context parameter
func (vpc *VpcV1) ListVPCRoutingTableRoutesWithContext(ctx context.Context, listVPCRoutingTableRoutesOptions *ListVPCRoutingTableRoutesOptions) (result *RouteCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCRoutingTableRoutesOptions, "listVPCRoutingTableRoutesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCRoutingTableRoutesOptions, "listVPCRoutingTableRoutesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id":           *listVPCRoutingTableRoutesOptions.VPCID,
		"routing_table_id": *listVPCRoutingTableRoutesOptions.RoutingTableID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCRoutingTableRoutesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCRoutingTableRoutes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCRoutingTableRoutesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCRoutingTableRoutesOptions.Start))
	}
	if listVPCRoutingTableRoutesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCRoutingTableRoutesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPCRoutingTableRoute : Create a route in a VPC routing table
// This request creates a new VPC route from a VPC route prototype object. The prototype object is structured in the
// same way as a retrieved VPC route and contains the information necessary to create the route.
func (vpc *VpcV1) CreateVPCRoutingTableRoute(createVPCRoutingTableRouteOptions *CreateVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	return vpc.CreateVPCRoutingTableRouteWithContext(context.Background(), createVPCRoutingTableRouteOptions)
}

// CreateVPCRoutingTableRouteWithContext is an alternate form of the CreateVPCRoutingTableRoute method which supports a Context parameter
func (vpc *VpcV1) CreateVPCRoutingTableRouteWithContext(ctx context.Context, createVPCRoutingTableRouteOptions *CreateVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCRoutingTableRouteOptions, "createVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCRoutingTableRouteOptions, "createVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id":           *createVPCRoutingTableRouteOptions.VPCID,
		"routing_table_id": *createVPCRoutingTableRouteOptions.RoutingTableID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCRoutingTableRouteOptions.Destination != nil {
		body["destination"] = createVPCRoutingTableRouteOptions.Destination
	}
	if createVPCRoutingTableRouteOptions.Zone != nil {
		body["zone"] = createVPCRoutingTableRouteOptions.Zone
	}
	if createVPCRoutingTableRouteOptions.Action != nil {
		body["action"] = createVPCRoutingTableRouteOptions.Action
	}
	if createVPCRoutingTableRouteOptions.Name != nil {
		body["name"] = createVPCRoutingTableRouteOptions.Name
	}
	if createVPCRoutingTableRouteOptions.NextHop != nil {
		body["next_hop"] = createVPCRoutingTableRouteOptions.NextHop
	}
	if createVPCRoutingTableRouteOptions.Priority != nil {
		body["priority"] = createVPCRoutingTableRouteOptions.Priority
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPCRoutingTableRoute : Delete a VPC routing table route
// This request deletes a VPC route. This operation cannot be reversed. Only VPC routes with an `origin` of `user` are
// allowed to be deleted.
func (vpc *VpcV1) DeleteVPCRoutingTableRoute(deleteVPCRoutingTableRouteOptions *DeleteVPCRoutingTableRouteOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPCRoutingTableRouteWithContext(context.Background(), deleteVPCRoutingTableRouteOptions)
}

// DeleteVPCRoutingTableRouteWithContext is an alternate form of the DeleteVPCRoutingTableRoute method which supports a Context parameter
func (vpc *VpcV1) DeleteVPCRoutingTableRouteWithContext(ctx context.Context, deleteVPCRoutingTableRouteOptions *DeleteVPCRoutingTableRouteOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCRoutingTableRouteOptions, "deleteVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCRoutingTableRouteOptions, "deleteVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id":           *deleteVPCRoutingTableRouteOptions.VPCID,
		"routing_table_id": *deleteVPCRoutingTableRouteOptions.RoutingTableID,
		"id":               *deleteVPCRoutingTableRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCRoutingTableRoute : Retrieve a VPC routing table route
// This request retrieves a single VPC route specified by the identifier in the URL path.
func (vpc *VpcV1) GetVPCRoutingTableRoute(getVPCRoutingTableRouteOptions *GetVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	return vpc.GetVPCRoutingTableRouteWithContext(context.Background(), getVPCRoutingTableRouteOptions)
}

// GetVPCRoutingTableRouteWithContext is an alternate form of the GetVPCRoutingTableRoute method which supports a Context parameter
func (vpc *VpcV1) GetVPCRoutingTableRouteWithContext(ctx context.Context, getVPCRoutingTableRouteOptions *GetVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCRoutingTableRouteOptions, "getVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCRoutingTableRouteOptions, "getVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id":           *getVPCRoutingTableRouteOptions.VPCID,
		"routing_table_id": *getVPCRoutingTableRouteOptions.RoutingTableID,
		"id":               *getVPCRoutingTableRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPCRoutingTableRoute : Update a VPC routing table route
// This request updates a VPC route with the information provided in a route patch object. The patch object is
// structured in the same way as a retrieved VPC route and needs to contain only the information to be updated. Only VPC
// routes with an `origin` of `user` are allowed to be updated.
func (vpc *VpcV1) UpdateVPCRoutingTableRoute(updateVPCRoutingTableRouteOptions *UpdateVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPCRoutingTableRouteWithContext(context.Background(), updateVPCRoutingTableRouteOptions)
}

// UpdateVPCRoutingTableRouteWithContext is an alternate form of the UpdateVPCRoutingTableRoute method which supports a Context parameter
func (vpc *VpcV1) UpdateVPCRoutingTableRouteWithContext(ctx context.Context, updateVPCRoutingTableRouteOptions *UpdateVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCRoutingTableRouteOptions, "updateVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCRoutingTableRouteOptions, "updateVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpc_id":           *updateVPCRoutingTableRouteOptions.VPCID,
		"routing_table_id": *updateVPCRoutingTableRouteOptions.RoutingTableID,
		"id":               *updateVPCRoutingTableRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpcs/{vpc_id}/routing_tables/{routing_table_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPCRoutingTableRouteOptions.RoutePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubnets : List all subnets
// This request lists all subnets in the region. Subnets are contiguous ranges of IP addresses specified in CIDR block
// notation. Each subnet is within a particular zone and cannot span multiple zones or regions.
func (vpc *VpcV1) ListSubnets(listSubnetsOptions *ListSubnetsOptions) (result *SubnetCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSubnetsWithContext(context.Background(), listSubnetsOptions)
}

// ListSubnetsWithContext is an alternate form of the ListSubnets method which supports a Context parameter
func (vpc *VpcV1) ListSubnetsWithContext(ctx context.Context, listSubnetsOptions *ListSubnetsOptions) (result *SubnetCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSubnetsOptions, "listSubnetsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubnetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSubnets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSubnetsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSubnetsOptions.Start))
	}
	if listSubnetsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubnetsOptions.Limit))
	}
	if listSubnetsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSubnetsOptions.ResourceGroupID))
	}
	if listSubnetsOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listSubnetsOptions.ZoneName))
	}
	if listSubnetsOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listSubnetsOptions.VPCID))
	}
	if listSubnetsOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listSubnetsOptions.VPCCRN))
	}
	if listSubnetsOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listSubnetsOptions.VPCName))
	}
	if listSubnetsOptions.RoutingTableID != nil {
		builder.AddQuery("routing_table.id", fmt.Sprint(*listSubnetsOptions.RoutingTableID))
	}
	if listSubnetsOptions.RoutingTableName != nil {
		builder.AddQuery("routing_table.name", fmt.Sprint(*listSubnetsOptions.RoutingTableName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnetCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSubnet : Create a subnet
// This request creates a new subnet from a subnet prototype object. The prototype object is structured in the same way
// as a retrieved subnet, and contains the information necessary to create the new subnet. For this request to succeed,
// the prototype's CIDR block must not overlap with an existing subnet in the VPC.
func (vpc *VpcV1) CreateSubnet(createSubnetOptions *CreateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	return vpc.CreateSubnetWithContext(context.Background(), createSubnetOptions)
}

// CreateSubnetWithContext is an alternate form of the CreateSubnet method which supports a Context parameter
func (vpc *VpcV1) CreateSubnetWithContext(ctx context.Context, createSubnetOptions *CreateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubnetOptions, "createSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubnetOptions, "createSubnetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSubnetOptions.SubnetPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubnet : Delete a subnet
// This request deletes a subnet. This operation cannot be reversed. For this request to succeed, the subnet must not be
// referenced by any bare metal server network interfaces, instance network interfaces, VPN gateways, or load balancers.
// A delete operation automatically detaches the subnet from any network ACLs, public gateways, or endpoint gateways.
// All flow log collectors with `auto_delete` set to `true` targeting the subnet or any resource in the subnet are
// automatically deleted.
func (vpc *VpcV1) DeleteSubnet(deleteSubnetOptions *DeleteSubnetOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSubnetWithContext(context.Background(), deleteSubnetOptions)
}

// DeleteSubnetWithContext is an alternate form of the DeleteSubnet method which supports a Context parameter
func (vpc *VpcV1) DeleteSubnetWithContext(ctx context.Context, deleteSubnetOptions *DeleteSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubnetOptions, "deleteSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubnetOptions, "deleteSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteSubnetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnet : Retrieve a subnet
// This request retrieves a single subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnet(getSubnetOptions *GetSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	return vpc.GetSubnetWithContext(context.Background(), getSubnetOptions)
}

// GetSubnetWithContext is an alternate form of the GetSubnet method which supports a Context parameter
func (vpc *VpcV1) GetSubnetWithContext(ctx context.Context, getSubnetOptions *GetSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetOptions, "getSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetOptions, "getSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getSubnetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSubnet : Update a subnet
// This request updates a subnet with the information in a provided subnet patch. The subnet patch object is structured
// in the same way as a retrieved subnet and contains only the information to be updated.
func (vpc *VpcV1) UpdateSubnet(updateSubnetOptions *UpdateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	return vpc.UpdateSubnetWithContext(context.Background(), updateSubnetOptions)
}

// UpdateSubnetWithContext is an alternate form of the UpdateSubnet method which supports a Context parameter
func (vpc *VpcV1) UpdateSubnetWithContext(ctx context.Context, updateSubnetOptions *UpdateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubnetOptions, "updateSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubnetOptions, "updateSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateSubnetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateSubnetOptions.SubnetPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubnetNetworkACL : Retrieve a subnet's attached network ACL
// This request retrieves the network ACL attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetNetworkACL(getSubnetNetworkACLOptions *GetSubnetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	return vpc.GetSubnetNetworkACLWithContext(context.Background(), getSubnetNetworkACLOptions)
}

// GetSubnetNetworkACLWithContext is an alternate form of the GetSubnetNetworkACL method which supports a Context parameter
func (vpc *VpcV1) GetSubnetNetworkACLWithContext(ctx context.Context, getSubnetNetworkACLOptions *GetSubnetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetNetworkACLOptions, "getSubnetNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetNetworkACLOptions, "getSubnetNetworkACLOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getSubnetNetworkACLOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/network_acl`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceSubnetNetworkACL : Replace the network ACL for a subnet
// This request replaces the existing network ACL for a subnet with the network ACL specified in the request body.
func (vpc *VpcV1) ReplaceSubnetNetworkACL(replaceSubnetNetworkACLOptions *ReplaceSubnetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	return vpc.ReplaceSubnetNetworkACLWithContext(context.Background(), replaceSubnetNetworkACLOptions)
}

// ReplaceSubnetNetworkACLWithContext is an alternate form of the ReplaceSubnetNetworkACL method which supports a Context parameter
func (vpc *VpcV1) ReplaceSubnetNetworkACLWithContext(ctx context.Context, replaceSubnetNetworkACLOptions *ReplaceSubnetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceSubnetNetworkACLOptions, "replaceSubnetNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceSubnetNetworkACLOptions, "replaceSubnetNetworkACLOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *replaceSubnetNetworkACLOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/network_acl`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceSubnetNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReplaceSubnetNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(replaceSubnetNetworkACLOptions.NetworkACLIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UnsetSubnetPublicGateway : Detach a public gateway from a subnet
// This request detaches the public gateway from the subnet specified by the subnet identifier in the URL.
func (vpc *VpcV1) UnsetSubnetPublicGateway(unsetSubnetPublicGatewayOptions *UnsetSubnetPublicGatewayOptions) (response *core.DetailedResponse, err error) {
	return vpc.UnsetSubnetPublicGatewayWithContext(context.Background(), unsetSubnetPublicGatewayOptions)
}

// UnsetSubnetPublicGatewayWithContext is an alternate form of the UnsetSubnetPublicGateway method which supports a Context parameter
func (vpc *VpcV1) UnsetSubnetPublicGatewayWithContext(ctx context.Context, unsetSubnetPublicGatewayOptions *UnsetSubnetPublicGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(unsetSubnetPublicGatewayOptions, "unsetSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(unsetSubnetPublicGatewayOptions, "unsetSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *unsetSubnetPublicGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/public_gateway`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range unsetSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UnsetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnetPublicGateway : Retrieve a subnet's attached public gateway
// This request retrieves the public gateway attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetPublicGateway(getSubnetPublicGatewayOptions *GetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	return vpc.GetSubnetPublicGatewayWithContext(context.Background(), getSubnetPublicGatewayOptions)
}

// GetSubnetPublicGatewayWithContext is an alternate form of the GetSubnetPublicGateway method which supports a Context parameter
func (vpc *VpcV1) GetSubnetPublicGatewayWithContext(ctx context.Context, getSubnetPublicGatewayOptions *GetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetPublicGatewayOptions, "getSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetPublicGatewayOptions, "getSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getSubnetPublicGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/public_gateway`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// SetSubnetPublicGateway : Attach a public gateway to a subnet
// This request attaches the public gateway, specified in the request body, to the subnet specified by the subnet
// identifier in the URL. The public gateway must have the same VPC and zone as the subnet.
func (vpc *VpcV1) SetSubnetPublicGateway(setSubnetPublicGatewayOptions *SetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	return vpc.SetSubnetPublicGatewayWithContext(context.Background(), setSubnetPublicGatewayOptions)
}

// SetSubnetPublicGatewayWithContext is an alternate form of the SetSubnetPublicGateway method which supports a Context parameter
func (vpc *VpcV1) SetSubnetPublicGatewayWithContext(ctx context.Context, setSubnetPublicGatewayOptions *SetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setSubnetPublicGatewayOptions, "setSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setSubnetPublicGatewayOptions, "setSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *setSubnetPublicGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/public_gateway`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range setSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "SetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(setSubnetPublicGatewayOptions.PublicGatewayIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubnetRoutingTable : Retrieve a subnet's attached routing table
// This request retrieves the routing table attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetRoutingTable(getSubnetRoutingTableOptions *GetSubnetRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	return vpc.GetSubnetRoutingTableWithContext(context.Background(), getSubnetRoutingTableOptions)
}

// GetSubnetRoutingTableWithContext is an alternate form of the GetSubnetRoutingTable method which supports a Context parameter
func (vpc *VpcV1) GetSubnetRoutingTableWithContext(ctx context.Context, getSubnetRoutingTableOptions *GetSubnetRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetRoutingTableOptions, "getSubnetRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetRoutingTableOptions, "getSubnetRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getSubnetRoutingTableOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/routing_table`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceSubnetRoutingTable : Replace the routing table for a subnet
// This request replaces the existing routing table for a subnet with the routing table specified in the request body.
//
// For this request to succeed, the routing table `route_direct_link_ingress`,
// `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` properties must be `false`.
func (vpc *VpcV1) ReplaceSubnetRoutingTable(replaceSubnetRoutingTableOptions *ReplaceSubnetRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	return vpc.ReplaceSubnetRoutingTableWithContext(context.Background(), replaceSubnetRoutingTableOptions)
}

// ReplaceSubnetRoutingTableWithContext is an alternate form of the ReplaceSubnetRoutingTable method which supports a Context parameter
func (vpc *VpcV1) ReplaceSubnetRoutingTableWithContext(ctx context.Context, replaceSubnetRoutingTableOptions *ReplaceSubnetRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceSubnetRoutingTableOptions, "replaceSubnetRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceSubnetRoutingTableOptions, "replaceSubnetRoutingTableOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *replaceSubnetRoutingTableOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{id}/routing_table`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceSubnetRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReplaceSubnetRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(replaceSubnetRoutingTableOptions.RoutingTableIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubnetReservedIps : List all reserved IPs in a subnet
// This request lists all reserved IPs in a subnet. A reserved IP resource will exist for every address in the subnet
// which is not available for use.
func (vpc *VpcV1) ListSubnetReservedIps(listSubnetReservedIpsOptions *ListSubnetReservedIpsOptions) (result *ReservedIPCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSubnetReservedIpsWithContext(context.Background(), listSubnetReservedIpsOptions)
}

// ListSubnetReservedIpsWithContext is an alternate form of the ListSubnetReservedIps method which supports a Context parameter
func (vpc *VpcV1) ListSubnetReservedIpsWithContext(ctx context.Context, listSubnetReservedIpsOptions *ListSubnetReservedIpsOptions) (result *ReservedIPCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubnetReservedIpsOptions, "listSubnetReservedIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubnetReservedIpsOptions, "listSubnetReservedIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"subnet_id": *listSubnetReservedIpsOptions.SubnetID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{subnet_id}/reserved_ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubnetReservedIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSubnetReservedIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSubnetReservedIpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSubnetReservedIpsOptions.Start))
	}
	if listSubnetReservedIpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubnetReservedIpsOptions.Limit))
	}
	if listSubnetReservedIpsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listSubnetReservedIpsOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIPCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSubnetReservedIP : Reserve an IP in a subnet
// This request reserves an IP address in a subnet. If the provided prototype object includes an `address`, the address
// must not already be reserved.
func (vpc *VpcV1) CreateSubnetReservedIP(createSubnetReservedIPOptions *CreateSubnetReservedIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.CreateSubnetReservedIPWithContext(context.Background(), createSubnetReservedIPOptions)
}

// CreateSubnetReservedIPWithContext is an alternate form of the CreateSubnetReservedIP method which supports a Context parameter
func (vpc *VpcV1) CreateSubnetReservedIPWithContext(ctx context.Context, createSubnetReservedIPOptions *CreateSubnetReservedIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubnetReservedIPOptions, "createSubnetReservedIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubnetReservedIPOptions, "createSubnetReservedIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"subnet_id": *createSubnetReservedIPOptions.SubnetID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{subnet_id}/reserved_ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubnetReservedIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSubnetReservedIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createSubnetReservedIPOptions.Address != nil {
		body["address"] = createSubnetReservedIPOptions.Address
	}
	if createSubnetReservedIPOptions.AutoDelete != nil {
		body["auto_delete"] = createSubnetReservedIPOptions.AutoDelete
	}
	if createSubnetReservedIPOptions.Name != nil {
		body["name"] = createSubnetReservedIPOptions.Name
	}
	if createSubnetReservedIPOptions.Target != nil {
		body["target"] = createSubnetReservedIPOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubnetReservedIP : Delete a reserved IP
// This request releases a reserved IP. This operation cannot be reversed.
//
// For this request to succeed, the reserved IP must not be required by another resource, such as a bare metal server
// network interface or instance network interface for which it is the primary IP. A provider-owned reserved IP is not
// allowed to be deleted.
func (vpc *VpcV1) DeleteSubnetReservedIP(deleteSubnetReservedIPOptions *DeleteSubnetReservedIPOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSubnetReservedIPWithContext(context.Background(), deleteSubnetReservedIPOptions)
}

// DeleteSubnetReservedIPWithContext is an alternate form of the DeleteSubnetReservedIP method which supports a Context parameter
func (vpc *VpcV1) DeleteSubnetReservedIPWithContext(ctx context.Context, deleteSubnetReservedIPOptions *DeleteSubnetReservedIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubnetReservedIPOptions, "deleteSubnetReservedIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubnetReservedIPOptions, "deleteSubnetReservedIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"subnet_id": *deleteSubnetReservedIPOptions.SubnetID,
		"id":        *deleteSubnetReservedIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{subnet_id}/reserved_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubnetReservedIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSubnetReservedIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnetReservedIP : Retrieve a reserved IP
// This request retrieves a single reserved IP specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetReservedIP(getSubnetReservedIPOptions *GetSubnetReservedIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.GetSubnetReservedIPWithContext(context.Background(), getSubnetReservedIPOptions)
}

// GetSubnetReservedIPWithContext is an alternate form of the GetSubnetReservedIP method which supports a Context parameter
func (vpc *VpcV1) GetSubnetReservedIPWithContext(ctx context.Context, getSubnetReservedIPOptions *GetSubnetReservedIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetReservedIPOptions, "getSubnetReservedIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetReservedIPOptions, "getSubnetReservedIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"subnet_id": *getSubnetReservedIPOptions.SubnetID,
		"id":        *getSubnetReservedIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{subnet_id}/reserved_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetReservedIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetReservedIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSubnetReservedIP : Update a reserved IP
// This request updates a reserved IP with the information in a provided reserved IP patch. The reserved IP patch object
// is structured in the same way as a retrieved reserved IP and contains only the information to be updated.
//
// A provider-owned reserved IP is not allowed to be updated.
func (vpc *VpcV1) UpdateSubnetReservedIP(updateSubnetReservedIPOptions *UpdateSubnetReservedIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.UpdateSubnetReservedIPWithContext(context.Background(), updateSubnetReservedIPOptions)
}

// UpdateSubnetReservedIPWithContext is an alternate form of the UpdateSubnetReservedIP method which supports a Context parameter
func (vpc *VpcV1) UpdateSubnetReservedIPWithContext(ctx context.Context, updateSubnetReservedIPOptions *UpdateSubnetReservedIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubnetReservedIPOptions, "updateSubnetReservedIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubnetReservedIPOptions, "updateSubnetReservedIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"subnet_id": *updateSubnetReservedIPOptions.SubnetID,
		"id":        *updateSubnetReservedIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/subnets/{subnet_id}/reserved_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubnetReservedIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSubnetReservedIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateSubnetReservedIPOptions.ReservedIPPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListImages : List all images
// This request lists all images available in the region. An image provides source data for a volume. Images are either
// system-provided, or created from another source, such as importing from Cloud Object Storage.
func (vpc *VpcV1) ListImages(listImagesOptions *ListImagesOptions) (result *ImageCollection, response *core.DetailedResponse, err error) {
	return vpc.ListImagesWithContext(context.Background(), listImagesOptions)
}

// ListImagesWithContext is an alternate form of the ListImages method which supports a Context parameter
func (vpc *VpcV1) ListImagesWithContext(ctx context.Context, listImagesOptions *ListImagesOptions) (result *ImageCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listImagesOptions, "listImagesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listImagesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListImages")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listImagesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listImagesOptions.Start))
	}
	if listImagesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listImagesOptions.Limit))
	}
	if listImagesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listImagesOptions.ResourceGroupID))
	}
	if listImagesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listImagesOptions.Name))
	}
	if listImagesOptions.Status != nil {
		builder.AddQuery("status", strings.Join(listImagesOptions.Status, ","))
	}
	if listImagesOptions.Visibility != nil {
		builder.AddQuery("visibility", fmt.Sprint(*listImagesOptions.Visibility))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImageCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateImage : Create an image
// This request creates a new image from an image prototype object. The prototype object is structured in the same way
// as a retrieved image, and contains the information necessary to create the new image. If an image is being imported,
// a URL to the image file on object storage must be specified. If an image is being created from an existing volume,
// that volume must be specified.
func (vpc *VpcV1) CreateImage(createImageOptions *CreateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	return vpc.CreateImageWithContext(context.Background(), createImageOptions)
}

// CreateImageWithContext is an alternate form of the CreateImage method which supports a Context parameter
func (vpc *VpcV1) CreateImageWithContext(ctx context.Context, createImageOptions *CreateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createImageOptions, "createImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createImageOptions, "createImageOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createImageOptions.ImagePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteImage : Delete an image
// This request deletes an image. Any active image export jobs will be completed first. This operation cannot be
// reversed. A system-provided image is not allowed to be deleted. Additionally, an image cannot be deleted if it:
// - has a `status` of `deleting`
// - has a `status` of `pending` with a `status_reasons` code of `image_request_in_progress`
// - has `catalog_offering.managed` set to `true`.
func (vpc *VpcV1) DeleteImage(deleteImageOptions *DeleteImageOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteImageWithContext(context.Background(), deleteImageOptions)
}

// DeleteImageWithContext is an alternate form of the DeleteImage method which supports a Context parameter
func (vpc *VpcV1) DeleteImageWithContext(ctx context.Context, deleteImageOptions *DeleteImageOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteImageOptions, "deleteImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteImageOptions, "deleteImageOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteImageOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetImage : Retrieve an image
// This request retrieves a single image specified by the identifier in the URL.
func (vpc *VpcV1) GetImage(getImageOptions *GetImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	return vpc.GetImageWithContext(context.Background(), getImageOptions)
}

// GetImageWithContext is an alternate form of the GetImage method which supports a Context parameter
func (vpc *VpcV1) GetImageWithContext(ctx context.Context, getImageOptions *GetImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getImageOptions, "getImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getImageOptions, "getImageOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getImageOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateImage : Update an image
// This request updates an image with the information in a provided image patch. The image patch object is structured in
// the same way as a retrieved image and contains only the information to be updated. A system-provided image is not
// allowed to be updated. An image with a `status` of `deleting` cannot be updated.
func (vpc *VpcV1) UpdateImage(updateImageOptions *UpdateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	return vpc.UpdateImageWithContext(context.Background(), updateImageOptions)
}

// UpdateImageWithContext is an alternate form of the UpdateImage method which supports a Context parameter
func (vpc *VpcV1) UpdateImageWithContext(ctx context.Context, updateImageOptions *UpdateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateImageOptions, "updateImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateImageOptions, "updateImageOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateImageOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateImageOptions.ImagePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeprecateImage : Deprecate an image
// This request deprecates an image, resulting in its `status` becoming `deprecated` and
// `deprecation_at` being set to the current date and time.
//
// The image must:
// - have a `status` of `available`
// - have `catalog_offering.managed` set to `false`
// - not have `deprecation_at` set
//
// The image must not have `deprecation_at` set, must have `catalog_offering.managed` set to
// `false`, and must have a `status` of `available`.
//
// A system-provided image is not allowed to be deprecated.
func (vpc *VpcV1) DeprecateImage(deprecateImageOptions *DeprecateImageOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeprecateImageWithContext(context.Background(), deprecateImageOptions)
}

// DeprecateImageWithContext is an alternate form of the DeprecateImage method which supports a Context parameter
func (vpc *VpcV1) DeprecateImageWithContext(ctx context.Context, deprecateImageOptions *DeprecateImageOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deprecateImageOptions, "deprecateImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deprecateImageOptions, "deprecateImageOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deprecateImageOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{id}/deprecate`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deprecateImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeprecateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ObsoleteImage : Obsolete an image
// This request obsoletes an image, resulting in its `status` becoming `obsolete` and
// `obsolescence_at` being set to the current date and time.
//
// The image must:
// - have a `status` of `available` or `deprecated`
// - have `catalog_offering.managed` set to `false`
// - not have `deprecation_at` set in the future
// - not have `obsolescence_at` set
//
// A system-provided image is not allowed to be obsoleted.
func (vpc *VpcV1) ObsoleteImage(obsoleteImageOptions *ObsoleteImageOptions) (response *core.DetailedResponse, err error) {
	return vpc.ObsoleteImageWithContext(context.Background(), obsoleteImageOptions)
}

// ObsoleteImageWithContext is an alternate form of the ObsoleteImage method which supports a Context parameter
func (vpc *VpcV1) ObsoleteImageWithContext(ctx context.Context, obsoleteImageOptions *ObsoleteImageOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(obsoleteImageOptions, "obsoleteImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(obsoleteImageOptions, "obsoleteImageOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *obsoleteImageOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{id}/obsolete`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range obsoleteImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ObsoleteImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListImageExportJobs : List all image export jobs
// This request lists all export jobs for an image. Each job tracks the exporting of the image to another location, such
// as a bucket within cloud object storage.
//
// The jobs will be sorted by their `created_at` property values, with newest jobs first. Jobs with identical
// `created_at` property values will in turn be sorted by ascending
// `name` property values.
func (vpc *VpcV1) ListImageExportJobs(listImageExportJobsOptions *ListImageExportJobsOptions) (result *ImageExportJobUnpaginatedCollection, response *core.DetailedResponse, err error) {
	return vpc.ListImageExportJobsWithContext(context.Background(), listImageExportJobsOptions)
}

// ListImageExportJobsWithContext is an alternate form of the ListImageExportJobs method which supports a Context parameter
func (vpc *VpcV1) ListImageExportJobsWithContext(ctx context.Context, listImageExportJobsOptions *ListImageExportJobsOptions) (result *ImageExportJobUnpaginatedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listImageExportJobsOptions, "listImageExportJobsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listImageExportJobsOptions, "listImageExportJobsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"image_id": *listImageExportJobsOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{image_id}/export_jobs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listImageExportJobsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListImageExportJobs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listImageExportJobsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listImageExportJobsOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImageExportJobUnpaginatedCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateImageExportJob : Create an image export job
// This request creates and queues a new export job for the image specified in the URL using the image export job
// prototype object. The image must be owned by the account and be in the `available`, `deprecated`, `obsolete`, or
// `unusable` state. The prototype object is structured in the same way as a retrieved image export job, and contains
// the information necessary to create and queue the new image export job.
func (vpc *VpcV1) CreateImageExportJob(createImageExportJobOptions *CreateImageExportJobOptions) (result *ImageExportJob, response *core.DetailedResponse, err error) {
	return vpc.CreateImageExportJobWithContext(context.Background(), createImageExportJobOptions)
}

// CreateImageExportJobWithContext is an alternate form of the CreateImageExportJob method which supports a Context parameter
func (vpc *VpcV1) CreateImageExportJobWithContext(ctx context.Context, createImageExportJobOptions *CreateImageExportJobOptions) (result *ImageExportJob, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createImageExportJobOptions, "createImageExportJobOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createImageExportJobOptions, "createImageExportJobOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"image_id": *createImageExportJobOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{image_id}/export_jobs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createImageExportJobOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateImageExportJob")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createImageExportJobOptions.StorageBucket != nil {
		body["storage_bucket"] = createImageExportJobOptions.StorageBucket
	}
	if createImageExportJobOptions.Format != nil {
		body["format"] = createImageExportJobOptions.Format
	}
	if createImageExportJobOptions.Name != nil {
		body["name"] = createImageExportJobOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImageExportJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteImageExportJob : Delete an image export job
// This request deletes an image export job. This operation cannot be reversed. If the job has not completed, the job
// will be canceled, and the incomplete exported image object deleted. If the job has completed, the exported image
// object will not be deleted.
func (vpc *VpcV1) DeleteImageExportJob(deleteImageExportJobOptions *DeleteImageExportJobOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteImageExportJobWithContext(context.Background(), deleteImageExportJobOptions)
}

// DeleteImageExportJobWithContext is an alternate form of the DeleteImageExportJob method which supports a Context parameter
func (vpc *VpcV1) DeleteImageExportJobWithContext(ctx context.Context, deleteImageExportJobOptions *DeleteImageExportJobOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteImageExportJobOptions, "deleteImageExportJobOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteImageExportJobOptions, "deleteImageExportJobOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"image_id": *deleteImageExportJobOptions.ImageID,
		"id":       *deleteImageExportJobOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{image_id}/export_jobs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteImageExportJobOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteImageExportJob")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetImageExportJob : Retrieve an image export job
// This request retrieves a single image export job specified by the identifier in the URL.
func (vpc *VpcV1) GetImageExportJob(getImageExportJobOptions *GetImageExportJobOptions) (result *ImageExportJob, response *core.DetailedResponse, err error) {
	return vpc.GetImageExportJobWithContext(context.Background(), getImageExportJobOptions)
}

// GetImageExportJobWithContext is an alternate form of the GetImageExportJob method which supports a Context parameter
func (vpc *VpcV1) GetImageExportJobWithContext(ctx context.Context, getImageExportJobOptions *GetImageExportJobOptions) (result *ImageExportJob, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getImageExportJobOptions, "getImageExportJobOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getImageExportJobOptions, "getImageExportJobOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"image_id": *getImageExportJobOptions.ImageID,
		"id":       *getImageExportJobOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{image_id}/export_jobs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getImageExportJobOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetImageExportJob")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImageExportJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateImageExportJob : Update an image export job
// This request updates an image export job with the information in a provided image export job patch. The image export
// job patch object is structured in the same way as a retrieved image export job and contains only the information to
// be updated.
func (vpc *VpcV1) UpdateImageExportJob(updateImageExportJobOptions *UpdateImageExportJobOptions) (result *ImageExportJob, response *core.DetailedResponse, err error) {
	return vpc.UpdateImageExportJobWithContext(context.Background(), updateImageExportJobOptions)
}

// UpdateImageExportJobWithContext is an alternate form of the UpdateImageExportJob method which supports a Context parameter
func (vpc *VpcV1) UpdateImageExportJobWithContext(ctx context.Context, updateImageExportJobOptions *UpdateImageExportJobOptions) (result *ImageExportJob, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateImageExportJobOptions, "updateImageExportJobOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateImageExportJobOptions, "updateImageExportJobOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"image_id": *updateImageExportJobOptions.ImageID,
		"id":       *updateImageExportJobOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/images/{image_id}/export_jobs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateImageExportJobOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateImageExportJob")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateImageExportJobOptions.ImageExportJobPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImageExportJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListOperatingSystems : List all operating systems
// This request lists all operating systems in the region.
func (vpc *VpcV1) ListOperatingSystems(listOperatingSystemsOptions *ListOperatingSystemsOptions) (result *OperatingSystemCollection, response *core.DetailedResponse, err error) {
	return vpc.ListOperatingSystemsWithContext(context.Background(), listOperatingSystemsOptions)
}

// ListOperatingSystemsWithContext is an alternate form of the ListOperatingSystems method which supports a Context parameter
func (vpc *VpcV1) ListOperatingSystemsWithContext(ctx context.Context, listOperatingSystemsOptions *ListOperatingSystemsOptions) (result *OperatingSystemCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listOperatingSystemsOptions, "listOperatingSystemsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/operating_systems`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listOperatingSystemsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListOperatingSystems")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listOperatingSystemsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listOperatingSystemsOptions.Start))
	}
	if listOperatingSystemsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listOperatingSystemsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOperatingSystemCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetOperatingSystem : Retrieve an operating system
// This request retrieves a single operating system specified by the name in the URL.
func (vpc *VpcV1) GetOperatingSystem(getOperatingSystemOptions *GetOperatingSystemOptions) (result *OperatingSystem, response *core.DetailedResponse, err error) {
	return vpc.GetOperatingSystemWithContext(context.Background(), getOperatingSystemOptions)
}

// GetOperatingSystemWithContext is an alternate form of the GetOperatingSystem method which supports a Context parameter
func (vpc *VpcV1) GetOperatingSystemWithContext(ctx context.Context, getOperatingSystemOptions *GetOperatingSystemOptions) (result *OperatingSystem, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getOperatingSystemOptions, "getOperatingSystemOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getOperatingSystemOptions, "getOperatingSystemOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getOperatingSystemOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/operating_systems/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getOperatingSystemOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetOperatingSystem")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOperatingSystem)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListKeys : List all keys
// This request lists all keys in the region. A key contains a public SSH key which may be installed on instances when
// they are created. Private keys are not stored.
func (vpc *VpcV1) ListKeys(listKeysOptions *ListKeysOptions) (result *KeyCollection, response *core.DetailedResponse, err error) {
	return vpc.ListKeysWithContext(context.Background(), listKeysOptions)
}

// ListKeysWithContext is an alternate form of the ListKeys method which supports a Context parameter
func (vpc *VpcV1) ListKeysWithContext(ctx context.Context, listKeysOptions *ListKeysOptions) (result *KeyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listKeysOptions, "listKeysOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/keys`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listKeysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListKeys")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listKeysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listKeysOptions.Start))
	}
	if listKeysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listKeysOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKeyCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateKey : Create a key
// This request creates a new SSH key from an key prototype object. The prototype object is structured in the same way
// as a retrieved key, and contains the information necessary to create the new key. The public key value must be
// provided.
func (vpc *VpcV1) CreateKey(createKeyOptions *CreateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	return vpc.CreateKeyWithContext(context.Background(), createKeyOptions)
}

// CreateKeyWithContext is an alternate form of the CreateKey method which supports a Context parameter
func (vpc *VpcV1) CreateKeyWithContext(ctx context.Context, createKeyOptions *CreateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createKeyOptions, "createKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createKeyOptions, "createKeyOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/keys`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createKeyOptions.PublicKey != nil {
		body["public_key"] = createKeyOptions.PublicKey
	}
	if createKeyOptions.Name != nil {
		body["name"] = createKeyOptions.Name
	}
	if createKeyOptions.ResourceGroup != nil {
		body["resource_group"] = createKeyOptions.ResourceGroup
	}
	if createKeyOptions.Type != nil {
		body["type"] = createKeyOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKey)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteKey : Delete a key
// This request deletes a key. This operation cannot be reversed.
func (vpc *VpcV1) DeleteKey(deleteKeyOptions *DeleteKeyOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteKeyWithContext(context.Background(), deleteKeyOptions)
}

// DeleteKeyWithContext is an alternate form of the DeleteKey method which supports a Context parameter
func (vpc *VpcV1) DeleteKeyWithContext(ctx context.Context, deleteKeyOptions *DeleteKeyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteKeyOptions, "deleteKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteKeyOptions, "deleteKeyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteKeyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/keys/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetKey : Retrieve a key
// This request retrieves a single key specified by the identifier in the URL.
func (vpc *VpcV1) GetKey(getKeyOptions *GetKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	return vpc.GetKeyWithContext(context.Background(), getKeyOptions)
}

// GetKeyWithContext is an alternate form of the GetKey method which supports a Context parameter
func (vpc *VpcV1) GetKeyWithContext(ctx context.Context, getKeyOptions *GetKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getKeyOptions, "getKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getKeyOptions, "getKeyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getKeyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/keys/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKey)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateKey : Update a key
// This request updates a key's name.
func (vpc *VpcV1) UpdateKey(updateKeyOptions *UpdateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	return vpc.UpdateKeyWithContext(context.Background(), updateKeyOptions)
}

// UpdateKeyWithContext is an alternate form of the UpdateKey method which supports a Context parameter
func (vpc *VpcV1) UpdateKeyWithContext(ctx context.Context, updateKeyOptions *UpdateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateKeyOptions, "updateKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateKeyOptions, "updateKeyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateKeyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/keys/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateKeyOptions.KeyPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKey)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceProfiles : List all instance profiles
// This request lists provisionable [instance profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) in the
// region. An instance profile specifies the performance characteristics and pricing model for an instance.
func (vpc *VpcV1) ListInstanceProfiles(listInstanceProfilesOptions *ListInstanceProfilesOptions) (result *InstanceProfileCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceProfilesWithContext(context.Background(), listInstanceProfilesOptions)
}

// ListInstanceProfilesWithContext is an alternate form of the ListInstanceProfiles method which supports a Context parameter
func (vpc *VpcV1) ListInstanceProfilesWithContext(ctx context.Context, listInstanceProfilesOptions *ListInstanceProfilesOptions) (result *InstanceProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceProfilesOptions, "listInstanceProfilesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/profiles`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceProfileCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetInstanceProfile : Retrieve an instance profile
// This request retrieves a single instance profile specified by the name in the URL.
func (vpc *VpcV1) GetInstanceProfile(getInstanceProfileOptions *GetInstanceProfileOptions) (result *InstanceProfile, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceProfileWithContext(context.Background(), getInstanceProfileOptions)
}

// GetInstanceProfileWithContext is an alternate form of the GetInstanceProfile method which supports a Context parameter
func (vpc *VpcV1) GetInstanceProfileWithContext(ctx context.Context, getInstanceProfileOptions *GetInstanceProfileOptions) (result *InstanceProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceProfileOptions, "getInstanceProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceProfileOptions, "getInstanceProfileOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getInstanceProfileOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/profiles/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceTemplates : List all instance templates
// This request lists all instance templates in the region.
func (vpc *VpcV1) ListInstanceTemplates(listInstanceTemplatesOptions *ListInstanceTemplatesOptions) (result *InstanceTemplateCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceTemplatesWithContext(context.Background(), listInstanceTemplatesOptions)
}

// ListInstanceTemplatesWithContext is an alternate form of the ListInstanceTemplates method which supports a Context parameter
func (vpc *VpcV1) ListInstanceTemplatesWithContext(ctx context.Context, listInstanceTemplatesOptions *ListInstanceTemplatesOptions) (result *InstanceTemplateCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceTemplatesOptions, "listInstanceTemplatesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/templates`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceTemplatesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceTemplates")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplateCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceTemplate : Create an instance template
// This request creates a new instance template. The prototype object is structured in the same way as a retrieved
// instance template, and contains the information necessary to provision a new instance from the template.
//
// If a `source_template` is specified in the prototype object, its contents are copied into the new template prior to
// copying any other properties provided in the prototype object.
func (vpc *VpcV1) CreateInstanceTemplate(createInstanceTemplateOptions *CreateInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceTemplateWithContext(context.Background(), createInstanceTemplateOptions)
}

// CreateInstanceTemplateWithContext is an alternate form of the CreateInstanceTemplate method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceTemplateWithContext(ctx context.Context, createInstanceTemplateOptions *CreateInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceTemplateOptions, "createInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceTemplateOptions, "createInstanceTemplateOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/templates`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceTemplateOptions.InstanceTemplatePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplate)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceTemplate : Delete an instance template
// This request deletes the instance template. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceTemplate(deleteInstanceTemplateOptions *DeleteInstanceTemplateOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceTemplateWithContext(context.Background(), deleteInstanceTemplateOptions)
}

// DeleteInstanceTemplateWithContext is an alternate form of the DeleteInstanceTemplate method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceTemplateWithContext(ctx context.Context, deleteInstanceTemplateOptions *DeleteInstanceTemplateOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceTemplateOptions, "deleteInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceTemplateOptions, "deleteInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteInstanceTemplateOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/templates/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceTemplate : Retrieve an instance template
// This request retrieves a single instance template specified by the identifier in the URL.
func (vpc *VpcV1) GetInstanceTemplate(getInstanceTemplateOptions *GetInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceTemplateWithContext(context.Background(), getInstanceTemplateOptions)
}

// GetInstanceTemplateWithContext is an alternate form of the GetInstanceTemplate method which supports a Context parameter
func (vpc *VpcV1) GetInstanceTemplateWithContext(ctx context.Context, getInstanceTemplateOptions *GetInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceTemplateOptions, "getInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceTemplateOptions, "getInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getInstanceTemplateOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/templates/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplate)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceTemplate : Update an instance template
// This request updates an instance template with the information provided in the instance template patch. The instance
// template patch object is structured in the same way as a retrieved instance template and contains only the
// information to be updated.
func (vpc *VpcV1) UpdateInstanceTemplate(updateInstanceTemplateOptions *UpdateInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceTemplateWithContext(context.Background(), updateInstanceTemplateOptions)
}

// UpdateInstanceTemplateWithContext is an alternate form of the UpdateInstanceTemplate method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceTemplateWithContext(ctx context.Context, updateInstanceTemplateOptions *UpdateInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceTemplateOptions, "updateInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceTemplateOptions, "updateInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateInstanceTemplateOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance/templates/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceTemplateOptions.InstanceTemplatePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplate)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstances : List all instances
// This request lists all instances in the region.
func (vpc *VpcV1) ListInstances(listInstancesOptions *ListInstancesOptions) (result *InstanceCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstancesWithContext(context.Background(), listInstancesOptions)
}

// ListInstancesWithContext is an alternate form of the ListInstances method which supports a Context parameter
func (vpc *VpcV1) ListInstancesWithContext(ctx context.Context, listInstancesOptions *ListInstancesOptions) (result *InstanceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstancesOptions, "listInstancesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstancesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstancesOptions.Start))
	}
	if listInstancesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstancesOptions.Limit))
	}
	if listInstancesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listInstancesOptions.ResourceGroupID))
	}
	if listInstancesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listInstancesOptions.Name))
	}
	if listInstancesOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listInstancesOptions.VPCID))
	}
	if listInstancesOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listInstancesOptions.VPCCRN))
	}
	if listInstancesOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listInstancesOptions.VPCName))
	}
	if listInstancesOptions.DedicatedHostID != nil {
		builder.AddQuery("dedicated_host.id", fmt.Sprint(*listInstancesOptions.DedicatedHostID))
	}
	if listInstancesOptions.DedicatedHostCRN != nil {
		builder.AddQuery("dedicated_host.crn", fmt.Sprint(*listInstancesOptions.DedicatedHostCRN))
	}
	if listInstancesOptions.DedicatedHostName != nil {
		builder.AddQuery("dedicated_host.name", fmt.Sprint(*listInstancesOptions.DedicatedHostName))
	}
	if listInstancesOptions.PlacementGroupID != nil {
		builder.AddQuery("placement_group.id", fmt.Sprint(*listInstancesOptions.PlacementGroupID))
	}
	if listInstancesOptions.PlacementGroupCRN != nil {
		builder.AddQuery("placement_group.crn", fmt.Sprint(*listInstancesOptions.PlacementGroupCRN))
	}
	if listInstancesOptions.PlacementGroupName != nil {
		builder.AddQuery("placement_group.name", fmt.Sprint(*listInstancesOptions.PlacementGroupName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstance : Create an instance
// This request provisions a new instance from an instance prototype object. The prototype object is structured in the
// same way as a retrieved instance, and contains the information necessary to provision the new instance. The instance
// is automatically started.
func (vpc *VpcV1) CreateInstance(createInstanceOptions *CreateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceWithContext(context.Background(), createInstanceOptions)
}

// CreateInstanceWithContext is an alternate form of the CreateInstance method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceWithContext(ctx context.Context, createInstanceOptions *CreateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceOptions, "createInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceOptions, "createInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceOptions.InstancePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstance : Delete an instance
// This request deletes an instance. This operation cannot be reversed. Any floating IPs associated with instance
// network interfaces are implicitly disassociated. All flow log collectors with `auto_delete` set to `true` targeting
// the instance and/or the instance network interfaces are automatically deleted.
func (vpc *VpcV1) DeleteInstance(deleteInstanceOptions *DeleteInstanceOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceWithContext(context.Background(), deleteInstanceOptions)
}

// DeleteInstanceWithContext is an alternate form of the DeleteInstance method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceWithContext(ctx context.Context, deleteInstanceOptions *DeleteInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceOptions, "deleteInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceOptions, "deleteInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstance : Retrieve an instance
// This request retrieves a single instance specified by the identifier in the URL.
func (vpc *VpcV1) GetInstance(getInstanceOptions *GetInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceWithContext(context.Background(), getInstanceOptions)
}

// GetInstanceWithContext is an alternate form of the GetInstance method which supports a Context parameter
func (vpc *VpcV1) GetInstanceWithContext(ctx context.Context, getInstanceOptions *GetInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceOptions, "getInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceOptions, "getInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstance : Update an instance
// This request updates an instance with the information in a provided instance patch. The instance patch object is
// structured in the same way as a retrieved instance and contains only the information to be updated.
func (vpc *VpcV1) UpdateInstance(updateInstanceOptions *UpdateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceWithContext(context.Background(), updateInstanceOptions)
}

// UpdateInstanceWithContext is an alternate form of the UpdateInstance method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceWithContext(ctx context.Context, updateInstanceOptions *UpdateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceOptions, "updateInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceOptions, "updateInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceOptions.InstancePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetInstanceInitialization : Retrieve initialization configuration for an instance
// This request retrieves configuration used to initialize the instance, such as SSH keys and the Windows administrator
// password. These can subsequently be changed on the instance and therefore may not be current.
func (vpc *VpcV1) GetInstanceInitialization(getInstanceInitializationOptions *GetInstanceInitializationOptions) (result *InstanceInitialization, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceInitializationWithContext(context.Background(), getInstanceInitializationOptions)
}

// GetInstanceInitializationWithContext is an alternate form of the GetInstanceInitialization method which supports a Context parameter
func (vpc *VpcV1) GetInstanceInitializationWithContext(ctx context.Context, getInstanceInitializationOptions *GetInstanceInitializationOptions) (result *InstanceInitialization, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceInitializationOptions, "getInstanceInitializationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceInitializationOptions, "getInstanceInitializationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getInstanceInitializationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{id}/initialization`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceInitializationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceInitialization")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceInitialization)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceAction : Create an instance action
// This request creates a new action which will be queued up to run as soon as any pending or running actions have
// completed.
func (vpc *VpcV1) CreateInstanceAction(createInstanceActionOptions *CreateInstanceActionOptions) (result *InstanceAction, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceActionWithContext(context.Background(), createInstanceActionOptions)
}

// CreateInstanceActionWithContext is an alternate form of the CreateInstanceAction method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceActionWithContext(ctx context.Context, createInstanceActionOptions *CreateInstanceActionOptions) (result *InstanceAction, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceActionOptions, "createInstanceActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceActionOptions, "createInstanceActionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createInstanceActionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/actions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceActionOptions.Type != nil {
		body["type"] = createInstanceActionOptions.Type
	}
	if createInstanceActionOptions.Force != nil {
		body["force"] = createInstanceActionOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceAction)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceConsoleAccessToken : Create a console access token for an instance
// This request creates a new single-use console access token for an instance. All console configuration is provided at
// token create time, and the token is subsequently used in the `access_token` query parameter for the WebSocket
// request.  The access token is only valid for a short period of time, and a maximum of one token is valid for a given
// instance at a time.
func (vpc *VpcV1) CreateInstanceConsoleAccessToken(createInstanceConsoleAccessTokenOptions *CreateInstanceConsoleAccessTokenOptions) (result *InstanceConsoleAccessToken, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceConsoleAccessTokenWithContext(context.Background(), createInstanceConsoleAccessTokenOptions)
}

// CreateInstanceConsoleAccessTokenWithContext is an alternate form of the CreateInstanceConsoleAccessToken method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceConsoleAccessTokenWithContext(ctx context.Context, createInstanceConsoleAccessTokenOptions *CreateInstanceConsoleAccessTokenOptions) (result *InstanceConsoleAccessToken, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceConsoleAccessTokenOptions, "createInstanceConsoleAccessTokenOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceConsoleAccessTokenOptions, "createInstanceConsoleAccessTokenOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createInstanceConsoleAccessTokenOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/console_access_token`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceConsoleAccessTokenOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceConsoleAccessToken")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceConsoleAccessTokenOptions.ConsoleType != nil {
		body["console_type"] = createInstanceConsoleAccessTokenOptions.ConsoleType
	}
	if createInstanceConsoleAccessTokenOptions.Force != nil {
		body["force"] = createInstanceConsoleAccessTokenOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceConsoleAccessToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceDisks : List all disks on an instance
// This request lists all disks on an instance.  A disk is a block device that is locally attached to the instance's
// physical host and is also referred to as instance storage. By default, the listed disks are sorted by their
// `created_at` property values, with the newest disk first.
func (vpc *VpcV1) ListInstanceDisks(listInstanceDisksOptions *ListInstanceDisksOptions) (result *InstanceDiskCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceDisksWithContext(context.Background(), listInstanceDisksOptions)
}

// ListInstanceDisksWithContext is an alternate form of the ListInstanceDisks method which supports a Context parameter
func (vpc *VpcV1) ListInstanceDisksWithContext(ctx context.Context, listInstanceDisksOptions *ListInstanceDisksOptions) (result *InstanceDiskCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceDisksOptions, "listInstanceDisksOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceDisksOptions, "listInstanceDisksOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listInstanceDisksOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/disks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceDisksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceDisks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceDiskCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetInstanceDisk : Retrieve an instance disk
// This request retrieves a single instance disk specified by the identifier in the URL.
func (vpc *VpcV1) GetInstanceDisk(getInstanceDiskOptions *GetInstanceDiskOptions) (result *InstanceDisk, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceDiskWithContext(context.Background(), getInstanceDiskOptions)
}

// GetInstanceDiskWithContext is an alternate form of the GetInstanceDisk method which supports a Context parameter
func (vpc *VpcV1) GetInstanceDiskWithContext(ctx context.Context, getInstanceDiskOptions *GetInstanceDiskOptions) (result *InstanceDisk, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceDiskOptions, "getInstanceDiskOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceDiskOptions, "getInstanceDiskOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getInstanceDiskOptions.InstanceID,
		"id":          *getInstanceDiskOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/disks/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceDiskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceDisk")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceDisk)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceDisk : Update an instance disk
// This request updates the instance disk with the information in a provided patch.
func (vpc *VpcV1) UpdateInstanceDisk(updateInstanceDiskOptions *UpdateInstanceDiskOptions) (result *InstanceDisk, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceDiskWithContext(context.Background(), updateInstanceDiskOptions)
}

// UpdateInstanceDiskWithContext is an alternate form of the UpdateInstanceDisk method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceDiskWithContext(ctx context.Context, updateInstanceDiskOptions *UpdateInstanceDiskOptions) (result *InstanceDisk, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceDiskOptions, "updateInstanceDiskOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceDiskOptions, "updateInstanceDiskOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateInstanceDiskOptions.InstanceID,
		"id":          *updateInstanceDiskOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/disks/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceDiskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceDisk")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceDiskOptions.InstanceDiskPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceDisk)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceNetworkInterfaces : List all network interfaces on an instance
// This request lists all network interfaces on an instance. An instance network interface is an abstract representation
// of a network device and attaches an instance to a single subnet. Each network interface on an instance can attach to
// any subnet in the zone, including subnets that are already attached to the instance. Multiple network interfaces on
// the instance may also attach to the same subnet.
func (vpc *VpcV1) ListInstanceNetworkInterfaces(listInstanceNetworkInterfacesOptions *ListInstanceNetworkInterfacesOptions) (result *NetworkInterfaceUnpaginatedCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceNetworkInterfacesWithContext(context.Background(), listInstanceNetworkInterfacesOptions)
}

// ListInstanceNetworkInterfacesWithContext is an alternate form of the ListInstanceNetworkInterfaces method which supports a Context parameter
func (vpc *VpcV1) ListInstanceNetworkInterfacesWithContext(ctx context.Context, listInstanceNetworkInterfacesOptions *ListInstanceNetworkInterfacesOptions) (result *NetworkInterfaceUnpaginatedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceNetworkInterfacesOptions, "listInstanceNetworkInterfacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceNetworkInterfacesOptions, "listInstanceNetworkInterfacesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listInstanceNetworkInterfacesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterfaceUnpaginatedCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceNetworkInterface : Create a network interface on an instance
// This request creates a new instance network interface from an instance network interface prototype object. The
// prototype object is structured in the same way as a retrieved instance network interface, and contains the
// information necessary to create the new instance network interface. Any subnet in the instance's VPC may be
// specified. Addresses on the instance network interface must be within the specified subnet's CIDR blocks.
func (vpc *VpcV1) CreateInstanceNetworkInterface(createInstanceNetworkInterfaceOptions *CreateInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceNetworkInterfaceWithContext(context.Background(), createInstanceNetworkInterfaceOptions)
}

// CreateInstanceNetworkInterfaceWithContext is an alternate form of the CreateInstanceNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceNetworkInterfaceWithContext(ctx context.Context, createInstanceNetworkInterfaceOptions *CreateInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceNetworkInterfaceOptions, "createInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceNetworkInterfaceOptions, "createInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createInstanceNetworkInterfaceOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceNetworkInterfaceOptions.Subnet != nil {
		body["subnet"] = createInstanceNetworkInterfaceOptions.Subnet
	}
	if createInstanceNetworkInterfaceOptions.AllowIPSpoofing != nil {
		body["allow_ip_spoofing"] = createInstanceNetworkInterfaceOptions.AllowIPSpoofing
	}
	if createInstanceNetworkInterfaceOptions.Name != nil {
		body["name"] = createInstanceNetworkInterfaceOptions.Name
	}
	if createInstanceNetworkInterfaceOptions.PrimaryIP != nil {
		body["primary_ip"] = createInstanceNetworkInterfaceOptions.PrimaryIP
	}
	if createInstanceNetworkInterfaceOptions.SecurityGroups != nil {
		body["security_groups"] = createInstanceNetworkInterfaceOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceNetworkInterface : Delete an instance network interface
// This request deletes an instance network interface. This operation cannot be reversed. Any floating IPs associated
// with the instance network interface are implicitly disassociated. All flow log collectors with `auto_delete` set to
// `true` targeting the instance network interface are automatically deleted. The primary instance network interface is
// not allowed to be deleted.
func (vpc *VpcV1) DeleteInstanceNetworkInterface(deleteInstanceNetworkInterfaceOptions *DeleteInstanceNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceNetworkInterfaceWithContext(context.Background(), deleteInstanceNetworkInterfaceOptions)
}

// DeleteInstanceNetworkInterfaceWithContext is an alternate form of the DeleteInstanceNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceNetworkInterfaceWithContext(ctx context.Context, deleteInstanceNetworkInterfaceOptions *DeleteInstanceNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceNetworkInterfaceOptions, "deleteInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceNetworkInterfaceOptions, "deleteInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteInstanceNetworkInterfaceOptions.InstanceID,
		"id":          *deleteInstanceNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceNetworkInterface : Retrieve an instance network interface
// This request retrieves a single instance network interface specified by the identifier in the URL.
func (vpc *VpcV1) GetInstanceNetworkInterface(getInstanceNetworkInterfaceOptions *GetInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceNetworkInterfaceWithContext(context.Background(), getInstanceNetworkInterfaceOptions)
}

// GetInstanceNetworkInterfaceWithContext is an alternate form of the GetInstanceNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) GetInstanceNetworkInterfaceWithContext(ctx context.Context, getInstanceNetworkInterfaceOptions *GetInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceNetworkInterfaceOptions, "getInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceNetworkInterfaceOptions, "getInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getInstanceNetworkInterfaceOptions.InstanceID,
		"id":          *getInstanceNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceNetworkInterface : Update an instance network interface
// This request updates an instance network interface with the information provided in an instance network interface
// patch object. The instance network interface patch object is structured in the same way as a retrieved instance
// network interface and needs to contain only the information to be updated.
func (vpc *VpcV1) UpdateInstanceNetworkInterface(updateInstanceNetworkInterfaceOptions *UpdateInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceNetworkInterfaceWithContext(context.Background(), updateInstanceNetworkInterfaceOptions)
}

// UpdateInstanceNetworkInterfaceWithContext is an alternate form of the UpdateInstanceNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceNetworkInterfaceWithContext(ctx context.Context, updateInstanceNetworkInterfaceOptions *UpdateInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceNetworkInterfaceOptions, "updateInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceNetworkInterfaceOptions, "updateInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateInstanceNetworkInterfaceOptions.InstanceID,
		"id":          *updateInstanceNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceNetworkInterfaceOptions.NetworkInterfacePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceNetworkInterfaceFloatingIps : List all floating IPs associated with an instance network interface
// This request lists all floating IPs associated with an instance network interface.
func (vpc *VpcV1) ListInstanceNetworkInterfaceFloatingIps(listInstanceNetworkInterfaceFloatingIpsOptions *ListInstanceNetworkInterfaceFloatingIpsOptions) (result *FloatingIPUnpaginatedCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceNetworkInterfaceFloatingIpsWithContext(context.Background(), listInstanceNetworkInterfaceFloatingIpsOptions)
}

// ListInstanceNetworkInterfaceFloatingIpsWithContext is an alternate form of the ListInstanceNetworkInterfaceFloatingIps method which supports a Context parameter
func (vpc *VpcV1) ListInstanceNetworkInterfaceFloatingIpsWithContext(ctx context.Context, listInstanceNetworkInterfaceFloatingIpsOptions *ListInstanceNetworkInterfaceFloatingIpsOptions) (result *FloatingIPUnpaginatedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceNetworkInterfaceFloatingIpsOptions, "listInstanceNetworkInterfaceFloatingIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceNetworkInterfaceFloatingIpsOptions, "listInstanceNetworkInterfaceFloatingIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id":          *listInstanceNetworkInterfaceFloatingIpsOptions.InstanceID,
		"network_interface_id": *listInstanceNetworkInterfaceFloatingIpsOptions.NetworkInterfaceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceNetworkInterfaceFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceNetworkInterfaceFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIPUnpaginatedCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RemoveInstanceNetworkInterfaceFloatingIP : Disassociate a floating IP from an instance network interface
// This request disassociates the specified floating IP from the specified instance network interface.
func (vpc *VpcV1) RemoveInstanceNetworkInterfaceFloatingIP(removeInstanceNetworkInterfaceFloatingIPOptions *RemoveInstanceNetworkInterfaceFloatingIPOptions) (response *core.DetailedResponse, err error) {
	return vpc.RemoveInstanceNetworkInterfaceFloatingIPWithContext(context.Background(), removeInstanceNetworkInterfaceFloatingIPOptions)
}

// RemoveInstanceNetworkInterfaceFloatingIPWithContext is an alternate form of the RemoveInstanceNetworkInterfaceFloatingIP method which supports a Context parameter
func (vpc *VpcV1) RemoveInstanceNetworkInterfaceFloatingIPWithContext(ctx context.Context, removeInstanceNetworkInterfaceFloatingIPOptions *RemoveInstanceNetworkInterfaceFloatingIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeInstanceNetworkInterfaceFloatingIPOptions, "removeInstanceNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeInstanceNetworkInterfaceFloatingIPOptions, "removeInstanceNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id":          *removeInstanceNetworkInterfaceFloatingIPOptions.InstanceID,
		"network_interface_id": *removeInstanceNetworkInterfaceFloatingIPOptions.NetworkInterfaceID,
		"id":                   *removeInstanceNetworkInterfaceFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeInstanceNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveInstanceNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceNetworkInterfaceFloatingIP : Retrieve associated floating IP
// This request retrieves a specified floating IP address if it is associated with the instance network interface and
// instance specified in the URL.
func (vpc *VpcV1) GetInstanceNetworkInterfaceFloatingIP(getInstanceNetworkInterfaceFloatingIPOptions *GetInstanceNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceNetworkInterfaceFloatingIPWithContext(context.Background(), getInstanceNetworkInterfaceFloatingIPOptions)
}

// GetInstanceNetworkInterfaceFloatingIPWithContext is an alternate form of the GetInstanceNetworkInterfaceFloatingIP method which supports a Context parameter
func (vpc *VpcV1) GetInstanceNetworkInterfaceFloatingIPWithContext(ctx context.Context, getInstanceNetworkInterfaceFloatingIPOptions *GetInstanceNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceNetworkInterfaceFloatingIPOptions, "getInstanceNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceNetworkInterfaceFloatingIPOptions, "getInstanceNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id":          *getInstanceNetworkInterfaceFloatingIPOptions.InstanceID,
		"network_interface_id": *getInstanceNetworkInterfaceFloatingIPOptions.NetworkInterfaceID,
		"id":                   *getInstanceNetworkInterfaceFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AddInstanceNetworkInterfaceFloatingIP : Associate a floating IP with an instance network interface
// This request associates the specified floating IP with the specified instance network interface, replacing any
// existing association. For this request to succeed, the existing floating IP must not be required by another resource,
// such as a public gateway. A request body is not required, and if provided, is ignored.
func (vpc *VpcV1) AddInstanceNetworkInterfaceFloatingIP(addInstanceNetworkInterfaceFloatingIPOptions *AddInstanceNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.AddInstanceNetworkInterfaceFloatingIPWithContext(context.Background(), addInstanceNetworkInterfaceFloatingIPOptions)
}

// AddInstanceNetworkInterfaceFloatingIPWithContext is an alternate form of the AddInstanceNetworkInterfaceFloatingIP method which supports a Context parameter
func (vpc *VpcV1) AddInstanceNetworkInterfaceFloatingIPWithContext(ctx context.Context, addInstanceNetworkInterfaceFloatingIPOptions *AddInstanceNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addInstanceNetworkInterfaceFloatingIPOptions, "addInstanceNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addInstanceNetworkInterfaceFloatingIPOptions, "addInstanceNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id":          *addInstanceNetworkInterfaceFloatingIPOptions.InstanceID,
		"network_interface_id": *addInstanceNetworkInterfaceFloatingIPOptions.NetworkInterfaceID,
		"id":                   *addInstanceNetworkInterfaceFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{network_interface_id}/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addInstanceNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddInstanceNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceNetworkInterfaceIps : List the primary reserved IP for an instance network interface
// This request lists the primary reserved IP for an instance network interface.
func (vpc *VpcV1) ListInstanceNetworkInterfaceIps(listInstanceNetworkInterfaceIpsOptions *ListInstanceNetworkInterfaceIpsOptions) (result *ReservedIPCollectionInstanceNetworkInterfaceContext, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceNetworkInterfaceIpsWithContext(context.Background(), listInstanceNetworkInterfaceIpsOptions)
}

// ListInstanceNetworkInterfaceIpsWithContext is an alternate form of the ListInstanceNetworkInterfaceIps method which supports a Context parameter
func (vpc *VpcV1) ListInstanceNetworkInterfaceIpsWithContext(ctx context.Context, listInstanceNetworkInterfaceIpsOptions *ListInstanceNetworkInterfaceIpsOptions) (result *ReservedIPCollectionInstanceNetworkInterfaceContext, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceNetworkInterfaceIpsOptions, "listInstanceNetworkInterfaceIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceNetworkInterfaceIpsOptions, "listInstanceNetworkInterfaceIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id":          *listInstanceNetworkInterfaceIpsOptions.InstanceID,
		"network_interface_id": *listInstanceNetworkInterfaceIpsOptions.NetworkInterfaceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{network_interface_id}/ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceNetworkInterfaceIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceNetworkInterfaceIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceNetworkInterfaceIpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceNetworkInterfaceIpsOptions.Start))
	}
	if listInstanceNetworkInterfaceIpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceNetworkInterfaceIpsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIPCollectionInstanceNetworkInterfaceContext)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetInstanceNetworkInterfaceIP : Retrieve the primary reserved IP
// This request retrieves the primary reserved IP for an instance network interface.
func (vpc *VpcV1) GetInstanceNetworkInterfaceIP(getInstanceNetworkInterfaceIPOptions *GetInstanceNetworkInterfaceIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceNetworkInterfaceIPWithContext(context.Background(), getInstanceNetworkInterfaceIPOptions)
}

// GetInstanceNetworkInterfaceIPWithContext is an alternate form of the GetInstanceNetworkInterfaceIP method which supports a Context parameter
func (vpc *VpcV1) GetInstanceNetworkInterfaceIPWithContext(ctx context.Context, getInstanceNetworkInterfaceIPOptions *GetInstanceNetworkInterfaceIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceNetworkInterfaceIPOptions, "getInstanceNetworkInterfaceIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceNetworkInterfaceIPOptions, "getInstanceNetworkInterfaceIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id":          *getInstanceNetworkInterfaceIPOptions.InstanceID,
		"network_interface_id": *getInstanceNetworkInterfaceIPOptions.NetworkInterfaceID,
		"id":                   *getInstanceNetworkInterfaceIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/network_interfaces/{network_interface_id}/ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceNetworkInterfaceIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceNetworkInterfaceIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceVolumeAttachments : List all volumes attachments on an instance
// This request lists all volume attachments on an instance. A volume attachment connects a volume to an instance. Each
// instance may have many volume attachments but each volume attachment connects exactly one instance to exactly one
// volume.
func (vpc *VpcV1) ListInstanceVolumeAttachments(listInstanceVolumeAttachmentsOptions *ListInstanceVolumeAttachmentsOptions) (result *VolumeAttachmentCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceVolumeAttachmentsWithContext(context.Background(), listInstanceVolumeAttachmentsOptions)
}

// ListInstanceVolumeAttachmentsWithContext is an alternate form of the ListInstanceVolumeAttachments method which supports a Context parameter
func (vpc *VpcV1) ListInstanceVolumeAttachmentsWithContext(ctx context.Context, listInstanceVolumeAttachmentsOptions *ListInstanceVolumeAttachmentsOptions) (result *VolumeAttachmentCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceVolumeAttachmentsOptions, "listInstanceVolumeAttachmentsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceVolumeAttachmentsOptions, "listInstanceVolumeAttachmentsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listInstanceVolumeAttachmentsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/volume_attachments`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceVolumeAttachmentsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceVolumeAttachments")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachmentCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceVolumeAttachment : Create a volume attachment on an instance
// This request creates a new volume attachment from a volume attachment prototype object, connecting a volume to an
// instance. For this request to succeed, the specified volume must not be busy. The prototype object is structured in
// the same way as a retrieved volume attachment, and contains the information necessary to create the new volume
// attachment.
func (vpc *VpcV1) CreateInstanceVolumeAttachment(createInstanceVolumeAttachmentOptions *CreateInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceVolumeAttachmentWithContext(context.Background(), createInstanceVolumeAttachmentOptions)
}

// CreateInstanceVolumeAttachmentWithContext is an alternate form of the CreateInstanceVolumeAttachment method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceVolumeAttachmentWithContext(ctx context.Context, createInstanceVolumeAttachmentOptions *CreateInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceVolumeAttachmentOptions, "createInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceVolumeAttachmentOptions, "createInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createInstanceVolumeAttachmentOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/volume_attachments`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceVolumeAttachmentOptions.Volume != nil {
		body["volume"] = createInstanceVolumeAttachmentOptions.Volume
	}
	if createInstanceVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete != nil {
		body["delete_volume_on_instance_delete"] = createInstanceVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete
	}
	if createInstanceVolumeAttachmentOptions.Name != nil {
		body["name"] = createInstanceVolumeAttachmentOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceVolumeAttachment : Delete a volume attachment
// This request deletes a volume attachment. This operation cannot be reversed, but a new volume attachment may
// subsequently be created for the volume.  For this request to succeed, the volume must not be busy.
func (vpc *VpcV1) DeleteInstanceVolumeAttachment(deleteInstanceVolumeAttachmentOptions *DeleteInstanceVolumeAttachmentOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceVolumeAttachmentWithContext(context.Background(), deleteInstanceVolumeAttachmentOptions)
}

// DeleteInstanceVolumeAttachmentWithContext is an alternate form of the DeleteInstanceVolumeAttachment method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceVolumeAttachmentWithContext(ctx context.Context, deleteInstanceVolumeAttachmentOptions *DeleteInstanceVolumeAttachmentOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceVolumeAttachmentOptions, "deleteInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceVolumeAttachmentOptions, "deleteInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteInstanceVolumeAttachmentOptions.InstanceID,
		"id":          *deleteInstanceVolumeAttachmentOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/volume_attachments/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceVolumeAttachment : Retrieve a volume attachment
// This request retrieves a single volume attachment specified by the identifier in the URL.
func (vpc *VpcV1) GetInstanceVolumeAttachment(getInstanceVolumeAttachmentOptions *GetInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceVolumeAttachmentWithContext(context.Background(), getInstanceVolumeAttachmentOptions)
}

// GetInstanceVolumeAttachmentWithContext is an alternate form of the GetInstanceVolumeAttachment method which supports a Context parameter
func (vpc *VpcV1) GetInstanceVolumeAttachmentWithContext(ctx context.Context, getInstanceVolumeAttachmentOptions *GetInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceVolumeAttachmentOptions, "getInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceVolumeAttachmentOptions, "getInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getInstanceVolumeAttachmentOptions.InstanceID,
		"id":          *getInstanceVolumeAttachmentOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/volume_attachments/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceVolumeAttachment : Update a volume attachment
// This request updates a volume attachment with the information provided in a volume attachment patch object. The
// volume attachment patch object is structured in the same way as a retrieved volume attachment and needs to contain
// only the information to be updated.
func (vpc *VpcV1) UpdateInstanceVolumeAttachment(updateInstanceVolumeAttachmentOptions *UpdateInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceVolumeAttachmentWithContext(context.Background(), updateInstanceVolumeAttachmentOptions)
}

// UpdateInstanceVolumeAttachmentWithContext is an alternate form of the UpdateInstanceVolumeAttachment method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceVolumeAttachmentWithContext(ctx context.Context, updateInstanceVolumeAttachmentOptions *UpdateInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceVolumeAttachmentOptions, "updateInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceVolumeAttachmentOptions, "updateInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateInstanceVolumeAttachmentOptions.InstanceID,
		"id":          *updateInstanceVolumeAttachmentOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instances/{instance_id}/volume_attachments/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceVolumeAttachmentOptions.VolumeAttachmentPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceGroups : List all instance groups
// This request lists all instance groups in the region.
func (vpc *VpcV1) ListInstanceGroups(listInstanceGroupsOptions *ListInstanceGroupsOptions) (result *InstanceGroupCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceGroupsWithContext(context.Background(), listInstanceGroupsOptions)
}

// ListInstanceGroupsWithContext is an alternate form of the ListInstanceGroups method which supports a Context parameter
func (vpc *VpcV1) ListInstanceGroupsWithContext(ctx context.Context, listInstanceGroupsOptions *ListInstanceGroupsOptions) (result *InstanceGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceGroupsOptions, "listInstanceGroupsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceGroupsOptions.Start))
	}
	if listInstanceGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceGroupsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceGroup : Create an instance group
// This request creates a new instance group.
func (vpc *VpcV1) CreateInstanceGroup(createInstanceGroupOptions *CreateInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceGroupWithContext(context.Background(), createInstanceGroupOptions)
}

// CreateInstanceGroupWithContext is an alternate form of the CreateInstanceGroup method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceGroupWithContext(ctx context.Context, createInstanceGroupOptions *CreateInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupOptions, "createInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupOptions, "createInstanceGroupOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceGroupOptions.InstanceTemplate != nil {
		body["instance_template"] = createInstanceGroupOptions.InstanceTemplate
	}
	if createInstanceGroupOptions.Subnets != nil {
		body["subnets"] = createInstanceGroupOptions.Subnets
	}
	if createInstanceGroupOptions.ApplicationPort != nil {
		body["application_port"] = createInstanceGroupOptions.ApplicationPort
	}
	if createInstanceGroupOptions.LoadBalancer != nil {
		body["load_balancer"] = createInstanceGroupOptions.LoadBalancer
	}
	if createInstanceGroupOptions.LoadBalancerPool != nil {
		body["load_balancer_pool"] = createInstanceGroupOptions.LoadBalancerPool
	}
	if createInstanceGroupOptions.MembershipCount != nil {
		body["membership_count"] = createInstanceGroupOptions.MembershipCount
	}
	if createInstanceGroupOptions.Name != nil {
		body["name"] = createInstanceGroupOptions.Name
	}
	if createInstanceGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createInstanceGroupOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroup : Delete an instance group
// This request deletes an instance group. This operation cannot be reversed. Any instances associated with the group
// will be deleted.
func (vpc *VpcV1) DeleteInstanceGroup(deleteInstanceGroupOptions *DeleteInstanceGroupOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupWithContext(context.Background(), deleteInstanceGroupOptions)
}

// DeleteInstanceGroupWithContext is an alternate form of the DeleteInstanceGroup method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupWithContext(ctx context.Context, deleteInstanceGroupOptions *DeleteInstanceGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupOptions, "deleteInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupOptions, "deleteInstanceGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteInstanceGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroup : Retrieve an instance group
// This request retrieves a single instance group specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroup(getInstanceGroupOptions *GetInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceGroupWithContext(context.Background(), getInstanceGroupOptions)
}

// GetInstanceGroupWithContext is an alternate form of the GetInstanceGroup method which supports a Context parameter
func (vpc *VpcV1) GetInstanceGroupWithContext(ctx context.Context, getInstanceGroupOptions *GetInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupOptions, "getInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupOptions, "getInstanceGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getInstanceGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceGroup : Update an instance group
// This request updates an instance group with the information provided instance group patch. The instance group patch
// object is structured in the same way as a retrieved instance group and contains only the information to be updated.
func (vpc *VpcV1) UpdateInstanceGroup(updateInstanceGroupOptions *UpdateInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceGroupWithContext(context.Background(), updateInstanceGroupOptions)
}

// UpdateInstanceGroupWithContext is an alternate form of the UpdateInstanceGroup method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceGroupWithContext(ctx context.Context, updateInstanceGroupOptions *UpdateInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupOptions, "updateInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupOptions, "updateInstanceGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateInstanceGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceGroupOptions.InstanceGroupPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroupLoadBalancer : Delete an instance group load balancer
// This request unbinds the instance group from the load balancer pool, and deletes the load balancer pool members.
func (vpc *VpcV1) DeleteInstanceGroupLoadBalancer(deleteInstanceGroupLoadBalancerOptions *DeleteInstanceGroupLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupLoadBalancerWithContext(context.Background(), deleteInstanceGroupLoadBalancerOptions)
}

// DeleteInstanceGroupLoadBalancerWithContext is an alternate form of the DeleteInstanceGroupLoadBalancer method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupLoadBalancerWithContext(ctx context.Context, deleteInstanceGroupLoadBalancerOptions *DeleteInstanceGroupLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupLoadBalancerOptions, "deleteInstanceGroupLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupLoadBalancerOptions, "deleteInstanceGroupLoadBalancerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *deleteInstanceGroupLoadBalancerOptions.InstanceGroupID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/load_balancer`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListInstanceGroupManagers : List all managers for an instance group
// This request lists all managers for an instance group.
func (vpc *VpcV1) ListInstanceGroupManagers(listInstanceGroupManagersOptions *ListInstanceGroupManagersOptions) (result *InstanceGroupManagerCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceGroupManagersWithContext(context.Background(), listInstanceGroupManagersOptions)
}

// ListInstanceGroupManagersWithContext is an alternate form of the ListInstanceGroupManagers method which supports a Context parameter
func (vpc *VpcV1) ListInstanceGroupManagersWithContext(ctx context.Context, listInstanceGroupManagersOptions *ListInstanceGroupManagersOptions) (result *InstanceGroupManagerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupManagersOptions, "listInstanceGroupManagersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupManagersOptions, "listInstanceGroupManagersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *listInstanceGroupManagersOptions.InstanceGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupManagersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupManagers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceGroupManagersOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceGroupManagersOptions.Start))
	}
	if listInstanceGroupManagersOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceGroupManagersOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceGroupManager : Create a manager for an instance group
// This request creates a new instance group manager.
func (vpc *VpcV1) CreateInstanceGroupManager(createInstanceGroupManagerOptions *CreateInstanceGroupManagerOptions) (result InstanceGroupManagerIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceGroupManagerWithContext(context.Background(), createInstanceGroupManagerOptions)
}

// CreateInstanceGroupManagerWithContext is an alternate form of the CreateInstanceGroupManager method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceGroupManagerWithContext(ctx context.Context, createInstanceGroupManagerOptions *CreateInstanceGroupManagerOptions) (result InstanceGroupManagerIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupManagerOptions, "createInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupManagerOptions, "createInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *createInstanceGroupManagerOptions.InstanceGroupID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceGroupManagerOptions.InstanceGroupManagerPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManager)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroupManager : Delete an instance group manager
// This request deletes an instance group manager. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceGroupManager(deleteInstanceGroupManagerOptions *DeleteInstanceGroupManagerOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupManagerWithContext(context.Background(), deleteInstanceGroupManagerOptions)
}

// DeleteInstanceGroupManagerWithContext is an alternate form of the DeleteInstanceGroupManager method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupManagerWithContext(ctx context.Context, deleteInstanceGroupManagerOptions *DeleteInstanceGroupManagerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupManagerOptions, "deleteInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupManagerOptions, "deleteInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *deleteInstanceGroupManagerOptions.InstanceGroupID,
		"id":                *deleteInstanceGroupManagerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupManager : Retrieve an instance group manager
// This request retrieves a single instance group manager specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupManager(getInstanceGroupManagerOptions *GetInstanceGroupManagerOptions) (result InstanceGroupManagerIntf, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceGroupManagerWithContext(context.Background(), getInstanceGroupManagerOptions)
}

// GetInstanceGroupManagerWithContext is an alternate form of the GetInstanceGroupManager method which supports a Context parameter
func (vpc *VpcV1) GetInstanceGroupManagerWithContext(ctx context.Context, getInstanceGroupManagerOptions *GetInstanceGroupManagerOptions) (result InstanceGroupManagerIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupManagerOptions, "getInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupManagerOptions, "getInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *getInstanceGroupManagerOptions.InstanceGroupID,
		"id":                *getInstanceGroupManagerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManager)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceGroupManager : Update an instance group manager
// This request updates an instance group manager with the information provided instance group manager patch.
func (vpc *VpcV1) UpdateInstanceGroupManager(updateInstanceGroupManagerOptions *UpdateInstanceGroupManagerOptions) (result InstanceGroupManagerIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceGroupManagerWithContext(context.Background(), updateInstanceGroupManagerOptions)
}

// UpdateInstanceGroupManagerWithContext is an alternate form of the UpdateInstanceGroupManager method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceGroupManagerWithContext(ctx context.Context, updateInstanceGroupManagerOptions *UpdateInstanceGroupManagerOptions) (result InstanceGroupManagerIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupManagerOptions, "updateInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupManagerOptions, "updateInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *updateInstanceGroupManagerOptions.InstanceGroupID,
		"id":                *updateInstanceGroupManagerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceGroupManagerOptions.InstanceGroupManagerPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManager)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceGroupManagerActions : List all actions for an instance group manager
// This request lists all instance group actions for an instance group manager.
func (vpc *VpcV1) ListInstanceGroupManagerActions(listInstanceGroupManagerActionsOptions *ListInstanceGroupManagerActionsOptions) (result *InstanceGroupManagerActionsCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceGroupManagerActionsWithContext(context.Background(), listInstanceGroupManagerActionsOptions)
}

// ListInstanceGroupManagerActionsWithContext is an alternate form of the ListInstanceGroupManagerActions method which supports a Context parameter
func (vpc *VpcV1) ListInstanceGroupManagerActionsWithContext(ctx context.Context, listInstanceGroupManagerActionsOptions *ListInstanceGroupManagerActionsOptions) (result *InstanceGroupManagerActionsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupManagerActionsOptions, "listInstanceGroupManagerActionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupManagerActionsOptions, "listInstanceGroupManagerActionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *listInstanceGroupManagerActionsOptions.InstanceGroupID,
		"instance_group_manager_id": *listInstanceGroupManagerActionsOptions.InstanceGroupManagerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupManagerActionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupManagerActions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceGroupManagerActionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceGroupManagerActionsOptions.Start))
	}
	if listInstanceGroupManagerActionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceGroupManagerActionsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerActionsCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceGroupManagerAction : Create an instance group manager action
// This request creates a new instance group manager action.
func (vpc *VpcV1) CreateInstanceGroupManagerAction(createInstanceGroupManagerActionOptions *CreateInstanceGroupManagerActionOptions) (result InstanceGroupManagerActionIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceGroupManagerActionWithContext(context.Background(), createInstanceGroupManagerActionOptions)
}

// CreateInstanceGroupManagerActionWithContext is an alternate form of the CreateInstanceGroupManagerAction method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceGroupManagerActionWithContext(ctx context.Context, createInstanceGroupManagerActionOptions *CreateInstanceGroupManagerActionOptions) (result InstanceGroupManagerActionIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupManagerActionOptions, "createInstanceGroupManagerActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupManagerActionOptions, "createInstanceGroupManagerActionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *createInstanceGroupManagerActionOptions.InstanceGroupID,
		"instance_group_manager_id": *createInstanceGroupManagerActionOptions.InstanceGroupManagerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupManagerActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroupManagerAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceGroupManagerActionOptions.InstanceGroupManagerActionPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerAction)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroupManagerAction : Delete specified instance group manager action
// This request deletes an instance group manager action. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceGroupManagerAction(deleteInstanceGroupManagerActionOptions *DeleteInstanceGroupManagerActionOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupManagerActionWithContext(context.Background(), deleteInstanceGroupManagerActionOptions)
}

// DeleteInstanceGroupManagerActionWithContext is an alternate form of the DeleteInstanceGroupManagerAction method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupManagerActionWithContext(ctx context.Context, deleteInstanceGroupManagerActionOptions *DeleteInstanceGroupManagerActionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupManagerActionOptions, "deleteInstanceGroupManagerActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupManagerActionOptions, "deleteInstanceGroupManagerActionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *deleteInstanceGroupManagerActionOptions.InstanceGroupID,
		"instance_group_manager_id": *deleteInstanceGroupManagerActionOptions.InstanceGroupManagerID,
		"id":                        *deleteInstanceGroupManagerActionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupManagerActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupManagerAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupManagerAction : Retrieve specified instance group manager action
// This request retrieves a single instance group manager action specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupManagerAction(getInstanceGroupManagerActionOptions *GetInstanceGroupManagerActionOptions) (result InstanceGroupManagerActionIntf, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceGroupManagerActionWithContext(context.Background(), getInstanceGroupManagerActionOptions)
}

// GetInstanceGroupManagerActionWithContext is an alternate form of the GetInstanceGroupManagerAction method which supports a Context parameter
func (vpc *VpcV1) GetInstanceGroupManagerActionWithContext(ctx context.Context, getInstanceGroupManagerActionOptions *GetInstanceGroupManagerActionOptions) (result InstanceGroupManagerActionIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupManagerActionOptions, "getInstanceGroupManagerActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupManagerActionOptions, "getInstanceGroupManagerActionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *getInstanceGroupManagerActionOptions.InstanceGroupID,
		"instance_group_manager_id": *getInstanceGroupManagerActionOptions.InstanceGroupManagerID,
		"id":                        *getInstanceGroupManagerActionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupManagerActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupManagerAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerAction)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceGroupManagerAction : Update specified instance group manager action
// This request updates an instance group manager action.
func (vpc *VpcV1) UpdateInstanceGroupManagerAction(updateInstanceGroupManagerActionOptions *UpdateInstanceGroupManagerActionOptions) (result InstanceGroupManagerActionIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceGroupManagerActionWithContext(context.Background(), updateInstanceGroupManagerActionOptions)
}

// UpdateInstanceGroupManagerActionWithContext is an alternate form of the UpdateInstanceGroupManagerAction method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceGroupManagerActionWithContext(ctx context.Context, updateInstanceGroupManagerActionOptions *UpdateInstanceGroupManagerActionOptions) (result InstanceGroupManagerActionIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupManagerActionOptions, "updateInstanceGroupManagerActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupManagerActionOptions, "updateInstanceGroupManagerActionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *updateInstanceGroupManagerActionOptions.InstanceGroupID,
		"instance_group_manager_id": *updateInstanceGroupManagerActionOptions.InstanceGroupManagerID,
		"id":                        *updateInstanceGroupManagerActionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/actions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupManagerActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupManagerAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceGroupManagerActionOptions.InstanceGroupManagerActionPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerAction)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListInstanceGroupManagerPolicies : List all policies for an instance group manager
// This request lists all policies for an instance group manager.
func (vpc *VpcV1) ListInstanceGroupManagerPolicies(listInstanceGroupManagerPoliciesOptions *ListInstanceGroupManagerPoliciesOptions) (result *InstanceGroupManagerPolicyCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceGroupManagerPoliciesWithContext(context.Background(), listInstanceGroupManagerPoliciesOptions)
}

// ListInstanceGroupManagerPoliciesWithContext is an alternate form of the ListInstanceGroupManagerPolicies method which supports a Context parameter
func (vpc *VpcV1) ListInstanceGroupManagerPoliciesWithContext(ctx context.Context, listInstanceGroupManagerPoliciesOptions *ListInstanceGroupManagerPoliciesOptions) (result *InstanceGroupManagerPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupManagerPoliciesOptions, "listInstanceGroupManagerPoliciesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupManagerPoliciesOptions, "listInstanceGroupManagerPoliciesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *listInstanceGroupManagerPoliciesOptions.InstanceGroupID,
		"instance_group_manager_id": *listInstanceGroupManagerPoliciesOptions.InstanceGroupManagerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupManagerPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupManagerPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceGroupManagerPoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceGroupManagerPoliciesOptions.Start))
	}
	if listInstanceGroupManagerPoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceGroupManagerPoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicyCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateInstanceGroupManagerPolicy : Create a policy for an instance group manager
// This request creates a new instance group manager policy.
func (vpc *VpcV1) CreateInstanceGroupManagerPolicy(createInstanceGroupManagerPolicyOptions *CreateInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateInstanceGroupManagerPolicyWithContext(context.Background(), createInstanceGroupManagerPolicyOptions)
}

// CreateInstanceGroupManagerPolicyWithContext is an alternate form of the CreateInstanceGroupManagerPolicy method which supports a Context parameter
func (vpc *VpcV1) CreateInstanceGroupManagerPolicyWithContext(ctx context.Context, createInstanceGroupManagerPolicyOptions *CreateInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupManagerPolicyOptions, "createInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupManagerPolicyOptions, "createInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *createInstanceGroupManagerPolicyOptions.InstanceGroupID,
		"instance_group_manager_id": *createInstanceGroupManagerPolicyOptions.InstanceGroupManagerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceGroupManagerPolicyOptions.InstanceGroupManagerPolicyPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroupManagerPolicy : Delete an instance group manager policy
// This request deletes an instance group manager policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceGroupManagerPolicy(deleteInstanceGroupManagerPolicyOptions *DeleteInstanceGroupManagerPolicyOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupManagerPolicyWithContext(context.Background(), deleteInstanceGroupManagerPolicyOptions)
}

// DeleteInstanceGroupManagerPolicyWithContext is an alternate form of the DeleteInstanceGroupManagerPolicy method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupManagerPolicyWithContext(ctx context.Context, deleteInstanceGroupManagerPolicyOptions *DeleteInstanceGroupManagerPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupManagerPolicyOptions, "deleteInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupManagerPolicyOptions, "deleteInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *deleteInstanceGroupManagerPolicyOptions.InstanceGroupID,
		"instance_group_manager_id": *deleteInstanceGroupManagerPolicyOptions.InstanceGroupManagerID,
		"id":                        *deleteInstanceGroupManagerPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupManagerPolicy : Retrieve an instance group manager policy
// This request retrieves a single instance group manager policy specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupManagerPolicy(getInstanceGroupManagerPolicyOptions *GetInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceGroupManagerPolicyWithContext(context.Background(), getInstanceGroupManagerPolicyOptions)
}

// GetInstanceGroupManagerPolicyWithContext is an alternate form of the GetInstanceGroupManagerPolicy method which supports a Context parameter
func (vpc *VpcV1) GetInstanceGroupManagerPolicyWithContext(ctx context.Context, getInstanceGroupManagerPolicyOptions *GetInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupManagerPolicyOptions, "getInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupManagerPolicyOptions, "getInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *getInstanceGroupManagerPolicyOptions.InstanceGroupID,
		"instance_group_manager_id": *getInstanceGroupManagerPolicyOptions.InstanceGroupManagerID,
		"id":                        *getInstanceGroupManagerPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceGroupManagerPolicy : Update an instance group manager policy
// This request updates an instance group manager policy.
func (vpc *VpcV1) UpdateInstanceGroupManagerPolicy(updateInstanceGroupManagerPolicyOptions *UpdateInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceGroupManagerPolicyWithContext(context.Background(), updateInstanceGroupManagerPolicyOptions)
}

// UpdateInstanceGroupManagerPolicyWithContext is an alternate form of the UpdateInstanceGroupManagerPolicy method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceGroupManagerPolicyWithContext(ctx context.Context, updateInstanceGroupManagerPolicyOptions *UpdateInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupManagerPolicyOptions, "updateInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupManagerPolicyOptions, "updateInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id":         *updateInstanceGroupManagerPolicyOptions.InstanceGroupID,
		"instance_group_manager_id": *updateInstanceGroupManagerPolicyOptions.InstanceGroupManagerID,
		"id":                        *updateInstanceGroupManagerPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/managers/{instance_group_manager_id}/policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceGroupManagerPolicyOptions.InstanceGroupManagerPolicyPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroupMemberships : Delete all memberships from an instance group
// This request deletes all memberships of an instance group. This operation cannot be reversed. reversed. Any
// memberships that have `delete_instance_on_membership_delete` set to `true` will also have their instances deleted.
func (vpc *VpcV1) DeleteInstanceGroupMemberships(deleteInstanceGroupMembershipsOptions *DeleteInstanceGroupMembershipsOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupMembershipsWithContext(context.Background(), deleteInstanceGroupMembershipsOptions)
}

// DeleteInstanceGroupMembershipsWithContext is an alternate form of the DeleteInstanceGroupMemberships method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupMembershipsWithContext(ctx context.Context, deleteInstanceGroupMembershipsOptions *DeleteInstanceGroupMembershipsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupMembershipsOptions, "deleteInstanceGroupMembershipsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupMembershipsOptions, "deleteInstanceGroupMembershipsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *deleteInstanceGroupMembershipsOptions.InstanceGroupID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/memberships`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupMembershipsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupMemberships")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListInstanceGroupMemberships : List all memberships for an instance group
// This request lists all instance group memberships for an instance group.
func (vpc *VpcV1) ListInstanceGroupMemberships(listInstanceGroupMembershipsOptions *ListInstanceGroupMembershipsOptions) (result *InstanceGroupMembershipCollection, response *core.DetailedResponse, err error) {
	return vpc.ListInstanceGroupMembershipsWithContext(context.Background(), listInstanceGroupMembershipsOptions)
}

// ListInstanceGroupMembershipsWithContext is an alternate form of the ListInstanceGroupMemberships method which supports a Context parameter
func (vpc *VpcV1) ListInstanceGroupMembershipsWithContext(ctx context.Context, listInstanceGroupMembershipsOptions *ListInstanceGroupMembershipsOptions) (result *InstanceGroupMembershipCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupMembershipsOptions, "listInstanceGroupMembershipsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupMembershipsOptions, "listInstanceGroupMembershipsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *listInstanceGroupMembershipsOptions.InstanceGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/memberships`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupMembershipsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupMemberships")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceGroupMembershipsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceGroupMembershipsOptions.Start))
	}
	if listInstanceGroupMembershipsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceGroupMembershipsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupMembershipCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteInstanceGroupMembership : Delete an instance group membership
// This request deletes a memberships of an instance group. This operation cannot be reversed. reversed. If the
// membership has `delete_instance_on_membership_delete` set to `true`, the instance will also be deleted.
func (vpc *VpcV1) DeleteInstanceGroupMembership(deleteInstanceGroupMembershipOptions *DeleteInstanceGroupMembershipOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteInstanceGroupMembershipWithContext(context.Background(), deleteInstanceGroupMembershipOptions)
}

// DeleteInstanceGroupMembershipWithContext is an alternate form of the DeleteInstanceGroupMembership method which supports a Context parameter
func (vpc *VpcV1) DeleteInstanceGroupMembershipWithContext(ctx context.Context, deleteInstanceGroupMembershipOptions *DeleteInstanceGroupMembershipOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupMembershipOptions, "deleteInstanceGroupMembershipOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupMembershipOptions, "deleteInstanceGroupMembershipOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *deleteInstanceGroupMembershipOptions.InstanceGroupID,
		"id":                *deleteInstanceGroupMembershipOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/memberships/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupMembershipOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupMembership")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupMembership : Retrieve an instance group membership
// This request retrieves a single instance group membership specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupMembership(getInstanceGroupMembershipOptions *GetInstanceGroupMembershipOptions) (result *InstanceGroupMembership, response *core.DetailedResponse, err error) {
	return vpc.GetInstanceGroupMembershipWithContext(context.Background(), getInstanceGroupMembershipOptions)
}

// GetInstanceGroupMembershipWithContext is an alternate form of the GetInstanceGroupMembership method which supports a Context parameter
func (vpc *VpcV1) GetInstanceGroupMembershipWithContext(ctx context.Context, getInstanceGroupMembershipOptions *GetInstanceGroupMembershipOptions) (result *InstanceGroupMembership, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupMembershipOptions, "getInstanceGroupMembershipOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupMembershipOptions, "getInstanceGroupMembershipOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *getInstanceGroupMembershipOptions.InstanceGroupID,
		"id":                *getInstanceGroupMembershipOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/memberships/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupMembershipOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupMembership")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupMembership)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateInstanceGroupMembership : Update an instance group membership
// This request updates an instance group membership with the information provided instance group membership patch.
func (vpc *VpcV1) UpdateInstanceGroupMembership(updateInstanceGroupMembershipOptions *UpdateInstanceGroupMembershipOptions) (result *InstanceGroupMembership, response *core.DetailedResponse, err error) {
	return vpc.UpdateInstanceGroupMembershipWithContext(context.Background(), updateInstanceGroupMembershipOptions)
}

// UpdateInstanceGroupMembershipWithContext is an alternate form of the UpdateInstanceGroupMembership method which supports a Context parameter
func (vpc *VpcV1) UpdateInstanceGroupMembershipWithContext(ctx context.Context, updateInstanceGroupMembershipOptions *UpdateInstanceGroupMembershipOptions) (result *InstanceGroupMembership, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupMembershipOptions, "updateInstanceGroupMembershipOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupMembershipOptions, "updateInstanceGroupMembershipOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_group_id": *updateInstanceGroupMembershipOptions.InstanceGroupID,
		"id":                *updateInstanceGroupMembershipOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/instance_groups/{instance_group_id}/memberships/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupMembershipOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupMembership")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateInstanceGroupMembershipOptions.InstanceGroupMembershipPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupMembership)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDedicatedHostGroups : List all dedicated host groups
// This request lists all dedicated host groups in the region. Host groups are a collection of dedicated hosts for
// placement of instances. Each dedicated host must belong to one and only one group. Host groups do not span zones.
func (vpc *VpcV1) ListDedicatedHostGroups(listDedicatedHostGroupsOptions *ListDedicatedHostGroupsOptions) (result *DedicatedHostGroupCollection, response *core.DetailedResponse, err error) {
	return vpc.ListDedicatedHostGroupsWithContext(context.Background(), listDedicatedHostGroupsOptions)
}

// ListDedicatedHostGroupsWithContext is an alternate form of the ListDedicatedHostGroups method which supports a Context parameter
func (vpc *VpcV1) ListDedicatedHostGroupsWithContext(ctx context.Context, listDedicatedHostGroupsOptions *ListDedicatedHostGroupsOptions) (result *DedicatedHostGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listDedicatedHostGroupsOptions, "listDedicatedHostGroupsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHostGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listDedicatedHostGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listDedicatedHostGroupsOptions.Start))
	}
	if listDedicatedHostGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDedicatedHostGroupsOptions.Limit))
	}
	if listDedicatedHostGroupsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listDedicatedHostGroupsOptions.ResourceGroupID))
	}
	if listDedicatedHostGroupsOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listDedicatedHostGroupsOptions.ZoneName))
	}
	if listDedicatedHostGroupsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listDedicatedHostGroupsOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroupCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateDedicatedHostGroup : Create a dedicated host group
// This request creates a new dedicated host group.
func (vpc *VpcV1) CreateDedicatedHostGroup(createDedicatedHostGroupOptions *CreateDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	return vpc.CreateDedicatedHostGroupWithContext(context.Background(), createDedicatedHostGroupOptions)
}

// CreateDedicatedHostGroupWithContext is an alternate form of the CreateDedicatedHostGroup method which supports a Context parameter
func (vpc *VpcV1) CreateDedicatedHostGroupWithContext(ctx context.Context, createDedicatedHostGroupOptions *CreateDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDedicatedHostGroupOptions, "createDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDedicatedHostGroupOptions, "createDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createDedicatedHostGroupOptions.Class != nil {
		body["class"] = createDedicatedHostGroupOptions.Class
	}
	if createDedicatedHostGroupOptions.Family != nil {
		body["family"] = createDedicatedHostGroupOptions.Family
	}
	if createDedicatedHostGroupOptions.Zone != nil {
		body["zone"] = createDedicatedHostGroupOptions.Zone
	}
	if createDedicatedHostGroupOptions.Name != nil {
		body["name"] = createDedicatedHostGroupOptions.Name
	}
	if createDedicatedHostGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createDedicatedHostGroupOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDedicatedHostGroup : Delete a dedicated host group
// This request deletes a dedicated host group.
func (vpc *VpcV1) DeleteDedicatedHostGroup(deleteDedicatedHostGroupOptions *DeleteDedicatedHostGroupOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteDedicatedHostGroupWithContext(context.Background(), deleteDedicatedHostGroupOptions)
}

// DeleteDedicatedHostGroupWithContext is an alternate form of the DeleteDedicatedHostGroup method which supports a Context parameter
func (vpc *VpcV1) DeleteDedicatedHostGroupWithContext(ctx context.Context, deleteDedicatedHostGroupOptions *DeleteDedicatedHostGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDedicatedHostGroupOptions, "deleteDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDedicatedHostGroupOptions, "deleteDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteDedicatedHostGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetDedicatedHostGroup : Retrieve a dedicated host group
// This request retrieves a single dedicated host group specified by the identifier in the URL.
func (vpc *VpcV1) GetDedicatedHostGroup(getDedicatedHostGroupOptions *GetDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	return vpc.GetDedicatedHostGroupWithContext(context.Background(), getDedicatedHostGroupOptions)
}

// GetDedicatedHostGroupWithContext is an alternate form of the GetDedicatedHostGroup method which supports a Context parameter
func (vpc *VpcV1) GetDedicatedHostGroupWithContext(ctx context.Context, getDedicatedHostGroupOptions *GetDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostGroupOptions, "getDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostGroupOptions, "getDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getDedicatedHostGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDedicatedHostGroup : Update a dedicated host group
// This request updates a dedicated host group with the information in a provided dedicated host group patch. The
// dedicated host group patch object is structured in the same way as a retrieved dedicated host group and contains only
// the information to be updated.
func (vpc *VpcV1) UpdateDedicatedHostGroup(updateDedicatedHostGroupOptions *UpdateDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	return vpc.UpdateDedicatedHostGroupWithContext(context.Background(), updateDedicatedHostGroupOptions)
}

// UpdateDedicatedHostGroupWithContext is an alternate form of the UpdateDedicatedHostGroup method which supports a Context parameter
func (vpc *VpcV1) UpdateDedicatedHostGroupWithContext(ctx context.Context, updateDedicatedHostGroupOptions *UpdateDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDedicatedHostGroupOptions, "updateDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDedicatedHostGroupOptions, "updateDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateDedicatedHostGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateDedicatedHostGroupOptions.DedicatedHostGroupPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDedicatedHostProfiles : List all dedicated host profiles
// This request lists provisionable [dedicated host profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) in
// the region. A dedicated host profile specifies the hardware characteristics for a dedicated host.
func (vpc *VpcV1) ListDedicatedHostProfiles(listDedicatedHostProfilesOptions *ListDedicatedHostProfilesOptions) (result *DedicatedHostProfileCollection, response *core.DetailedResponse, err error) {
	return vpc.ListDedicatedHostProfilesWithContext(context.Background(), listDedicatedHostProfilesOptions)
}

// ListDedicatedHostProfilesWithContext is an alternate form of the ListDedicatedHostProfiles method which supports a Context parameter
func (vpc *VpcV1) ListDedicatedHostProfilesWithContext(ctx context.Context, listDedicatedHostProfilesOptions *ListDedicatedHostProfilesOptions) (result *DedicatedHostProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listDedicatedHostProfilesOptions, "listDedicatedHostProfilesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/profiles`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHostProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listDedicatedHostProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listDedicatedHostProfilesOptions.Start))
	}
	if listDedicatedHostProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDedicatedHostProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostProfileCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDedicatedHostProfile : Retrieve a dedicated host profile
// This request retrieves a single dedicated host profile specified by the name in the URL.
func (vpc *VpcV1) GetDedicatedHostProfile(getDedicatedHostProfileOptions *GetDedicatedHostProfileOptions) (result *DedicatedHostProfile, response *core.DetailedResponse, err error) {
	return vpc.GetDedicatedHostProfileWithContext(context.Background(), getDedicatedHostProfileOptions)
}

// GetDedicatedHostProfileWithContext is an alternate form of the GetDedicatedHostProfile method which supports a Context parameter
func (vpc *VpcV1) GetDedicatedHostProfileWithContext(ctx context.Context, getDedicatedHostProfileOptions *GetDedicatedHostProfileOptions) (result *DedicatedHostProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostProfileOptions, "getDedicatedHostProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostProfileOptions, "getDedicatedHostProfileOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getDedicatedHostProfileOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_host/profiles/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHostProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDedicatedHosts : List all dedicated hosts
// This request lists all dedicated hosts in the region.
func (vpc *VpcV1) ListDedicatedHosts(listDedicatedHostsOptions *ListDedicatedHostsOptions) (result *DedicatedHostCollection, response *core.DetailedResponse, err error) {
	return vpc.ListDedicatedHostsWithContext(context.Background(), listDedicatedHostsOptions)
}

// ListDedicatedHostsWithContext is an alternate form of the ListDedicatedHosts method which supports a Context parameter
func (vpc *VpcV1) ListDedicatedHostsWithContext(ctx context.Context, listDedicatedHostsOptions *ListDedicatedHostsOptions) (result *DedicatedHostCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listDedicatedHostsOptions, "listDedicatedHostsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHosts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listDedicatedHostsOptions.DedicatedHostGroupID != nil {
		builder.AddQuery("dedicated_host_group.id", fmt.Sprint(*listDedicatedHostsOptions.DedicatedHostGroupID))
	}
	if listDedicatedHostsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listDedicatedHostsOptions.Start))
	}
	if listDedicatedHostsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDedicatedHostsOptions.Limit))
	}
	if listDedicatedHostsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listDedicatedHostsOptions.ResourceGroupID))
	}
	if listDedicatedHostsOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listDedicatedHostsOptions.ZoneName))
	}
	if listDedicatedHostsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listDedicatedHostsOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateDedicatedHost : Create a dedicated host
// This request creates a new dedicated host.
func (vpc *VpcV1) CreateDedicatedHost(createDedicatedHostOptions *CreateDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	return vpc.CreateDedicatedHostWithContext(context.Background(), createDedicatedHostOptions)
}

// CreateDedicatedHostWithContext is an alternate form of the CreateDedicatedHost method which supports a Context parameter
func (vpc *VpcV1) CreateDedicatedHostWithContext(ctx context.Context, createDedicatedHostOptions *CreateDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDedicatedHostOptions, "createDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDedicatedHostOptions, "createDedicatedHostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createDedicatedHostOptions.DedicatedHostPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHost)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDedicatedHostDisks : List all disks on a dedicated host
// This request lists all disks on a dedicated host.  A disk is a physical device that is locally attached to the
// compute node. By default, the listed disks are sorted by their
// `created_at` property values, with the newest disk first.
func (vpc *VpcV1) ListDedicatedHostDisks(listDedicatedHostDisksOptions *ListDedicatedHostDisksOptions) (result *DedicatedHostDiskCollection, response *core.DetailedResponse, err error) {
	return vpc.ListDedicatedHostDisksWithContext(context.Background(), listDedicatedHostDisksOptions)
}

// ListDedicatedHostDisksWithContext is an alternate form of the ListDedicatedHostDisks method which supports a Context parameter
func (vpc *VpcV1) ListDedicatedHostDisksWithContext(ctx context.Context, listDedicatedHostDisksOptions *ListDedicatedHostDisksOptions) (result *DedicatedHostDiskCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDedicatedHostDisksOptions, "listDedicatedHostDisksOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDedicatedHostDisksOptions, "listDedicatedHostDisksOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"dedicated_host_id": *listDedicatedHostDisksOptions.DedicatedHostID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts/{dedicated_host_id}/disks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostDisksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHostDisks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostDiskCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDedicatedHostDisk : Retrieve a dedicated host disk
// This request retrieves a single dedicated host disk specified by the identifier in the URL.
func (vpc *VpcV1) GetDedicatedHostDisk(getDedicatedHostDiskOptions *GetDedicatedHostDiskOptions) (result *DedicatedHostDisk, response *core.DetailedResponse, err error) {
	return vpc.GetDedicatedHostDiskWithContext(context.Background(), getDedicatedHostDiskOptions)
}

// GetDedicatedHostDiskWithContext is an alternate form of the GetDedicatedHostDisk method which supports a Context parameter
func (vpc *VpcV1) GetDedicatedHostDiskWithContext(ctx context.Context, getDedicatedHostDiskOptions *GetDedicatedHostDiskOptions) (result *DedicatedHostDisk, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostDiskOptions, "getDedicatedHostDiskOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostDiskOptions, "getDedicatedHostDiskOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"dedicated_host_id": *getDedicatedHostDiskOptions.DedicatedHostID,
		"id":                *getDedicatedHostDiskOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts/{dedicated_host_id}/disks/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostDiskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHostDisk")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostDisk)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDedicatedHostDisk : Update a dedicated host disk
// This request updates the dedicated host disk with the information in a provided patch.
func (vpc *VpcV1) UpdateDedicatedHostDisk(updateDedicatedHostDiskOptions *UpdateDedicatedHostDiskOptions) (result *DedicatedHostDisk, response *core.DetailedResponse, err error) {
	return vpc.UpdateDedicatedHostDiskWithContext(context.Background(), updateDedicatedHostDiskOptions)
}

// UpdateDedicatedHostDiskWithContext is an alternate form of the UpdateDedicatedHostDisk method which supports a Context parameter
func (vpc *VpcV1) UpdateDedicatedHostDiskWithContext(ctx context.Context, updateDedicatedHostDiskOptions *UpdateDedicatedHostDiskOptions) (result *DedicatedHostDisk, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDedicatedHostDiskOptions, "updateDedicatedHostDiskOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDedicatedHostDiskOptions, "updateDedicatedHostDiskOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"dedicated_host_id": *updateDedicatedHostDiskOptions.DedicatedHostID,
		"id":                *updateDedicatedHostDiskOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts/{dedicated_host_id}/disks/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDedicatedHostDiskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateDedicatedHostDisk")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateDedicatedHostDiskOptions.DedicatedHostDiskPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostDisk)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDedicatedHost : Delete a dedicated host
// This request deletes a dedicated host.
func (vpc *VpcV1) DeleteDedicatedHost(deleteDedicatedHostOptions *DeleteDedicatedHostOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteDedicatedHostWithContext(context.Background(), deleteDedicatedHostOptions)
}

// DeleteDedicatedHostWithContext is an alternate form of the DeleteDedicatedHost method which supports a Context parameter
func (vpc *VpcV1) DeleteDedicatedHostWithContext(ctx context.Context, deleteDedicatedHostOptions *DeleteDedicatedHostOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDedicatedHostOptions, "deleteDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDedicatedHostOptions, "deleteDedicatedHostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteDedicatedHostOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetDedicatedHost : Retrieve a dedicated host
// This request retrieves a single dedicated host specified by the identifiers in the URL.
func (vpc *VpcV1) GetDedicatedHost(getDedicatedHostOptions *GetDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	return vpc.GetDedicatedHostWithContext(context.Background(), getDedicatedHostOptions)
}

// GetDedicatedHostWithContext is an alternate form of the GetDedicatedHost method which supports a Context parameter
func (vpc *VpcV1) GetDedicatedHostWithContext(ctx context.Context, getDedicatedHostOptions *GetDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostOptions, "getDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostOptions, "getDedicatedHostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getDedicatedHostOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHost)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDedicatedHost : Update a dedicated host
// This request updates a dedicated host with the information in a provided dedicated host patch. The dedicated host
// patch object is structured in the same way as a retrieved dedicated host and contains only the information to be
// updated.
func (vpc *VpcV1) UpdateDedicatedHost(updateDedicatedHostOptions *UpdateDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	return vpc.UpdateDedicatedHostWithContext(context.Background(), updateDedicatedHostOptions)
}

// UpdateDedicatedHostWithContext is an alternate form of the UpdateDedicatedHost method which supports a Context parameter
func (vpc *VpcV1) UpdateDedicatedHostWithContext(ctx context.Context, updateDedicatedHostOptions *UpdateDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDedicatedHostOptions, "updateDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDedicatedHostOptions, "updateDedicatedHostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateDedicatedHostOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/dedicated_hosts/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateDedicatedHostOptions.DedicatedHostPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHost)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBackupPolicies : List all backup policies
// This request lists all backup policies in the region. Backup policies control which sources are selected for backup
// and include a set of backup policy plans that provide the backup schedules and deletion triggers.
func (vpc *VpcV1) ListBackupPolicies(listBackupPoliciesOptions *ListBackupPoliciesOptions) (result *BackupPolicyCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBackupPoliciesWithContext(context.Background(), listBackupPoliciesOptions)
}

// ListBackupPoliciesWithContext is an alternate form of the ListBackupPolicies method which supports a Context parameter
func (vpc *VpcV1) ListBackupPoliciesWithContext(ctx context.Context, listBackupPoliciesOptions *ListBackupPoliciesOptions) (result *BackupPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listBackupPoliciesOptions, "listBackupPoliciesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBackupPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBackupPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listBackupPoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listBackupPoliciesOptions.Start))
	}
	if listBackupPoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listBackupPoliciesOptions.Limit))
	}
	if listBackupPoliciesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listBackupPoliciesOptions.ResourceGroupID))
	}
	if listBackupPoliciesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listBackupPoliciesOptions.Name))
	}
	if listBackupPoliciesOptions.Tag != nil {
		builder.AddQuery("tag", fmt.Sprint(*listBackupPoliciesOptions.Tag))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateBackupPolicy : Create a backup policy
// This request creates a new backup policy from a backup policy prototype object. The prototype object is structured in
// the same way as a retrieved backup policy, and contains the information necessary to create the new backup policy.
func (vpc *VpcV1) CreateBackupPolicy(createBackupPolicyOptions *CreateBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	return vpc.CreateBackupPolicyWithContext(context.Background(), createBackupPolicyOptions)
}

// CreateBackupPolicyWithContext is an alternate form of the CreateBackupPolicy method which supports a Context parameter
func (vpc *VpcV1) CreateBackupPolicyWithContext(ctx context.Context, createBackupPolicyOptions *CreateBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createBackupPolicyOptions, "createBackupPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createBackupPolicyOptions, "createBackupPolicyOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createBackupPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateBackupPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createBackupPolicyOptions.MatchUserTags != nil {
		body["match_user_tags"] = createBackupPolicyOptions.MatchUserTags
	}
	if createBackupPolicyOptions.MatchResourceTypes != nil {
		body["match_resource_types"] = createBackupPolicyOptions.MatchResourceTypes
	}
	if createBackupPolicyOptions.Name != nil {
		body["name"] = createBackupPolicyOptions.Name
	}
	if createBackupPolicyOptions.Plans != nil {
		body["plans"] = createBackupPolicyOptions.Plans
	}
	if createBackupPolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createBackupPolicyOptions.ResourceGroup
	}
	if createBackupPolicyOptions.Scope != nil {
		body["scope"] = createBackupPolicyOptions.Scope
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBackupPolicyJobs : List all jobs for a backup policy
// This request retrieves all jobs for a backup policy. A backup job represents the execution of a backup policy plan
// for a resource matching the policy's criteria.
func (vpc *VpcV1) ListBackupPolicyJobs(listBackupPolicyJobsOptions *ListBackupPolicyJobsOptions) (result *BackupPolicyJobCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBackupPolicyJobsWithContext(context.Background(), listBackupPolicyJobsOptions)
}

// ListBackupPolicyJobsWithContext is an alternate form of the ListBackupPolicyJobs method which supports a Context parameter
func (vpc *VpcV1) ListBackupPolicyJobsWithContext(ctx context.Context, listBackupPolicyJobsOptions *ListBackupPolicyJobsOptions) (result *BackupPolicyJobCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBackupPolicyJobsOptions, "listBackupPolicyJobsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBackupPolicyJobsOptions, "listBackupPolicyJobsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *listBackupPolicyJobsOptions.BackupPolicyID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/jobs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBackupPolicyJobsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBackupPolicyJobs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listBackupPolicyJobsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listBackupPolicyJobsOptions.Status))
	}
	if listBackupPolicyJobsOptions.BackupPolicyPlanID != nil {
		builder.AddQuery("backup_policy_plan.id", fmt.Sprint(*listBackupPolicyJobsOptions.BackupPolicyPlanID))
	}
	if listBackupPolicyJobsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listBackupPolicyJobsOptions.Start))
	}
	if listBackupPolicyJobsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listBackupPolicyJobsOptions.Limit))
	}
	if listBackupPolicyJobsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listBackupPolicyJobsOptions.Sort))
	}
	if listBackupPolicyJobsOptions.SourceID != nil {
		builder.AddQuery("source.id", fmt.Sprint(*listBackupPolicyJobsOptions.SourceID))
	}
	if listBackupPolicyJobsOptions.TargetSnapshotsID != nil {
		builder.AddQuery("target_snapshots[].id", fmt.Sprint(*listBackupPolicyJobsOptions.TargetSnapshotsID))
	}
	if listBackupPolicyJobsOptions.TargetSnapshotsCRN != nil {
		builder.AddQuery("target_snapshots[].crn", fmt.Sprint(*listBackupPolicyJobsOptions.TargetSnapshotsCRN))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyJobCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBackupPolicyJob : Retrieve a backup policy job
// This request retrieves a single backup policy job specified by the identifier in the URL.
func (vpc *VpcV1) GetBackupPolicyJob(getBackupPolicyJobOptions *GetBackupPolicyJobOptions) (result *BackupPolicyJob, response *core.DetailedResponse, err error) {
	return vpc.GetBackupPolicyJobWithContext(context.Background(), getBackupPolicyJobOptions)
}

// GetBackupPolicyJobWithContext is an alternate form of the GetBackupPolicyJob method which supports a Context parameter
func (vpc *VpcV1) GetBackupPolicyJobWithContext(ctx context.Context, getBackupPolicyJobOptions *GetBackupPolicyJobOptions) (result *BackupPolicyJob, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBackupPolicyJobOptions, "getBackupPolicyJobOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBackupPolicyJobOptions, "getBackupPolicyJobOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *getBackupPolicyJobOptions.BackupPolicyID,
		"id":               *getBackupPolicyJobOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/jobs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBackupPolicyJobOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBackupPolicyJob")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBackupPolicyPlans : List all plans for a backup policy
// This request retrieves all plans for a backup policy. Backup plans provide the backup schedule and deletion triggers.
func (vpc *VpcV1) ListBackupPolicyPlans(listBackupPolicyPlansOptions *ListBackupPolicyPlansOptions) (result *BackupPolicyPlanCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBackupPolicyPlansWithContext(context.Background(), listBackupPolicyPlansOptions)
}

// ListBackupPolicyPlansWithContext is an alternate form of the ListBackupPolicyPlans method which supports a Context parameter
func (vpc *VpcV1) ListBackupPolicyPlansWithContext(ctx context.Context, listBackupPolicyPlansOptions *ListBackupPolicyPlansOptions) (result *BackupPolicyPlanCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBackupPolicyPlansOptions, "listBackupPolicyPlansOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBackupPolicyPlansOptions, "listBackupPolicyPlansOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *listBackupPolicyPlansOptions.BackupPolicyID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/plans`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBackupPolicyPlansOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBackupPolicyPlans")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listBackupPolicyPlansOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listBackupPolicyPlansOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyPlanCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateBackupPolicyPlan : Create a plan for a backup policy
// This request creates a new backup policy plan from a backup policy plan prototype object. The prototype object is
// structured in the same way as a retrieved backup policy plan, and contains the information necessary to create the
// new backup policy plan.
//
// Backups created by this plan will use the resource group of the source being backed up.
//
// Backups created by this plan will use the plan's name truncated to 46 characters, followed by a unique 16-character
// suffix.
func (vpc *VpcV1) CreateBackupPolicyPlan(createBackupPolicyPlanOptions *CreateBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	return vpc.CreateBackupPolicyPlanWithContext(context.Background(), createBackupPolicyPlanOptions)
}

// CreateBackupPolicyPlanWithContext is an alternate form of the CreateBackupPolicyPlan method which supports a Context parameter
func (vpc *VpcV1) CreateBackupPolicyPlanWithContext(ctx context.Context, createBackupPolicyPlanOptions *CreateBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createBackupPolicyPlanOptions, "createBackupPolicyPlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createBackupPolicyPlanOptions, "createBackupPolicyPlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *createBackupPolicyPlanOptions.BackupPolicyID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/plans`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createBackupPolicyPlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateBackupPolicyPlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createBackupPolicyPlanOptions.CronSpec != nil {
		body["cron_spec"] = createBackupPolicyPlanOptions.CronSpec
	}
	if createBackupPolicyPlanOptions.Active != nil {
		body["active"] = createBackupPolicyPlanOptions.Active
	}
	if createBackupPolicyPlanOptions.AttachUserTags != nil {
		body["attach_user_tags"] = createBackupPolicyPlanOptions.AttachUserTags
	}
	if createBackupPolicyPlanOptions.ClonePolicy != nil {
		body["clone_policy"] = createBackupPolicyPlanOptions.ClonePolicy
	}
	if createBackupPolicyPlanOptions.CopyUserTags != nil {
		body["copy_user_tags"] = createBackupPolicyPlanOptions.CopyUserTags
	}
	if createBackupPolicyPlanOptions.DeletionTrigger != nil {
		body["deletion_trigger"] = createBackupPolicyPlanOptions.DeletionTrigger
	}
	if createBackupPolicyPlanOptions.Name != nil {
		body["name"] = createBackupPolicyPlanOptions.Name
	}
	if createBackupPolicyPlanOptions.RemoteRegionPolicies != nil {
		body["remote_region_policies"] = createBackupPolicyPlanOptions.RemoteRegionPolicies
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyPlan)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteBackupPolicyPlan : Delete a backup policy plan
// This request deletes a backup policy plan. This operation cannot be reversed. Any backups that have been created by
// the plan will remain but will no longer be subject to the plan's deletion trigger. Any running jobs associated with
// the plan will run to completion before the plan is deleted.
//
// If the request is accepted, the backup policy plan `status` will be set to `deleting`. Once deletion processing
// completes, the backup policy plan will no longer be retrievable.
func (vpc *VpcV1) DeleteBackupPolicyPlan(deleteBackupPolicyPlanOptions *DeleteBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	return vpc.DeleteBackupPolicyPlanWithContext(context.Background(), deleteBackupPolicyPlanOptions)
}

// DeleteBackupPolicyPlanWithContext is an alternate form of the DeleteBackupPolicyPlan method which supports a Context parameter
func (vpc *VpcV1) DeleteBackupPolicyPlanWithContext(ctx context.Context, deleteBackupPolicyPlanOptions *DeleteBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteBackupPolicyPlanOptions, "deleteBackupPolicyPlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteBackupPolicyPlanOptions, "deleteBackupPolicyPlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *deleteBackupPolicyPlanOptions.BackupPolicyID,
		"id":               *deleteBackupPolicyPlanOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/plans/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteBackupPolicyPlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteBackupPolicyPlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if deleteBackupPolicyPlanOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteBackupPolicyPlanOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyPlan)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBackupPolicyPlan : Retrieve a backup policy plan
// This request retrieves a single backup policy plan specified by the identifier in the URL.
func (vpc *VpcV1) GetBackupPolicyPlan(getBackupPolicyPlanOptions *GetBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	return vpc.GetBackupPolicyPlanWithContext(context.Background(), getBackupPolicyPlanOptions)
}

// GetBackupPolicyPlanWithContext is an alternate form of the GetBackupPolicyPlan method which supports a Context parameter
func (vpc *VpcV1) GetBackupPolicyPlanWithContext(ctx context.Context, getBackupPolicyPlanOptions *GetBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBackupPolicyPlanOptions, "getBackupPolicyPlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBackupPolicyPlanOptions, "getBackupPolicyPlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *getBackupPolicyPlanOptions.BackupPolicyID,
		"id":               *getBackupPolicyPlanOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/plans/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBackupPolicyPlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBackupPolicyPlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyPlan)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateBackupPolicyPlan : Update a backup policy plan
// This request updates a backup policy plan with the information in a provided plan patch. The plan patch object is
// structured in the same way as a retrieved backup policy plan and can contains only the information to be updated.
func (vpc *VpcV1) UpdateBackupPolicyPlan(updateBackupPolicyPlanOptions *UpdateBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	return vpc.UpdateBackupPolicyPlanWithContext(context.Background(), updateBackupPolicyPlanOptions)
}

// UpdateBackupPolicyPlanWithContext is an alternate form of the UpdateBackupPolicyPlan method which supports a Context parameter
func (vpc *VpcV1) UpdateBackupPolicyPlanWithContext(ctx context.Context, updateBackupPolicyPlanOptions *UpdateBackupPolicyPlanOptions) (result *BackupPolicyPlan, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateBackupPolicyPlanOptions, "updateBackupPolicyPlanOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateBackupPolicyPlanOptions, "updateBackupPolicyPlanOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"backup_policy_id": *updateBackupPolicyPlanOptions.BackupPolicyID,
		"id":               *updateBackupPolicyPlanOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{backup_policy_id}/plans/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateBackupPolicyPlanOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateBackupPolicyPlan")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateBackupPolicyPlanOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateBackupPolicyPlanOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateBackupPolicyPlanOptions.BackupPolicyPlanPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicyPlan)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteBackupPolicy : Delete a backup policy
// This request deletes a backup policy. This operation cannot be reversed.
//
// If the request is accepted, the backup policy `status` will be set to `deleting`. Once deletion processing completes,
// the backup policy will no longer be retrievable.
func (vpc *VpcV1) DeleteBackupPolicy(deleteBackupPolicyOptions *DeleteBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	return vpc.DeleteBackupPolicyWithContext(context.Background(), deleteBackupPolicyOptions)
}

// DeleteBackupPolicyWithContext is an alternate form of the DeleteBackupPolicy method which supports a Context parameter
func (vpc *VpcV1) DeleteBackupPolicyWithContext(ctx context.Context, deleteBackupPolicyOptions *DeleteBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteBackupPolicyOptions, "deleteBackupPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteBackupPolicyOptions, "deleteBackupPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteBackupPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteBackupPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteBackupPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if deleteBackupPolicyOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteBackupPolicyOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBackupPolicy : Retrieve a backup policy
// This request retrieves a single backup policy specified by the identifier in the URL.
func (vpc *VpcV1) GetBackupPolicy(getBackupPolicyOptions *GetBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	return vpc.GetBackupPolicyWithContext(context.Background(), getBackupPolicyOptions)
}

// GetBackupPolicyWithContext is an alternate form of the GetBackupPolicy method which supports a Context parameter
func (vpc *VpcV1) GetBackupPolicyWithContext(ctx context.Context, getBackupPolicyOptions *GetBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBackupPolicyOptions, "getBackupPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBackupPolicyOptions, "getBackupPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getBackupPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBackupPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBackupPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateBackupPolicy : Update a backup policy
// This request updates a backup policy with the information in a provided backup policy patch. The backup policy patch
// object is structured in the same way as a retrieved backup policy and contains only the information to be updated.
func (vpc *VpcV1) UpdateBackupPolicy(updateBackupPolicyOptions *UpdateBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	return vpc.UpdateBackupPolicyWithContext(context.Background(), updateBackupPolicyOptions)
}

// UpdateBackupPolicyWithContext is an alternate form of the UpdateBackupPolicy method which supports a Context parameter
func (vpc *VpcV1) UpdateBackupPolicyWithContext(ctx context.Context, updateBackupPolicyOptions *UpdateBackupPolicyOptions) (result *BackupPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateBackupPolicyOptions, "updateBackupPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateBackupPolicyOptions, "updateBackupPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateBackupPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/backup_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateBackupPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateBackupPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateBackupPolicyOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateBackupPolicyOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateBackupPolicyOptions.BackupPolicyPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBackupPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListPlacementGroups : List all placement groups
// This request lists all placement groups in the region.
func (vpc *VpcV1) ListPlacementGroups(listPlacementGroupsOptions *ListPlacementGroupsOptions) (result *PlacementGroupCollection, response *core.DetailedResponse, err error) {
	return vpc.ListPlacementGroupsWithContext(context.Background(), listPlacementGroupsOptions)
}

// ListPlacementGroupsWithContext is an alternate form of the ListPlacementGroups method which supports a Context parameter
func (vpc *VpcV1) ListPlacementGroupsWithContext(ctx context.Context, listPlacementGroupsOptions *ListPlacementGroupsOptions) (result *PlacementGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listPlacementGroupsOptions, "listPlacementGroupsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/placement_groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listPlacementGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListPlacementGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listPlacementGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listPlacementGroupsOptions.Start))
	}
	if listPlacementGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listPlacementGroupsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroupCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreatePlacementGroup : Create a placement group
// This request creates a new placement group.
func (vpc *VpcV1) CreatePlacementGroup(createPlacementGroupOptions *CreatePlacementGroupOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return vpc.CreatePlacementGroupWithContext(context.Background(), createPlacementGroupOptions)
}

// CreatePlacementGroupWithContext is an alternate form of the CreatePlacementGroup method which supports a Context parameter
func (vpc *VpcV1) CreatePlacementGroupWithContext(ctx context.Context, createPlacementGroupOptions *CreatePlacementGroupOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createPlacementGroupOptions, "createPlacementGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createPlacementGroupOptions, "createPlacementGroupOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/placement_groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createPlacementGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreatePlacementGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createPlacementGroupOptions.Strategy != nil {
		body["strategy"] = createPlacementGroupOptions.Strategy
	}
	if createPlacementGroupOptions.Name != nil {
		body["name"] = createPlacementGroupOptions.Name
	}
	if createPlacementGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createPlacementGroupOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeletePlacementGroup : Delete a placement group
// This request deletes a placement group. This operation cannot be reversed. For this request to succeed, the placement
// group must not be associated with an instance.
func (vpc *VpcV1) DeletePlacementGroup(deletePlacementGroupOptions *DeletePlacementGroupOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeletePlacementGroupWithContext(context.Background(), deletePlacementGroupOptions)
}

// DeletePlacementGroupWithContext is an alternate form of the DeletePlacementGroup method which supports a Context parameter
func (vpc *VpcV1) DeletePlacementGroupWithContext(ctx context.Context, deletePlacementGroupOptions *DeletePlacementGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deletePlacementGroupOptions, "deletePlacementGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deletePlacementGroupOptions, "deletePlacementGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deletePlacementGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/placement_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deletePlacementGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeletePlacementGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetPlacementGroup : Retrieve a placement group
// This request retrieves a single placement group specified by identifier in the URL.
func (vpc *VpcV1) GetPlacementGroup(getPlacementGroupOptions *GetPlacementGroupOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return vpc.GetPlacementGroupWithContext(context.Background(), getPlacementGroupOptions)
}

// GetPlacementGroupWithContext is an alternate form of the GetPlacementGroup method which supports a Context parameter
func (vpc *VpcV1) GetPlacementGroupWithContext(ctx context.Context, getPlacementGroupOptions *GetPlacementGroupOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getPlacementGroupOptions, "getPlacementGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getPlacementGroupOptions, "getPlacementGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getPlacementGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/placement_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getPlacementGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetPlacementGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdatePlacementGroup : Update a placement group
// This request updates a placement group with the information provided placement group patch. The placement group patch
// object is structured in the same way as a retrieved placement group and contains only the information to be updated.
func (vpc *VpcV1) UpdatePlacementGroup(updatePlacementGroupOptions *UpdatePlacementGroupOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return vpc.UpdatePlacementGroupWithContext(context.Background(), updatePlacementGroupOptions)
}

// UpdatePlacementGroupWithContext is an alternate form of the UpdatePlacementGroup method which supports a Context parameter
func (vpc *VpcV1) UpdatePlacementGroupWithContext(ctx context.Context, updatePlacementGroupOptions *UpdatePlacementGroupOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updatePlacementGroupOptions, "updatePlacementGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updatePlacementGroupOptions, "updatePlacementGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updatePlacementGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/placement_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updatePlacementGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdatePlacementGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updatePlacementGroupOptions.PlacementGroupPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBareMetalServerProfiles : List all bare metal server profiles
// This request lists all [bare metal server
// profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile) available in the region. A bare metal
// server profile specifies the performance characteristics and pricing model for a bare metal server.
func (vpc *VpcV1) ListBareMetalServerProfiles(listBareMetalServerProfilesOptions *ListBareMetalServerProfilesOptions) (result *BareMetalServerProfileCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBareMetalServerProfilesWithContext(context.Background(), listBareMetalServerProfilesOptions)
}

// ListBareMetalServerProfilesWithContext is an alternate form of the ListBareMetalServerProfiles method which supports a Context parameter
func (vpc *VpcV1) ListBareMetalServerProfilesWithContext(ctx context.Context, listBareMetalServerProfilesOptions *ListBareMetalServerProfilesOptions) (result *BareMetalServerProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listBareMetalServerProfilesOptions, "listBareMetalServerProfilesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_server/profiles`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBareMetalServerProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBareMetalServerProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listBareMetalServerProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listBareMetalServerProfilesOptions.Start))
	}
	if listBareMetalServerProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listBareMetalServerProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerProfileCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBareMetalServerProfile : Retrieve a bare metal server profile
// This request retrieves a single bare metal server profile specified by the name in the URL.
func (vpc *VpcV1) GetBareMetalServerProfile(getBareMetalServerProfileOptions *GetBareMetalServerProfileOptions) (result *BareMetalServerProfile, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerProfileWithContext(context.Background(), getBareMetalServerProfileOptions)
}

// GetBareMetalServerProfileWithContext is an alternate form of the GetBareMetalServerProfile method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerProfileWithContext(ctx context.Context, getBareMetalServerProfileOptions *GetBareMetalServerProfileOptions) (result *BareMetalServerProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerProfileOptions, "getBareMetalServerProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerProfileOptions, "getBareMetalServerProfileOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getBareMetalServerProfileOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_server/profiles/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServerProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBareMetalServers : List all bare metal servers
// This request lists all bare metal servers in the region.
func (vpc *VpcV1) ListBareMetalServers(listBareMetalServersOptions *ListBareMetalServersOptions) (result *BareMetalServerCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBareMetalServersWithContext(context.Background(), listBareMetalServersOptions)
}

// ListBareMetalServersWithContext is an alternate form of the ListBareMetalServers method which supports a Context parameter
func (vpc *VpcV1) ListBareMetalServersWithContext(ctx context.Context, listBareMetalServersOptions *ListBareMetalServersOptions) (result *BareMetalServerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listBareMetalServersOptions, "listBareMetalServersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBareMetalServersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBareMetalServers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listBareMetalServersOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listBareMetalServersOptions.Start))
	}
	if listBareMetalServersOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listBareMetalServersOptions.Limit))
	}
	if listBareMetalServersOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listBareMetalServersOptions.ResourceGroupID))
	}
	if listBareMetalServersOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listBareMetalServersOptions.Name))
	}
	if listBareMetalServersOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listBareMetalServersOptions.VPCID))
	}
	if listBareMetalServersOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listBareMetalServersOptions.VPCCRN))
	}
	if listBareMetalServersOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listBareMetalServersOptions.VPCName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateBareMetalServer : Create a bare metal server
// This request provisions a new bare metal server from a prototype object. The prototype object is structured in the
// same way as a retrieved bare metal server, and contains the information necessary to provision the new bare metal
// server. The bare metal server is automatically started.
func (vpc *VpcV1) CreateBareMetalServer(createBareMetalServerOptions *CreateBareMetalServerOptions) (result *BareMetalServer, response *core.DetailedResponse, err error) {
	return vpc.CreateBareMetalServerWithContext(context.Background(), createBareMetalServerOptions)
}

// CreateBareMetalServerWithContext is an alternate form of the CreateBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) CreateBareMetalServerWithContext(ctx context.Context, createBareMetalServerOptions *CreateBareMetalServerOptions) (result *BareMetalServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createBareMetalServerOptions, "createBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createBareMetalServerOptions, "createBareMetalServerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createBareMetalServerOptions.Initialization != nil {
		body["initialization"] = createBareMetalServerOptions.Initialization
	}
	if createBareMetalServerOptions.PrimaryNetworkInterface != nil {
		body["primary_network_interface"] = createBareMetalServerOptions.PrimaryNetworkInterface
	}
	if createBareMetalServerOptions.Profile != nil {
		body["profile"] = createBareMetalServerOptions.Profile
	}
	if createBareMetalServerOptions.Zone != nil {
		body["zone"] = createBareMetalServerOptions.Zone
	}
	if createBareMetalServerOptions.EnableSecureBoot != nil {
		body["enable_secure_boot"] = createBareMetalServerOptions.EnableSecureBoot
	}
	if createBareMetalServerOptions.Name != nil {
		body["name"] = createBareMetalServerOptions.Name
	}
	if createBareMetalServerOptions.NetworkInterfaces != nil {
		body["network_interfaces"] = createBareMetalServerOptions.NetworkInterfaces
	}
	if createBareMetalServerOptions.ResourceGroup != nil {
		body["resource_group"] = createBareMetalServerOptions.ResourceGroup
	}
	if createBareMetalServerOptions.TrustedPlatformModule != nil {
		body["trusted_platform_module"] = createBareMetalServerOptions.TrustedPlatformModule
	}
	if createBareMetalServerOptions.VPC != nil {
		body["vpc"] = createBareMetalServerOptions.VPC
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateBareMetalServerConsoleAccessToken : Create a console access token for a bare metal server
// This request creates a new single-use console access token for a bare metal server. All console configuration is
// provided at token create time, and the token is subsequently used in the `access_token` query parameter for the
// WebSocket request.  The access token is only valid for a short period of time, and a maximum of one token is valid
// for a given bare metal server at a time.
func (vpc *VpcV1) CreateBareMetalServerConsoleAccessToken(createBareMetalServerConsoleAccessTokenOptions *CreateBareMetalServerConsoleAccessTokenOptions) (result *BareMetalServerConsoleAccessToken, response *core.DetailedResponse, err error) {
	return vpc.CreateBareMetalServerConsoleAccessTokenWithContext(context.Background(), createBareMetalServerConsoleAccessTokenOptions)
}

// CreateBareMetalServerConsoleAccessTokenWithContext is an alternate form of the CreateBareMetalServerConsoleAccessToken method which supports a Context parameter
func (vpc *VpcV1) CreateBareMetalServerConsoleAccessTokenWithContext(ctx context.Context, createBareMetalServerConsoleAccessTokenOptions *CreateBareMetalServerConsoleAccessTokenOptions) (result *BareMetalServerConsoleAccessToken, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createBareMetalServerConsoleAccessTokenOptions, "createBareMetalServerConsoleAccessTokenOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createBareMetalServerConsoleAccessTokenOptions, "createBareMetalServerConsoleAccessTokenOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *createBareMetalServerConsoleAccessTokenOptions.BareMetalServerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/console_access_token`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createBareMetalServerConsoleAccessTokenOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateBareMetalServerConsoleAccessToken")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createBareMetalServerConsoleAccessTokenOptions.ConsoleType != nil {
		body["console_type"] = createBareMetalServerConsoleAccessTokenOptions.ConsoleType
	}
	if createBareMetalServerConsoleAccessTokenOptions.Force != nil {
		body["force"] = createBareMetalServerConsoleAccessTokenOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerConsoleAccessToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBareMetalServerDisks : List all disks on a bare metal server
// This request lists all disks on a bare metal server.  A disk is a block device that is locally attached to the
// physical server.  By default, the listed disks are sorted by their `created_at` property values, with the newest disk
// first.
func (vpc *VpcV1) ListBareMetalServerDisks(listBareMetalServerDisksOptions *ListBareMetalServerDisksOptions) (result *BareMetalServerDiskCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBareMetalServerDisksWithContext(context.Background(), listBareMetalServerDisksOptions)
}

// ListBareMetalServerDisksWithContext is an alternate form of the ListBareMetalServerDisks method which supports a Context parameter
func (vpc *VpcV1) ListBareMetalServerDisksWithContext(ctx context.Context, listBareMetalServerDisksOptions *ListBareMetalServerDisksOptions) (result *BareMetalServerDiskCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBareMetalServerDisksOptions, "listBareMetalServerDisksOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBareMetalServerDisksOptions, "listBareMetalServerDisksOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *listBareMetalServerDisksOptions.BareMetalServerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/disks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBareMetalServerDisksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBareMetalServerDisks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerDiskCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBareMetalServerDisk : Retrieve a bare metal server disk
// This request retrieves a single disk specified by the identifier in the URL.
func (vpc *VpcV1) GetBareMetalServerDisk(getBareMetalServerDiskOptions *GetBareMetalServerDiskOptions) (result *BareMetalServerDisk, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerDiskWithContext(context.Background(), getBareMetalServerDiskOptions)
}

// GetBareMetalServerDiskWithContext is an alternate form of the GetBareMetalServerDisk method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerDiskWithContext(ctx context.Context, getBareMetalServerDiskOptions *GetBareMetalServerDiskOptions) (result *BareMetalServerDisk, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerDiskOptions, "getBareMetalServerDiskOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerDiskOptions, "getBareMetalServerDiskOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *getBareMetalServerDiskOptions.BareMetalServerID,
		"id":                   *getBareMetalServerDiskOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/disks/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerDiskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServerDisk")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerDisk)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateBareMetalServerDisk : Update a bare metal server disk
// This request updates the bare metal server disk with the information in a provided patch.
func (vpc *VpcV1) UpdateBareMetalServerDisk(updateBareMetalServerDiskOptions *UpdateBareMetalServerDiskOptions) (result *BareMetalServerDisk, response *core.DetailedResponse, err error) {
	return vpc.UpdateBareMetalServerDiskWithContext(context.Background(), updateBareMetalServerDiskOptions)
}

// UpdateBareMetalServerDiskWithContext is an alternate form of the UpdateBareMetalServerDisk method which supports a Context parameter
func (vpc *VpcV1) UpdateBareMetalServerDiskWithContext(ctx context.Context, updateBareMetalServerDiskOptions *UpdateBareMetalServerDiskOptions) (result *BareMetalServerDisk, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateBareMetalServerDiskOptions, "updateBareMetalServerDiskOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateBareMetalServerDiskOptions, "updateBareMetalServerDiskOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *updateBareMetalServerDiskOptions.BareMetalServerID,
		"id":                   *updateBareMetalServerDiskOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/disks/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateBareMetalServerDiskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateBareMetalServerDisk")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateBareMetalServerDiskOptions.BareMetalServerDiskPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerDisk)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBareMetalServerNetworkInterfaces : List all network interfaces on a bare metal server
// This request lists all network interfaces on a bare metal server. A bare metal server network interface is an
// abstract representation of a network device and attaches a bare metal server to a single subnet. Each network
// interface on a bare metal server can attach to any subnet in the zone, including subnets that are already attached to
// the bare metal server.
func (vpc *VpcV1) ListBareMetalServerNetworkInterfaces(listBareMetalServerNetworkInterfacesOptions *ListBareMetalServerNetworkInterfacesOptions) (result *BareMetalServerNetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBareMetalServerNetworkInterfacesWithContext(context.Background(), listBareMetalServerNetworkInterfacesOptions)
}

// ListBareMetalServerNetworkInterfacesWithContext is an alternate form of the ListBareMetalServerNetworkInterfaces method which supports a Context parameter
func (vpc *VpcV1) ListBareMetalServerNetworkInterfacesWithContext(ctx context.Context, listBareMetalServerNetworkInterfacesOptions *ListBareMetalServerNetworkInterfacesOptions) (result *BareMetalServerNetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBareMetalServerNetworkInterfacesOptions, "listBareMetalServerNetworkInterfacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBareMetalServerNetworkInterfacesOptions, "listBareMetalServerNetworkInterfacesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *listBareMetalServerNetworkInterfacesOptions.BareMetalServerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBareMetalServerNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBareMetalServerNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listBareMetalServerNetworkInterfacesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listBareMetalServerNetworkInterfacesOptions.Start))
	}
	if listBareMetalServerNetworkInterfacesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listBareMetalServerNetworkInterfacesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerNetworkInterfaceCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateBareMetalServerNetworkInterface : Create a network interface on a bare metal server
// This request creates a new bare metal server network interface from a bare metal server network interface prototype
// object. The prototype object is structured in the same way as a retrieved bare metal server network interface, and
// contains the information necessary to create the new bare metal server network interface. Any subnet in the bare
// metal server's VPC may be specified, even if it is already attached to another bare metal server network interface.
// Addresses on the bare metal server network interface must be within the specified subnet's CIDR blocks.
func (vpc *VpcV1) CreateBareMetalServerNetworkInterface(createBareMetalServerNetworkInterfaceOptions *CreateBareMetalServerNetworkInterfaceOptions) (result BareMetalServerNetworkInterfaceIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateBareMetalServerNetworkInterfaceWithContext(context.Background(), createBareMetalServerNetworkInterfaceOptions)
}

// CreateBareMetalServerNetworkInterfaceWithContext is an alternate form of the CreateBareMetalServerNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) CreateBareMetalServerNetworkInterfaceWithContext(ctx context.Context, createBareMetalServerNetworkInterfaceOptions *CreateBareMetalServerNetworkInterfaceOptions) (result BareMetalServerNetworkInterfaceIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createBareMetalServerNetworkInterfaceOptions, "createBareMetalServerNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createBareMetalServerNetworkInterfaceOptions, "createBareMetalServerNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *createBareMetalServerNetworkInterfaceOptions.BareMetalServerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createBareMetalServerNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateBareMetalServerNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createBareMetalServerNetworkInterfaceOptions.BareMetalServerNetworkInterfacePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteBareMetalServerNetworkInterface : Delete a bare metal server network interface
// This request deletes a bare metal server network interface. This operation cannot be reversed. Any floating IPs
// associated with the bare metal server network interface are implicitly disassociated.  The primary bare metal server
// network interface is not allowed to be deleted.
func (vpc *VpcV1) DeleteBareMetalServerNetworkInterface(deleteBareMetalServerNetworkInterfaceOptions *DeleteBareMetalServerNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteBareMetalServerNetworkInterfaceWithContext(context.Background(), deleteBareMetalServerNetworkInterfaceOptions)
}

// DeleteBareMetalServerNetworkInterfaceWithContext is an alternate form of the DeleteBareMetalServerNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) DeleteBareMetalServerNetworkInterfaceWithContext(ctx context.Context, deleteBareMetalServerNetworkInterfaceOptions *DeleteBareMetalServerNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteBareMetalServerNetworkInterfaceOptions, "deleteBareMetalServerNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteBareMetalServerNetworkInterfaceOptions, "deleteBareMetalServerNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *deleteBareMetalServerNetworkInterfaceOptions.BareMetalServerID,
		"id":                   *deleteBareMetalServerNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteBareMetalServerNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteBareMetalServerNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetBareMetalServerNetworkInterface : Retrieve a bare metal server network interface
// This request retrieves a single bare metal server network interface specified by the identifier in the URL.
func (vpc *VpcV1) GetBareMetalServerNetworkInterface(getBareMetalServerNetworkInterfaceOptions *GetBareMetalServerNetworkInterfaceOptions) (result BareMetalServerNetworkInterfaceIntf, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerNetworkInterfaceWithContext(context.Background(), getBareMetalServerNetworkInterfaceOptions)
}

// GetBareMetalServerNetworkInterfaceWithContext is an alternate form of the GetBareMetalServerNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerNetworkInterfaceWithContext(ctx context.Context, getBareMetalServerNetworkInterfaceOptions *GetBareMetalServerNetworkInterfaceOptions) (result BareMetalServerNetworkInterfaceIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerNetworkInterfaceOptions, "getBareMetalServerNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerNetworkInterfaceOptions, "getBareMetalServerNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *getBareMetalServerNetworkInterfaceOptions.BareMetalServerID,
		"id":                   *getBareMetalServerNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServerNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateBareMetalServerNetworkInterface : Update a bare metal server network interface
// This request updates a bare metal server network interface with the information provided in a bare metal server
// network interface patch object. The bare metal server network interface patch object is structured in the same way as
// a retrieved bare metal server network interface and needs to contain only the information to be updated.
func (vpc *VpcV1) UpdateBareMetalServerNetworkInterface(updateBareMetalServerNetworkInterfaceOptions *UpdateBareMetalServerNetworkInterfaceOptions) (result BareMetalServerNetworkInterfaceIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateBareMetalServerNetworkInterfaceWithContext(context.Background(), updateBareMetalServerNetworkInterfaceOptions)
}

// UpdateBareMetalServerNetworkInterfaceWithContext is an alternate form of the UpdateBareMetalServerNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) UpdateBareMetalServerNetworkInterfaceWithContext(ctx context.Context, updateBareMetalServerNetworkInterfaceOptions *UpdateBareMetalServerNetworkInterfaceOptions) (result BareMetalServerNetworkInterfaceIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateBareMetalServerNetworkInterfaceOptions, "updateBareMetalServerNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateBareMetalServerNetworkInterfaceOptions, "updateBareMetalServerNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *updateBareMetalServerNetworkInterfaceOptions.BareMetalServerID,
		"id":                   *updateBareMetalServerNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateBareMetalServerNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateBareMetalServerNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateBareMetalServerNetworkInterfaceOptions.BareMetalServerNetworkInterfacePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBareMetalServerNetworkInterfaceFloatingIps : List all floating IPs associated with a bare metal server network interface
// This request lists all floating IPs associated with a bare metal server network interface.
func (vpc *VpcV1) ListBareMetalServerNetworkInterfaceFloatingIps(listBareMetalServerNetworkInterfaceFloatingIpsOptions *ListBareMetalServerNetworkInterfaceFloatingIpsOptions) (result *FloatingIPUnpaginatedCollection, response *core.DetailedResponse, err error) {
	return vpc.ListBareMetalServerNetworkInterfaceFloatingIpsWithContext(context.Background(), listBareMetalServerNetworkInterfaceFloatingIpsOptions)
}

// ListBareMetalServerNetworkInterfaceFloatingIpsWithContext is an alternate form of the ListBareMetalServerNetworkInterfaceFloatingIps method which supports a Context parameter
func (vpc *VpcV1) ListBareMetalServerNetworkInterfaceFloatingIpsWithContext(ctx context.Context, listBareMetalServerNetworkInterfaceFloatingIpsOptions *ListBareMetalServerNetworkInterfaceFloatingIpsOptions) (result *FloatingIPUnpaginatedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBareMetalServerNetworkInterfaceFloatingIpsOptions, "listBareMetalServerNetworkInterfaceFloatingIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBareMetalServerNetworkInterfaceFloatingIpsOptions, "listBareMetalServerNetworkInterfaceFloatingIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *listBareMetalServerNetworkInterfaceFloatingIpsOptions.BareMetalServerID,
		"network_interface_id": *listBareMetalServerNetworkInterfaceFloatingIpsOptions.NetworkInterfaceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBareMetalServerNetworkInterfaceFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBareMetalServerNetworkInterfaceFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIPUnpaginatedCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RemoveBareMetalServerNetworkInterfaceFloatingIP : Disassociate a floating IP from a bare metal server network interface
// This request disassociates the specified floating IP from the specified bare metal server network interface.
func (vpc *VpcV1) RemoveBareMetalServerNetworkInterfaceFloatingIP(removeBareMetalServerNetworkInterfaceFloatingIPOptions *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions) (response *core.DetailedResponse, err error) {
	return vpc.RemoveBareMetalServerNetworkInterfaceFloatingIPWithContext(context.Background(), removeBareMetalServerNetworkInterfaceFloatingIPOptions)
}

// RemoveBareMetalServerNetworkInterfaceFloatingIPWithContext is an alternate form of the RemoveBareMetalServerNetworkInterfaceFloatingIP method which supports a Context parameter
func (vpc *VpcV1) RemoveBareMetalServerNetworkInterfaceFloatingIPWithContext(ctx context.Context, removeBareMetalServerNetworkInterfaceFloatingIPOptions *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeBareMetalServerNetworkInterfaceFloatingIPOptions, "removeBareMetalServerNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeBareMetalServerNetworkInterfaceFloatingIPOptions, "removeBareMetalServerNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *removeBareMetalServerNetworkInterfaceFloatingIPOptions.BareMetalServerID,
		"network_interface_id": *removeBareMetalServerNetworkInterfaceFloatingIPOptions.NetworkInterfaceID,
		"id":                   *removeBareMetalServerNetworkInterfaceFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeBareMetalServerNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveBareMetalServerNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetBareMetalServerNetworkInterfaceFloatingIP : Retrieve associated floating IP
// This request retrieves a specified floating IP if it is associated with the bare metal server network interface
// specified in the URL.
func (vpc *VpcV1) GetBareMetalServerNetworkInterfaceFloatingIP(getBareMetalServerNetworkInterfaceFloatingIPOptions *GetBareMetalServerNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerNetworkInterfaceFloatingIPWithContext(context.Background(), getBareMetalServerNetworkInterfaceFloatingIPOptions)
}

// GetBareMetalServerNetworkInterfaceFloatingIPWithContext is an alternate form of the GetBareMetalServerNetworkInterfaceFloatingIP method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerNetworkInterfaceFloatingIPWithContext(ctx context.Context, getBareMetalServerNetworkInterfaceFloatingIPOptions *GetBareMetalServerNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerNetworkInterfaceFloatingIPOptions, "getBareMetalServerNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerNetworkInterfaceFloatingIPOptions, "getBareMetalServerNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *getBareMetalServerNetworkInterfaceFloatingIPOptions.BareMetalServerID,
		"network_interface_id": *getBareMetalServerNetworkInterfaceFloatingIPOptions.NetworkInterfaceID,
		"id":                   *getBareMetalServerNetworkInterfaceFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServerNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AddBareMetalServerNetworkInterfaceFloatingIP : Associate a floating IP with a bare metal server network interface
// This request associates the specified floating IP with the specified bare metal server network interface. If
// `enable_infrastructure_nat` is `false`, this adds the IP to any existing associations. If `enable_infrastructure_nat`
// is `true`, this replaces any existing association.  For this request to succeed, the existing floating IP must not be
// required by another resource, such as a public gateway. A request body is not required, and if provided, is ignored.
func (vpc *VpcV1) AddBareMetalServerNetworkInterfaceFloatingIP(addBareMetalServerNetworkInterfaceFloatingIPOptions *AddBareMetalServerNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.AddBareMetalServerNetworkInterfaceFloatingIPWithContext(context.Background(), addBareMetalServerNetworkInterfaceFloatingIPOptions)
}

// AddBareMetalServerNetworkInterfaceFloatingIPWithContext is an alternate form of the AddBareMetalServerNetworkInterfaceFloatingIP method which supports a Context parameter
func (vpc *VpcV1) AddBareMetalServerNetworkInterfaceFloatingIPWithContext(ctx context.Context, addBareMetalServerNetworkInterfaceFloatingIPOptions *AddBareMetalServerNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addBareMetalServerNetworkInterfaceFloatingIPOptions, "addBareMetalServerNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addBareMetalServerNetworkInterfaceFloatingIPOptions, "addBareMetalServerNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *addBareMetalServerNetworkInterfaceFloatingIPOptions.BareMetalServerID,
		"network_interface_id": *addBareMetalServerNetworkInterfaceFloatingIPOptions.NetworkInterfaceID,
		"id":                   *addBareMetalServerNetworkInterfaceFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addBareMetalServerNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddBareMetalServerNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBareMetalServerNetworkInterfaceIps : List the primary reserved IP for a bare metal server network interface
// This request lists the primary reserved IP for a bare metal server network interface.
func (vpc *VpcV1) ListBareMetalServerNetworkInterfaceIps(listBareMetalServerNetworkInterfaceIpsOptions *ListBareMetalServerNetworkInterfaceIpsOptions) (result *ReservedIPCollectionBareMetalServerNetworkInterfaceContext, response *core.DetailedResponse, err error) {
	return vpc.ListBareMetalServerNetworkInterfaceIpsWithContext(context.Background(), listBareMetalServerNetworkInterfaceIpsOptions)
}

// ListBareMetalServerNetworkInterfaceIpsWithContext is an alternate form of the ListBareMetalServerNetworkInterfaceIps method which supports a Context parameter
func (vpc *VpcV1) ListBareMetalServerNetworkInterfaceIpsWithContext(ctx context.Context, listBareMetalServerNetworkInterfaceIpsOptions *ListBareMetalServerNetworkInterfaceIpsOptions) (result *ReservedIPCollectionBareMetalServerNetworkInterfaceContext, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBareMetalServerNetworkInterfaceIpsOptions, "listBareMetalServerNetworkInterfaceIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBareMetalServerNetworkInterfaceIpsOptions, "listBareMetalServerNetworkInterfaceIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *listBareMetalServerNetworkInterfaceIpsOptions.BareMetalServerID,
		"network_interface_id": *listBareMetalServerNetworkInterfaceIpsOptions.NetworkInterfaceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBareMetalServerNetworkInterfaceIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListBareMetalServerNetworkInterfaceIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContext)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBareMetalServerNetworkInterfaceIP : Retrieve the primary reserved IP
// This request retrieves the primary reserved IP for a bare metal server network interface.
func (vpc *VpcV1) GetBareMetalServerNetworkInterfaceIP(getBareMetalServerNetworkInterfaceIPOptions *GetBareMetalServerNetworkInterfaceIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerNetworkInterfaceIPWithContext(context.Background(), getBareMetalServerNetworkInterfaceIPOptions)
}

// GetBareMetalServerNetworkInterfaceIPWithContext is an alternate form of the GetBareMetalServerNetworkInterfaceIP method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerNetworkInterfaceIPWithContext(ctx context.Context, getBareMetalServerNetworkInterfaceIPOptions *GetBareMetalServerNetworkInterfaceIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerNetworkInterfaceIPOptions, "getBareMetalServerNetworkInterfaceIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerNetworkInterfaceIPOptions, "getBareMetalServerNetworkInterfaceIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"bare_metal_server_id": *getBareMetalServerNetworkInterfaceIPOptions.BareMetalServerID,
		"network_interface_id": *getBareMetalServerNetworkInterfaceIPOptions.NetworkInterfaceID,
		"id":                   *getBareMetalServerNetworkInterfaceIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{bare_metal_server_id}/network_interfaces/{network_interface_id}/ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerNetworkInterfaceIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServerNetworkInterfaceIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteBareMetalServer : Delete a bare metal server
// This request deletes a bare metal server. This operation cannot be reversed. Any floating IPs associated with the
// bare metal server network interfaces are implicitly disassociated.
func (vpc *VpcV1) DeleteBareMetalServer(deleteBareMetalServerOptions *DeleteBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteBareMetalServerWithContext(context.Background(), deleteBareMetalServerOptions)
}

// DeleteBareMetalServerWithContext is an alternate form of the DeleteBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) DeleteBareMetalServerWithContext(ctx context.Context, deleteBareMetalServerOptions *DeleteBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteBareMetalServerOptions, "deleteBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteBareMetalServerOptions, "deleteBareMetalServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteBareMetalServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetBareMetalServer : Retrieve a bare metal server
// This request retrieves a single bare metal server specified by the identifier in the URL.
func (vpc *VpcV1) GetBareMetalServer(getBareMetalServerOptions *GetBareMetalServerOptions) (result *BareMetalServer, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerWithContext(context.Background(), getBareMetalServerOptions)
}

// GetBareMetalServerWithContext is an alternate form of the GetBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerWithContext(ctx context.Context, getBareMetalServerOptions *GetBareMetalServerOptions) (result *BareMetalServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerOptions, "getBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerOptions, "getBareMetalServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getBareMetalServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateBareMetalServer : Update a bare metal server
// This request updates a bare metal server with the information in a provided patch. The bare metal server patch object
// is structured in the same way as a retrieved bare metal server and contains only the information to be updated.
func (vpc *VpcV1) UpdateBareMetalServer(updateBareMetalServerOptions *UpdateBareMetalServerOptions) (result *BareMetalServer, response *core.DetailedResponse, err error) {
	return vpc.UpdateBareMetalServerWithContext(context.Background(), updateBareMetalServerOptions)
}

// UpdateBareMetalServerWithContext is an alternate form of the UpdateBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) UpdateBareMetalServerWithContext(ctx context.Context, updateBareMetalServerOptions *UpdateBareMetalServerOptions) (result *BareMetalServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateBareMetalServerOptions, "updateBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateBareMetalServerOptions, "updateBareMetalServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateBareMetalServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateBareMetalServerOptions.BareMetalServerPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetBareMetalServerInitialization : Retrieve initialization configuration for a bare metal server
// This request retrieves configuration used to initialize the bare metal server, such as the image used, SSH keys, and
// any configured usernames and passwords. These can subsequently be changed on the server and therefore may not be
// current.
func (vpc *VpcV1) GetBareMetalServerInitialization(getBareMetalServerInitializationOptions *GetBareMetalServerInitializationOptions) (result *BareMetalServerInitialization, response *core.DetailedResponse, err error) {
	return vpc.GetBareMetalServerInitializationWithContext(context.Background(), getBareMetalServerInitializationOptions)
}

// GetBareMetalServerInitializationWithContext is an alternate form of the GetBareMetalServerInitialization method which supports a Context parameter
func (vpc *VpcV1) GetBareMetalServerInitializationWithContext(ctx context.Context, getBareMetalServerInitializationOptions *GetBareMetalServerInitializationOptions) (result *BareMetalServerInitialization, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getBareMetalServerInitializationOptions, "getBareMetalServerInitializationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getBareMetalServerInitializationOptions, "getBareMetalServerInitializationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getBareMetalServerInitializationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}/initialization`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBareMetalServerInitializationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetBareMetalServerInitialization")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBareMetalServerInitialization)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RestartBareMetalServer : Restart a bare metal server
// This request restarts a bare metal server.  It will run immediately regardless of the state of the server.
func (vpc *VpcV1) RestartBareMetalServer(restartBareMetalServerOptions *RestartBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	return vpc.RestartBareMetalServerWithContext(context.Background(), restartBareMetalServerOptions)
}

// RestartBareMetalServerWithContext is an alternate form of the RestartBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) RestartBareMetalServerWithContext(ctx context.Context, restartBareMetalServerOptions *RestartBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(restartBareMetalServerOptions, "restartBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(restartBareMetalServerOptions, "restartBareMetalServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *restartBareMetalServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}/restart`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range restartBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RestartBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// StartBareMetalServer : Start a bare metal server
// This request starts a bare metal server.  It will run immediately provided the server is stopped.
func (vpc *VpcV1) StartBareMetalServer(startBareMetalServerOptions *StartBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	return vpc.StartBareMetalServerWithContext(context.Background(), startBareMetalServerOptions)
}

// StartBareMetalServerWithContext is an alternate form of the StartBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) StartBareMetalServerWithContext(ctx context.Context, startBareMetalServerOptions *StartBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(startBareMetalServerOptions, "startBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(startBareMetalServerOptions, "startBareMetalServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *startBareMetalServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}/start`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range startBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "StartBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// StopBareMetalServer : Stop a bare metal server
// This request stops a bare metal server. It will run immediately provided the server is running. Note: A soft stop may
// not complete as it relies on the operating system to perform the operation.
func (vpc *VpcV1) StopBareMetalServer(stopBareMetalServerOptions *StopBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	return vpc.StopBareMetalServerWithContext(context.Background(), stopBareMetalServerOptions)
}

// StopBareMetalServerWithContext is an alternate form of the StopBareMetalServer method which supports a Context parameter
func (vpc *VpcV1) StopBareMetalServerWithContext(ctx context.Context, stopBareMetalServerOptions *StopBareMetalServerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(stopBareMetalServerOptions, "stopBareMetalServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(stopBareMetalServerOptions, "stopBareMetalServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *stopBareMetalServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/bare_metal_servers/{id}/stop`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range stopBareMetalServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "StopBareMetalServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if stopBareMetalServerOptions.Type != nil {
		body["type"] = stopBareMetalServerOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVolumeProfiles : List all volume profiles
// This request lists all [volume profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) available
// in the region. A volume profile specifies the performance characteristics and pricing model for a volume.
func (vpc *VpcV1) ListVolumeProfiles(listVolumeProfilesOptions *ListVolumeProfilesOptions) (result *VolumeProfileCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVolumeProfilesWithContext(context.Background(), listVolumeProfilesOptions)
}

// ListVolumeProfilesWithContext is an alternate form of the ListVolumeProfiles method which supports a Context parameter
func (vpc *VpcV1) ListVolumeProfilesWithContext(ctx context.Context, listVolumeProfilesOptions *ListVolumeProfilesOptions) (result *VolumeProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVolumeProfilesOptions, "listVolumeProfilesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volume/profiles`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumeProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumeProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVolumeProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVolumeProfilesOptions.Start))
	}
	if listVolumeProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVolumeProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeProfileCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetVolumeProfile : Retrieve a volume profile
// This request retrieves a single volume profile specified by the name in the URL.
func (vpc *VpcV1) GetVolumeProfile(getVolumeProfileOptions *GetVolumeProfileOptions) (result *VolumeProfile, response *core.DetailedResponse, err error) {
	return vpc.GetVolumeProfileWithContext(context.Background(), getVolumeProfileOptions)
}

// GetVolumeProfileWithContext is an alternate form of the GetVolumeProfile method which supports a Context parameter
func (vpc *VpcV1) GetVolumeProfileWithContext(ctx context.Context, getVolumeProfileOptions *GetVolumeProfileOptions) (result *VolumeProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeProfileOptions, "getVolumeProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeProfileOptions, "getVolumeProfileOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getVolumeProfileOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volume/profiles/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolumeProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVolumes : List all volumes
// This request lists all volumes in the region. Volumes are network-connected block storage devices that may be
// attached to one or more instances in the same region.
func (vpc *VpcV1) ListVolumes(listVolumesOptions *ListVolumesOptions) (result *VolumeCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVolumesWithContext(context.Background(), listVolumesOptions)
}

// ListVolumesWithContext is an alternate form of the ListVolumes method which supports a Context parameter
func (vpc *VpcV1) ListVolumesWithContext(ctx context.Context, listVolumesOptions *ListVolumesOptions) (result *VolumeCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVolumesOptions, "listVolumesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volumes`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVolumesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVolumesOptions.Start))
	}
	if listVolumesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVolumesOptions.Limit))
	}
	if listVolumesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listVolumesOptions.Name))
	}
	if listVolumesOptions.AttachmentState != nil {
		builder.AddQuery("attachment_state", fmt.Sprint(*listVolumesOptions.AttachmentState))
	}
	if listVolumesOptions.Encryption != nil {
		builder.AddQuery("encryption", fmt.Sprint(*listVolumesOptions.Encryption))
	}
	if listVolumesOptions.OperatingSystemFamily != nil {
		builder.AddQuery("operating_system.family", fmt.Sprint(*listVolumesOptions.OperatingSystemFamily))
	}
	if listVolumesOptions.OperatingSystemArchitecture != nil {
		builder.AddQuery("operating_system.architecture", fmt.Sprint(*listVolumesOptions.OperatingSystemArchitecture))
	}
	if listVolumesOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listVolumesOptions.ZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVolume : Create a volume
// This request creates a new volume from a volume prototype object. The prototype object is structured in the same way
// as a retrieved volume, and contains the information necessary to create the new volume.
func (vpc *VpcV1) CreateVolume(createVolumeOptions *CreateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return vpc.CreateVolumeWithContext(context.Background(), createVolumeOptions)
}

// CreateVolumeWithContext is an alternate form of the CreateVolume method which supports a Context parameter
func (vpc *VpcV1) CreateVolumeWithContext(ctx context.Context, createVolumeOptions *CreateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVolumeOptions, "createVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVolumeOptions, "createVolumeOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volumes`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createVolumeOptions.VolumePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVolume : Delete a volume
// This request deletes a volume. This operation cannot be reversed. For this request to succeed, the volume must not be
// attached to any instances.
func (vpc *VpcV1) DeleteVolume(deleteVolumeOptions *DeleteVolumeOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVolumeWithContext(context.Background(), deleteVolumeOptions)
}

// DeleteVolumeWithContext is an alternate form of the DeleteVolume method which supports a Context parameter
func (vpc *VpcV1) DeleteVolumeWithContext(ctx context.Context, deleteVolumeOptions *DeleteVolumeOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVolumeOptions, "deleteVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVolumeOptions, "deleteVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteVolumeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volumes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteVolumeOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteVolumeOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVolume : Retrieve a volume
// This request retrieves a single volume specified by the identifier in the URL.
func (vpc *VpcV1) GetVolume(getVolumeOptions *GetVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return vpc.GetVolumeWithContext(context.Background(), getVolumeOptions)
}

// GetVolumeWithContext is an alternate form of the GetVolume method which supports a Context parameter
func (vpc *VpcV1) GetVolumeWithContext(ctx context.Context, getVolumeOptions *GetVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeOptions, "getVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeOptions, "getVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVolumeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volumes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVolume : Update a volume
// This request updates a volume with the information in a provided volume patch. The volume patch object is structured
// in the same way as a retrieved volume and contains only the information to be updated.
func (vpc *VpcV1) UpdateVolume(updateVolumeOptions *UpdateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return vpc.UpdateVolumeWithContext(context.Background(), updateVolumeOptions)
}

// UpdateVolumeWithContext is an alternate form of the UpdateVolume method which supports a Context parameter
func (vpc *VpcV1) UpdateVolumeWithContext(ctx context.Context, updateVolumeOptions *UpdateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVolumeOptions, "updateVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVolumeOptions, "updateVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateVolumeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/volumes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateVolumeOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateVolumeOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVolumeOptions.VolumePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSnapshots : Delete a filtered collection of snapshots
// This request deletes all snapshots created from a specific source volume.
func (vpc *VpcV1) DeleteSnapshots(deleteSnapshotsOptions *DeleteSnapshotsOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSnapshotsWithContext(context.Background(), deleteSnapshotsOptions)
}

// DeleteSnapshotsWithContext is an alternate form of the DeleteSnapshots method which supports a Context parameter
func (vpc *VpcV1) DeleteSnapshotsWithContext(ctx context.Context, deleteSnapshotsOptions *DeleteSnapshotsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSnapshotsOptions, "deleteSnapshotsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSnapshotsOptions, "deleteSnapshotsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSnapshotsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSnapshots")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	builder.AddQuery("source_volume.id", fmt.Sprint(*deleteSnapshotsOptions.SourceVolumeID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListSnapshots : List all snapshots
// This request lists all snapshots in the region. A snapshot preserves the data of a volume at the time the snapshot is
// created.
func (vpc *VpcV1) ListSnapshots(listSnapshotsOptions *ListSnapshotsOptions) (result *SnapshotCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSnapshotsWithContext(context.Background(), listSnapshotsOptions)
}

// ListSnapshotsWithContext is an alternate form of the ListSnapshots method which supports a Context parameter
func (vpc *VpcV1) ListSnapshotsWithContext(ctx context.Context, listSnapshotsOptions *ListSnapshotsOptions) (result *SnapshotCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSnapshotsOptions, "listSnapshotsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSnapshotsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSnapshots")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSnapshotsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSnapshotsOptions.Start))
	}
	if listSnapshotsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSnapshotsOptions.Limit))
	}
	if listSnapshotsOptions.Tag != nil {
		builder.AddQuery("tag", fmt.Sprint(*listSnapshotsOptions.Tag))
	}
	if listSnapshotsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSnapshotsOptions.ResourceGroupID))
	}
	if listSnapshotsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listSnapshotsOptions.Name))
	}
	if listSnapshotsOptions.SourceVolumeID != nil {
		builder.AddQuery("source_volume.id", fmt.Sprint(*listSnapshotsOptions.SourceVolumeID))
	}
	if listSnapshotsOptions.SourceVolumeCRN != nil {
		builder.AddQuery("source_volume.crn", fmt.Sprint(*listSnapshotsOptions.SourceVolumeCRN))
	}
	if listSnapshotsOptions.SourceImageID != nil {
		builder.AddQuery("source_image.id", fmt.Sprint(*listSnapshotsOptions.SourceImageID))
	}
	if listSnapshotsOptions.SourceImageCRN != nil {
		builder.AddQuery("source_image.crn", fmt.Sprint(*listSnapshotsOptions.SourceImageCRN))
	}
	if listSnapshotsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listSnapshotsOptions.Sort))
	}
	if listSnapshotsOptions.BackupPolicyPlanID != nil {
		builder.AddQuery("backup_policy_plan.id", fmt.Sprint(*listSnapshotsOptions.BackupPolicyPlanID))
	}
	if listSnapshotsOptions.CopiesID != nil {
		builder.AddQuery("copies[].id", fmt.Sprint(*listSnapshotsOptions.CopiesID))
	}
	if listSnapshotsOptions.CopiesName != nil {
		builder.AddQuery("copies[].name", fmt.Sprint(*listSnapshotsOptions.CopiesName))
	}
	if listSnapshotsOptions.CopiesCRN != nil {
		builder.AddQuery("copies[].crn", fmt.Sprint(*listSnapshotsOptions.CopiesCRN))
	}
	if listSnapshotsOptions.CopiesRemoteRegionName != nil {
		builder.AddQuery("copies[].remote.region.name", fmt.Sprint(*listSnapshotsOptions.CopiesRemoteRegionName))
	}
	if listSnapshotsOptions.SourceSnapshotID != nil {
		builder.AddQuery("source_snapshot.id", fmt.Sprint(*listSnapshotsOptions.SourceSnapshotID))
	}
	if listSnapshotsOptions.SourceSnapshotRemoteRegionName != nil {
		builder.AddQuery("source_snapshot.remote.region.name", fmt.Sprint(*listSnapshotsOptions.SourceSnapshotRemoteRegionName))
	}
	if listSnapshotsOptions.SourceVolumeRemoteRegionName != nil {
		builder.AddQuery("source_volume.remote.region.name", fmt.Sprint(*listSnapshotsOptions.SourceVolumeRemoteRegionName))
	}
	if listSnapshotsOptions.SourceImageRemoteRegionName != nil {
		builder.AddQuery("source_image.remote.region.name", fmt.Sprint(*listSnapshotsOptions.SourceImageRemoteRegionName))
	}
	if listSnapshotsOptions.ClonesZoneName != nil {
		builder.AddQuery("clones[].zone.name", fmt.Sprint(*listSnapshotsOptions.ClonesZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshotCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSnapshot : Create a snapshot
// This request creates a new snapshot from a snapshot prototype object.  The prototype object is structured in the same
// way as a retrieved snapshot, and contains the information necessary to provision the new snapshot.
func (vpc *VpcV1) CreateSnapshot(createSnapshotOptions *CreateSnapshotOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	return vpc.CreateSnapshotWithContext(context.Background(), createSnapshotOptions)
}

// CreateSnapshotWithContext is an alternate form of the CreateSnapshot method which supports a Context parameter
func (vpc *VpcV1) CreateSnapshotWithContext(ctx context.Context, createSnapshotOptions *CreateSnapshotOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSnapshotOptions, "createSnapshotOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSnapshotOptions, "createSnapshotOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSnapshotOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSnapshot")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSnapshotOptions.SnapshotPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshot)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSnapshot : Delete a snapshot
// This request deletes a snapshot. This operation cannot be reversed.
func (vpc *VpcV1) DeleteSnapshot(deleteSnapshotOptions *DeleteSnapshotOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSnapshotWithContext(context.Background(), deleteSnapshotOptions)
}

// DeleteSnapshotWithContext is an alternate form of the DeleteSnapshot method which supports a Context parameter
func (vpc *VpcV1) DeleteSnapshotWithContext(ctx context.Context, deleteSnapshotOptions *DeleteSnapshotOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSnapshotOptions, "deleteSnapshotOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSnapshotOptions, "deleteSnapshotOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteSnapshotOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSnapshotOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSnapshot")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteSnapshotOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteSnapshotOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSnapshot : Retrieve a snapshot
// This request retrieves a single snapshot specified by the identifier in the URL.
func (vpc *VpcV1) GetSnapshot(getSnapshotOptions *GetSnapshotOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	return vpc.GetSnapshotWithContext(context.Background(), getSnapshotOptions)
}

// GetSnapshotWithContext is an alternate form of the GetSnapshot method which supports a Context parameter
func (vpc *VpcV1) GetSnapshotWithContext(ctx context.Context, getSnapshotOptions *GetSnapshotOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSnapshotOptions, "getSnapshotOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSnapshotOptions, "getSnapshotOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getSnapshotOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSnapshotOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSnapshot")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshot)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSnapshot : Update a snapshot
// This request updates a snapshot with the information in a provided snapshot patch. The snapshot consistency group
// patch object is structured in the same way as a retrieved snapshot and contains only the information to be updated.
func (vpc *VpcV1) UpdateSnapshot(updateSnapshotOptions *UpdateSnapshotOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	return vpc.UpdateSnapshotWithContext(context.Background(), updateSnapshotOptions)
}

// UpdateSnapshotWithContext is an alternate form of the UpdateSnapshot method which supports a Context parameter
func (vpc *VpcV1) UpdateSnapshotWithContext(ctx context.Context, updateSnapshotOptions *UpdateSnapshotOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSnapshotOptions, "updateSnapshotOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSnapshotOptions, "updateSnapshotOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateSnapshotOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSnapshotOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSnapshot")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateSnapshotOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateSnapshotOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateSnapshotOptions.SnapshotPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshot)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSnapshotClones : List all clones for a snapshot
// This request lists all clones for a snapshot. Use a clone to quickly restore a snapshot within the clone's zone.
func (vpc *VpcV1) ListSnapshotClones(listSnapshotClonesOptions *ListSnapshotClonesOptions) (result *SnapshotCloneCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSnapshotClonesWithContext(context.Background(), listSnapshotClonesOptions)
}

// ListSnapshotClonesWithContext is an alternate form of the ListSnapshotClones method which supports a Context parameter
func (vpc *VpcV1) ListSnapshotClonesWithContext(ctx context.Context, listSnapshotClonesOptions *ListSnapshotClonesOptions) (result *SnapshotCloneCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSnapshotClonesOptions, "listSnapshotClonesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSnapshotClonesOptions, "listSnapshotClonesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *listSnapshotClonesOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}/clones`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSnapshotClonesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSnapshotClones")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshotCloneCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSnapshotClone : Delete a snapshot clone
// This request deletes a snapshot clone. This operation cannot be reversed, but an equivalent clone may be recreated
// from the snapshot.
func (vpc *VpcV1) DeleteSnapshotClone(deleteSnapshotCloneOptions *DeleteSnapshotCloneOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSnapshotCloneWithContext(context.Background(), deleteSnapshotCloneOptions)
}

// DeleteSnapshotCloneWithContext is an alternate form of the DeleteSnapshotClone method which supports a Context parameter
func (vpc *VpcV1) DeleteSnapshotCloneWithContext(ctx context.Context, deleteSnapshotCloneOptions *DeleteSnapshotCloneOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSnapshotCloneOptions, "deleteSnapshotCloneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSnapshotCloneOptions, "deleteSnapshotCloneOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id":        *deleteSnapshotCloneOptions.ID,
		"zone_name": *deleteSnapshotCloneOptions.ZoneName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}/clones/{zone_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSnapshotCloneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSnapshotClone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSnapshotClone : Retrieve a snapshot clone
// This request retrieves a single clone specified by the snapshot identifier and zone name in the URL.
func (vpc *VpcV1) GetSnapshotClone(getSnapshotCloneOptions *GetSnapshotCloneOptions) (result *SnapshotClone, response *core.DetailedResponse, err error) {
	return vpc.GetSnapshotCloneWithContext(context.Background(), getSnapshotCloneOptions)
}

// GetSnapshotCloneWithContext is an alternate form of the GetSnapshotClone method which supports a Context parameter
func (vpc *VpcV1) GetSnapshotCloneWithContext(ctx context.Context, getSnapshotCloneOptions *GetSnapshotCloneOptions) (result *SnapshotClone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSnapshotCloneOptions, "getSnapshotCloneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSnapshotCloneOptions, "getSnapshotCloneOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id":        *getSnapshotCloneOptions.ID,
		"zone_name": *getSnapshotCloneOptions.ZoneName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}/clones/{zone_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSnapshotCloneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSnapshotClone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshotClone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSnapshotClone : Create a clone for a snapshot
// This request creates a new clone for a snapshot in the specified zone. A request body is not required, and if
// provided, is ignored. If the snapshot already has a clone in the zone, it is returned.
func (vpc *VpcV1) CreateSnapshotClone(createSnapshotCloneOptions *CreateSnapshotCloneOptions) (result *SnapshotClone, response *core.DetailedResponse, err error) {
	return vpc.CreateSnapshotCloneWithContext(context.Background(), createSnapshotCloneOptions)
}

// CreateSnapshotCloneWithContext is an alternate form of the CreateSnapshotClone method which supports a Context parameter
func (vpc *VpcV1) CreateSnapshotCloneWithContext(ctx context.Context, createSnapshotCloneOptions *CreateSnapshotCloneOptions) (result *SnapshotClone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSnapshotCloneOptions, "createSnapshotCloneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSnapshotCloneOptions, "createSnapshotCloneOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id":        *createSnapshotCloneOptions.ID,
		"zone_name": *createSnapshotCloneOptions.ZoneName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/snapshots/{id}/clones/{zone_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSnapshotCloneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSnapshotClone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshotClone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListShareProfiles : List all file share profiles
// This request lists all [file share profiles](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles)
// available in the region. A file share profile specifies the performance characteristics and pricing model for a file
// share.
func (vpc *VpcV1) ListShareProfiles(listShareProfilesOptions *ListShareProfilesOptions) (result *ShareProfileCollection, response *core.DetailedResponse, err error) {
	return vpc.ListShareProfilesWithContext(context.Background(), listShareProfilesOptions)
}

// ListShareProfilesWithContext is an alternate form of the ListShareProfiles method which supports a Context parameter
func (vpc *VpcV1) ListShareProfilesWithContext(ctx context.Context, listShareProfilesOptions *ListShareProfilesOptions) (result *ShareProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listShareProfilesOptions, "listShareProfilesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/share/profiles`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listShareProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListShareProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listShareProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listShareProfilesOptions.Start))
	}
	if listShareProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listShareProfilesOptions.Limit))
	}
	if listShareProfilesOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listShareProfilesOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareProfileCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetShareProfile : Retrieve a file share profile
// This request retrieves a single file share profile specified by the name in the URL.
func (vpc *VpcV1) GetShareProfile(getShareProfileOptions *GetShareProfileOptions) (result *ShareProfile, response *core.DetailedResponse, err error) {
	return vpc.GetShareProfileWithContext(context.Background(), getShareProfileOptions)
}

// GetShareProfileWithContext is an alternate form of the GetShareProfile method which supports a Context parameter
func (vpc *VpcV1) GetShareProfileWithContext(ctx context.Context, getShareProfileOptions *GetShareProfileOptions) (result *ShareProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getShareProfileOptions, "getShareProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getShareProfileOptions, "getShareProfileOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getShareProfileOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/share/profiles/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getShareProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetShareProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListShares : List all file shares
// This request lists all file shares in the region.
func (vpc *VpcV1) ListShares(listSharesOptions *ListSharesOptions) (result *ShareCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSharesWithContext(context.Background(), listSharesOptions)
}

// ListSharesWithContext is an alternate form of the ListShares method which supports a Context parameter
func (vpc *VpcV1) ListSharesWithContext(ctx context.Context, listSharesOptions *ListSharesOptions) (result *ShareCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSharesOptions, "listSharesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSharesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListShares")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSharesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSharesOptions.Start))
	}
	if listSharesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSharesOptions.Limit))
	}
	if listSharesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSharesOptions.ResourceGroupID))
	}
	if listSharesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listSharesOptions.Name))
	}
	if listSharesOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listSharesOptions.Sort))
	}
	if listSharesOptions.ReplicationRole != nil {
		builder.AddQuery("replication_role", fmt.Sprint(*listSharesOptions.ReplicationRole))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateShare : Create a file share
// This request provisions new file shares from a share prototype object. The new file shares can be a standalone share,
// a replica share, or both a source and replica share.
//
// The prototype object is structured in the same way as a retrieved share, and contains the information necessary to
// provision the new file shares.
func (vpc *VpcV1) CreateShare(createShareOptions *CreateShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	return vpc.CreateShareWithContext(context.Background(), createShareOptions)
}

// CreateShareWithContext is an alternate form of the CreateShare method which supports a Context parameter
func (vpc *VpcV1) CreateShareWithContext(ctx context.Context, createShareOptions *CreateShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createShareOptions, "createShareOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createShareOptions, "createShareOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createShareOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateShare")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createShareOptions.SharePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShare)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteShare : Delete a file share
// This request deletes a share. This operation cannot be reversed. A share cannot be deleted if it:
// - has share mount targets
// - has a `lifecycle_state` of `updating`
// - has a replication operation in progress
//
// If the request is accepted, the share `lifecycle_state` will be set to `deleting`. Once deletion processing
// completes, it will no longer be retrievable.
func (vpc *VpcV1) DeleteShare(deleteShareOptions *DeleteShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	return vpc.DeleteShareWithContext(context.Background(), deleteShareOptions)
}

// DeleteShareWithContext is an alternate form of the DeleteShare method which supports a Context parameter
func (vpc *VpcV1) DeleteShareWithContext(ctx context.Context, deleteShareOptions *DeleteShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteShareOptions, "deleteShareOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteShareOptions, "deleteShareOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteShareOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteShareOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteShare")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if deleteShareOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteShareOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShare)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetShare : Retrieve a file share
// This request retrieves a single file share specified by the identifier in the URL.
func (vpc *VpcV1) GetShare(getShareOptions *GetShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	return vpc.GetShareWithContext(context.Background(), getShareOptions)
}

// GetShareWithContext is an alternate form of the GetShare method which supports a Context parameter
func (vpc *VpcV1) GetShareWithContext(ctx context.Context, getShareOptions *GetShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getShareOptions, "getShareOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getShareOptions, "getShareOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getShareOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getShareOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetShare")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShare)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateShare : Update a file share
// This request updates a share with the information in a provided share patch. The share patch object is structured in
// the same way as a retrieved share and contains only the information to be updated.
func (vpc *VpcV1) UpdateShare(updateShareOptions *UpdateShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	return vpc.UpdateShareWithContext(context.Background(), updateShareOptions)
}

// UpdateShareWithContext is an alternate form of the UpdateShare method which supports a Context parameter
func (vpc *VpcV1) UpdateShareWithContext(ctx context.Context, updateShareOptions *UpdateShareOptions) (result *Share, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateShareOptions, "updateShareOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateShareOptions, "updateShareOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateShareOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateShareOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateShare")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateShareOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateShareOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateShareOptions.SharePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShare)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// FailoverShare : Failover to replica file share
// This request triggers a failover to the replica file share specified by the identifier in the URL. The failover
// cannot be started if a source share or the replica share has a `lifecycle_state` of `updating`, or has a replication
// operation in progress.
//
// If `fallback_policy` is specified as `split`, and the request is accepted but the failover operation cannot be
// performed, a split will be triggered.
func (vpc *VpcV1) FailoverShare(failoverShareOptions *FailoverShareOptions) (response *core.DetailedResponse, err error) {
	return vpc.FailoverShareWithContext(context.Background(), failoverShareOptions)
}

// FailoverShareWithContext is an alternate form of the FailoverShare method which supports a Context parameter
func (vpc *VpcV1) FailoverShareWithContext(ctx context.Context, failoverShareOptions *FailoverShareOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(failoverShareOptions, "failoverShareOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(failoverShareOptions, "failoverShareOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *failoverShareOptions.ShareID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/failover`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range failoverShareOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "FailoverShare")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if failoverShareOptions.FallbackPolicy != nil {
		body["fallback_policy"] = failoverShareOptions.FallbackPolicy
	}
	if failoverShareOptions.Timeout != nil {
		body["timeout"] = failoverShareOptions.Timeout
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListShareMountTargets : List all mount targets for a file share
// This request retrieves all share mount targets for a file share. A share mount target is a network endpoint at which
// a file share may be mounted. The file share can be mounted by clients in the same VPC and zone after creating share
// mount targets.
//
// The share mount targets will be sorted by their `created_at` property values, with newest targets first.
func (vpc *VpcV1) ListShareMountTargets(listShareMountTargetsOptions *ListShareMountTargetsOptions) (result *ShareMountTargetCollection, response *core.DetailedResponse, err error) {
	return vpc.ListShareMountTargetsWithContext(context.Background(), listShareMountTargetsOptions)
}

// ListShareMountTargetsWithContext is an alternate form of the ListShareMountTargets method which supports a Context parameter
func (vpc *VpcV1) ListShareMountTargetsWithContext(ctx context.Context, listShareMountTargetsOptions *ListShareMountTargetsOptions) (result *ShareMountTargetCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listShareMountTargetsOptions, "listShareMountTargetsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listShareMountTargetsOptions, "listShareMountTargetsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *listShareMountTargetsOptions.ShareID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/mount_targets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listShareMountTargetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListShareMountTargets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listShareMountTargetsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listShareMountTargetsOptions.Name))
	}
	if listShareMountTargetsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listShareMountTargetsOptions.Start))
	}
	if listShareMountTargetsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listShareMountTargetsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareMountTargetCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateShareMountTarget : Create a mount target for a file share
// This request creates a new share mount target from a share mount target prototype object.
//
// The prototype object is structured in the same way as a retrieved share mount target, and contains the information
// necessary to provision the new file share mount target.
func (vpc *VpcV1) CreateShareMountTarget(createShareMountTargetOptions *CreateShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	return vpc.CreateShareMountTargetWithContext(context.Background(), createShareMountTargetOptions)
}

// CreateShareMountTargetWithContext is an alternate form of the CreateShareMountTarget method which supports a Context parameter
func (vpc *VpcV1) CreateShareMountTargetWithContext(ctx context.Context, createShareMountTargetOptions *CreateShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createShareMountTargetOptions, "createShareMountTargetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createShareMountTargetOptions, "createShareMountTargetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *createShareMountTargetOptions.ShareID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/mount_targets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createShareMountTargetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateShareMountTarget")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createShareMountTargetOptions.ShareMountTargetPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareMountTarget)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteShareMountTarget : Delete a share mount target
// This request deletes a share mount target. This operation cannot be reversed.
//
// If the request is accepted, the share mount target `lifecycle_state` will be set to
// `deleting`. Once deletion processing completes, it will no longer be retrievable.
func (vpc *VpcV1) DeleteShareMountTarget(deleteShareMountTargetOptions *DeleteShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	return vpc.DeleteShareMountTargetWithContext(context.Background(), deleteShareMountTargetOptions)
}

// DeleteShareMountTargetWithContext is an alternate form of the DeleteShareMountTarget method which supports a Context parameter
func (vpc *VpcV1) DeleteShareMountTargetWithContext(ctx context.Context, deleteShareMountTargetOptions *DeleteShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteShareMountTargetOptions, "deleteShareMountTargetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteShareMountTargetOptions, "deleteShareMountTargetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *deleteShareMountTargetOptions.ShareID,
		"id":       *deleteShareMountTargetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/mount_targets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteShareMountTargetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteShareMountTarget")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareMountTarget)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetShareMountTarget : Retrieve a share mount target
// This request retrieves a single share mount target specified by the identifier in the URL.
func (vpc *VpcV1) GetShareMountTarget(getShareMountTargetOptions *GetShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	return vpc.GetShareMountTargetWithContext(context.Background(), getShareMountTargetOptions)
}

// GetShareMountTargetWithContext is an alternate form of the GetShareMountTarget method which supports a Context parameter
func (vpc *VpcV1) GetShareMountTargetWithContext(ctx context.Context, getShareMountTargetOptions *GetShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getShareMountTargetOptions, "getShareMountTargetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getShareMountTargetOptions, "getShareMountTargetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *getShareMountTargetOptions.ShareID,
		"id":       *getShareMountTargetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/mount_targets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getShareMountTargetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetShareMountTarget")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareMountTarget)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateShareMountTarget : Update a share mount target
// This request updates a share mount target with the information provided in a share mount target patch object. The
// share mount target patch object is structured in the same way as a retrieved share mount target and needs to contain
// only the information to be updated.
func (vpc *VpcV1) UpdateShareMountTarget(updateShareMountTargetOptions *UpdateShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	return vpc.UpdateShareMountTargetWithContext(context.Background(), updateShareMountTargetOptions)
}

// UpdateShareMountTargetWithContext is an alternate form of the UpdateShareMountTarget method which supports a Context parameter
func (vpc *VpcV1) UpdateShareMountTargetWithContext(ctx context.Context, updateShareMountTargetOptions *UpdateShareMountTargetOptions) (result *ShareMountTarget, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateShareMountTargetOptions, "updateShareMountTargetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateShareMountTargetOptions, "updateShareMountTargetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *updateShareMountTargetOptions.ShareID,
		"id":       *updateShareMountTargetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/mount_targets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateShareMountTargetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateShareMountTarget")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateShareMountTargetOptions.ShareMountTargetPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShareMountTarget)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteShareSource : Split the source file share from a replica share
// This request removes the replication relationship between a source share and the replica share specified by the
// identifier in the URL. The replication relationship cannot be removed if a source share or the replica share has a
// `lifecycle_state` of `updating`, or has a replication operation in progress.
//
// This operation cannot be reversed.
func (vpc *VpcV1) DeleteShareSource(deleteShareSourceOptions *DeleteShareSourceOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteShareSourceWithContext(context.Background(), deleteShareSourceOptions)
}

// DeleteShareSourceWithContext is an alternate form of the DeleteShareSource method which supports a Context parameter
func (vpc *VpcV1) DeleteShareSourceWithContext(ctx context.Context, deleteShareSourceOptions *DeleteShareSourceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteShareSourceOptions, "deleteShareSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteShareSourceOptions, "deleteShareSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *deleteShareSourceOptions.ShareID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/source`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteShareSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteShareSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetShareSource : Retrieve the source file share for a replica file share
// This request retrieves the source file share associated with the replica file share specified by the identifier in
// the URL.
func (vpc *VpcV1) GetShareSource(getShareSourceOptions *GetShareSourceOptions) (result *Share, response *core.DetailedResponse, err error) {
	return vpc.GetShareSourceWithContext(context.Background(), getShareSourceOptions)
}

// GetShareSourceWithContext is an alternate form of the GetShareSource method which supports a Context parameter
func (vpc *VpcV1) GetShareSourceWithContext(ctx context.Context, getShareSourceOptions *GetShareSourceOptions) (result *Share, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getShareSourceOptions, "getShareSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getShareSourceOptions, "getShareSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"share_id": *getShareSourceOptions.ShareID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/shares/{share_id}/source`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getShareSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetShareSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalShare)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListRegions : List all regions
// This request lists all regions. Each region is a separate geographic area that contains multiple isolated zones.
// Resources can be provisioned into one or more zones in a region. Each zone is isolated, but connected to other zones
// in the same region with low-latency and high-bandwidth links. Regions represent the top-level of fault isolation
// available. Resources deployed within a single region also benefit from the low latency afforded by geographic
// proximity.
func (vpc *VpcV1) ListRegions(listRegionsOptions *ListRegionsOptions) (result *RegionCollection, response *core.DetailedResponse, err error) {
	return vpc.ListRegionsWithContext(context.Background(), listRegionsOptions)
}

// ListRegionsWithContext is an alternate form of the ListRegions method which supports a Context parameter
func (vpc *VpcV1) ListRegionsWithContext(ctx context.Context, listRegionsOptions *ListRegionsOptions) (result *RegionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listRegionsOptions, "listRegionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/regions`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listRegionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListRegions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetRegion : Retrieve a region
// This request retrieves a single region specified by the name in the URL.
func (vpc *VpcV1) GetRegion(getRegionOptions *GetRegionOptions) (result *Region, response *core.DetailedResponse, err error) {
	return vpc.GetRegionWithContext(context.Background(), getRegionOptions)
}

// GetRegionWithContext is an alternate form of the GetRegion method which supports a Context parameter
func (vpc *VpcV1) GetRegionWithContext(ctx context.Context, getRegionOptions *GetRegionOptions) (result *Region, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRegionOptions, "getRegionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getRegionOptions, "getRegionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getRegionOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/regions/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRegionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetRegion")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegion)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListRegionZones : List all zones in a region
// This request lists all zones in a region. Zones represent logically-isolated data centers with high-bandwidth and
// low-latency interconnects to other zones in the same region. Faults in a zone do not affect other zones.
func (vpc *VpcV1) ListRegionZones(listRegionZonesOptions *ListRegionZonesOptions) (result *ZoneCollection, response *core.DetailedResponse, err error) {
	return vpc.ListRegionZonesWithContext(context.Background(), listRegionZonesOptions)
}

// ListRegionZonesWithContext is an alternate form of the ListRegionZones method which supports a Context parameter
func (vpc *VpcV1) ListRegionZonesWithContext(ctx context.Context, listRegionZonesOptions *ListRegionZonesOptions) (result *ZoneCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listRegionZonesOptions, "listRegionZonesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listRegionZonesOptions, "listRegionZonesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_name": *listRegionZonesOptions.RegionName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/regions/{region_name}/zones`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listRegionZonesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListRegionZones")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalZoneCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetRegionZone : Retrieve a zone
// This request retrieves a single zone specified by the region and zone names in the URL.
func (vpc *VpcV1) GetRegionZone(getRegionZoneOptions *GetRegionZoneOptions) (result *Zone, response *core.DetailedResponse, err error) {
	return vpc.GetRegionZoneWithContext(context.Background(), getRegionZoneOptions)
}

// GetRegionZoneWithContext is an alternate form of the GetRegionZone method which supports a Context parameter
func (vpc *VpcV1) GetRegionZoneWithContext(ctx context.Context, getRegionZoneOptions *GetRegionZoneOptions) (result *Zone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRegionZoneOptions, "getRegionZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getRegionZoneOptions, "getRegionZoneOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_name": *getRegionZoneOptions.RegionName,
		"name":        *getRegionZoneOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/regions/{region_name}/zones/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRegionZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetRegionZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalZone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVirtualNetworkInterfaces : List all virtual network interfaces
// This request lists all virtual network interfaces in the region. A virtual network interface is a logical abstraction
// of a virtual network interface in a subnet, and may be attached to a target resource.
//
// The virtual network interfaces will be sorted by their `created_at` property values, with newest virtual network
// interfaces first. Virtual network interfaces with identical
// `created_at` property values will in turn be sorted by ascending `name` property values.
func (vpc *VpcV1) ListVirtualNetworkInterfaces(listVirtualNetworkInterfacesOptions *ListVirtualNetworkInterfacesOptions) (result *VirtualNetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVirtualNetworkInterfacesWithContext(context.Background(), listVirtualNetworkInterfacesOptions)
}

// ListVirtualNetworkInterfacesWithContext is an alternate form of the ListVirtualNetworkInterfaces method which supports a Context parameter
func (vpc *VpcV1) ListVirtualNetworkInterfacesWithContext(ctx context.Context, listVirtualNetworkInterfacesOptions *ListVirtualNetworkInterfacesOptions) (result *VirtualNetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVirtualNetworkInterfacesOptions, "listVirtualNetworkInterfacesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/virtual_network_interfaces`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVirtualNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVirtualNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVirtualNetworkInterfacesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVirtualNetworkInterfacesOptions.Start))
	}
	if listVirtualNetworkInterfacesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVirtualNetworkInterfacesOptions.Limit))
	}
	if listVirtualNetworkInterfacesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVirtualNetworkInterfacesOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVirtualNetworkInterfaceCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetVirtualNetworkInterface : Retrieve a virtual network interface
// This request retrieves a single virtual network interface specified by the identifier in the URL.
func (vpc *VpcV1) GetVirtualNetworkInterface(getVirtualNetworkInterfaceOptions *GetVirtualNetworkInterfaceOptions) (result *VirtualNetworkInterface, response *core.DetailedResponse, err error) {
	return vpc.GetVirtualNetworkInterfaceWithContext(context.Background(), getVirtualNetworkInterfaceOptions)
}

// GetVirtualNetworkInterfaceWithContext is an alternate form of the GetVirtualNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) GetVirtualNetworkInterfaceWithContext(ctx context.Context, getVirtualNetworkInterfaceOptions *GetVirtualNetworkInterfaceOptions) (result *VirtualNetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVirtualNetworkInterfaceOptions, "getVirtualNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVirtualNetworkInterfaceOptions, "getVirtualNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVirtualNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/virtual_network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVirtualNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVirtualNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVirtualNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVirtualNetworkInterface : Update a virtual network interface
// This request updates a virtual network interface with the information in a provided virtual network interface patch.
// The virtual network interface patch object is structured in the same way as a retrieved virtual network interface and
// contains only the information to be updated.
func (vpc *VpcV1) UpdateVirtualNetworkInterface(updateVirtualNetworkInterfaceOptions *UpdateVirtualNetworkInterfaceOptions) (result *VirtualNetworkInterface, response *core.DetailedResponse, err error) {
	return vpc.UpdateVirtualNetworkInterfaceWithContext(context.Background(), updateVirtualNetworkInterfaceOptions)
}

// UpdateVirtualNetworkInterfaceWithContext is an alternate form of the UpdateVirtualNetworkInterface method which supports a Context parameter
func (vpc *VpcV1) UpdateVirtualNetworkInterfaceWithContext(ctx context.Context, updateVirtualNetworkInterfaceOptions *UpdateVirtualNetworkInterfaceOptions) (result *VirtualNetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVirtualNetworkInterfaceOptions, "updateVirtualNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVirtualNetworkInterfaceOptions, "updateVirtualNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateVirtualNetworkInterfaceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/virtual_network_interfaces/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVirtualNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVirtualNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVirtualNetworkInterfaceOptions.VirtualNetworkInterfacePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVirtualNetworkInterface)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListPublicGateways : List all public gateways
// This request lists all public gateways in the region. A public gateway is a virtual network device associated with a
// VPC, which allows access to the Internet. A public gateway resides in a zone and can be connected to subnets in the
// same zone only.
func (vpc *VpcV1) ListPublicGateways(listPublicGatewaysOptions *ListPublicGatewaysOptions) (result *PublicGatewayCollection, response *core.DetailedResponse, err error) {
	return vpc.ListPublicGatewaysWithContext(context.Background(), listPublicGatewaysOptions)
}

// ListPublicGatewaysWithContext is an alternate form of the ListPublicGateways method which supports a Context parameter
func (vpc *VpcV1) ListPublicGatewaysWithContext(ctx context.Context, listPublicGatewaysOptions *ListPublicGatewaysOptions) (result *PublicGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listPublicGatewaysOptions, "listPublicGatewaysOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/public_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listPublicGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListPublicGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listPublicGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listPublicGatewaysOptions.Start))
	}
	if listPublicGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listPublicGatewaysOptions.Limit))
	}
	if listPublicGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listPublicGatewaysOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGatewayCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreatePublicGateway : Create a public gateway
// This request creates a new public gateway from a public gateway prototype object. For this to succeed, the VPC must
// not already have a public gateway in the specified zone.
//
// If a floating IP is provided, it must be unbound. If a floating IP is not provided, one will be created and bound to
// the public gateway. Once a public gateway has been created, its floating IP cannot be unbound. A public gateway must
// be explicitly attached to each subnet it will provide connectivity for.
func (vpc *VpcV1) CreatePublicGateway(createPublicGatewayOptions *CreatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	return vpc.CreatePublicGatewayWithContext(context.Background(), createPublicGatewayOptions)
}

// CreatePublicGatewayWithContext is an alternate form of the CreatePublicGateway method which supports a Context parameter
func (vpc *VpcV1) CreatePublicGatewayWithContext(ctx context.Context, createPublicGatewayOptions *CreatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createPublicGatewayOptions, "createPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createPublicGatewayOptions, "createPublicGatewayOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/public_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreatePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createPublicGatewayOptions.VPC != nil {
		body["vpc"] = createPublicGatewayOptions.VPC
	}
	if createPublicGatewayOptions.Zone != nil {
		body["zone"] = createPublicGatewayOptions.Zone
	}
	if createPublicGatewayOptions.FloatingIP != nil {
		body["floating_ip"] = createPublicGatewayOptions.FloatingIP
	}
	if createPublicGatewayOptions.Name != nil {
		body["name"] = createPublicGatewayOptions.Name
	}
	if createPublicGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createPublicGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeletePublicGateway : Delete a public gateway
// This request deletes a public gateway. This operation cannot be reversed. For this request to succeed, the public
// gateway must not be attached to any subnets. The public gateway's floating IP will be automatically unbound. If the
// floating IP was created when the public gateway was created, it will be deleted.
func (vpc *VpcV1) DeletePublicGateway(deletePublicGatewayOptions *DeletePublicGatewayOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeletePublicGatewayWithContext(context.Background(), deletePublicGatewayOptions)
}

// DeletePublicGatewayWithContext is an alternate form of the DeletePublicGateway method which supports a Context parameter
func (vpc *VpcV1) DeletePublicGatewayWithContext(ctx context.Context, deletePublicGatewayOptions *DeletePublicGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deletePublicGatewayOptions, "deletePublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deletePublicGatewayOptions, "deletePublicGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deletePublicGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/public_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deletePublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeletePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetPublicGateway : Retrieve a public gateway
// This request retrieves a single public gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetPublicGateway(getPublicGatewayOptions *GetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	return vpc.GetPublicGatewayWithContext(context.Background(), getPublicGatewayOptions)
}

// GetPublicGatewayWithContext is an alternate form of the GetPublicGateway method which supports a Context parameter
func (vpc *VpcV1) GetPublicGatewayWithContext(ctx context.Context, getPublicGatewayOptions *GetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getPublicGatewayOptions, "getPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getPublicGatewayOptions, "getPublicGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getPublicGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/public_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdatePublicGateway : Update a public gateway
// This request updates a public gateway's name.
func (vpc *VpcV1) UpdatePublicGateway(updatePublicGatewayOptions *UpdatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	return vpc.UpdatePublicGatewayWithContext(context.Background(), updatePublicGatewayOptions)
}

// UpdatePublicGatewayWithContext is an alternate form of the UpdatePublicGateway method which supports a Context parameter
func (vpc *VpcV1) UpdatePublicGatewayWithContext(ctx context.Context, updatePublicGatewayOptions *UpdatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updatePublicGatewayOptions, "updatePublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updatePublicGatewayOptions, "updatePublicGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updatePublicGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/public_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updatePublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdatePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updatePublicGatewayOptions.PublicGatewayPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListFloatingIps : List all floating IPs
// This request lists all floating IPs in the region. Floating IPs allow inbound and outbound traffic from the Internet
// to an instance.
func (vpc *VpcV1) ListFloatingIps(listFloatingIpsOptions *ListFloatingIpsOptions) (result *FloatingIPCollection, response *core.DetailedResponse, err error) {
	return vpc.ListFloatingIpsWithContext(context.Background(), listFloatingIpsOptions)
}

// ListFloatingIpsWithContext is an alternate form of the ListFloatingIps method which supports a Context parameter
func (vpc *VpcV1) ListFloatingIpsWithContext(ctx context.Context, listFloatingIpsOptions *ListFloatingIpsOptions) (result *FloatingIPCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listFloatingIpsOptions, "listFloatingIpsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/floating_ips`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listFloatingIpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listFloatingIpsOptions.Start))
	}
	if listFloatingIpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listFloatingIpsOptions.Limit))
	}
	if listFloatingIpsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listFloatingIpsOptions.ResourceGroupID))
	}
	if listFloatingIpsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listFloatingIpsOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIPCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateFloatingIP : Reserve a floating IP
// This request reserves a new floating IP.
func (vpc *VpcV1) CreateFloatingIP(createFloatingIPOptions *CreateFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.CreateFloatingIPWithContext(context.Background(), createFloatingIPOptions)
}

// CreateFloatingIPWithContext is an alternate form of the CreateFloatingIP method which supports a Context parameter
func (vpc *VpcV1) CreateFloatingIPWithContext(ctx context.Context, createFloatingIPOptions *CreateFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createFloatingIPOptions, "createFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createFloatingIPOptions, "createFloatingIPOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/floating_ips`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createFloatingIPOptions.FloatingIPPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteFloatingIP : Delete a floating IP
// This request disassociates (if associated) and releases a floating IP. This operation cannot be reversed. For this
// request to succeed, the floating IP must not be required by another resource, such as a public gateway.
func (vpc *VpcV1) DeleteFloatingIP(deleteFloatingIPOptions *DeleteFloatingIPOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteFloatingIPWithContext(context.Background(), deleteFloatingIPOptions)
}

// DeleteFloatingIPWithContext is an alternate form of the DeleteFloatingIP method which supports a Context parameter
func (vpc *VpcV1) DeleteFloatingIPWithContext(ctx context.Context, deleteFloatingIPOptions *DeleteFloatingIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFloatingIPOptions, "deleteFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFloatingIPOptions, "deleteFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetFloatingIP : Retrieve a floating IP
// This request retrieves a single floating IP specified by the identifier in the URL.
func (vpc *VpcV1) GetFloatingIP(getFloatingIPOptions *GetFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.GetFloatingIPWithContext(context.Background(), getFloatingIPOptions)
}

// GetFloatingIPWithContext is an alternate form of the GetFloatingIP method which supports a Context parameter
func (vpc *VpcV1) GetFloatingIPWithContext(ctx context.Context, getFloatingIPOptions *GetFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFloatingIPOptions, "getFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFloatingIPOptions, "getFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateFloatingIP : Update a floating IP
// This request updates a floating IP's name and/or target.
func (vpc *VpcV1) UpdateFloatingIP(updateFloatingIPOptions *UpdateFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	return vpc.UpdateFloatingIPWithContext(context.Background(), updateFloatingIPOptions)
}

// UpdateFloatingIPWithContext is an alternate form of the UpdateFloatingIP method which supports a Context parameter
func (vpc *VpcV1) UpdateFloatingIPWithContext(ctx context.Context, updateFloatingIPOptions *UpdateFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFloatingIPOptions, "updateFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateFloatingIPOptions, "updateFloatingIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateFloatingIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/floating_ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateFloatingIPOptions.FloatingIPPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListNetworkAcls : List all network ACLs
// This request lists all network ACLs in the region. A network ACL defines a set of packet filtering (5-tuple) rules
// for all traffic in and out of a subnet. Both allow and deny rules can be defined, and rules are stateless such that
// reverse traffic in response to allowed traffic is not automatically permitted.
func (vpc *VpcV1) ListNetworkAcls(listNetworkAclsOptions *ListNetworkAclsOptions) (result *NetworkACLCollection, response *core.DetailedResponse, err error) {
	return vpc.ListNetworkAclsWithContext(context.Background(), listNetworkAclsOptions)
}

// ListNetworkAclsWithContext is an alternate form of the ListNetworkAcls method which supports a Context parameter
func (vpc *VpcV1) ListNetworkAclsWithContext(ctx context.Context, listNetworkAclsOptions *ListNetworkAclsOptions) (result *NetworkACLCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listNetworkAclsOptions, "listNetworkAclsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkAclsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkAcls")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listNetworkAclsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listNetworkAclsOptions.Start))
	}
	if listNetworkAclsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listNetworkAclsOptions.Limit))
	}
	if listNetworkAclsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listNetworkAclsOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateNetworkACL : Create a network ACL
// This request creates a new stateless network ACL from a network ACL prototype object. The prototype object is
// structured in the same way as a retrieved network ACL, and contains the information necessary to create the new
// network ACL.
func (vpc *VpcV1) CreateNetworkACL(createNetworkACLOptions *CreateNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	return vpc.CreateNetworkACLWithContext(context.Background(), createNetworkACLOptions)
}

// CreateNetworkACLWithContext is an alternate form of the CreateNetworkACL method which supports a Context parameter
func (vpc *VpcV1) CreateNetworkACLWithContext(ctx context.Context, createNetworkACLOptions *CreateNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNetworkACLOptions, "createNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNetworkACLOptions, "createNetworkACLOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createNetworkACLOptions.NetworkACLPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteNetworkACL : Delete a network ACL
// This request deletes a network ACL. This operation cannot be reversed. For this request to succeed, the network ACL
// must not be the default network ACL for any VPCs, and the network ACL must not be attached to any subnets.
func (vpc *VpcV1) DeleteNetworkACL(deleteNetworkACLOptions *DeleteNetworkACLOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteNetworkACLWithContext(context.Background(), deleteNetworkACLOptions)
}

// DeleteNetworkACLWithContext is an alternate form of the DeleteNetworkACL method which supports a Context parameter
func (vpc *VpcV1) DeleteNetworkACLWithContext(ctx context.Context, deleteNetworkACLOptions *DeleteNetworkACLOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkACLOptions, "deleteNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkACLOptions, "deleteNetworkACLOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteNetworkACLOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkACL : Retrieve a network ACL
// This request retrieves a single network ACL specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkACL(getNetworkACLOptions *GetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	return vpc.GetNetworkACLWithContext(context.Background(), getNetworkACLOptions)
}

// GetNetworkACLWithContext is an alternate form of the GetNetworkACL method which supports a Context parameter
func (vpc *VpcV1) GetNetworkACLWithContext(ctx context.Context, getNetworkACLOptions *GetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkACLOptions, "getNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkACLOptions, "getNetworkACLOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getNetworkACLOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateNetworkACL : Update a network ACL
// This request updates a network ACL's name.
func (vpc *VpcV1) UpdateNetworkACL(updateNetworkACLOptions *UpdateNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	return vpc.UpdateNetworkACLWithContext(context.Background(), updateNetworkACLOptions)
}

// UpdateNetworkACLWithContext is an alternate form of the UpdateNetworkACL method which supports a Context parameter
func (vpc *VpcV1) UpdateNetworkACLWithContext(ctx context.Context, updateNetworkACLOptions *UpdateNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkACLOptions, "updateNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkACLOptions, "updateNetworkACLOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateNetworkACLOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateNetworkACLOptions.NetworkACLPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListNetworkACLRules : List all rules for a network ACL
// This request lists all rules for a network ACL. These rules can allow or deny traffic between a source CIDR block and
// a destination CIDR block over a particular protocol and port range.
func (vpc *VpcV1) ListNetworkACLRules(listNetworkACLRulesOptions *ListNetworkACLRulesOptions) (result *NetworkACLRuleCollection, response *core.DetailedResponse, err error) {
	return vpc.ListNetworkACLRulesWithContext(context.Background(), listNetworkACLRulesOptions)
}

// ListNetworkACLRulesWithContext is an alternate form of the ListNetworkACLRules method which supports a Context parameter
func (vpc *VpcV1) ListNetworkACLRulesWithContext(ctx context.Context, listNetworkACLRulesOptions *ListNetworkACLRulesOptions) (result *NetworkACLRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNetworkACLRulesOptions, "listNetworkACLRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNetworkACLRulesOptions, "listNetworkACLRulesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"network_acl_id": *listNetworkACLRulesOptions.NetworkACLID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{network_acl_id}/rules`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkACLRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkACLRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listNetworkACLRulesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listNetworkACLRulesOptions.Start))
	}
	if listNetworkACLRulesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listNetworkACLRulesOptions.Limit))
	}
	if listNetworkACLRulesOptions.Direction != nil {
		builder.AddQuery("direction", fmt.Sprint(*listNetworkACLRulesOptions.Direction))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRuleCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateNetworkACLRule : Create a rule for a network ACL
// This request creates a new rule from a network ACL rule prototype object. The prototype object is structured in the
// same way as a retrieved rule, and contains the information necessary to create the new rule.
func (vpc *VpcV1) CreateNetworkACLRule(createNetworkACLRuleOptions *CreateNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateNetworkACLRuleWithContext(context.Background(), createNetworkACLRuleOptions)
}

// CreateNetworkACLRuleWithContext is an alternate form of the CreateNetworkACLRule method which supports a Context parameter
func (vpc *VpcV1) CreateNetworkACLRuleWithContext(ctx context.Context, createNetworkACLRuleOptions *CreateNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNetworkACLRuleOptions, "createNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNetworkACLRuleOptions, "createNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"network_acl_id": *createNetworkACLRuleOptions.NetworkACLID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{network_acl_id}/rules`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createNetworkACLRuleOptions.NetworkACLRulePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteNetworkACLRule : Delete a network ACL rule
// This request deletes a rule. This operation cannot be reversed.
func (vpc *VpcV1) DeleteNetworkACLRule(deleteNetworkACLRuleOptions *DeleteNetworkACLRuleOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteNetworkACLRuleWithContext(context.Background(), deleteNetworkACLRuleOptions)
}

// DeleteNetworkACLRuleWithContext is an alternate form of the DeleteNetworkACLRule method which supports a Context parameter
func (vpc *VpcV1) DeleteNetworkACLRuleWithContext(ctx context.Context, deleteNetworkACLRuleOptions *DeleteNetworkACLRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkACLRuleOptions, "deleteNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkACLRuleOptions, "deleteNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"network_acl_id": *deleteNetworkACLRuleOptions.NetworkACLID,
		"id":             *deleteNetworkACLRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{network_acl_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkACLRule : Retrieve a network ACL rule
// This request retrieves a single rule specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkACLRule(getNetworkACLRuleOptions *GetNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	return vpc.GetNetworkACLRuleWithContext(context.Background(), getNetworkACLRuleOptions)
}

// GetNetworkACLRuleWithContext is an alternate form of the GetNetworkACLRule method which supports a Context parameter
func (vpc *VpcV1) GetNetworkACLRuleWithContext(ctx context.Context, getNetworkACLRuleOptions *GetNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkACLRuleOptions, "getNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkACLRuleOptions, "getNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"network_acl_id": *getNetworkACLRuleOptions.NetworkACLID,
		"id":             *getNetworkACLRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{network_acl_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateNetworkACLRule : Update a network ACL rule
// This request updates a rule with the information in a provided rule patch. The rule patch object contains only the
// information to be updated. The request will fail if the information is not applicable to the rule's protocol.
func (vpc *VpcV1) UpdateNetworkACLRule(updateNetworkACLRuleOptions *UpdateNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateNetworkACLRuleWithContext(context.Background(), updateNetworkACLRuleOptions)
}

// UpdateNetworkACLRuleWithContext is an alternate form of the UpdateNetworkACLRule method which supports a Context parameter
func (vpc *VpcV1) UpdateNetworkACLRuleWithContext(ctx context.Context, updateNetworkACLRuleOptions *UpdateNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkACLRuleOptions, "updateNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkACLRuleOptions, "updateNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"network_acl_id": *updateNetworkACLRuleOptions.NetworkACLID,
		"id":             *updateNetworkACLRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/network_acls/{network_acl_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateNetworkACLRuleOptions.NetworkACLRulePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSecurityGroups : List all security groups
// This request lists all security groups in the region. Security groups provide a way to apply IP filtering rules to
// instances in the associated VPC. With security groups, all traffic is denied by default, and rules added to security
// groups define which traffic the security group permits. Security group rules are stateful such that reverse traffic
// in response to allowed traffic is automatically permitted.
func (vpc *VpcV1) ListSecurityGroups(listSecurityGroupsOptions *ListSecurityGroupsOptions) (result *SecurityGroupCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSecurityGroupsWithContext(context.Background(), listSecurityGroupsOptions)
}

// ListSecurityGroupsWithContext is an alternate form of the ListSecurityGroups method which supports a Context parameter
func (vpc *VpcV1) ListSecurityGroupsWithContext(ctx context.Context, listSecurityGroupsOptions *ListSecurityGroupsOptions) (result *SecurityGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSecurityGroupsOptions, "listSecurityGroupsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSecurityGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSecurityGroupsOptions.Start))
	}
	if listSecurityGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSecurityGroupsOptions.Limit))
	}
	if listSecurityGroupsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSecurityGroupsOptions.ResourceGroupID))
	}
	if listSecurityGroupsOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listSecurityGroupsOptions.VPCID))
	}
	if listSecurityGroupsOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listSecurityGroupsOptions.VPCCRN))
	}
	if listSecurityGroupsOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listSecurityGroupsOptions.VPCName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSecurityGroup : Create a security group
// This request creates a new security group from a security group prototype object. The prototype object is structured
// in the same way as a retrieved security group, and contains the information necessary to create the new security
// group. If security group rules are included in the prototype object, those rules will be added to the security group.
// Each security group is scoped to one VPC. Only resources in that VPC can be added to the security group.
func (vpc *VpcV1) CreateSecurityGroup(createSecurityGroupOptions *CreateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	return vpc.CreateSecurityGroupWithContext(context.Background(), createSecurityGroupOptions)
}

// CreateSecurityGroupWithContext is an alternate form of the CreateSecurityGroup method which supports a Context parameter
func (vpc *VpcV1) CreateSecurityGroupWithContext(ctx context.Context, createSecurityGroupOptions *CreateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupOptions, "createSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupOptions, "createSecurityGroupOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createSecurityGroupOptions.VPC != nil {
		body["vpc"] = createSecurityGroupOptions.VPC
	}
	if createSecurityGroupOptions.Name != nil {
		body["name"] = createSecurityGroupOptions.Name
	}
	if createSecurityGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createSecurityGroupOptions.ResourceGroup
	}
	if createSecurityGroupOptions.Rules != nil {
		body["rules"] = createSecurityGroupOptions.Rules
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSecurityGroup : Delete a security group
// This request deletes a security group. A security group cannot be deleted if it is referenced by any security group
// targets or rules. Additionally, a VPC's default security group cannot be deleted. This operation cannot be reversed.
func (vpc *VpcV1) DeleteSecurityGroup(deleteSecurityGroupOptions *DeleteSecurityGroupOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSecurityGroupWithContext(context.Background(), deleteSecurityGroupOptions)
}

// DeleteSecurityGroupWithContext is an alternate form of the DeleteSecurityGroup method which supports a Context parameter
func (vpc *VpcV1) DeleteSecurityGroupWithContext(ctx context.Context, deleteSecurityGroupOptions *DeleteSecurityGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupOptions, "deleteSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupOptions, "deleteSecurityGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteSecurityGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroup : Retrieve a security group
// This request retrieves a single security group specified by the identifier in the URL path.
func (vpc *VpcV1) GetSecurityGroup(getSecurityGroupOptions *GetSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	return vpc.GetSecurityGroupWithContext(context.Background(), getSecurityGroupOptions)
}

// GetSecurityGroupWithContext is an alternate form of the GetSecurityGroup method which supports a Context parameter
func (vpc *VpcV1) GetSecurityGroupWithContext(ctx context.Context, getSecurityGroupOptions *GetSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupOptions, "getSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupOptions, "getSecurityGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getSecurityGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSecurityGroup : Update a security group
// This request updates a security group with the information provided in a security group patch object. The security
// group patch object is structured in the same way as a retrieved security group and contains only the information to
// be updated.
func (vpc *VpcV1) UpdateSecurityGroup(updateSecurityGroupOptions *UpdateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	return vpc.UpdateSecurityGroupWithContext(context.Background(), updateSecurityGroupOptions)
}

// UpdateSecurityGroupWithContext is an alternate form of the UpdateSecurityGroup method which supports a Context parameter
func (vpc *VpcV1) UpdateSecurityGroupWithContext(ctx context.Context, updateSecurityGroupOptions *UpdateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecurityGroupOptions, "updateSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecurityGroupOptions, "updateSecurityGroupOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateSecurityGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateSecurityGroupOptions.SecurityGroupPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSecurityGroupRules : List all rules in a security group
// This request lists all rules in a security group. These rules define what traffic the security group permits.
// Security group rules are stateful, such that reverse traffic in response to allowed traffic is automatically
// permitted.
func (vpc *VpcV1) ListSecurityGroupRules(listSecurityGroupRulesOptions *ListSecurityGroupRulesOptions) (result *SecurityGroupRuleCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSecurityGroupRulesWithContext(context.Background(), listSecurityGroupRulesOptions)
}

// ListSecurityGroupRulesWithContext is an alternate form of the ListSecurityGroupRules method which supports a Context parameter
func (vpc *VpcV1) ListSecurityGroupRulesWithContext(ctx context.Context, listSecurityGroupRulesOptions *ListSecurityGroupRulesOptions) (result *SecurityGroupRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSecurityGroupRulesOptions, "listSecurityGroupRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSecurityGroupRulesOptions, "listSecurityGroupRulesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *listSecurityGroupRulesOptions.SecurityGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/rules`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroupRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRuleCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSecurityGroupRule : Create a rule for a security group
// This request creates a new security group rule from a security group rule prototype object. The prototype object is
// structured in the same way as a retrieved security group rule and contains the information necessary to create the
// rule. As part of creating a new rule in a security group, the rule is applied to all the networking interfaces in the
// security group. Rules specify which IP traffic a security group will allow. Security group rules are stateful, such
// that reverse traffic in response to allowed traffic is automatically permitted. A rule allowing inbound TCP traffic
// on port 80 also allows outbound TCP traffic on port 80 without the need for an additional rule.
func (vpc *VpcV1) CreateSecurityGroupRule(createSecurityGroupRuleOptions *CreateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateSecurityGroupRuleWithContext(context.Background(), createSecurityGroupRuleOptions)
}

// CreateSecurityGroupRuleWithContext is an alternate form of the CreateSecurityGroupRule method which supports a Context parameter
func (vpc *VpcV1) CreateSecurityGroupRuleWithContext(ctx context.Context, createSecurityGroupRuleOptions *CreateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupRuleOptions, "createSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupRuleOptions, "createSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *createSecurityGroupRuleOptions.SecurityGroupID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/rules`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSecurityGroupRuleOptions.SecurityGroupRulePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSecurityGroupRule : Delete a security group rule
// This request deletes a security group rule. This operation cannot be reversed. Removing a security group rule will
// not end existing connections allowed by that rule.
func (vpc *VpcV1) DeleteSecurityGroupRule(deleteSecurityGroupRuleOptions *DeleteSecurityGroupRuleOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSecurityGroupRuleWithContext(context.Background(), deleteSecurityGroupRuleOptions)
}

// DeleteSecurityGroupRuleWithContext is an alternate form of the DeleteSecurityGroupRule method which supports a Context parameter
func (vpc *VpcV1) DeleteSecurityGroupRuleWithContext(ctx context.Context, deleteSecurityGroupRuleOptions *DeleteSecurityGroupRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupRuleOptions, "deleteSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupRuleOptions, "deleteSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *deleteSecurityGroupRuleOptions.SecurityGroupID,
		"id":                *deleteSecurityGroupRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroupRule : Retrieve a security group rule
// This request retrieves a single security group rule specified by the identifier in the URL path.
func (vpc *VpcV1) GetSecurityGroupRule(getSecurityGroupRuleOptions *GetSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	return vpc.GetSecurityGroupRuleWithContext(context.Background(), getSecurityGroupRuleOptions)
}

// GetSecurityGroupRuleWithContext is an alternate form of the GetSecurityGroupRule method which supports a Context parameter
func (vpc *VpcV1) GetSecurityGroupRuleWithContext(ctx context.Context, getSecurityGroupRuleOptions *GetSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupRuleOptions, "getSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupRuleOptions, "getSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *getSecurityGroupRuleOptions.SecurityGroupID,
		"id":                *getSecurityGroupRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSecurityGroupRule : Update a security group rule
// This request updates a security group rule with the information in a provided rule patch object. The rule patch
// object contains only the information to be updated. The request will fail if the information is not applicable to the
// rule's protocol.
func (vpc *VpcV1) UpdateSecurityGroupRule(updateSecurityGroupRuleOptions *UpdateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateSecurityGroupRuleWithContext(context.Background(), updateSecurityGroupRuleOptions)
}

// UpdateSecurityGroupRuleWithContext is an alternate form of the UpdateSecurityGroupRule method which supports a Context parameter
func (vpc *VpcV1) UpdateSecurityGroupRuleWithContext(ctx context.Context, updateSecurityGroupRuleOptions *UpdateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecurityGroupRuleOptions, "updateSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecurityGroupRuleOptions, "updateSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *updateSecurityGroupRuleOptions.SecurityGroupID,
		"id":                *updateSecurityGroupRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateSecurityGroupRuleOptions.SecurityGroupRulePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSecurityGroupTargets : List all targets associated with a security group
// This request lists all targets associated with a security group, to which the rules in the security group are
// applied.
func (vpc *VpcV1) ListSecurityGroupTargets(listSecurityGroupTargetsOptions *ListSecurityGroupTargetsOptions) (result *SecurityGroupTargetCollection, response *core.DetailedResponse, err error) {
	return vpc.ListSecurityGroupTargetsWithContext(context.Background(), listSecurityGroupTargetsOptions)
}

// ListSecurityGroupTargetsWithContext is an alternate form of the ListSecurityGroupTargets method which supports a Context parameter
func (vpc *VpcV1) ListSecurityGroupTargetsWithContext(ctx context.Context, listSecurityGroupTargetsOptions *ListSecurityGroupTargetsOptions) (result *SecurityGroupTargetCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSecurityGroupTargetsOptions, "listSecurityGroupTargetsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSecurityGroupTargetsOptions, "listSecurityGroupTargetsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *listSecurityGroupTargetsOptions.SecurityGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/targets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupTargetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroupTargets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSecurityGroupTargetsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSecurityGroupTargetsOptions.Start))
	}
	if listSecurityGroupTargetsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSecurityGroupTargetsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupTargetCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSecurityGroupTargetBinding : Remove a target from a security group
// This request removes a target from a security group. For this request to succeed, the target must be attached to at
// least one other security group.  The specified target identifier can be:
//
// - A bare metal server network interface identifier
// - A virtual network interface identifier
// - A VPN server identifier
// - An application load balancer identifier
// - An endpoint gateway identifier
// - An instance network interface identifier
//
// Security groups are stateful, so any changes to a target's security groups are applied to new connections. Existing
// connections are not affected.
func (vpc *VpcV1) DeleteSecurityGroupTargetBinding(deleteSecurityGroupTargetBindingOptions *DeleteSecurityGroupTargetBindingOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteSecurityGroupTargetBindingWithContext(context.Background(), deleteSecurityGroupTargetBindingOptions)
}

// DeleteSecurityGroupTargetBindingWithContext is an alternate form of the DeleteSecurityGroupTargetBinding method which supports a Context parameter
func (vpc *VpcV1) DeleteSecurityGroupTargetBindingWithContext(ctx context.Context, deleteSecurityGroupTargetBindingOptions *DeleteSecurityGroupTargetBindingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupTargetBindingOptions, "deleteSecurityGroupTargetBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupTargetBindingOptions, "deleteSecurityGroupTargetBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *deleteSecurityGroupTargetBindingOptions.SecurityGroupID,
		"id":                *deleteSecurityGroupTargetBindingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/targets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupTargetBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroupTargetBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroupTarget : Retrieve a security group target
// This request retrieves a single target specified by the identifier in the URL path. The target must be an existing
// target of the security group.
func (vpc *VpcV1) GetSecurityGroupTarget(getSecurityGroupTargetOptions *GetSecurityGroupTargetOptions) (result SecurityGroupTargetReferenceIntf, response *core.DetailedResponse, err error) {
	return vpc.GetSecurityGroupTargetWithContext(context.Background(), getSecurityGroupTargetOptions)
}

// GetSecurityGroupTargetWithContext is an alternate form of the GetSecurityGroupTarget method which supports a Context parameter
func (vpc *VpcV1) GetSecurityGroupTargetWithContext(ctx context.Context, getSecurityGroupTargetOptions *GetSecurityGroupTargetOptions) (result SecurityGroupTargetReferenceIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupTargetOptions, "getSecurityGroupTargetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupTargetOptions, "getSecurityGroupTargetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *getSecurityGroupTargetOptions.SecurityGroupID,
		"id":                *getSecurityGroupTargetOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/targets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupTargetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroupTarget")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupTargetReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSecurityGroupTargetBinding : Add a target to a security group
// This request adds a resource to an existing security group. The specified target identifier can be:
//
// - A bare metal server network interface identifier
// - A virtual network interface identifier
// - A VPN server identifier
// - An application load balancer identifier
// - An endpoint gateway identifier
// - An instance network interface identifier
//
// When a target is added to a security group, the security group rules are applied to the target. A request body is not
// required, and if provided, is ignored.
func (vpc *VpcV1) CreateSecurityGroupTargetBinding(createSecurityGroupTargetBindingOptions *CreateSecurityGroupTargetBindingOptions) (result SecurityGroupTargetReferenceIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateSecurityGroupTargetBindingWithContext(context.Background(), createSecurityGroupTargetBindingOptions)
}

// CreateSecurityGroupTargetBindingWithContext is an alternate form of the CreateSecurityGroupTargetBinding method which supports a Context parameter
func (vpc *VpcV1) CreateSecurityGroupTargetBindingWithContext(ctx context.Context, createSecurityGroupTargetBindingOptions *CreateSecurityGroupTargetBindingOptions) (result SecurityGroupTargetReferenceIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupTargetBindingOptions, "createSecurityGroupTargetBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupTargetBindingOptions, "createSecurityGroupTargetBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"security_group_id": *createSecurityGroupTargetBindingOptions.SecurityGroupID,
		"id":                *createSecurityGroupTargetBindingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/security_groups/{security_group_id}/targets/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupTargetBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroupTargetBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupTargetReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListIkePolicies : List all IKE policies
// This request lists all IKE policies in the region.
func (vpc *VpcV1) ListIkePolicies(listIkePoliciesOptions *ListIkePoliciesOptions) (result *IkePolicyCollection, response *core.DetailedResponse, err error) {
	return vpc.ListIkePoliciesWithContext(context.Background(), listIkePoliciesOptions)
}

// ListIkePoliciesWithContext is an alternate form of the ListIkePolicies method which supports a Context parameter
func (vpc *VpcV1) ListIkePoliciesWithContext(ctx context.Context, listIkePoliciesOptions *ListIkePoliciesOptions) (result *IkePolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listIkePoliciesOptions, "listIkePoliciesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ike_policies`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIkePoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIkePolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listIkePoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listIkePoliciesOptions.Start))
	}
	if listIkePoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIkePoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicyCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateIkePolicy : Create an IKE policy
// This request creates a new IKE policy.
func (vpc *VpcV1) CreateIkePolicy(createIkePolicyOptions *CreateIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	return vpc.CreateIkePolicyWithContext(context.Background(), createIkePolicyOptions)
}

// CreateIkePolicyWithContext is an alternate form of the CreateIkePolicy method which supports a Context parameter
func (vpc *VpcV1) CreateIkePolicyWithContext(ctx context.Context, createIkePolicyOptions *CreateIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIkePolicyOptions, "createIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIkePolicyOptions, "createIkePolicyOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ike_policies`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createIkePolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = createIkePolicyOptions.AuthenticationAlgorithm
	}
	if createIkePolicyOptions.DhGroup != nil {
		body["dh_group"] = createIkePolicyOptions.DhGroup
	}
	if createIkePolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = createIkePolicyOptions.EncryptionAlgorithm
	}
	if createIkePolicyOptions.IkeVersion != nil {
		body["ike_version"] = createIkePolicyOptions.IkeVersion
	}
	if createIkePolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = createIkePolicyOptions.KeyLifetime
	}
	if createIkePolicyOptions.Name != nil {
		body["name"] = createIkePolicyOptions.Name
	}
	if createIkePolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createIkePolicyOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteIkePolicy : Delete an IKE policy
// This request deletes an IKE policy. This operation cannot be reversed. For this request to succeed, there must not be
// any VPN gateway connections using this policy.
func (vpc *VpcV1) DeleteIkePolicy(deleteIkePolicyOptions *DeleteIkePolicyOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteIkePolicyWithContext(context.Background(), deleteIkePolicyOptions)
}

// DeleteIkePolicyWithContext is an alternate form of the DeleteIkePolicy method which supports a Context parameter
func (vpc *VpcV1) DeleteIkePolicyWithContext(ctx context.Context, deleteIkePolicyOptions *DeleteIkePolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIkePolicyOptions, "deleteIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIkePolicyOptions, "deleteIkePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteIkePolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ike_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetIkePolicy : Retrieve an IKE policy
// This request retrieves a single IKE policy specified by the identifier in the URL.
func (vpc *VpcV1) GetIkePolicy(getIkePolicyOptions *GetIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	return vpc.GetIkePolicyWithContext(context.Background(), getIkePolicyOptions)
}

// GetIkePolicyWithContext is an alternate form of the GetIkePolicy method which supports a Context parameter
func (vpc *VpcV1) GetIkePolicyWithContext(ctx context.Context, getIkePolicyOptions *GetIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIkePolicyOptions, "getIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIkePolicyOptions, "getIkePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getIkePolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ike_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateIkePolicy : Update an IKE policy
// This request updates the properties of an existing IKE policy.
func (vpc *VpcV1) UpdateIkePolicy(updateIkePolicyOptions *UpdateIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	return vpc.UpdateIkePolicyWithContext(context.Background(), updateIkePolicyOptions)
}

// UpdateIkePolicyWithContext is an alternate form of the UpdateIkePolicy method which supports a Context parameter
func (vpc *VpcV1) UpdateIkePolicyWithContext(ctx context.Context, updateIkePolicyOptions *UpdateIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateIkePolicyOptions, "updateIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateIkePolicyOptions, "updateIkePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateIkePolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ike_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateIkePolicyOptions.IkePolicyPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListIkePolicyConnections : List all VPN gateway connections that use a specified IKE policy
// This request lists all VPN gateway connections that use a policy.
func (vpc *VpcV1) ListIkePolicyConnections(listIkePolicyConnectionsOptions *ListIkePolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	return vpc.ListIkePolicyConnectionsWithContext(context.Background(), listIkePolicyConnectionsOptions)
}

// ListIkePolicyConnectionsWithContext is an alternate form of the ListIkePolicyConnections method which supports a Context parameter
func (vpc *VpcV1) ListIkePolicyConnectionsWithContext(ctx context.Context, listIkePolicyConnectionsOptions *ListIkePolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listIkePolicyConnectionsOptions, "listIkePolicyConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listIkePolicyConnectionsOptions, "listIkePolicyConnectionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *listIkePolicyConnectionsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ike_policies/{id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIkePolicyConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIkePolicyConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListIpsecPolicies : List all IPsec policies
// This request lists all IPsec policies in the region.
func (vpc *VpcV1) ListIpsecPolicies(listIpsecPoliciesOptions *ListIpsecPoliciesOptions) (result *IPsecPolicyCollection, response *core.DetailedResponse, err error) {
	return vpc.ListIpsecPoliciesWithContext(context.Background(), listIpsecPoliciesOptions)
}

// ListIpsecPoliciesWithContext is an alternate form of the ListIpsecPolicies method which supports a Context parameter
func (vpc *VpcV1) ListIpsecPoliciesWithContext(ctx context.Context, listIpsecPoliciesOptions *ListIpsecPoliciesOptions) (result *IPsecPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listIpsecPoliciesOptions, "listIpsecPoliciesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ipsec_policies`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIpsecPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIpsecPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listIpsecPoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listIpsecPoliciesOptions.Start))
	}
	if listIpsecPoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIpsecPoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicyCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateIpsecPolicy : Create an IPsec policy
// This request creates a new IPsec policy.
func (vpc *VpcV1) CreateIpsecPolicy(createIpsecPolicyOptions *CreateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	return vpc.CreateIpsecPolicyWithContext(context.Background(), createIpsecPolicyOptions)
}

// CreateIpsecPolicyWithContext is an alternate form of the CreateIpsecPolicy method which supports a Context parameter
func (vpc *VpcV1) CreateIpsecPolicyWithContext(ctx context.Context, createIpsecPolicyOptions *CreateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIpsecPolicyOptions, "createIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIpsecPolicyOptions, "createIpsecPolicyOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ipsec_policies`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createIpsecPolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = createIpsecPolicyOptions.AuthenticationAlgorithm
	}
	if createIpsecPolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = createIpsecPolicyOptions.EncryptionAlgorithm
	}
	if createIpsecPolicyOptions.Pfs != nil {
		body["pfs"] = createIpsecPolicyOptions.Pfs
	}
	if createIpsecPolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = createIpsecPolicyOptions.KeyLifetime
	}
	if createIpsecPolicyOptions.Name != nil {
		body["name"] = createIpsecPolicyOptions.Name
	}
	if createIpsecPolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createIpsecPolicyOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteIpsecPolicy : Delete an IPsec policy
// This request deletes an IPsec policy. This operation cannot be reversed. For this request to succeed, there must not
// be any VPN gateway connections using this policy.
func (vpc *VpcV1) DeleteIpsecPolicy(deleteIpsecPolicyOptions *DeleteIpsecPolicyOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteIpsecPolicyWithContext(context.Background(), deleteIpsecPolicyOptions)
}

// DeleteIpsecPolicyWithContext is an alternate form of the DeleteIpsecPolicy method which supports a Context parameter
func (vpc *VpcV1) DeleteIpsecPolicyWithContext(ctx context.Context, deleteIpsecPolicyOptions *DeleteIpsecPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIpsecPolicyOptions, "deleteIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIpsecPolicyOptions, "deleteIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteIpsecPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ipsec_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetIpsecPolicy : Retrieve an IPsec policy
// This request retrieves a single IPsec policy specified by the identifier in the URL.
func (vpc *VpcV1) GetIpsecPolicy(getIpsecPolicyOptions *GetIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	return vpc.GetIpsecPolicyWithContext(context.Background(), getIpsecPolicyOptions)
}

// GetIpsecPolicyWithContext is an alternate form of the GetIpsecPolicy method which supports a Context parameter
func (vpc *VpcV1) GetIpsecPolicyWithContext(ctx context.Context, getIpsecPolicyOptions *GetIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIpsecPolicyOptions, "getIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIpsecPolicyOptions, "getIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getIpsecPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ipsec_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateIpsecPolicy : Update an IPsec policy
// This request updates the properties of an existing IPsec policy.
func (vpc *VpcV1) UpdateIpsecPolicy(updateIpsecPolicyOptions *UpdateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	return vpc.UpdateIpsecPolicyWithContext(context.Background(), updateIpsecPolicyOptions)
}

// UpdateIpsecPolicyWithContext is an alternate form of the UpdateIpsecPolicy method which supports a Context parameter
func (vpc *VpcV1) UpdateIpsecPolicyWithContext(ctx context.Context, updateIpsecPolicyOptions *UpdateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateIpsecPolicyOptions, "updateIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateIpsecPolicyOptions, "updateIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateIpsecPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ipsec_policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateIpsecPolicyOptions.IPsecPolicyPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListIpsecPolicyConnections : List all VPN gateway connections that use a specified IPsec policy
// This request lists all VPN gateway connections that use a policy.
func (vpc *VpcV1) ListIpsecPolicyConnections(listIpsecPolicyConnectionsOptions *ListIpsecPolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	return vpc.ListIpsecPolicyConnectionsWithContext(context.Background(), listIpsecPolicyConnectionsOptions)
}

// ListIpsecPolicyConnectionsWithContext is an alternate form of the ListIpsecPolicyConnections method which supports a Context parameter
func (vpc *VpcV1) ListIpsecPolicyConnectionsWithContext(ctx context.Context, listIpsecPolicyConnectionsOptions *ListIpsecPolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listIpsecPolicyConnectionsOptions, "listIpsecPolicyConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listIpsecPolicyConnectionsOptions, "listIpsecPolicyConnectionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *listIpsecPolicyConnectionsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/ipsec_policies/{id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIpsecPolicyConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIpsecPolicyConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPNGateways : List all VPN gateways
// This request lists all VPN gateways in the region.
func (vpc *VpcV1) ListVPNGateways(listVPNGatewaysOptions *ListVPNGatewaysOptions) (result *VPNGatewayCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPNGatewaysWithContext(context.Background(), listVPNGatewaysOptions)
}

// ListVPNGatewaysWithContext is an alternate form of the ListVPNGateways method which supports a Context parameter
func (vpc *VpcV1) ListVPNGatewaysWithContext(ctx context.Context, listVPNGatewaysOptions *ListVPNGatewaysOptions) (result *VPNGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVPNGatewaysOptions, "listVPNGatewaysOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPNGatewaysOptions.Start))
	}
	if listVPNGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPNGatewaysOptions.Limit))
	}
	if listVPNGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVPNGatewaysOptions.ResourceGroupID))
	}
	if listVPNGatewaysOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listVPNGatewaysOptions.Sort))
	}
	if listVPNGatewaysOptions.Mode != nil {
		builder.AddQuery("mode", fmt.Sprint(*listVPNGatewaysOptions.Mode))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPNGateway : Create a VPN gateway
// This request creates a new VPN gateway.
func (vpc *VpcV1) CreateVPNGateway(createVPNGatewayOptions *CreateVPNGatewayOptions) (result VPNGatewayIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateVPNGatewayWithContext(context.Background(), createVPNGatewayOptions)
}

// CreateVPNGatewayWithContext is an alternate form of the CreateVPNGateway method which supports a Context parameter
func (vpc *VpcV1) CreateVPNGatewayWithContext(ctx context.Context, createVPNGatewayOptions *CreateVPNGatewayOptions) (result VPNGatewayIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPNGatewayOptions, "createVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPNGatewayOptions, "createVPNGatewayOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createVPNGatewayOptions.VPNGatewayPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPNGateway : Delete a VPN gateway
// This request deletes a VPN gateway. This operation cannot be reversed. For this request to succeed, the VPN gateway
// must not have a `status` of `pending`, and there must not be any VPC routes using the VPN gateway's connections as a
// next hop.
func (vpc *VpcV1) DeleteVPNGateway(deleteVPNGatewayOptions *DeleteVPNGatewayOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPNGatewayWithContext(context.Background(), deleteVPNGatewayOptions)
}

// DeleteVPNGatewayWithContext is an alternate form of the DeleteVPNGateway method which supports a Context parameter
func (vpc *VpcV1) DeleteVPNGatewayWithContext(ctx context.Context, deleteVPNGatewayOptions *DeleteVPNGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNGatewayOptions, "deleteVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNGatewayOptions, "deleteVPNGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteVPNGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNGateway : Retrieve a VPN gateway
// This request retrieves a single VPN gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNGateway(getVPNGatewayOptions *GetVPNGatewayOptions) (result VPNGatewayIntf, response *core.DetailedResponse, err error) {
	return vpc.GetVPNGatewayWithContext(context.Background(), getVPNGatewayOptions)
}

// GetVPNGatewayWithContext is an alternate form of the GetVPNGateway method which supports a Context parameter
func (vpc *VpcV1) GetVPNGatewayWithContext(ctx context.Context, getVPNGatewayOptions *GetVPNGatewayOptions) (result VPNGatewayIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNGatewayOptions, "getVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNGatewayOptions, "getVPNGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPNGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPNGateway : Update a VPN gateway
// This request updates the properties of an existing VPN gateway.
func (vpc *VpcV1) UpdateVPNGateway(updateVPNGatewayOptions *UpdateVPNGatewayOptions) (result VPNGatewayIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPNGatewayWithContext(context.Background(), updateVPNGatewayOptions)
}

// UpdateVPNGatewayWithContext is an alternate form of the UpdateVPNGateway method which supports a Context parameter
func (vpc *VpcV1) UpdateVPNGatewayWithContext(ctx context.Context, updateVPNGatewayOptions *UpdateVPNGatewayOptions) (result VPNGatewayIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPNGatewayOptions, "updateVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPNGatewayOptions, "updateVPNGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateVPNGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPNGatewayOptions.VPNGatewayPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPNGatewayConnections : List all connections of a VPN gateway
// This request lists all connections of a VPN gateway.
func (vpc *VpcV1) ListVPNGatewayConnections(listVPNGatewayConnectionsOptions *ListVPNGatewayConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPNGatewayConnectionsWithContext(context.Background(), listVPNGatewayConnectionsOptions)
}

// ListVPNGatewayConnectionsWithContext is an alternate form of the ListVPNGatewayConnections method which supports a Context parameter
func (vpc *VpcV1) ListVPNGatewayConnectionsWithContext(ctx context.Context, listVPNGatewayConnectionsOptions *ListVPNGatewayConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNGatewayConnectionsOptions, "listVPNGatewayConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNGatewayConnectionsOptions, "listVPNGatewayConnectionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *listVPNGatewayConnectionsOptions.VPNGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNGatewayConnectionsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listVPNGatewayConnectionsOptions.Status))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPNGatewayConnection : Create a connection for a VPN gateway
// This request creates a new VPN gateway connection.
func (vpc *VpcV1) CreateVPNGatewayConnection(createVPNGatewayConnectionOptions *CreateVPNGatewayConnectionOptions) (result VPNGatewayConnectionIntf, response *core.DetailedResponse, err error) {
	return vpc.CreateVPNGatewayConnectionWithContext(context.Background(), createVPNGatewayConnectionOptions)
}

// CreateVPNGatewayConnectionWithContext is an alternate form of the CreateVPNGatewayConnection method which supports a Context parameter
func (vpc *VpcV1) CreateVPNGatewayConnectionWithContext(ctx context.Context, createVPNGatewayConnectionOptions *CreateVPNGatewayConnectionOptions) (result VPNGatewayConnectionIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPNGatewayConnectionOptions, "createVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPNGatewayConnectionOptions, "createVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *createVPNGatewayConnectionOptions.VPNGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createVPNGatewayConnectionOptions.VPNGatewayConnectionPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPNGatewayConnection : Delete a VPN gateway connection
// This request deletes a VPN gateway connection. This operation cannot be reversed. For this request to succeed, there
// must not be VPC routes using this VPN connection as a next hop.
func (vpc *VpcV1) DeleteVPNGatewayConnection(deleteVPNGatewayConnectionOptions *DeleteVPNGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPNGatewayConnectionWithContext(context.Background(), deleteVPNGatewayConnectionOptions)
}

// DeleteVPNGatewayConnectionWithContext is an alternate form of the DeleteVPNGatewayConnection method which supports a Context parameter
func (vpc *VpcV1) DeleteVPNGatewayConnectionWithContext(ctx context.Context, deleteVPNGatewayConnectionOptions *DeleteVPNGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNGatewayConnectionOptions, "deleteVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNGatewayConnectionOptions, "deleteVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *deleteVPNGatewayConnectionOptions.VPNGatewayID,
		"id":             *deleteVPNGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNGatewayConnection : Retrieve a VPN gateway connection
// This request retrieves a single VPN gateway connection specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNGatewayConnection(getVPNGatewayConnectionOptions *GetVPNGatewayConnectionOptions) (result VPNGatewayConnectionIntf, response *core.DetailedResponse, err error) {
	return vpc.GetVPNGatewayConnectionWithContext(context.Background(), getVPNGatewayConnectionOptions)
}

// GetVPNGatewayConnectionWithContext is an alternate form of the GetVPNGatewayConnection method which supports a Context parameter
func (vpc *VpcV1) GetVPNGatewayConnectionWithContext(ctx context.Context, getVPNGatewayConnectionOptions *GetVPNGatewayConnectionOptions) (result VPNGatewayConnectionIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNGatewayConnectionOptions, "getVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNGatewayConnectionOptions, "getVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *getVPNGatewayConnectionOptions.VPNGatewayID,
		"id":             *getVPNGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPNGatewayConnection : Update a VPN gateway connection
// This request updates the properties of an existing VPN gateway connection.
func (vpc *VpcV1) UpdateVPNGatewayConnection(updateVPNGatewayConnectionOptions *UpdateVPNGatewayConnectionOptions) (result VPNGatewayConnectionIntf, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPNGatewayConnectionWithContext(context.Background(), updateVPNGatewayConnectionOptions)
}

// UpdateVPNGatewayConnectionWithContext is an alternate form of the UpdateVPNGatewayConnection method which supports a Context parameter
func (vpc *VpcV1) UpdateVPNGatewayConnectionWithContext(ctx context.Context, updateVPNGatewayConnectionOptions *UpdateVPNGatewayConnectionOptions) (result VPNGatewayConnectionIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPNGatewayConnectionOptions, "updateVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPNGatewayConnectionOptions, "updateVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *updateVPNGatewayConnectionOptions.VPNGatewayID,
		"id":             *updateVPNGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPNGatewayConnectionOptions.VPNGatewayConnectionPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListVPNGatewayConnectionLocalCIDRs : List all local CIDRs for a VPN gateway connection
// This request lists all local CIDRs for a VPN gateway connection.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) ListVPNGatewayConnectionLocalCIDRs(listVPNGatewayConnectionLocalCIDRsOptions *ListVPNGatewayConnectionLocalCIDRsOptions) (result *VPNGatewayConnectionLocalCIDRs, response *core.DetailedResponse, err error) {
	return vpc.ListVPNGatewayConnectionLocalCIDRsWithContext(context.Background(), listVPNGatewayConnectionLocalCIDRsOptions)
}

// ListVPNGatewayConnectionLocalCIDRsWithContext is an alternate form of the ListVPNGatewayConnectionLocalCIDRs method which supports a Context parameter
func (vpc *VpcV1) ListVPNGatewayConnectionLocalCIDRsWithContext(ctx context.Context, listVPNGatewayConnectionLocalCIDRsOptions *ListVPNGatewayConnectionLocalCIDRsOptions) (result *VPNGatewayConnectionLocalCIDRs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNGatewayConnectionLocalCIDRsOptions, "listVPNGatewayConnectionLocalCIDRsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNGatewayConnectionLocalCIDRsOptions, "listVPNGatewayConnectionLocalCIDRsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *listVPNGatewayConnectionLocalCIDRsOptions.VPNGatewayID,
		"id":             *listVPNGatewayConnectionLocalCIDRsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewayConnectionLocalCIDRsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGatewayConnectionLocalCIDRs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionLocalCIDRs)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RemoveVPNGatewayConnectionLocalCIDR : Remove a local CIDR from a VPN gateway connection
// This request removes a CIDR from a VPN gateway connection.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) RemoveVPNGatewayConnectionLocalCIDR(removeVPNGatewayConnectionLocalCIDROptions *RemoveVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	return vpc.RemoveVPNGatewayConnectionLocalCIDRWithContext(context.Background(), removeVPNGatewayConnectionLocalCIDROptions)
}

// RemoveVPNGatewayConnectionLocalCIDRWithContext is an alternate form of the RemoveVPNGatewayConnectionLocalCIDR method which supports a Context parameter
func (vpc *VpcV1) RemoveVPNGatewayConnectionLocalCIDRWithContext(ctx context.Context, removeVPNGatewayConnectionLocalCIDROptions *RemoveVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeVPNGatewayConnectionLocalCIDROptions, "removeVPNGatewayConnectionLocalCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeVPNGatewayConnectionLocalCIDROptions, "removeVPNGatewayConnectionLocalCIDROptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *removeVPNGatewayConnectionLocalCIDROptions.VPNGatewayID,
		"id":             *removeVPNGatewayConnectionLocalCIDROptions.ID,
		"cidr_prefix":    *removeVPNGatewayConnectionLocalCIDROptions.CIDRPrefix,
		"prefix_length":  *removeVPNGatewayConnectionLocalCIDROptions.PrefixLength,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs/{cidr_prefix}/{prefix_length}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeVPNGatewayConnectionLocalCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveVPNGatewayConnectionLocalCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// CheckVPNGatewayConnectionLocalCIDR : Check if the specified local CIDR exists on a VPN gateway connection
// This request succeeds if a CIDR exists on the specified VPN gateway connection, and fails otherwise.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) CheckVPNGatewayConnectionLocalCIDR(checkVPNGatewayConnectionLocalCIDROptions *CheckVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	return vpc.CheckVPNGatewayConnectionLocalCIDRWithContext(context.Background(), checkVPNGatewayConnectionLocalCIDROptions)
}

// CheckVPNGatewayConnectionLocalCIDRWithContext is an alternate form of the CheckVPNGatewayConnectionLocalCIDR method which supports a Context parameter
func (vpc *VpcV1) CheckVPNGatewayConnectionLocalCIDRWithContext(ctx context.Context, checkVPNGatewayConnectionLocalCIDROptions *CheckVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(checkVPNGatewayConnectionLocalCIDROptions, "checkVPNGatewayConnectionLocalCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(checkVPNGatewayConnectionLocalCIDROptions, "checkVPNGatewayConnectionLocalCIDROptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *checkVPNGatewayConnectionLocalCIDROptions.VPNGatewayID,
		"id":             *checkVPNGatewayConnectionLocalCIDROptions.ID,
		"cidr_prefix":    *checkVPNGatewayConnectionLocalCIDROptions.CIDRPrefix,
		"prefix_length":  *checkVPNGatewayConnectionLocalCIDROptions.PrefixLength,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs/{cidr_prefix}/{prefix_length}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range checkVPNGatewayConnectionLocalCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CheckVPNGatewayConnectionLocalCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// AddVPNGatewayConnectionLocalCIDR : Set a local CIDR on a VPN gateway connection
// This request adds the specified CIDR to the specified VPN gateway connection. This request succeeds if the specified
// CIDR already exists. A request body is not required, and if provided, is ignored.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) AddVPNGatewayConnectionLocalCIDR(addVPNGatewayConnectionLocalCIDROptions *AddVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	return vpc.AddVPNGatewayConnectionLocalCIDRWithContext(context.Background(), addVPNGatewayConnectionLocalCIDROptions)
}

// AddVPNGatewayConnectionLocalCIDRWithContext is an alternate form of the AddVPNGatewayConnectionLocalCIDR method which supports a Context parameter
func (vpc *VpcV1) AddVPNGatewayConnectionLocalCIDRWithContext(ctx context.Context, addVPNGatewayConnectionLocalCIDROptions *AddVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addVPNGatewayConnectionLocalCIDROptions, "addVPNGatewayConnectionLocalCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addVPNGatewayConnectionLocalCIDROptions, "addVPNGatewayConnectionLocalCIDROptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *addVPNGatewayConnectionLocalCIDROptions.VPNGatewayID,
		"id":             *addVPNGatewayConnectionLocalCIDROptions.ID,
		"cidr_prefix":    *addVPNGatewayConnectionLocalCIDROptions.CIDRPrefix,
		"prefix_length":  *addVPNGatewayConnectionLocalCIDROptions.PrefixLength,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/local_cidrs/{cidr_prefix}/{prefix_length}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addVPNGatewayConnectionLocalCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddVPNGatewayConnectionLocalCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVPNGatewayConnectionPeerCIDRs : List all peer CIDRs for a VPN gateway connection
// This request lists all peer CIDRs for a VPN gateway connection.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) ListVPNGatewayConnectionPeerCIDRs(listVPNGatewayConnectionPeerCIDRsOptions *ListVPNGatewayConnectionPeerCIDRsOptions) (result *VPNGatewayConnectionPeerCIDRs, response *core.DetailedResponse, err error) {
	return vpc.ListVPNGatewayConnectionPeerCIDRsWithContext(context.Background(), listVPNGatewayConnectionPeerCIDRsOptions)
}

// ListVPNGatewayConnectionPeerCIDRsWithContext is an alternate form of the ListVPNGatewayConnectionPeerCIDRs method which supports a Context parameter
func (vpc *VpcV1) ListVPNGatewayConnectionPeerCIDRsWithContext(ctx context.Context, listVPNGatewayConnectionPeerCIDRsOptions *ListVPNGatewayConnectionPeerCIDRsOptions) (result *VPNGatewayConnectionPeerCIDRs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNGatewayConnectionPeerCIDRsOptions, "listVPNGatewayConnectionPeerCIDRsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNGatewayConnectionPeerCIDRsOptions, "listVPNGatewayConnectionPeerCIDRsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *listVPNGatewayConnectionPeerCIDRsOptions.VPNGatewayID,
		"id":             *listVPNGatewayConnectionPeerCIDRsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewayConnectionPeerCIDRsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGatewayConnectionPeerCIDRs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionPeerCIDRs)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RemoveVPNGatewayConnectionPeerCIDR : Remove a peer CIDR from a VPN gateway connection
// This request removes a CIDR from a VPN gateway connection.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) RemoveVPNGatewayConnectionPeerCIDR(removeVPNGatewayConnectionPeerCIDROptions *RemoveVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	return vpc.RemoveVPNGatewayConnectionPeerCIDRWithContext(context.Background(), removeVPNGatewayConnectionPeerCIDROptions)
}

// RemoveVPNGatewayConnectionPeerCIDRWithContext is an alternate form of the RemoveVPNGatewayConnectionPeerCIDR method which supports a Context parameter
func (vpc *VpcV1) RemoveVPNGatewayConnectionPeerCIDRWithContext(ctx context.Context, removeVPNGatewayConnectionPeerCIDROptions *RemoveVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeVPNGatewayConnectionPeerCIDROptions, "removeVPNGatewayConnectionPeerCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeVPNGatewayConnectionPeerCIDROptions, "removeVPNGatewayConnectionPeerCIDROptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *removeVPNGatewayConnectionPeerCIDROptions.VPNGatewayID,
		"id":             *removeVPNGatewayConnectionPeerCIDROptions.ID,
		"cidr_prefix":    *removeVPNGatewayConnectionPeerCIDROptions.CIDRPrefix,
		"prefix_length":  *removeVPNGatewayConnectionPeerCIDROptions.PrefixLength,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs/{cidr_prefix}/{prefix_length}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeVPNGatewayConnectionPeerCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveVPNGatewayConnectionPeerCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// CheckVPNGatewayConnectionPeerCIDR : Check if the specified peer CIDR exists on a VPN gateway connection
// This request succeeds if a CIDR exists on the specified VPN gateway connection, and fails otherwise.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) CheckVPNGatewayConnectionPeerCIDR(checkVPNGatewayConnectionPeerCIDROptions *CheckVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	return vpc.CheckVPNGatewayConnectionPeerCIDRWithContext(context.Background(), checkVPNGatewayConnectionPeerCIDROptions)
}

// CheckVPNGatewayConnectionPeerCIDRWithContext is an alternate form of the CheckVPNGatewayConnectionPeerCIDR method which supports a Context parameter
func (vpc *VpcV1) CheckVPNGatewayConnectionPeerCIDRWithContext(ctx context.Context, checkVPNGatewayConnectionPeerCIDROptions *CheckVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(checkVPNGatewayConnectionPeerCIDROptions, "checkVPNGatewayConnectionPeerCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(checkVPNGatewayConnectionPeerCIDROptions, "checkVPNGatewayConnectionPeerCIDROptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *checkVPNGatewayConnectionPeerCIDROptions.VPNGatewayID,
		"id":             *checkVPNGatewayConnectionPeerCIDROptions.ID,
		"cidr_prefix":    *checkVPNGatewayConnectionPeerCIDROptions.CIDRPrefix,
		"prefix_length":  *checkVPNGatewayConnectionPeerCIDROptions.PrefixLength,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs/{cidr_prefix}/{prefix_length}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range checkVPNGatewayConnectionPeerCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CheckVPNGatewayConnectionPeerCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// AddVPNGatewayConnectionPeerCIDR : Set a peer CIDR on a VPN gateway connection
// This request adds the specified CIDR to the specified VPN gateway connection. This request succeeds if the specified
// CIDR already exists. A request body is not required, and if provided, is ignored.
//
// This request is only supported for policy mode VPN gateways.
func (vpc *VpcV1) AddVPNGatewayConnectionPeerCIDR(addVPNGatewayConnectionPeerCIDROptions *AddVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	return vpc.AddVPNGatewayConnectionPeerCIDRWithContext(context.Background(), addVPNGatewayConnectionPeerCIDROptions)
}

// AddVPNGatewayConnectionPeerCIDRWithContext is an alternate form of the AddVPNGatewayConnectionPeerCIDR method which supports a Context parameter
func (vpc *VpcV1) AddVPNGatewayConnectionPeerCIDRWithContext(ctx context.Context, addVPNGatewayConnectionPeerCIDROptions *AddVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addVPNGatewayConnectionPeerCIDROptions, "addVPNGatewayConnectionPeerCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addVPNGatewayConnectionPeerCIDROptions, "addVPNGatewayConnectionPeerCIDROptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_gateway_id": *addVPNGatewayConnectionPeerCIDROptions.VPNGatewayID,
		"id":             *addVPNGatewayConnectionPeerCIDROptions.ID,
		"cidr_prefix":    *addVPNGatewayConnectionPeerCIDROptions.CIDRPrefix,
		"prefix_length":  *addVPNGatewayConnectionPeerCIDROptions.PrefixLength,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_gateways/{vpn_gateway_id}/connections/{id}/peer_cidrs/{cidr_prefix}/{prefix_length}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addVPNGatewayConnectionPeerCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddVPNGatewayConnectionPeerCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVPNServers : List all VPN servers
// This request lists all VPN servers.
func (vpc *VpcV1) ListVPNServers(listVPNServersOptions *ListVPNServersOptions) (result *VPNServerCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPNServersWithContext(context.Background(), listVPNServersOptions)
}

// ListVPNServersWithContext is an alternate form of the ListVPNServers method which supports a Context parameter
func (vpc *VpcV1) ListVPNServersWithContext(ctx context.Context, listVPNServersOptions *ListVPNServersOptions) (result *VPNServerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVPNServersOptions, "listVPNServersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNServersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNServers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNServersOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listVPNServersOptions.Name))
	}
	if listVPNServersOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPNServersOptions.Start))
	}
	if listVPNServersOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPNServersOptions.Limit))
	}
	if listVPNServersOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVPNServersOptions.ResourceGroupID))
	}
	if listVPNServersOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listVPNServersOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPNServer : Create a VPN server
// This request creates a new VPN server.
func (vpc *VpcV1) CreateVPNServer(createVPNServerOptions *CreateVPNServerOptions) (result *VPNServer, response *core.DetailedResponse, err error) {
	return vpc.CreateVPNServerWithContext(context.Background(), createVPNServerOptions)
}

// CreateVPNServerWithContext is an alternate form of the CreateVPNServer method which supports a Context parameter
func (vpc *VpcV1) CreateVPNServerWithContext(ctx context.Context, createVPNServerOptions *CreateVPNServerOptions) (result *VPNServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPNServerOptions, "createVPNServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPNServerOptions, "createVPNServerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPNServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPNServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPNServerOptions.Certificate != nil {
		body["certificate"] = createVPNServerOptions.Certificate
	}
	if createVPNServerOptions.ClientAuthentication != nil {
		body["client_authentication"] = createVPNServerOptions.ClientAuthentication
	}
	if createVPNServerOptions.ClientIPPool != nil {
		body["client_ip_pool"] = createVPNServerOptions.ClientIPPool
	}
	if createVPNServerOptions.Subnets != nil {
		body["subnets"] = createVPNServerOptions.Subnets
	}
	if createVPNServerOptions.ClientDnsServerIps != nil {
		body["client_dns_server_ips"] = createVPNServerOptions.ClientDnsServerIps
	}
	if createVPNServerOptions.ClientIdleTimeout != nil {
		body["client_idle_timeout"] = createVPNServerOptions.ClientIdleTimeout
	}
	if createVPNServerOptions.EnableSplitTunneling != nil {
		body["enable_split_tunneling"] = createVPNServerOptions.EnableSplitTunneling
	}
	if createVPNServerOptions.Name != nil {
		body["name"] = createVPNServerOptions.Name
	}
	if createVPNServerOptions.Port != nil {
		body["port"] = createVPNServerOptions.Port
	}
	if createVPNServerOptions.Protocol != nil {
		body["protocol"] = createVPNServerOptions.Protocol
	}
	if createVPNServerOptions.ResourceGroup != nil {
		body["resource_group"] = createVPNServerOptions.ResourceGroup
	}
	if createVPNServerOptions.SecurityGroups != nil {
		body["security_groups"] = createVPNServerOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPNServer : Delete a VPN server
// This request deletes a VPN server. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPNServer(deleteVPNServerOptions *DeleteVPNServerOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPNServerWithContext(context.Background(), deleteVPNServerOptions)
}

// DeleteVPNServerWithContext is an alternate form of the DeleteVPNServer method which supports a Context parameter
func (vpc *VpcV1) DeleteVPNServerWithContext(ctx context.Context, deleteVPNServerOptions *DeleteVPNServerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNServerOptions, "deleteVPNServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNServerOptions, "deleteVPNServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteVPNServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteVPNServerOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteVPNServerOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNServer : Retrieve a VPN server
// This request retrieves a single VPN server specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNServer(getVPNServerOptions *GetVPNServerOptions) (result *VPNServer, response *core.DetailedResponse, err error) {
	return vpc.GetVPNServerWithContext(context.Background(), getVPNServerOptions)
}

// GetVPNServerWithContext is an alternate form of the GetVPNServer method which supports a Context parameter
func (vpc *VpcV1) GetVPNServerWithContext(ctx context.Context, getVPNServerOptions *GetVPNServerOptions) (result *VPNServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNServerOptions, "getVPNServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNServerOptions, "getVPNServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPNServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPNServer : Update a VPN server
// This request updates the properties of an existing VPN server. Any property changes will cause all connected VPN
// clients are disconnected from this VPN server except for the name change.
func (vpc *VpcV1) UpdateVPNServer(updateVPNServerOptions *UpdateVPNServerOptions) (result *VPNServer, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPNServerWithContext(context.Background(), updateVPNServerOptions)
}

// UpdateVPNServerWithContext is an alternate form of the UpdateVPNServer method which supports a Context parameter
func (vpc *VpcV1) UpdateVPNServerWithContext(ctx context.Context, updateVPNServerOptions *UpdateVPNServerOptions) (result *VPNServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPNServerOptions, "updateVPNServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPNServerOptions, "updateVPNServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateVPNServerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPNServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPNServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateVPNServerOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateVPNServerOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPNServerOptions.VPNServerPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetVPNServerClientConfiguration : Retrieve client configuration
// This request retrieves OpenVPN client configuration on a single VPN server specified by the identifier in the URL.
// This configuration includes directives compatible with OpenVPN releases 2.4 and 2.5.
func (vpc *VpcV1) GetVPNServerClientConfiguration(getVPNServerClientConfigurationOptions *GetVPNServerClientConfigurationOptions) (result *string, response *core.DetailedResponse, err error) {
	return vpc.GetVPNServerClientConfigurationWithContext(context.Background(), getVPNServerClientConfigurationOptions)
}

// GetVPNServerClientConfigurationWithContext is an alternate form of the GetVPNServerClientConfiguration method which supports a Context parameter
func (vpc *VpcV1) GetVPNServerClientConfigurationWithContext(ctx context.Context, getVPNServerClientConfigurationOptions *GetVPNServerClientConfigurationOptions) (result *string, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNServerClientConfigurationOptions, "getVPNServerClientConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNServerClientConfigurationOptions, "getVPNServerClientConfigurationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getVPNServerClientConfigurationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{id}/client_configuration`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNServerClientConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNServerClientConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "text/plain")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, &result)

	return
}

// ListVPNServerClients : List all VPN clients for a VPN server
// This request retrieves all connected VPN clients, and any disconnected VPN clients that the VPN server has not yet
// deleted based on its auto-deletion policy.
func (vpc *VpcV1) ListVPNServerClients(listVPNServerClientsOptions *ListVPNServerClientsOptions) (result *VPNServerClientCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPNServerClientsWithContext(context.Background(), listVPNServerClientsOptions)
}

// ListVPNServerClientsWithContext is an alternate form of the ListVPNServerClients method which supports a Context parameter
func (vpc *VpcV1) ListVPNServerClientsWithContext(ctx context.Context, listVPNServerClientsOptions *ListVPNServerClientsOptions) (result *VPNServerClientCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNServerClientsOptions, "listVPNServerClientsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNServerClientsOptions, "listVPNServerClientsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *listVPNServerClientsOptions.VPNServerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/clients`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNServerClientsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNServerClients")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNServerClientsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPNServerClientsOptions.Start))
	}
	if listVPNServerClientsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPNServerClientsOptions.Limit))
	}
	if listVPNServerClientsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listVPNServerClientsOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerClientCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPNServerClient : Delete a VPN client
// This request disconnects and deletes the VPN client from the VPN server. The VPN client may reconnect unless its
// authentication permissions for the configured authentication methods (such as its client certificate) have been
// revoked.
func (vpc *VpcV1) DeleteVPNServerClient(deleteVPNServerClientOptions *DeleteVPNServerClientOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPNServerClientWithContext(context.Background(), deleteVPNServerClientOptions)
}

// DeleteVPNServerClientWithContext is an alternate form of the DeleteVPNServerClient method which supports a Context parameter
func (vpc *VpcV1) DeleteVPNServerClientWithContext(ctx context.Context, deleteVPNServerClientOptions *DeleteVPNServerClientOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNServerClientOptions, "deleteVPNServerClientOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNServerClientOptions, "deleteVPNServerClientOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *deleteVPNServerClientOptions.VPNServerID,
		"id":            *deleteVPNServerClientOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/clients/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNServerClientOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNServerClient")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNServerClient : Retrieve a VPN client
// This request retrieves a single VPN client specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNServerClient(getVPNServerClientOptions *GetVPNServerClientOptions) (result *VPNServerClient, response *core.DetailedResponse, err error) {
	return vpc.GetVPNServerClientWithContext(context.Background(), getVPNServerClientOptions)
}

// GetVPNServerClientWithContext is an alternate form of the GetVPNServerClient method which supports a Context parameter
func (vpc *VpcV1) GetVPNServerClientWithContext(ctx context.Context, getVPNServerClientOptions *GetVPNServerClientOptions) (result *VPNServerClient, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNServerClientOptions, "getVPNServerClientOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNServerClientOptions, "getVPNServerClientOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *getVPNServerClientOptions.VPNServerID,
		"id":            *getVPNServerClientOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/clients/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNServerClientOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNServerClient")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerClient)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DisconnectVPNClient : Disconnect a VPN client
// This request disconnects the specified VPN client, and deletes the client according to the VPN server's auto-deletion
// policy. The VPN client may reconnect unless its authentication permissions for the configured authentication methods
// (such as its client certificate) have been revoked.
func (vpc *VpcV1) DisconnectVPNClient(disconnectVPNClientOptions *DisconnectVPNClientOptions) (response *core.DetailedResponse, err error) {
	return vpc.DisconnectVPNClientWithContext(context.Background(), disconnectVPNClientOptions)
}

// DisconnectVPNClientWithContext is an alternate form of the DisconnectVPNClient method which supports a Context parameter
func (vpc *VpcV1) DisconnectVPNClientWithContext(ctx context.Context, disconnectVPNClientOptions *DisconnectVPNClientOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(disconnectVPNClientOptions, "disconnectVPNClientOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(disconnectVPNClientOptions, "disconnectVPNClientOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *disconnectVPNClientOptions.VPNServerID,
		"id":            *disconnectVPNClientOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/clients/{id}/disconnect`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range disconnectVPNClientOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DisconnectVPNClient")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVPNServerRoutes : List all VPN routes for a VPN server
// This request lists all VPN routes in a VPN server. All VPN routes are provided to the VPN client when the connection
// is established.  Packets received from the VPN client will be dropped by the VPN server if there is no VPN route
// matching their specified destinations. All VPN routes must be unique within the VPN server.
func (vpc *VpcV1) ListVPNServerRoutes(listVPNServerRoutesOptions *ListVPNServerRoutesOptions) (result *VPNServerRouteCollection, response *core.DetailedResponse, err error) {
	return vpc.ListVPNServerRoutesWithContext(context.Background(), listVPNServerRoutesOptions)
}

// ListVPNServerRoutesWithContext is an alternate form of the ListVPNServerRoutes method which supports a Context parameter
func (vpc *VpcV1) ListVPNServerRoutesWithContext(ctx context.Context, listVPNServerRoutesOptions *ListVPNServerRoutesOptions) (result *VPNServerRouteCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNServerRoutesOptions, "listVPNServerRoutesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNServerRoutesOptions, "listVPNServerRoutesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *listVPNServerRoutesOptions.VPNServerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/routes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNServerRoutesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNServerRoutes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNServerRoutesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPNServerRoutesOptions.Start))
	}
	if listVPNServerRoutesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPNServerRoutesOptions.Limit))
	}
	if listVPNServerRoutesOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listVPNServerRoutesOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerRouteCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateVPNServerRoute : Create a VPN route for a VPN server
// This request creates a new VPN route in the VPN server. All VPN routes are provided to the VPN client when the
// connection is established. Packets received from the VPN client will be dropped by the VPN server if there is no VPN
// route matching their specified destinations. All VPN routes must be unique within the VPN server. destination of the
// packet.
func (vpc *VpcV1) CreateVPNServerRoute(createVPNServerRouteOptions *CreateVPNServerRouteOptions) (result *VPNServerRoute, response *core.DetailedResponse, err error) {
	return vpc.CreateVPNServerRouteWithContext(context.Background(), createVPNServerRouteOptions)
}

// CreateVPNServerRouteWithContext is an alternate form of the CreateVPNServerRoute method which supports a Context parameter
func (vpc *VpcV1) CreateVPNServerRouteWithContext(ctx context.Context, createVPNServerRouteOptions *CreateVPNServerRouteOptions) (result *VPNServerRoute, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPNServerRouteOptions, "createVPNServerRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPNServerRouteOptions, "createVPNServerRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *createVPNServerRouteOptions.VPNServerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/routes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPNServerRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPNServerRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPNServerRouteOptions.Destination != nil {
		body["destination"] = createVPNServerRouteOptions.Destination
	}
	if createVPNServerRouteOptions.Action != nil {
		body["action"] = createVPNServerRouteOptions.Action
	}
	if createVPNServerRouteOptions.Name != nil {
		body["name"] = createVPNServerRouteOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteVPNServerRoute : Delete a VPN route
// This request deletes a VPN route. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPNServerRoute(deleteVPNServerRouteOptions *DeleteVPNServerRouteOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteVPNServerRouteWithContext(context.Background(), deleteVPNServerRouteOptions)
}

// DeleteVPNServerRouteWithContext is an alternate form of the DeleteVPNServerRoute method which supports a Context parameter
func (vpc *VpcV1) DeleteVPNServerRouteWithContext(ctx context.Context, deleteVPNServerRouteOptions *DeleteVPNServerRouteOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNServerRouteOptions, "deleteVPNServerRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNServerRouteOptions, "deleteVPNServerRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *deleteVPNServerRouteOptions.VPNServerID,
		"id":            *deleteVPNServerRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNServerRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNServerRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNServerRoute : Retrieve a VPN route
// This request retrieves a single VPN route specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNServerRoute(getVPNServerRouteOptions *GetVPNServerRouteOptions) (result *VPNServerRoute, response *core.DetailedResponse, err error) {
	return vpc.GetVPNServerRouteWithContext(context.Background(), getVPNServerRouteOptions)
}

// GetVPNServerRouteWithContext is an alternate form of the GetVPNServerRoute method which supports a Context parameter
func (vpc *VpcV1) GetVPNServerRouteWithContext(ctx context.Context, getVPNServerRouteOptions *GetVPNServerRouteOptions) (result *VPNServerRoute, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNServerRouteOptions, "getVPNServerRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNServerRouteOptions, "getVPNServerRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *getVPNServerRouteOptions.VPNServerID,
		"id":            *getVPNServerRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNServerRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNServerRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVPNServerRoute : Update a VPN route
// This request updates a VPN route with the information in a provided VPN route patch. The VPN route patch object is
// structured in the same way as a retrieved VPN route and contains only the information to be updated.
func (vpc *VpcV1) UpdateVPNServerRoute(updateVPNServerRouteOptions *UpdateVPNServerRouteOptions) (result *VPNServerRoute, response *core.DetailedResponse, err error) {
	return vpc.UpdateVPNServerRouteWithContext(context.Background(), updateVPNServerRouteOptions)
}

// UpdateVPNServerRouteWithContext is an alternate form of the UpdateVPNServerRoute method which supports a Context parameter
func (vpc *VpcV1) UpdateVPNServerRouteWithContext(ctx context.Context, updateVPNServerRouteOptions *UpdateVPNServerRouteOptions) (result *VPNServerRoute, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPNServerRouteOptions, "updateVPNServerRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPNServerRouteOptions, "updateVPNServerRouteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"vpn_server_id": *updateVPNServerRouteOptions.VPNServerID,
		"id":            *updateVPNServerRouteOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/vpn_servers/{vpn_server_id}/routes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPNServerRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPNServerRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateVPNServerRouteOptions.VPNServerRoutePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNServerRoute)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancerProfiles : List all load balancer profiles
// This request lists all load balancer profiles available in the region. A load balancer profile specifies the
// performance characteristics and pricing model for a load balancer.
func (vpc *VpcV1) ListLoadBalancerProfiles(listLoadBalancerProfilesOptions *ListLoadBalancerProfilesOptions) (result *LoadBalancerProfileCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancerProfilesWithContext(context.Background(), listLoadBalancerProfilesOptions)
}

// ListLoadBalancerProfilesWithContext is an alternate form of the ListLoadBalancerProfiles method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancerProfilesWithContext(ctx context.Context, listLoadBalancerProfilesOptions *ListLoadBalancerProfilesOptions) (result *LoadBalancerProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listLoadBalancerProfilesOptions, "listLoadBalancerProfilesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancer/profiles`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listLoadBalancerProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listLoadBalancerProfilesOptions.Start))
	}
	if listLoadBalancerProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listLoadBalancerProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerProfileCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetLoadBalancerProfile : Retrieve a load balancer profile
// This request retrieves a load balancer profile specified by the name in the URL.
func (vpc *VpcV1) GetLoadBalancerProfile(getLoadBalancerProfileOptions *GetLoadBalancerProfileOptions) (result *LoadBalancerProfile, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerProfileWithContext(context.Background(), getLoadBalancerProfileOptions)
}

// GetLoadBalancerProfileWithContext is an alternate form of the GetLoadBalancerProfile method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerProfileWithContext(ctx context.Context, getLoadBalancerProfileOptions *GetLoadBalancerProfileOptions) (result *LoadBalancerProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerProfileOptions, "getLoadBalancerProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerProfileOptions, "getLoadBalancerProfileOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *getLoadBalancerProfileOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancer/profiles/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancers : List all load balancers
// This request lists all load balancers in the region.
func (vpc *VpcV1) ListLoadBalancers(listLoadBalancersOptions *ListLoadBalancersOptions) (result *LoadBalancerCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancersWithContext(context.Background(), listLoadBalancersOptions)
}

// ListLoadBalancersWithContext is an alternate form of the ListLoadBalancers method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancersWithContext(ctx context.Context, listLoadBalancersOptions *ListLoadBalancersOptions) (result *LoadBalancerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listLoadBalancersOptions, "listLoadBalancersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listLoadBalancersOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listLoadBalancersOptions.Start))
	}
	if listLoadBalancersOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listLoadBalancersOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateLoadBalancer : Create a load balancer
// This request creates and provisions a new load balancer.
func (vpc *VpcV1) CreateLoadBalancer(createLoadBalancerOptions *CreateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	return vpc.CreateLoadBalancerWithContext(context.Background(), createLoadBalancerOptions)
}

// CreateLoadBalancerWithContext is an alternate form of the CreateLoadBalancer method which supports a Context parameter
func (vpc *VpcV1) CreateLoadBalancerWithContext(ctx context.Context, createLoadBalancerOptions *CreateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerOptions, "createLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerOptions, "createLoadBalancerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerOptions.IsPublic != nil {
		body["is_public"] = createLoadBalancerOptions.IsPublic
	}
	if createLoadBalancerOptions.Subnets != nil {
		body["subnets"] = createLoadBalancerOptions.Subnets
	}
	if createLoadBalancerOptions.Datapath != nil {
		body["datapath"] = createLoadBalancerOptions.Datapath
	}
	if createLoadBalancerOptions.Dns != nil {
		body["dns"] = createLoadBalancerOptions.Dns
	}
	if createLoadBalancerOptions.Listeners != nil {
		body["listeners"] = createLoadBalancerOptions.Listeners
	}
	if createLoadBalancerOptions.Logging != nil {
		body["logging"] = createLoadBalancerOptions.Logging
	}
	if createLoadBalancerOptions.Name != nil {
		body["name"] = createLoadBalancerOptions.Name
	}
	if createLoadBalancerOptions.Pools != nil {
		body["pools"] = createLoadBalancerOptions.Pools
	}
	if createLoadBalancerOptions.Profile != nil {
		body["profile"] = createLoadBalancerOptions.Profile
	}
	if createLoadBalancerOptions.ResourceGroup != nil {
		body["resource_group"] = createLoadBalancerOptions.ResourceGroup
	}
	if createLoadBalancerOptions.RouteMode != nil {
		body["route_mode"] = createLoadBalancerOptions.RouteMode
	}
	if createLoadBalancerOptions.SecurityGroups != nil {
		body["security_groups"] = createLoadBalancerOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteLoadBalancer : Delete a load balancer
// This request deletes a load balancer. This operation cannot be reversed. A load balancer cannot be deleted if its
// `provisioning_status` is `delete_pending`.
func (vpc *VpcV1) DeleteLoadBalancer(deleteLoadBalancerOptions *DeleteLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteLoadBalancerWithContext(context.Background(), deleteLoadBalancerOptions)
}

// DeleteLoadBalancerWithContext is an alternate form of the DeleteLoadBalancer method which supports a Context parameter
func (vpc *VpcV1) DeleteLoadBalancerWithContext(ctx context.Context, deleteLoadBalancerOptions *DeleteLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerOptions, "deleteLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerOptions, "deleteLoadBalancerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteLoadBalancerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteLoadBalancerOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteLoadBalancerOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancer : Retrieve a load balancer
// This request retrieves a single load balancer specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancer(getLoadBalancerOptions *GetLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerWithContext(context.Background(), getLoadBalancerOptions)
}

// GetLoadBalancerWithContext is an alternate form of the GetLoadBalancer method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerWithContext(ctx context.Context, getLoadBalancerOptions *GetLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerOptions, "getLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerOptions, "getLoadBalancerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getLoadBalancerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateLoadBalancer : Update a load balancer
// This request updates a load balancer with the information in a provided load balancer patch. The load balancer patch
// object is structured in the same way as a retrieved load balancer and contains only the information to be updated. A
// load balancer can only be updated if its `provisioning_status` is `active`.
func (vpc *VpcV1) UpdateLoadBalancer(updateLoadBalancerOptions *UpdateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	return vpc.UpdateLoadBalancerWithContext(context.Background(), updateLoadBalancerOptions)
}

// UpdateLoadBalancerWithContext is an alternate form of the UpdateLoadBalancer method which supports a Context parameter
func (vpc *VpcV1) UpdateLoadBalancerWithContext(ctx context.Context, updateLoadBalancerOptions *UpdateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerOptions, "updateLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerOptions, "updateLoadBalancerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateLoadBalancerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateLoadBalancerOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateLoadBalancerOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateLoadBalancerOptions.LoadBalancerPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetLoadBalancerStatistics : List all statistics of a load balancer
// This request lists statistics of a load balancer.
func (vpc *VpcV1) GetLoadBalancerStatistics(getLoadBalancerStatisticsOptions *GetLoadBalancerStatisticsOptions) (result *LoadBalancerStatistics, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerStatisticsWithContext(context.Background(), getLoadBalancerStatisticsOptions)
}

// GetLoadBalancerStatisticsWithContext is an alternate form of the GetLoadBalancerStatistics method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerStatisticsWithContext(ctx context.Context, getLoadBalancerStatisticsOptions *GetLoadBalancerStatisticsOptions) (result *LoadBalancerStatistics, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerStatisticsOptions, "getLoadBalancerStatisticsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerStatisticsOptions, "getLoadBalancerStatisticsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getLoadBalancerStatisticsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{id}/statistics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerStatisticsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerStatistics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerStatistics)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancerListeners : List all listeners for a load balancer
// This request lists all listeners for a load balancer.
func (vpc *VpcV1) ListLoadBalancerListeners(listLoadBalancerListenersOptions *ListLoadBalancerListenersOptions) (result *LoadBalancerListenerCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancerListenersWithContext(context.Background(), listLoadBalancerListenersOptions)
}

// ListLoadBalancerListenersWithContext is an alternate form of the ListLoadBalancerListeners method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancerListenersWithContext(ctx context.Context, listLoadBalancerListenersOptions *ListLoadBalancerListenersOptions) (result *LoadBalancerListenerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenersOptions, "listLoadBalancerListenersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenersOptions, "listLoadBalancerListenersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *listLoadBalancerListenersOptions.LoadBalancerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListeners")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateLoadBalancerListener : Create a listener for a load balancer
// This request creates a new listener for a load balancer.
func (vpc *VpcV1) CreateLoadBalancerListener(createLoadBalancerListenerOptions *CreateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	return vpc.CreateLoadBalancerListenerWithContext(context.Background(), createLoadBalancerListenerOptions)
}

// CreateLoadBalancerListenerWithContext is an alternate form of the CreateLoadBalancerListener method which supports a Context parameter
func (vpc *VpcV1) CreateLoadBalancerListenerWithContext(ctx context.Context, createLoadBalancerListenerOptions *CreateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerOptions, "createLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerOptions, "createLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *createLoadBalancerListenerOptions.LoadBalancerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerOptions.Protocol != nil {
		body["protocol"] = createLoadBalancerListenerOptions.Protocol
	}
	if createLoadBalancerListenerOptions.AcceptProxyProtocol != nil {
		body["accept_proxy_protocol"] = createLoadBalancerListenerOptions.AcceptProxyProtocol
	}
	if createLoadBalancerListenerOptions.CertificateInstance != nil {
		body["certificate_instance"] = createLoadBalancerListenerOptions.CertificateInstance
	}
	if createLoadBalancerListenerOptions.ConnectionLimit != nil {
		body["connection_limit"] = createLoadBalancerListenerOptions.ConnectionLimit
	}
	if createLoadBalancerListenerOptions.DefaultPool != nil {
		body["default_pool"] = createLoadBalancerListenerOptions.DefaultPool
	}
	if createLoadBalancerListenerOptions.HTTPSRedirect != nil {
		body["https_redirect"] = createLoadBalancerListenerOptions.HTTPSRedirect
	}
	if createLoadBalancerListenerOptions.IdleConnectionTimeout != nil {
		body["idle_connection_timeout"] = createLoadBalancerListenerOptions.IdleConnectionTimeout
	}
	if createLoadBalancerListenerOptions.Policies != nil {
		body["policies"] = createLoadBalancerListenerOptions.Policies
	}
	if createLoadBalancerListenerOptions.Port != nil {
		body["port"] = createLoadBalancerListenerOptions.Port
	}
	if createLoadBalancerListenerOptions.PortMax != nil {
		body["port_max"] = createLoadBalancerListenerOptions.PortMax
	}
	if createLoadBalancerListenerOptions.PortMin != nil {
		body["port_min"] = createLoadBalancerListenerOptions.PortMin
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListener)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteLoadBalancerListener : Delete a load balancer listener
// This request deletes a load balancer listener. This operation cannot be reversed. For this operation to succeed, the
// listener must not be the target of another load balancer listener.
func (vpc *VpcV1) DeleteLoadBalancerListener(deleteLoadBalancerListenerOptions *DeleteLoadBalancerListenerOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteLoadBalancerListenerWithContext(context.Background(), deleteLoadBalancerListenerOptions)
}

// DeleteLoadBalancerListenerWithContext is an alternate form of the DeleteLoadBalancerListener method which supports a Context parameter
func (vpc *VpcV1) DeleteLoadBalancerListenerWithContext(ctx context.Context, deleteLoadBalancerListenerOptions *DeleteLoadBalancerListenerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerOptions, "deleteLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerOptions, "deleteLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *deleteLoadBalancerListenerOptions.LoadBalancerID,
		"id":               *deleteLoadBalancerListenerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListener : Retrieve a load balancer listener
// This request retrieves a single listener specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListener(getLoadBalancerListenerOptions *GetLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerListenerWithContext(context.Background(), getLoadBalancerListenerOptions)
}

// GetLoadBalancerListenerWithContext is an alternate form of the GetLoadBalancerListener method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerListenerWithContext(ctx context.Context, getLoadBalancerListenerOptions *GetLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerOptions, "getLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerOptions, "getLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *getLoadBalancerListenerOptions.LoadBalancerID,
		"id":               *getLoadBalancerListenerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListener)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateLoadBalancerListener : Update a load balancer listener
// This request updates a load balancer listener from a listener patch.
func (vpc *VpcV1) UpdateLoadBalancerListener(updateLoadBalancerListenerOptions *UpdateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	return vpc.UpdateLoadBalancerListenerWithContext(context.Background(), updateLoadBalancerListenerOptions)
}

// UpdateLoadBalancerListenerWithContext is an alternate form of the UpdateLoadBalancerListener method which supports a Context parameter
func (vpc *VpcV1) UpdateLoadBalancerListenerWithContext(ctx context.Context, updateLoadBalancerListenerOptions *UpdateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerOptions, "updateLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerOptions, "updateLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *updateLoadBalancerListenerOptions.LoadBalancerID,
		"id":               *updateLoadBalancerListenerOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateLoadBalancerListenerOptions.LoadBalancerListenerPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListener)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancerListenerPolicies : List all policies for a load balancer listener
// This request lists all policies for a load balancer listener.
func (vpc *VpcV1) ListLoadBalancerListenerPolicies(listLoadBalancerListenerPoliciesOptions *ListLoadBalancerListenerPoliciesOptions) (result *LoadBalancerListenerPolicyCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancerListenerPoliciesWithContext(context.Background(), listLoadBalancerListenerPoliciesOptions)
}

// ListLoadBalancerListenerPoliciesWithContext is an alternate form of the ListLoadBalancerListenerPolicies method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancerListenerPoliciesWithContext(ctx context.Context, listLoadBalancerListenerPoliciesOptions *ListLoadBalancerListenerPoliciesOptions) (result *LoadBalancerListenerPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenerPoliciesOptions, "listLoadBalancerListenerPoliciesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenerPoliciesOptions, "listLoadBalancerListenerPoliciesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *listLoadBalancerListenerPoliciesOptions.LoadBalancerID,
		"listener_id":      *listLoadBalancerListenerPoliciesOptions.ListenerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenerPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListenerPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateLoadBalancerListenerPolicy : Create a policy for a load balancer listener
// Creates a new policy for a load balancer listener.
func (vpc *VpcV1) CreateLoadBalancerListenerPolicy(createLoadBalancerListenerPolicyOptions *CreateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	return vpc.CreateLoadBalancerListenerPolicyWithContext(context.Background(), createLoadBalancerListenerPolicyOptions)
}

// CreateLoadBalancerListenerPolicyWithContext is an alternate form of the CreateLoadBalancerListenerPolicy method which supports a Context parameter
func (vpc *VpcV1) CreateLoadBalancerListenerPolicyWithContext(ctx context.Context, createLoadBalancerListenerPolicyOptions *CreateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerPolicyOptions, "createLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerPolicyOptions, "createLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *createLoadBalancerListenerPolicyOptions.LoadBalancerID,
		"listener_id":      *createLoadBalancerListenerPolicyOptions.ListenerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerPolicyOptions.Action != nil {
		body["action"] = createLoadBalancerListenerPolicyOptions.Action
	}
	if createLoadBalancerListenerPolicyOptions.Priority != nil {
		body["priority"] = createLoadBalancerListenerPolicyOptions.Priority
	}
	if createLoadBalancerListenerPolicyOptions.Name != nil {
		body["name"] = createLoadBalancerListenerPolicyOptions.Name
	}
	if createLoadBalancerListenerPolicyOptions.Rules != nil {
		body["rules"] = createLoadBalancerListenerPolicyOptions.Rules
	}
	if createLoadBalancerListenerPolicyOptions.Target != nil {
		body["target"] = createLoadBalancerListenerPolicyOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteLoadBalancerListenerPolicy : Delete a load balancer listener policy
// Deletes a policy of the load balancer listener. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicy(deleteLoadBalancerListenerPolicyOptions *DeleteLoadBalancerListenerPolicyOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteLoadBalancerListenerPolicyWithContext(context.Background(), deleteLoadBalancerListenerPolicyOptions)
}

// DeleteLoadBalancerListenerPolicyWithContext is an alternate form of the DeleteLoadBalancerListenerPolicy method which supports a Context parameter
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicyWithContext(ctx context.Context, deleteLoadBalancerListenerPolicyOptions *DeleteLoadBalancerListenerPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerPolicyOptions, "deleteLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerPolicyOptions, "deleteLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *deleteLoadBalancerListenerPolicyOptions.LoadBalancerID,
		"listener_id":      *deleteLoadBalancerListenerPolicyOptions.ListenerID,
		"id":               *deleteLoadBalancerListenerPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListenerPolicy : Retrieve a load balancer listener policy
// Retrieve a single policy specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListenerPolicy(getLoadBalancerListenerPolicyOptions *GetLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerListenerPolicyWithContext(context.Background(), getLoadBalancerListenerPolicyOptions)
}

// GetLoadBalancerListenerPolicyWithContext is an alternate form of the GetLoadBalancerListenerPolicy method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerListenerPolicyWithContext(ctx context.Context, getLoadBalancerListenerPolicyOptions *GetLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerPolicyOptions, "getLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerPolicyOptions, "getLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *getLoadBalancerListenerPolicyOptions.LoadBalancerID,
		"listener_id":      *getLoadBalancerListenerPolicyOptions.ListenerID,
		"id":               *getLoadBalancerListenerPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateLoadBalancerListenerPolicy : Update a load balancer listener policy
// Updates a policy from a policy patch.
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicy(updateLoadBalancerListenerPolicyOptions *UpdateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	return vpc.UpdateLoadBalancerListenerPolicyWithContext(context.Background(), updateLoadBalancerListenerPolicyOptions)
}

// UpdateLoadBalancerListenerPolicyWithContext is an alternate form of the UpdateLoadBalancerListenerPolicy method which supports a Context parameter
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicyWithContext(ctx context.Context, updateLoadBalancerListenerPolicyOptions *UpdateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerPolicyOptions, "updateLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerPolicyOptions, "updateLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *updateLoadBalancerListenerPolicyOptions.LoadBalancerID,
		"listener_id":      *updateLoadBalancerListenerPolicyOptions.ListenerID,
		"id":               *updateLoadBalancerListenerPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateLoadBalancerListenerPolicyOptions.LoadBalancerListenerPolicyPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancerListenerPolicyRules : List all rules of a load balancer listener policy
// This request lists all rules of a load balancer listener policy.
func (vpc *VpcV1) ListLoadBalancerListenerPolicyRules(listLoadBalancerListenerPolicyRulesOptions *ListLoadBalancerListenerPolicyRulesOptions) (result *LoadBalancerListenerPolicyRuleCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancerListenerPolicyRulesWithContext(context.Background(), listLoadBalancerListenerPolicyRulesOptions)
}

// ListLoadBalancerListenerPolicyRulesWithContext is an alternate form of the ListLoadBalancerListenerPolicyRules method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancerListenerPolicyRulesWithContext(ctx context.Context, listLoadBalancerListenerPolicyRulesOptions *ListLoadBalancerListenerPolicyRulesOptions) (result *LoadBalancerListenerPolicyRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenerPolicyRulesOptions, "listLoadBalancerListenerPolicyRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenerPolicyRulesOptions, "listLoadBalancerListenerPolicyRulesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *listLoadBalancerListenerPolicyRulesOptions.LoadBalancerID,
		"listener_id":      *listLoadBalancerListenerPolicyRulesOptions.ListenerID,
		"policy_id":        *listLoadBalancerListenerPolicyRulesOptions.PolicyID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenerPolicyRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListenerPolicyRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRuleCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateLoadBalancerListenerPolicyRule : Create a rule for a load balancer listener policy
// Creates a new rule for the load balancer listener policy.
func (vpc *VpcV1) CreateLoadBalancerListenerPolicyRule(createLoadBalancerListenerPolicyRuleOptions *CreateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	return vpc.CreateLoadBalancerListenerPolicyRuleWithContext(context.Background(), createLoadBalancerListenerPolicyRuleOptions)
}

// CreateLoadBalancerListenerPolicyRuleWithContext is an alternate form of the CreateLoadBalancerListenerPolicyRule method which supports a Context parameter
func (vpc *VpcV1) CreateLoadBalancerListenerPolicyRuleWithContext(ctx context.Context, createLoadBalancerListenerPolicyRuleOptions *CreateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerPolicyRuleOptions, "createLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerPolicyRuleOptions, "createLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *createLoadBalancerListenerPolicyRuleOptions.LoadBalancerID,
		"listener_id":      *createLoadBalancerListenerPolicyRuleOptions.ListenerID,
		"policy_id":        *createLoadBalancerListenerPolicyRuleOptions.PolicyID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerPolicyRuleOptions.Condition != nil {
		body["condition"] = createLoadBalancerListenerPolicyRuleOptions.Condition
	}
	if createLoadBalancerListenerPolicyRuleOptions.Type != nil {
		body["type"] = createLoadBalancerListenerPolicyRuleOptions.Type
	}
	if createLoadBalancerListenerPolicyRuleOptions.Value != nil {
		body["value"] = createLoadBalancerListenerPolicyRuleOptions.Value
	}
	if createLoadBalancerListenerPolicyRuleOptions.Field != nil {
		body["field"] = createLoadBalancerListenerPolicyRuleOptions.Field
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteLoadBalancerListenerPolicyRule : Delete a load balancer listener policy rule
// Deletes a rule from the load balancer listener policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicyRule(deleteLoadBalancerListenerPolicyRuleOptions *DeleteLoadBalancerListenerPolicyRuleOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteLoadBalancerListenerPolicyRuleWithContext(context.Background(), deleteLoadBalancerListenerPolicyRuleOptions)
}

// DeleteLoadBalancerListenerPolicyRuleWithContext is an alternate form of the DeleteLoadBalancerListenerPolicyRule method which supports a Context parameter
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicyRuleWithContext(ctx context.Context, deleteLoadBalancerListenerPolicyRuleOptions *DeleteLoadBalancerListenerPolicyRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerPolicyRuleOptions, "deleteLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerPolicyRuleOptions, "deleteLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *deleteLoadBalancerListenerPolicyRuleOptions.LoadBalancerID,
		"listener_id":      *deleteLoadBalancerListenerPolicyRuleOptions.ListenerID,
		"policy_id":        *deleteLoadBalancerListenerPolicyRuleOptions.PolicyID,
		"id":               *deleteLoadBalancerListenerPolicyRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListenerPolicyRule : Retrieve a load balancer listener policy rule
// Retrieves a single rule specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListenerPolicyRule(getLoadBalancerListenerPolicyRuleOptions *GetLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerListenerPolicyRuleWithContext(context.Background(), getLoadBalancerListenerPolicyRuleOptions)
}

// GetLoadBalancerListenerPolicyRuleWithContext is an alternate form of the GetLoadBalancerListenerPolicyRule method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerListenerPolicyRuleWithContext(ctx context.Context, getLoadBalancerListenerPolicyRuleOptions *GetLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerPolicyRuleOptions, "getLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerPolicyRuleOptions, "getLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *getLoadBalancerListenerPolicyRuleOptions.LoadBalancerID,
		"listener_id":      *getLoadBalancerListenerPolicyRuleOptions.ListenerID,
		"policy_id":        *getLoadBalancerListenerPolicyRuleOptions.PolicyID,
		"id":               *getLoadBalancerListenerPolicyRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateLoadBalancerListenerPolicyRule : Update a load balancer listener policy rule
// Updates a rule of the load balancer listener policy.
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicyRule(updateLoadBalancerListenerPolicyRuleOptions *UpdateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	return vpc.UpdateLoadBalancerListenerPolicyRuleWithContext(context.Background(), updateLoadBalancerListenerPolicyRuleOptions)
}

// UpdateLoadBalancerListenerPolicyRuleWithContext is an alternate form of the UpdateLoadBalancerListenerPolicyRule method which supports a Context parameter
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicyRuleWithContext(ctx context.Context, updateLoadBalancerListenerPolicyRuleOptions *UpdateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerPolicyRuleOptions, "updateLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerPolicyRuleOptions, "updateLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *updateLoadBalancerListenerPolicyRuleOptions.LoadBalancerID,
		"listener_id":      *updateLoadBalancerListenerPolicyRuleOptions.ListenerID,
		"policy_id":        *updateLoadBalancerListenerPolicyRuleOptions.PolicyID,
		"id":               *updateLoadBalancerListenerPolicyRuleOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/listeners/{listener_id}/policies/{policy_id}/rules/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateLoadBalancerListenerPolicyRuleOptions.LoadBalancerListenerPolicyRulePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRule)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancerPools : List all pools of a load balancer
// This request lists all pools of a load balancer.
func (vpc *VpcV1) ListLoadBalancerPools(listLoadBalancerPoolsOptions *ListLoadBalancerPoolsOptions) (result *LoadBalancerPoolCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancerPoolsWithContext(context.Background(), listLoadBalancerPoolsOptions)
}

// ListLoadBalancerPoolsWithContext is an alternate form of the ListLoadBalancerPools method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancerPoolsWithContext(ctx context.Context, listLoadBalancerPoolsOptions *ListLoadBalancerPoolsOptions) (result *LoadBalancerPoolCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerPoolsOptions, "listLoadBalancerPoolsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerPoolsOptions, "listLoadBalancerPoolsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *listLoadBalancerPoolsOptions.LoadBalancerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerPoolsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerPools")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateLoadBalancerPool : Create a load balancer pool
// This request creates a new pool from a pool prototype object.
func (vpc *VpcV1) CreateLoadBalancerPool(createLoadBalancerPoolOptions *CreateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	return vpc.CreateLoadBalancerPoolWithContext(context.Background(), createLoadBalancerPoolOptions)
}

// CreateLoadBalancerPoolWithContext is an alternate form of the CreateLoadBalancerPool method which supports a Context parameter
func (vpc *VpcV1) CreateLoadBalancerPoolWithContext(ctx context.Context, createLoadBalancerPoolOptions *CreateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerPoolOptions, "createLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerPoolOptions, "createLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *createLoadBalancerPoolOptions.LoadBalancerID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerPoolOptions.Algorithm != nil {
		body["algorithm"] = createLoadBalancerPoolOptions.Algorithm
	}
	if createLoadBalancerPoolOptions.HealthMonitor != nil {
		body["health_monitor"] = createLoadBalancerPoolOptions.HealthMonitor
	}
	if createLoadBalancerPoolOptions.Protocol != nil {
		body["protocol"] = createLoadBalancerPoolOptions.Protocol
	}
	if createLoadBalancerPoolOptions.Members != nil {
		body["members"] = createLoadBalancerPoolOptions.Members
	}
	if createLoadBalancerPoolOptions.Name != nil {
		body["name"] = createLoadBalancerPoolOptions.Name
	}
	if createLoadBalancerPoolOptions.ProxyProtocol != nil {
		body["proxy_protocol"] = createLoadBalancerPoolOptions.ProxyProtocol
	}
	if createLoadBalancerPoolOptions.SessionPersistence != nil {
		body["session_persistence"] = createLoadBalancerPoolOptions.SessionPersistence
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteLoadBalancerPool : Delete a load balancer pool
// This request deletes a load balancer pool. This operation cannot be reversed. The pool must not currently be the
// default pool for any listener in the load balancer.
func (vpc *VpcV1) DeleteLoadBalancerPool(deleteLoadBalancerPoolOptions *DeleteLoadBalancerPoolOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteLoadBalancerPoolWithContext(context.Background(), deleteLoadBalancerPoolOptions)
}

// DeleteLoadBalancerPoolWithContext is an alternate form of the DeleteLoadBalancerPool method which supports a Context parameter
func (vpc *VpcV1) DeleteLoadBalancerPoolWithContext(ctx context.Context, deleteLoadBalancerPoolOptions *DeleteLoadBalancerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerPoolOptions, "deleteLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerPoolOptions, "deleteLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *deleteLoadBalancerPoolOptions.LoadBalancerID,
		"id":               *deleteLoadBalancerPoolOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerPool : Retrieve a load balancer pool
// This request retrieves a single pool specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerPool(getLoadBalancerPoolOptions *GetLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerPoolWithContext(context.Background(), getLoadBalancerPoolOptions)
}

// GetLoadBalancerPoolWithContext is an alternate form of the GetLoadBalancerPool method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerPoolWithContext(ctx context.Context, getLoadBalancerPoolOptions *GetLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerPoolOptions, "getLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerPoolOptions, "getLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *getLoadBalancerPoolOptions.LoadBalancerID,
		"id":               *getLoadBalancerPoolOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateLoadBalancerPool : Update a load balancer pool
// This request updates a load balancer pool from a pool patch.
func (vpc *VpcV1) UpdateLoadBalancerPool(updateLoadBalancerPoolOptions *UpdateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	return vpc.UpdateLoadBalancerPoolWithContext(context.Background(), updateLoadBalancerPoolOptions)
}

// UpdateLoadBalancerPoolWithContext is an alternate form of the UpdateLoadBalancerPool method which supports a Context parameter
func (vpc *VpcV1) UpdateLoadBalancerPoolWithContext(ctx context.Context, updateLoadBalancerPoolOptions *UpdateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolOptions, "updateLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolOptions, "updateLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *updateLoadBalancerPoolOptions.LoadBalancerID,
		"id":               *updateLoadBalancerPoolOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateLoadBalancerPoolOptions.LoadBalancerPoolPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListLoadBalancerPoolMembers : List all members of a load balancer pool
// This request lists all members of a load balancer pool.
func (vpc *VpcV1) ListLoadBalancerPoolMembers(listLoadBalancerPoolMembersOptions *ListLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	return vpc.ListLoadBalancerPoolMembersWithContext(context.Background(), listLoadBalancerPoolMembersOptions)
}

// ListLoadBalancerPoolMembersWithContext is an alternate form of the ListLoadBalancerPoolMembers method which supports a Context parameter
func (vpc *VpcV1) ListLoadBalancerPoolMembersWithContext(ctx context.Context, listLoadBalancerPoolMembersOptions *ListLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerPoolMembersOptions, "listLoadBalancerPoolMembersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerPoolMembersOptions, "listLoadBalancerPoolMembersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *listLoadBalancerPoolMembersOptions.LoadBalancerID,
		"pool_id":          *listLoadBalancerPoolMembersOptions.PoolID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{pool_id}/members`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerPoolMembersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerPoolMembers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMemberCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateLoadBalancerPoolMember : Create a member in a load balancer pool
// This request creates a new member and adds the member to the pool.
func (vpc *VpcV1) CreateLoadBalancerPoolMember(createLoadBalancerPoolMemberOptions *CreateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	return vpc.CreateLoadBalancerPoolMemberWithContext(context.Background(), createLoadBalancerPoolMemberOptions)
}

// CreateLoadBalancerPoolMemberWithContext is an alternate form of the CreateLoadBalancerPoolMember method which supports a Context parameter
func (vpc *VpcV1) CreateLoadBalancerPoolMemberWithContext(ctx context.Context, createLoadBalancerPoolMemberOptions *CreateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerPoolMemberOptions, "createLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerPoolMemberOptions, "createLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *createLoadBalancerPoolMemberOptions.LoadBalancerID,
		"pool_id":          *createLoadBalancerPoolMemberOptions.PoolID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{pool_id}/members`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerPoolMemberOptions.Port != nil {
		body["port"] = createLoadBalancerPoolMemberOptions.Port
	}
	if createLoadBalancerPoolMemberOptions.Target != nil {
		body["target"] = createLoadBalancerPoolMemberOptions.Target
	}
	if createLoadBalancerPoolMemberOptions.Weight != nil {
		body["weight"] = createLoadBalancerPoolMemberOptions.Weight
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMember)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceLoadBalancerPoolMembers : Replace load balancer pool members
// This request replaces the existing members of the load balancer pool with new members created from the collection of
// member prototype objects.
func (vpc *VpcV1) ReplaceLoadBalancerPoolMembers(replaceLoadBalancerPoolMembersOptions *ReplaceLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	return vpc.ReplaceLoadBalancerPoolMembersWithContext(context.Background(), replaceLoadBalancerPoolMembersOptions)
}

// ReplaceLoadBalancerPoolMembersWithContext is an alternate form of the ReplaceLoadBalancerPoolMembers method which supports a Context parameter
func (vpc *VpcV1) ReplaceLoadBalancerPoolMembersWithContext(ctx context.Context, replaceLoadBalancerPoolMembersOptions *ReplaceLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceLoadBalancerPoolMembersOptions, "replaceLoadBalancerPoolMembersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceLoadBalancerPoolMembersOptions, "replaceLoadBalancerPoolMembersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *replaceLoadBalancerPoolMembersOptions.LoadBalancerID,
		"pool_id":          *replaceLoadBalancerPoolMembersOptions.PoolID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{pool_id}/members`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceLoadBalancerPoolMembersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReplaceLoadBalancerPoolMembers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if replaceLoadBalancerPoolMembersOptions.Members != nil {
		body["members"] = replaceLoadBalancerPoolMembersOptions.Members
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMemberCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteLoadBalancerPoolMember : Delete a load balancer pool member
// This request deletes a member from the pool. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerPoolMember(deleteLoadBalancerPoolMemberOptions *DeleteLoadBalancerPoolMemberOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteLoadBalancerPoolMemberWithContext(context.Background(), deleteLoadBalancerPoolMemberOptions)
}

// DeleteLoadBalancerPoolMemberWithContext is an alternate form of the DeleteLoadBalancerPoolMember method which supports a Context parameter
func (vpc *VpcV1) DeleteLoadBalancerPoolMemberWithContext(ctx context.Context, deleteLoadBalancerPoolMemberOptions *DeleteLoadBalancerPoolMemberOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerPoolMemberOptions, "deleteLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerPoolMemberOptions, "deleteLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *deleteLoadBalancerPoolMemberOptions.LoadBalancerID,
		"pool_id":          *deleteLoadBalancerPoolMemberOptions.PoolID,
		"id":               *deleteLoadBalancerPoolMemberOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerPoolMember : Retrieve a load balancer pool member
// This request retrieves a single member specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerPoolMember(getLoadBalancerPoolMemberOptions *GetLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	return vpc.GetLoadBalancerPoolMemberWithContext(context.Background(), getLoadBalancerPoolMemberOptions)
}

// GetLoadBalancerPoolMemberWithContext is an alternate form of the GetLoadBalancerPoolMember method which supports a Context parameter
func (vpc *VpcV1) GetLoadBalancerPoolMemberWithContext(ctx context.Context, getLoadBalancerPoolMemberOptions *GetLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerPoolMemberOptions, "getLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerPoolMemberOptions, "getLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *getLoadBalancerPoolMemberOptions.LoadBalancerID,
		"pool_id":          *getLoadBalancerPoolMemberOptions.PoolID,
		"id":               *getLoadBalancerPoolMemberOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMember)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateLoadBalancerPoolMember : Update a load balancer pool member
// This request updates an existing member from a member patch.
func (vpc *VpcV1) UpdateLoadBalancerPoolMember(updateLoadBalancerPoolMemberOptions *UpdateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	return vpc.UpdateLoadBalancerPoolMemberWithContext(context.Background(), updateLoadBalancerPoolMemberOptions)
}

// UpdateLoadBalancerPoolMemberWithContext is an alternate form of the UpdateLoadBalancerPoolMember method which supports a Context parameter
func (vpc *VpcV1) UpdateLoadBalancerPoolMemberWithContext(ctx context.Context, updateLoadBalancerPoolMemberOptions *UpdateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolMemberOptions, "updateLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolMemberOptions, "updateLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"load_balancer_id": *updateLoadBalancerPoolMemberOptions.LoadBalancerID,
		"pool_id":          *updateLoadBalancerPoolMemberOptions.PoolID,
		"id":               *updateLoadBalancerPoolMemberOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/load_balancers/{load_balancer_id}/pools/{pool_id}/members/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateLoadBalancerPoolMemberOptions.LoadBalancerPoolMemberPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMember)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListEndpointGateways : List all endpoint gateways
// This request lists all endpoint gateways in the region. An endpoint gateway maps one or more reserved IPs in a VPC to
// a target outside the VPC.
func (vpc *VpcV1) ListEndpointGateways(listEndpointGatewaysOptions *ListEndpointGatewaysOptions) (result *EndpointGatewayCollection, response *core.DetailedResponse, err error) {
	return vpc.ListEndpointGatewaysWithContext(context.Background(), listEndpointGatewaysOptions)
}

// ListEndpointGatewaysWithContext is an alternate form of the ListEndpointGateways method which supports a Context parameter
func (vpc *VpcV1) ListEndpointGatewaysWithContext(ctx context.Context, listEndpointGatewaysOptions *ListEndpointGatewaysOptions) (result *EndpointGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listEndpointGatewaysOptions, "listEndpointGatewaysOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listEndpointGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListEndpointGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listEndpointGatewaysOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listEndpointGatewaysOptions.Name))
	}
	if listEndpointGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listEndpointGatewaysOptions.Start))
	}
	if listEndpointGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listEndpointGatewaysOptions.Limit))
	}
	if listEndpointGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listEndpointGatewaysOptions.ResourceGroupID))
	}
	if listEndpointGatewaysOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listEndpointGatewaysOptions.VPCID))
	}
	if listEndpointGatewaysOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listEndpointGatewaysOptions.VPCCRN))
	}
	if listEndpointGatewaysOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listEndpointGatewaysOptions.VPCName))
	}
	if listEndpointGatewaysOptions.AllowDnsResolutionBinding != nil {
		builder.AddQuery("allow_dns_resolution_binding", fmt.Sprint(*listEndpointGatewaysOptions.AllowDnsResolutionBinding))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEndpointGatewayCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateEndpointGateway : Create an endpoint gateway
// This request creates a new endpoint gateway. An endpoint gateway maps one or more reserved IPs in a VPC to a target
// outside the VPC.
func (vpc *VpcV1) CreateEndpointGateway(createEndpointGatewayOptions *CreateEndpointGatewayOptions) (result *EndpointGateway, response *core.DetailedResponse, err error) {
	return vpc.CreateEndpointGatewayWithContext(context.Background(), createEndpointGatewayOptions)
}

// CreateEndpointGatewayWithContext is an alternate form of the CreateEndpointGateway method which supports a Context parameter
func (vpc *VpcV1) CreateEndpointGatewayWithContext(ctx context.Context, createEndpointGatewayOptions *CreateEndpointGatewayOptions) (result *EndpointGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createEndpointGatewayOptions, "createEndpointGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createEndpointGatewayOptions, "createEndpointGatewayOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createEndpointGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateEndpointGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createEndpointGatewayOptions.Target != nil {
		body["target"] = createEndpointGatewayOptions.Target
	}
	if createEndpointGatewayOptions.VPC != nil {
		body["vpc"] = createEndpointGatewayOptions.VPC
	}
	if createEndpointGatewayOptions.AllowDnsResolutionBinding != nil {
		body["allow_dns_resolution_binding"] = createEndpointGatewayOptions.AllowDnsResolutionBinding
	}
	if createEndpointGatewayOptions.Ips != nil {
		body["ips"] = createEndpointGatewayOptions.Ips
	}
	if createEndpointGatewayOptions.Name != nil {
		body["name"] = createEndpointGatewayOptions.Name
	}
	if createEndpointGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createEndpointGatewayOptions.ResourceGroup
	}
	if createEndpointGatewayOptions.SecurityGroups != nil {
		body["security_groups"] = createEndpointGatewayOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEndpointGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListEndpointGatewayIps : List all reserved IPs bound to an endpoint gateway
// This request lists all reserved IPs bound to an endpoint gateway.
func (vpc *VpcV1) ListEndpointGatewayIps(listEndpointGatewayIpsOptions *ListEndpointGatewayIpsOptions) (result *ReservedIPCollectionEndpointGatewayContext, response *core.DetailedResponse, err error) {
	return vpc.ListEndpointGatewayIpsWithContext(context.Background(), listEndpointGatewayIpsOptions)
}

// ListEndpointGatewayIpsWithContext is an alternate form of the ListEndpointGatewayIps method which supports a Context parameter
func (vpc *VpcV1) ListEndpointGatewayIpsWithContext(ctx context.Context, listEndpointGatewayIpsOptions *ListEndpointGatewayIpsOptions) (result *ReservedIPCollectionEndpointGatewayContext, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listEndpointGatewayIpsOptions, "listEndpointGatewayIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listEndpointGatewayIpsOptions, "listEndpointGatewayIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"endpoint_gateway_id": *listEndpointGatewayIpsOptions.EndpointGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{endpoint_gateway_id}/ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listEndpointGatewayIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListEndpointGatewayIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listEndpointGatewayIpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listEndpointGatewayIpsOptions.Start))
	}
	if listEndpointGatewayIpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listEndpointGatewayIpsOptions.Limit))
	}
	if listEndpointGatewayIpsOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listEndpointGatewayIpsOptions.Sort))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIPCollectionEndpointGatewayContext)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RemoveEndpointGatewayIP : Unbind a reserved IP from an endpoint gateway
// This request unbinds the specified reserved IP from the specified endpoint gateway. If the reserved IP has
// `auto_delete` set to `true`, the reserved IP will be deleted.
func (vpc *VpcV1) RemoveEndpointGatewayIP(removeEndpointGatewayIPOptions *RemoveEndpointGatewayIPOptions) (response *core.DetailedResponse, err error) {
	return vpc.RemoveEndpointGatewayIPWithContext(context.Background(), removeEndpointGatewayIPOptions)
}

// RemoveEndpointGatewayIPWithContext is an alternate form of the RemoveEndpointGatewayIP method which supports a Context parameter
func (vpc *VpcV1) RemoveEndpointGatewayIPWithContext(ctx context.Context, removeEndpointGatewayIPOptions *RemoveEndpointGatewayIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeEndpointGatewayIPOptions, "removeEndpointGatewayIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeEndpointGatewayIPOptions, "removeEndpointGatewayIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"endpoint_gateway_id": *removeEndpointGatewayIPOptions.EndpointGatewayID,
		"id":                  *removeEndpointGatewayIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{endpoint_gateway_id}/ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeEndpointGatewayIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveEndpointGatewayIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetEndpointGatewayIP : Retrieve a reserved IP bound to an endpoint gateway
// This request retrieves the specified reserved IP address if it is bound to the endpoint gateway specified in the URL.
func (vpc *VpcV1) GetEndpointGatewayIP(getEndpointGatewayIPOptions *GetEndpointGatewayIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.GetEndpointGatewayIPWithContext(context.Background(), getEndpointGatewayIPOptions)
}

// GetEndpointGatewayIPWithContext is an alternate form of the GetEndpointGatewayIP method which supports a Context parameter
func (vpc *VpcV1) GetEndpointGatewayIPWithContext(ctx context.Context, getEndpointGatewayIPOptions *GetEndpointGatewayIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getEndpointGatewayIPOptions, "getEndpointGatewayIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getEndpointGatewayIPOptions, "getEndpointGatewayIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"endpoint_gateway_id": *getEndpointGatewayIPOptions.EndpointGatewayID,
		"id":                  *getEndpointGatewayIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{endpoint_gateway_id}/ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getEndpointGatewayIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetEndpointGatewayIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AddEndpointGatewayIP : Bind a reserved IP to an endpoint gateway
// This request binds the specified reserved IP to the specified endpoint gateway. The reserved IP:
//
// - must currently be unbound
// - must not be in the same zone as any other reserved IP bound to the endpoint gateway.
func (vpc *VpcV1) AddEndpointGatewayIP(addEndpointGatewayIPOptions *AddEndpointGatewayIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	return vpc.AddEndpointGatewayIPWithContext(context.Background(), addEndpointGatewayIPOptions)
}

// AddEndpointGatewayIPWithContext is an alternate form of the AddEndpointGatewayIP method which supports a Context parameter
func (vpc *VpcV1) AddEndpointGatewayIPWithContext(ctx context.Context, addEndpointGatewayIPOptions *AddEndpointGatewayIPOptions) (result *ReservedIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addEndpointGatewayIPOptions, "addEndpointGatewayIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addEndpointGatewayIPOptions, "addEndpointGatewayIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"endpoint_gateway_id": *addEndpointGatewayIPOptions.EndpointGatewayID,
		"id":                  *addEndpointGatewayIPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{endpoint_gateway_id}/ips/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addEndpointGatewayIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddEndpointGatewayIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalReservedIP)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteEndpointGateway : Delete an endpoint gateway
// This request deletes an endpoint gateway. This operation cannot be reversed.
//
// Reserved IPs that were bound to the endpoint gateway will be released if their
// `auto_delete` property is set to true.
func (vpc *VpcV1) DeleteEndpointGateway(deleteEndpointGatewayOptions *DeleteEndpointGatewayOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteEndpointGatewayWithContext(context.Background(), deleteEndpointGatewayOptions)
}

// DeleteEndpointGatewayWithContext is an alternate form of the DeleteEndpointGateway method which supports a Context parameter
func (vpc *VpcV1) DeleteEndpointGatewayWithContext(ctx context.Context, deleteEndpointGatewayOptions *DeleteEndpointGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteEndpointGatewayOptions, "deleteEndpointGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteEndpointGatewayOptions, "deleteEndpointGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteEndpointGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteEndpointGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteEndpointGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetEndpointGateway : Retrieve an endpoint gateway
// This request retrieves a single endpoint gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetEndpointGateway(getEndpointGatewayOptions *GetEndpointGatewayOptions) (result *EndpointGateway, response *core.DetailedResponse, err error) {
	return vpc.GetEndpointGatewayWithContext(context.Background(), getEndpointGatewayOptions)
}

// GetEndpointGatewayWithContext is an alternate form of the GetEndpointGateway method which supports a Context parameter
func (vpc *VpcV1) GetEndpointGatewayWithContext(ctx context.Context, getEndpointGatewayOptions *GetEndpointGatewayOptions) (result *EndpointGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getEndpointGatewayOptions, "getEndpointGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getEndpointGatewayOptions, "getEndpointGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getEndpointGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getEndpointGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetEndpointGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEndpointGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateEndpointGateway : Update an endpoint gateway
// This request updates an endpoint gateway's name.
func (vpc *VpcV1) UpdateEndpointGateway(updateEndpointGatewayOptions *UpdateEndpointGatewayOptions) (result *EndpointGateway, response *core.DetailedResponse, err error) {
	return vpc.UpdateEndpointGatewayWithContext(context.Background(), updateEndpointGatewayOptions)
}

// UpdateEndpointGatewayWithContext is an alternate form of the UpdateEndpointGateway method which supports a Context parameter
func (vpc *VpcV1) UpdateEndpointGatewayWithContext(ctx context.Context, updateEndpointGatewayOptions *UpdateEndpointGatewayOptions) (result *EndpointGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateEndpointGatewayOptions, "updateEndpointGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateEndpointGatewayOptions, "updateEndpointGatewayOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateEndpointGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/endpoint_gateways/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateEndpointGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateEndpointGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateEndpointGatewayOptions.EndpointGatewayPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEndpointGateway)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListFlowLogCollectors : List all flow log collectors
// This request lists all flow log collectors in the region. A flow log collector summarizes data sent over the instance
// network interfaces contained within its target.
func (vpc *VpcV1) ListFlowLogCollectors(listFlowLogCollectorsOptions *ListFlowLogCollectorsOptions) (result *FlowLogCollectorCollection, response *core.DetailedResponse, err error) {
	return vpc.ListFlowLogCollectorsWithContext(context.Background(), listFlowLogCollectorsOptions)
}

// ListFlowLogCollectorsWithContext is an alternate form of the ListFlowLogCollectors method which supports a Context parameter
func (vpc *VpcV1) ListFlowLogCollectorsWithContext(ctx context.Context, listFlowLogCollectorsOptions *ListFlowLogCollectorsOptions) (result *FlowLogCollectorCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listFlowLogCollectorsOptions, "listFlowLogCollectorsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/flow_log_collectors`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listFlowLogCollectorsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListFlowLogCollectors")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listFlowLogCollectorsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listFlowLogCollectorsOptions.Start))
	}
	if listFlowLogCollectorsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listFlowLogCollectorsOptions.Limit))
	}
	if listFlowLogCollectorsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listFlowLogCollectorsOptions.ResourceGroupID))
	}
	if listFlowLogCollectorsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listFlowLogCollectorsOptions.Name))
	}
	if listFlowLogCollectorsOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listFlowLogCollectorsOptions.VPCID))
	}
	if listFlowLogCollectorsOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listFlowLogCollectorsOptions.VPCCRN))
	}
	if listFlowLogCollectorsOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listFlowLogCollectorsOptions.VPCName))
	}
	if listFlowLogCollectorsOptions.TargetID != nil {
		builder.AddQuery("target.id", fmt.Sprint(*listFlowLogCollectorsOptions.TargetID))
	}
	if listFlowLogCollectorsOptions.TargetResourceType != nil {
		builder.AddQuery("target.resource_type", fmt.Sprint(*listFlowLogCollectorsOptions.TargetResourceType))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollectorCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateFlowLogCollector : Create a flow log collector
// This request creates and starts a new flow log collector from a flow log collector prototype object. The prototype
// object is structured in the same way as a retrieved flow log collector, and contains the information necessary to
// create and start the new flow log collector.
func (vpc *VpcV1) CreateFlowLogCollector(createFlowLogCollectorOptions *CreateFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	return vpc.CreateFlowLogCollectorWithContext(context.Background(), createFlowLogCollectorOptions)
}

// CreateFlowLogCollectorWithContext is an alternate form of the CreateFlowLogCollector method which supports a Context parameter
func (vpc *VpcV1) CreateFlowLogCollectorWithContext(ctx context.Context, createFlowLogCollectorOptions *CreateFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createFlowLogCollectorOptions, "createFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createFlowLogCollectorOptions, "createFlowLogCollectorOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/flow_log_collectors`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createFlowLogCollectorOptions.StorageBucket != nil {
		body["storage_bucket"] = createFlowLogCollectorOptions.StorageBucket
	}
	if createFlowLogCollectorOptions.Target != nil {
		body["target"] = createFlowLogCollectorOptions.Target
	}
	if createFlowLogCollectorOptions.Active != nil {
		body["active"] = createFlowLogCollectorOptions.Active
	}
	if createFlowLogCollectorOptions.Name != nil {
		body["name"] = createFlowLogCollectorOptions.Name
	}
	if createFlowLogCollectorOptions.ResourceGroup != nil {
		body["resource_group"] = createFlowLogCollectorOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollector)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteFlowLogCollector : Delete a flow log collector
// This request stops and deletes a flow log collector. This operation cannot be reversed.
//
// Collected flow logs remain available within the flow log collector's Cloud Object Storage bucket.
func (vpc *VpcV1) DeleteFlowLogCollector(deleteFlowLogCollectorOptions *DeleteFlowLogCollectorOptions) (response *core.DetailedResponse, err error) {
	return vpc.DeleteFlowLogCollectorWithContext(context.Background(), deleteFlowLogCollectorOptions)
}

// DeleteFlowLogCollectorWithContext is an alternate form of the DeleteFlowLogCollector method which supports a Context parameter
func (vpc *VpcV1) DeleteFlowLogCollectorWithContext(ctx context.Context, deleteFlowLogCollectorOptions *DeleteFlowLogCollectorOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFlowLogCollectorOptions, "deleteFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFlowLogCollectorOptions, "deleteFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteFlowLogCollectorOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/flow_log_collectors/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetFlowLogCollector : Retrieve a flow log collector
// This request retrieves a single flow log collector specified by the identifier in the URL.
func (vpc *VpcV1) GetFlowLogCollector(getFlowLogCollectorOptions *GetFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	return vpc.GetFlowLogCollectorWithContext(context.Background(), getFlowLogCollectorOptions)
}

// GetFlowLogCollectorWithContext is an alternate form of the GetFlowLogCollector method which supports a Context parameter
func (vpc *VpcV1) GetFlowLogCollectorWithContext(ctx context.Context, getFlowLogCollectorOptions *GetFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFlowLogCollectorOptions, "getFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFlowLogCollectorOptions, "getFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getFlowLogCollectorOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/flow_log_collectors/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollector)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateFlowLogCollector : Update a flow log collector
// This request updates a flow log collector with the information in a provided flow log collector patch. The flow log
// collector patch object is structured in the same way as a retrieved flow log collector and contains only the
// information to be updated.
func (vpc *VpcV1) UpdateFlowLogCollector(updateFlowLogCollectorOptions *UpdateFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	return vpc.UpdateFlowLogCollectorWithContext(context.Background(), updateFlowLogCollectorOptions)
}

// UpdateFlowLogCollectorWithContext is an alternate form of the UpdateFlowLogCollector method which supports a Context parameter
func (vpc *VpcV1) UpdateFlowLogCollectorWithContext(ctx context.Context, updateFlowLogCollectorOptions *UpdateFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFlowLogCollectorOptions, "updateFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateFlowLogCollectorOptions, "updateFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateFlowLogCollectorOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vpc.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vpc.Service.Options.URL, `/flow_log_collectors/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(updateFlowLogCollectorOptions.FlowLogCollectorPatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollector)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AccountReference : AccountReference struct
type AccountReference struct {
	// The unique identifier for this account.
	ID *string `json:"id" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the AccountReference.ResourceType property.
// The resource type.
const (
	AccountReferenceResourceTypeAccountConst = "account"
)

// UnmarshalAccountReference unmarshals an instance of AccountReference from the specified map of raw messages.
func UnmarshalAccountReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AccountReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddBareMetalServerNetworkInterfaceFloatingIPOptions : The AddBareMetalServerNetworkInterfaceFloatingIP options.
type AddBareMetalServerNetworkInterfaceFloatingIPOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddBareMetalServerNetworkInterfaceFloatingIPOptions : Instantiate AddBareMetalServerNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewAddBareMetalServerNetworkInterfaceFloatingIPOptions(bareMetalServerID string, networkInterfaceID string, id string) *AddBareMetalServerNetworkInterfaceFloatingIPOptions {
	return &AddBareMetalServerNetworkInterfaceFloatingIPOptions{
		BareMetalServerID:  core.StringPtr(bareMetalServerID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *AddBareMetalServerNetworkInterfaceFloatingIPOptions) SetBareMetalServerID(bareMetalServerID string) *AddBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *AddBareMetalServerNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *AddBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *AddBareMetalServerNetworkInterfaceFloatingIPOptions) SetID(id string) *AddBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AddBareMetalServerNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *AddBareMetalServerNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// AddEndpointGatewayIPOptions : The AddEndpointGatewayIP options.
type AddEndpointGatewayIPOptions struct {
	// The endpoint gateway identifier.
	EndpointGatewayID *string `json:"endpoint_gateway_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddEndpointGatewayIPOptions : Instantiate AddEndpointGatewayIPOptions
func (*VpcV1) NewAddEndpointGatewayIPOptions(endpointGatewayID string, id string) *AddEndpointGatewayIPOptions {
	return &AddEndpointGatewayIPOptions{
		EndpointGatewayID: core.StringPtr(endpointGatewayID),
		ID:                core.StringPtr(id),
	}
}

// SetEndpointGatewayID : Allow user to set EndpointGatewayID
func (_options *AddEndpointGatewayIPOptions) SetEndpointGatewayID(endpointGatewayID string) *AddEndpointGatewayIPOptions {
	_options.EndpointGatewayID = core.StringPtr(endpointGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *AddEndpointGatewayIPOptions) SetID(id string) *AddEndpointGatewayIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AddEndpointGatewayIPOptions) SetHeaders(param map[string]string) *AddEndpointGatewayIPOptions {
	options.Headers = param
	return options
}

// AddInstanceNetworkInterfaceFloatingIPOptions : The AddInstanceNetworkInterfaceFloatingIP options.
type AddInstanceNetworkInterfaceFloatingIPOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddInstanceNetworkInterfaceFloatingIPOptions : Instantiate AddInstanceNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewAddInstanceNetworkInterfaceFloatingIPOptions(instanceID string, networkInterfaceID string, id string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	return &AddInstanceNetworkInterfaceFloatingIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *AddInstanceNetworkInterfaceFloatingIPOptions) SetInstanceID(instanceID string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *AddInstanceNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *AddInstanceNetworkInterfaceFloatingIPOptions) SetID(id string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AddInstanceNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// AddVPNGatewayConnectionLocalCIDROptions : The AddVPNGatewayConnectionLocalCIDR options.
type AddVPNGatewayConnectionLocalCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required,ne="`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddVPNGatewayConnectionLocalCIDROptions : Instantiate AddVPNGatewayConnectionLocalCIDROptions
func (*VpcV1) NewAddVPNGatewayConnectionLocalCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *AddVPNGatewayConnectionLocalCIDROptions {
	return &AddVPNGatewayConnectionLocalCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *AddVPNGatewayConnectionLocalCIDROptions) SetVPNGatewayID(vpnGatewayID string) *AddVPNGatewayConnectionLocalCIDROptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *AddVPNGatewayConnectionLocalCIDROptions) SetID(id string) *AddVPNGatewayConnectionLocalCIDROptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (_options *AddVPNGatewayConnectionLocalCIDROptions) SetCIDRPrefix(cidrPrefix string) *AddVPNGatewayConnectionLocalCIDROptions {
	_options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return _options
}

// SetPrefixLength : Allow user to set PrefixLength
func (_options *AddVPNGatewayConnectionLocalCIDROptions) SetPrefixLength(prefixLength string) *AddVPNGatewayConnectionLocalCIDROptions {
	_options.PrefixLength = core.StringPtr(prefixLength)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AddVPNGatewayConnectionLocalCIDROptions) SetHeaders(param map[string]string) *AddVPNGatewayConnectionLocalCIDROptions {
	options.Headers = param
	return options
}

// AddVPNGatewayConnectionPeerCIDROptions : The AddVPNGatewayConnectionPeerCIDR options.
type AddVPNGatewayConnectionPeerCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required,ne="`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddVPNGatewayConnectionPeerCIDROptions : Instantiate AddVPNGatewayConnectionPeerCIDROptions
func (*VpcV1) NewAddVPNGatewayConnectionPeerCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *AddVPNGatewayConnectionPeerCIDROptions {
	return &AddVPNGatewayConnectionPeerCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *AddVPNGatewayConnectionPeerCIDROptions) SetVPNGatewayID(vpnGatewayID string) *AddVPNGatewayConnectionPeerCIDROptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *AddVPNGatewayConnectionPeerCIDROptions) SetID(id string) *AddVPNGatewayConnectionPeerCIDROptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (_options *AddVPNGatewayConnectionPeerCIDROptions) SetCIDRPrefix(cidrPrefix string) *AddVPNGatewayConnectionPeerCIDROptions {
	_options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return _options
}

// SetPrefixLength : Allow user to set PrefixLength
func (_options *AddVPNGatewayConnectionPeerCIDROptions) SetPrefixLength(prefixLength string) *AddVPNGatewayConnectionPeerCIDROptions {
	_options.PrefixLength = core.StringPtr(prefixLength)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AddVPNGatewayConnectionPeerCIDROptions) SetHeaders(param map[string]string) *AddVPNGatewayConnectionPeerCIDROptions {
	options.Headers = param
	return options
}

// AddressPrefix : AddressPrefix struct
type AddressPrefix struct {
	// The CIDR block for this prefix.
	CIDR *string `json:"cidr" validate:"required"`

	// The date and time that the prefix was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Indicates whether subnets exist with addresses from this prefix.
	HasSubnets *bool `json:"has_subnets" validate:"required"`

	// The URL for this address prefix.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this address prefix.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. If a default prefix was automatically
	// created when the VPC was created, the prefix is automatically named using a hyphenated list of randomly-selected
	// words, but may be changed.
	IsDefault *bool `json:"is_default" validate:"required"`

	// The name for this address prefix. The name must not be used by another address prefix for the VPC.
	Name *string `json:"name" validate:"required"`

	// The zone this address prefix resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalAddressPrefix unmarshals an instance of AddressPrefix from the specified map of raw messages.
func UnmarshalAddressPrefix(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefix)
	err = core.UnmarshalPrimitive(m, "cidr", &obj.CIDR)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "has_subnets", &obj.HasSubnets)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_default", &obj.IsDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixCollection : AddressPrefixCollection struct
type AddressPrefixCollection struct {
	// Collection of address prefixes.
	AddressPrefixes []AddressPrefix `json:"address_prefixes" validate:"required"`

	// A link to the first page of resources.
	First *AddressPrefixCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *AddressPrefixCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalAddressPrefixCollection unmarshals an instance of AddressPrefixCollection from the specified map of raw messages.
func UnmarshalAddressPrefixCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixCollection)
	err = core.UnmarshalModel(m, "address_prefixes", &obj.AddressPrefixes, UnmarshalAddressPrefix)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalAddressPrefixCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalAddressPrefixCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *AddressPrefixCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// AddressPrefixCollectionFirst : A link to the first page of resources.
type AddressPrefixCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalAddressPrefixCollectionFirst unmarshals an instance of AddressPrefixCollectionFirst from the specified map of raw messages.
func UnmarshalAddressPrefixCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type AddressPrefixCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalAddressPrefixCollectionNext unmarshals an instance of AddressPrefixCollectionNext from the specified map of raw messages.
func UnmarshalAddressPrefixCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixPatch : AddressPrefixPatch struct
type AddressPrefixPatch struct {
	// Indicates whether this is the default prefix for this zone in this VPC. Updating to true makes this prefix the
	// default prefix for this zone in this VPC, provided the VPC currently has no default address prefix for this zone.
	// Updating to false removes the default prefix for this zone in this VPC.
	IsDefault *bool `json:"is_default,omitempty"`

	// The name for this address prefix. The name must not be used by another address prefix for the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalAddressPrefixPatch unmarshals an instance of AddressPrefixPatch from the specified map of raw messages.
func UnmarshalAddressPrefixPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixPatch)
	err = core.UnmarshalPrimitive(m, "is_default", &obj.IsDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the AddressPrefixPatch
func (addressPrefixPatch *AddressPrefixPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(addressPrefixPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// BackupPolicy : BackupPolicy struct
type BackupPolicy struct {
	// The date and time that the backup policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this backup policy.
	CRN *string `json:"crn" validate:"required"`

	// The reasons for the current `health_state` (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []BackupPolicyHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this backup policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this backup policy.
	ID *string `json:"id" validate:"required"`

	// The date and time that the most recent job for this backup policy completed.
	//
	// If absent, no job has yet completed for this backup policy.
	LastJobCompletedAt *strfmt.DateTime `json:"last_job_completed_at,omitempty"`

	// The lifecycle state of the backup policy.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The resource types this backup policy applies to. Resources that have both a matching type and a matching user tag
	// will be subject to the backup policy.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the backup policy on which the
	// unexpected property value was encountered.
	MatchResourceTypes []string `json:"match_resource_types" validate:"required"`

	// The user tags this backup policy applies to. Resources that have both a matching user tag and a matching type will
	// be subject to the backup policy.
	MatchUserTags []string `json:"match_user_tags" validate:"required"`

	// The name for this backup policy. The name is unique across all backup policies in the region.
	Name *string `json:"name" validate:"required"`

	// The plans for the backup policy.
	Plans []BackupPolicyPlanReference `json:"plans" validate:"required"`

	// The resource group for this backup policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The scope for this backup policy.
	Scope BackupPolicyScopeIntf `json:"scope" validate:"required"`
}

// Constants associated with the BackupPolicy.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	BackupPolicyHealthStateDegradedConst     = "degraded"
	BackupPolicyHealthStateFaultedConst      = "faulted"
	BackupPolicyHealthStateInapplicableConst = "inapplicable"
	BackupPolicyHealthStateOkConst           = "ok"
)

// Constants associated with the BackupPolicy.LifecycleState property.
// The lifecycle state of the backup policy.
const (
	BackupPolicyLifecycleStateDeletingConst  = "deleting"
	BackupPolicyLifecycleStateFailedConst    = "failed"
	BackupPolicyLifecycleStatePendingConst   = "pending"
	BackupPolicyLifecycleStateStableConst    = "stable"
	BackupPolicyLifecycleStateSuspendedConst = "suspended"
	BackupPolicyLifecycleStateUpdatingConst  = "updating"
	BackupPolicyLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the BackupPolicy.MatchResourceTypes property.
// The resource type.
const (
	BackupPolicyMatchResourceTypesVolumeConst = "volume"
)

// Constants associated with the BackupPolicy.ResourceType property.
// The resource type.
const (
	BackupPolicyResourceTypeBackupPolicyConst = "backup_policy"
)

// UnmarshalBackupPolicy unmarshals an instance of BackupPolicy from the specified map of raw messages.
func UnmarshalBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicy)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalBackupPolicyHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "last_job_completed_at", &obj.LastJobCompletedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "match_resource_types", &obj.MatchResourceTypes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "match_user_tags", &obj.MatchUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "plans", &obj.Plans, UnmarshalBackupPolicyPlanReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "scope", &obj.Scope, UnmarshalBackupPolicyScope)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyCollection : BackupPolicyCollection struct
type BackupPolicyCollection struct {
	// Collection of backup policies.
	BackupPolicies []BackupPolicy `json:"backup_policies" validate:"required"`

	// A link to the first page of resources.
	First *BackupPolicyCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *BackupPolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalBackupPolicyCollection unmarshals an instance of BackupPolicyCollection from the specified map of raw messages.
func UnmarshalBackupPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyCollection)
	err = core.UnmarshalModel(m, "backup_policies", &obj.BackupPolicies, UnmarshalBackupPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalBackupPolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalBackupPolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *BackupPolicyCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// BackupPolicyCollectionFirst : A link to the first page of resources.
type BackupPolicyCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBackupPolicyCollectionFirst unmarshals an instance of BackupPolicyCollectionFirst from the specified map of raw messages.
func UnmarshalBackupPolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type BackupPolicyCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBackupPolicyCollectionNext unmarshals an instance of BackupPolicyCollectionNext from the specified map of raw messages.
func UnmarshalBackupPolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyHealthReason : BackupPolicyHealthReason struct
type BackupPolicyHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the BackupPolicyHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	BackupPolicyHealthReasonCodeMissingServiceAuthorizationPoliciesConst = "missing_service_authorization_policies"
)

// UnmarshalBackupPolicyHealthReason unmarshals an instance of BackupPolicyHealthReason from the specified map of raw messages.
func UnmarshalBackupPolicyHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyJob : BackupPolicyJob struct
type BackupPolicyJob struct {
	// Indicates whether this backup policy job will be automatically deleted after it completes. At present, this is
	// always `true`, but may be modifiable in the future.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// If `auto_delete` is `true`, the days after completion that this backup policy job will be deleted. This value may be
	// modifiable in the future.
	AutoDeleteAfter *int64 `json:"auto_delete_after" validate:"required"`

	// The backup policy plan operated this backup policy job (may be
	// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
	BackupPolicyPlan *BackupPolicyPlanReference `json:"backup_policy_plan" validate:"required"`

	// The date and time that the backup policy job was completed.
	//
	// If absent, the backup policy job has not yet completed.
	CompletedAt *strfmt.DateTime `json:"completed_at,omitempty"`

	// The date and time that the backup policy job was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this backup policy job.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this backup policy job.
	ID *string `json:"id" validate:"required"`

	// The type of backup policy job.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the backup policy job on which the
	// unexpected property value was encountered.
	JobType *string `json:"job_type" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The source this backup was created from (may be
	// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
	Source BackupPolicyJobSourceIntf `json:"source" validate:"required"`

	// The status of the backup policy job.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the backup policy job on which the
	// unexpected property value was encountered.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []BackupPolicyJobStatusReason `json:"status_reasons" validate:"required"`

	// The snapshots operated on by this backup policy job (may be
	// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
	TargetSnapshots []SnapshotReference `json:"target_snapshots" validate:"required"`
}

// Constants associated with the BackupPolicyJob.JobType property.
// The type of backup policy job.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the backup policy job on which the
// unexpected property value was encountered.
const (
	BackupPolicyJobJobTypeCreationConst = "creation"
	BackupPolicyJobJobTypeDeletionConst = "deletion"
)

// Constants associated with the BackupPolicyJob.ResourceType property.
// The resource type.
const (
	BackupPolicyJobResourceTypeBackupPolicyJobConst = "backup_policy_job"
)

// Constants associated with the BackupPolicyJob.Status property.
// The status of the backup policy job.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the backup policy job on which the
// unexpected property value was encountered.
const (
	BackupPolicyJobStatusFailedConst    = "failed"
	BackupPolicyJobStatusRunningConst   = "running"
	BackupPolicyJobStatusSucceededConst = "succeeded"
)

// UnmarshalBackupPolicyJob unmarshals an instance of BackupPolicyJob from the specified map of raw messages.
func UnmarshalBackupPolicyJob(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJob)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete_after", &obj.AutoDeleteAfter)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "backup_policy_plan", &obj.BackupPolicyPlan, UnmarshalBackupPolicyPlanReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "completed_at", &obj.CompletedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "job_type", &obj.JobType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source", &obj.Source, UnmarshalBackupPolicyJobSource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalBackupPolicyJobStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target_snapshots", &obj.TargetSnapshots, UnmarshalSnapshotReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyJobCollection : BackupPolicyJobCollection struct
type BackupPolicyJobCollection struct {
	// A link to the first page of resources.
	First *BackupPolicyJobCollectionFirst `json:"first" validate:"required"`

	// Collection of backup policy jobs.
	Jobs []BackupPolicyJob `json:"jobs" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *BackupPolicyJobCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalBackupPolicyJobCollection unmarshals an instance of BackupPolicyJobCollection from the specified map of raw messages.
func UnmarshalBackupPolicyJobCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJobCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalBackupPolicyJobCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "jobs", &obj.Jobs, UnmarshalBackupPolicyJob)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalBackupPolicyJobCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *BackupPolicyJobCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// BackupPolicyJobCollectionFirst : A link to the first page of resources.
type BackupPolicyJobCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBackupPolicyJobCollectionFirst unmarshals an instance of BackupPolicyJobCollectionFirst from the specified map of raw messages.
func UnmarshalBackupPolicyJobCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJobCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyJobCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type BackupPolicyJobCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBackupPolicyJobCollectionNext unmarshals an instance of BackupPolicyJobCollectionNext from the specified map of raw messages.
func UnmarshalBackupPolicyJobCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJobCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyJobSource : The source this backup was created from (may be
// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
// Models which "extend" this model:
// - BackupPolicyJobSourceVolumeReference
type BackupPolicyJobSource struct {
	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VolumeReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The name for this volume. The name is unique across all volumes in the region.
	Name *string `json:"name,omitempty"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *VolumeRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the BackupPolicyJobSource.ResourceType property.
// The resource type.
const (
	BackupPolicyJobSourceResourceTypeVolumeConst = "volume"
)

func (*BackupPolicyJobSource) isaBackupPolicyJobSource() bool {
	return true
}

type BackupPolicyJobSourceIntf interface {
	isaBackupPolicyJobSource() bool
}

// UnmarshalBackupPolicyJobSource unmarshals an instance of BackupPolicyJobSource from the specified map of raw messages.
func UnmarshalBackupPolicyJobSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJobSource)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVolumeReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalVolumeRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyJobStatusReason : BackupPolicyJobStatusReason struct
type BackupPolicyJobStatusReason struct {
	// A snake case string succinctly identifying the status reason:
	// - `internal_error`: Internal error (contact IBM support)
	// - `snapshot_pending`: Cannot delete backup (snapshot) in the `pending` lifecycle state
	// - `snapshot_volume_limit`: The snapshot limit for the source volume has been reached
	// - `source_volume_busy`: The source volume has `busy` set (after multiple retries).
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the BackupPolicyJobStatusReason.Code property.
// A snake case string succinctly identifying the status reason:
// - `internal_error`: Internal error (contact IBM support)
// - `snapshot_pending`: Cannot delete backup (snapshot) in the `pending` lifecycle state
// - `snapshot_volume_limit`: The snapshot limit for the source volume has been reached
// - `source_volume_busy`: The source volume has `busy` set (after multiple retries).
const (
	BackupPolicyJobStatusReasonCodeInternalErrorConst       = "internal_error"
	BackupPolicyJobStatusReasonCodeSnapshotPendingConst     = "snapshot_pending"
	BackupPolicyJobStatusReasonCodeSnapshotVolumeLimitConst = "snapshot_volume_limit"
	BackupPolicyJobStatusReasonCodeSourceVolumeBusyConst    = "source_volume_busy"
)

// UnmarshalBackupPolicyJobStatusReason unmarshals an instance of BackupPolicyJobStatusReason from the specified map of raw messages.
func UnmarshalBackupPolicyJobStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJobStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPatch : BackupPolicyPatch struct
type BackupPolicyPatch struct {
	// The user tags this backup policy will apply to (replacing any existing tags). Resources that have both a matching
	// user tag and a matching type will be subject to the backup policy.
	MatchUserTags []string `json:"match_user_tags,omitempty"`

	// The name for this backup policy. The name must not be used by another backup policy in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalBackupPolicyPatch unmarshals an instance of BackupPolicyPatch from the specified map of raw messages.
func UnmarshalBackupPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPatch)
	err = core.UnmarshalPrimitive(m, "match_user_tags", &obj.MatchUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the BackupPolicyPatch
func (backupPolicyPatch *BackupPolicyPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(backupPolicyPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// BackupPolicyPlan : BackupPolicyPlan struct
type BackupPolicyPlan struct {
	// Indicates whether the plan is active.
	Active *bool `json:"active" validate:"required"`

	// The user tags to attach to backups (snapshots) created by this plan.
	AttachUserTags []string `json:"attach_user_tags" validate:"required"`

	ClonePolicy *BackupPolicyPlanClonePolicy `json:"clone_policy" validate:"required"`

	// Indicates whether to copy the source's user tags to the created backups (snapshots).
	CopyUserTags *bool `json:"copy_user_tags" validate:"required"`

	// The date and time that the backup policy plan was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The cron specification for the backup schedule. The backup policy jobs
	// (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
	// after this time.
	//
	// All backup schedules for plans in the same policy must be at least an hour apart.
	CronSpec *string `json:"cron_spec" validate:"required"`

	DeletionTrigger *BackupPolicyPlanDeletionTrigger `json:"deletion_trigger" validate:"required"`

	// The URL for this backup policy plan.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this backup policy plan.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of this backup policy plan.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this backup policy plan. The name is unique across all plans in the backup policy.
	Name *string `json:"name" validate:"required"`

	// The policies for additional backups in remote regions.
	RemoteRegionPolicies []BackupPolicyPlanRemoteRegionPolicy `json:"remote_region_policies" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BackupPolicyPlan.LifecycleState property.
// The lifecycle state of this backup policy plan.
const (
	BackupPolicyPlanLifecycleStateDeletingConst  = "deleting"
	BackupPolicyPlanLifecycleStateFailedConst    = "failed"
	BackupPolicyPlanLifecycleStatePendingConst   = "pending"
	BackupPolicyPlanLifecycleStateStableConst    = "stable"
	BackupPolicyPlanLifecycleStateSuspendedConst = "suspended"
	BackupPolicyPlanLifecycleStateUpdatingConst  = "updating"
	BackupPolicyPlanLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the BackupPolicyPlan.ResourceType property.
// The resource type.
const (
	BackupPolicyPlanResourceTypeBackupPolicyPlanConst = "backup_policy_plan"
)

// UnmarshalBackupPolicyPlan unmarshals an instance of BackupPolicyPlan from the specified map of raw messages.
func UnmarshalBackupPolicyPlan(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlan)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attach_user_tags", &obj.AttachUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clone_policy", &obj.ClonePolicy, UnmarshalBackupPolicyPlanClonePolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "copy_user_tags", &obj.CopyUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deletion_trigger", &obj.DeletionTrigger, UnmarshalBackupPolicyPlanDeletionTrigger)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote_region_policies", &obj.RemoteRegionPolicies, UnmarshalBackupPolicyPlanRemoteRegionPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanClonePolicy : BackupPolicyPlanClonePolicy struct
type BackupPolicyPlanClonePolicy struct {
	// The maximum number of recent snapshots (per source) that will keep clones.
	MaxSnapshots *int64 `json:"max_snapshots" validate:"required"`

	// The zone this backup policy plan will create snapshot clones in.
	Zones []ZoneReference `json:"zones" validate:"required"`
}

// UnmarshalBackupPolicyPlanClonePolicy unmarshals an instance of BackupPolicyPlanClonePolicy from the specified map of raw messages.
func UnmarshalBackupPolicyPlanClonePolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanClonePolicy)
	err = core.UnmarshalPrimitive(m, "max_snapshots", &obj.MaxSnapshots)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanClonePolicyPatch : BackupPolicyPlanClonePolicyPatch struct
type BackupPolicyPlanClonePolicyPatch struct {
	// The maximum number of recent snapshots (per source) that will keep clones.
	MaxSnapshots *int64 `json:"max_snapshots,omitempty"`

	// The zones this backup policy plan will create snapshot clones in. Updating this value does not change the clones for
	// snapshots that have already been created by this plan.
	Zones []ZoneIdentityIntf `json:"zones,omitempty"`
}

// UnmarshalBackupPolicyPlanClonePolicyPatch unmarshals an instance of BackupPolicyPlanClonePolicyPatch from the specified map of raw messages.
func UnmarshalBackupPolicyPlanClonePolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanClonePolicyPatch)
	err = core.UnmarshalPrimitive(m, "max_snapshots", &obj.MaxSnapshots)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanClonePolicyPrototype : BackupPolicyPlanClonePolicyPrototype struct
type BackupPolicyPlanClonePolicyPrototype struct {
	// The maximum number of recent snapshots (per source) that will keep clones.
	MaxSnapshots *int64 `json:"max_snapshots,omitempty"`

	// The zone this backup policy plan will create snapshot clones in.
	Zones []ZoneIdentityIntf `json:"zones" validate:"required"`
}

// NewBackupPolicyPlanClonePolicyPrototype : Instantiate BackupPolicyPlanClonePolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewBackupPolicyPlanClonePolicyPrototype(zones []ZoneIdentityIntf) (_model *BackupPolicyPlanClonePolicyPrototype, err error) {
	_model = &BackupPolicyPlanClonePolicyPrototype{
		Zones: zones,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalBackupPolicyPlanClonePolicyPrototype unmarshals an instance of BackupPolicyPlanClonePolicyPrototype from the specified map of raw messages.
func UnmarshalBackupPolicyPlanClonePolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanClonePolicyPrototype)
	err = core.UnmarshalPrimitive(m, "max_snapshots", &obj.MaxSnapshots)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanCollection : BackupPolicyPlanCollection struct
type BackupPolicyPlanCollection struct {
	// Collection of backup policy plans.
	Plans []BackupPolicyPlan `json:"plans" validate:"required"`
}

// UnmarshalBackupPolicyPlanCollection unmarshals an instance of BackupPolicyPlanCollection from the specified map of raw messages.
func UnmarshalBackupPolicyPlanCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanCollection)
	err = core.UnmarshalModel(m, "plans", &obj.Plans, UnmarshalBackupPolicyPlan)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanDeletionTrigger : BackupPolicyPlanDeletionTrigger struct
type BackupPolicyPlanDeletionTrigger struct {
	// The maximum number of days to keep each backup after creation.
	DeleteAfter *int64 `json:"delete_after" validate:"required"`

	// The maximum number of recent backups to keep. If absent, there is no maximum.
	DeleteOverCount *int64 `json:"delete_over_count,omitempty"`
}

// UnmarshalBackupPolicyPlanDeletionTrigger unmarshals an instance of BackupPolicyPlanDeletionTrigger from the specified map of raw messages.
func UnmarshalBackupPolicyPlanDeletionTrigger(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanDeletionTrigger)
	err = core.UnmarshalPrimitive(m, "delete_after", &obj.DeleteAfter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delete_over_count", &obj.DeleteOverCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanDeletionTriggerPatch : BackupPolicyPlanDeletionTriggerPatch struct
type BackupPolicyPlanDeletionTriggerPatch struct {
	// The maximum number of days to keep each backup after creation.
	DeleteAfter *int64 `json:"delete_after,omitempty"`

	// The maximum number of recent backups to keep. Specify `null` to remove any existing maximum.
	DeleteOverCount *int64 `json:"delete_over_count,omitempty"`
}

// UnmarshalBackupPolicyPlanDeletionTriggerPatch unmarshals an instance of BackupPolicyPlanDeletionTriggerPatch from the specified map of raw messages.
func UnmarshalBackupPolicyPlanDeletionTriggerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanDeletionTriggerPatch)
	err = core.UnmarshalPrimitive(m, "delete_after", &obj.DeleteAfter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delete_over_count", &obj.DeleteOverCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanDeletionTriggerPrototype : BackupPolicyPlanDeletionTriggerPrototype struct
type BackupPolicyPlanDeletionTriggerPrototype struct {
	// The maximum number of days to keep each backup after creation.
	DeleteAfter *int64 `json:"delete_after,omitempty"`

	// The maximum number of recent backups to keep. If unspecified, there will be no maximum.
	DeleteOverCount *int64 `json:"delete_over_count,omitempty"`
}

// UnmarshalBackupPolicyPlanDeletionTriggerPrototype unmarshals an instance of BackupPolicyPlanDeletionTriggerPrototype from the specified map of raw messages.
func UnmarshalBackupPolicyPlanDeletionTriggerPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanDeletionTriggerPrototype)
	err = core.UnmarshalPrimitive(m, "delete_after", &obj.DeleteAfter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delete_over_count", &obj.DeleteOverCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanPatch : BackupPolicyPlanPatch struct
type BackupPolicyPlanPatch struct {
	// Indicates whether the plan is active.
	Active *bool `json:"active,omitempty"`

	// The user tags to attach to backups (snapshots) created by this plan. Updating this value does not change the user
	// tags for backups that have already been created by this plan.
	AttachUserTags []string `json:"attach_user_tags,omitempty"`

	ClonePolicy *BackupPolicyPlanClonePolicyPatch `json:"clone_policy,omitempty"`

	// Indicates whether to copy the source's user tags to the created backups (snapshots).
	CopyUserTags *bool `json:"copy_user_tags,omitempty"`

	// The cron specification for the backup schedule. The backup policy jobs
	// (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
	// after this time.
	//
	// All backup schedules for plans in the same policy must be at least an hour apart.
	CronSpec *string `json:"cron_spec,omitempty"`

	DeletionTrigger *BackupPolicyPlanDeletionTriggerPatch `json:"deletion_trigger,omitempty"`

	// The name for this backup policy plan. The name must not be used by another plan for the backup policy.
	Name *string `json:"name,omitempty"`

	// The policies for additional backups in remote regions (replacing any existing policies).
	RemoteRegionPolicies []BackupPolicyPlanRemoteRegionPolicyPrototype `json:"remote_region_policies,omitempty"`
}

// UnmarshalBackupPolicyPlanPatch unmarshals an instance of BackupPolicyPlanPatch from the specified map of raw messages.
func UnmarshalBackupPolicyPlanPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanPatch)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attach_user_tags", &obj.AttachUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clone_policy", &obj.ClonePolicy, UnmarshalBackupPolicyPlanClonePolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "copy_user_tags", &obj.CopyUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deletion_trigger", &obj.DeletionTrigger, UnmarshalBackupPolicyPlanDeletionTriggerPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote_region_policies", &obj.RemoteRegionPolicies, UnmarshalBackupPolicyPlanRemoteRegionPolicyPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the BackupPolicyPlanPatch
func (backupPolicyPlanPatch *BackupPolicyPlanPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(backupPolicyPlanPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// BackupPolicyPlanPrototype : BackupPolicyPlanPrototype struct
type BackupPolicyPlanPrototype struct {
	// Indicates whether the plan is active.
	Active *bool `json:"active,omitempty"`

	// User tags to attach to each backup (snapshot) created by this plan. If unspecified, no user tags will be attached.
	AttachUserTags []string `json:"attach_user_tags,omitempty"`

	ClonePolicy *BackupPolicyPlanClonePolicyPrototype `json:"clone_policy,omitempty"`

	// Indicates whether to copy the source's user tags to the created backups (snapshots).
	CopyUserTags *bool `json:"copy_user_tags,omitempty"`

	// The cron specification for the backup schedule. The backup policy jobs
	// (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
	// after this time.
	//
	// All backup schedules for plans in the same policy must be at least an hour apart.
	CronSpec *string `json:"cron_spec" validate:"required"`

	DeletionTrigger *BackupPolicyPlanDeletionTriggerPrototype `json:"deletion_trigger,omitempty"`

	// The name for this backup policy plan. The name must not be used by another plan for the backup policy. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The policies for additional backups in remote regions.
	RemoteRegionPolicies []BackupPolicyPlanRemoteRegionPolicyPrototype `json:"remote_region_policies,omitempty"`
}

// NewBackupPolicyPlanPrototype : Instantiate BackupPolicyPlanPrototype (Generic Model Constructor)
func (*VpcV1) NewBackupPolicyPlanPrototype(cronSpec string) (_model *BackupPolicyPlanPrototype, err error) {
	_model = &BackupPolicyPlanPrototype{
		CronSpec: core.StringPtr(cronSpec),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalBackupPolicyPlanPrototype unmarshals an instance of BackupPolicyPlanPrototype from the specified map of raw messages.
func UnmarshalBackupPolicyPlanPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanPrototype)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attach_user_tags", &obj.AttachUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clone_policy", &obj.ClonePolicy, UnmarshalBackupPolicyPlanClonePolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "copy_user_tags", &obj.CopyUserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deletion_trigger", &obj.DeletionTrigger, UnmarshalBackupPolicyPlanDeletionTriggerPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote_region_policies", &obj.RemoteRegionPolicies, UnmarshalBackupPolicyPlanRemoteRegionPolicyPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanReference : BackupPolicyPlanReference struct
type BackupPolicyPlanReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *BackupPolicyPlanReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this backup policy plan.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this backup policy plan.
	ID *string `json:"id" validate:"required"`

	// The name for this backup policy plan. The name is unique across all plans in the backup policy.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *BackupPolicyPlanRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BackupPolicyPlanReference.ResourceType property.
// The resource type.
const (
	BackupPolicyPlanReferenceResourceTypeBackupPolicyPlanConst = "backup_policy_plan"
)

// UnmarshalBackupPolicyPlanReference unmarshals an instance of BackupPolicyPlanReference from the specified map of raw messages.
func UnmarshalBackupPolicyPlanReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalBackupPolicyPlanReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalBackupPolicyPlanRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type BackupPolicyPlanReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalBackupPolicyPlanReferenceDeleted unmarshals an instance of BackupPolicyPlanReferenceDeleted from the specified map of raw messages.
func UnmarshalBackupPolicyPlanReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanRemote : If present, this property indicates that the resource associated with this reference is remote and therefore may not
// be directly retrievable.
type BackupPolicyPlanRemote struct {
	// If present, this property indicates that the referenced resource is remote to this
	// region, and identifies the native region.
	Region *RegionReference `json:"region,omitempty"`
}

// UnmarshalBackupPolicyPlanRemote unmarshals an instance of BackupPolicyPlanRemote from the specified map of raw messages.
func UnmarshalBackupPolicyPlanRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanRemote)
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanRemoteRegionPolicy : BackupPolicyPlanRemoteRegionPolicy struct
type BackupPolicyPlanRemoteRegionPolicy struct {
	// The region this backup policy plan will create backups in.
	DeleteOverCount *int64 `json:"delete_over_count" validate:"required"`

	// The root key used to rewrap the data encryption key for the backup (snapshot).
	EncryptionKey *EncryptionKeyReference `json:"encryption_key" validate:"required"`

	// The region this backup policy plan will create backups in.
	Region *RegionReference `json:"region" validate:"required"`
}

// UnmarshalBackupPolicyPlanRemoteRegionPolicy unmarshals an instance of BackupPolicyPlanRemoteRegionPolicy from the specified map of raw messages.
func UnmarshalBackupPolicyPlanRemoteRegionPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanRemoteRegionPolicy)
	err = core.UnmarshalPrimitive(m, "delete_over_count", &obj.DeleteOverCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyPlanRemoteRegionPolicyPrototype : BackupPolicyPlanRemoteRegionPolicyPrototype struct
type BackupPolicyPlanRemoteRegionPolicyPrototype struct {
	// The region this backup policy plan will create backups in.
	DeleteOverCount *int64 `json:"delete_over_count,omitempty"`

	// The root key to use to rewrap the data encryption key for the backup (snapshot).
	//
	// If unspecified, the source's `encryption_key` will be used.
	// The specified key may be in a different account, subject to IAM policies.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The region this backup policy plan will create backups in.
	Region RegionIdentityIntf `json:"region" validate:"required"`
}

// NewBackupPolicyPlanRemoteRegionPolicyPrototype : Instantiate BackupPolicyPlanRemoteRegionPolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewBackupPolicyPlanRemoteRegionPolicyPrototype(region RegionIdentityIntf) (_model *BackupPolicyPlanRemoteRegionPolicyPrototype, err error) {
	_model = &BackupPolicyPlanRemoteRegionPolicyPrototype{
		Region: region,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalBackupPolicyPlanRemoteRegionPolicyPrototype unmarshals an instance of BackupPolicyPlanRemoteRegionPolicyPrototype from the specified map of raw messages.
func UnmarshalBackupPolicyPlanRemoteRegionPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyPlanRemoteRegionPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "delete_over_count", &obj.DeleteOverCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyScope : The scope for this backup policy.
// Models which "extend" this model:
// - BackupPolicyScopeEnterpriseReference
// - BackupPolicyScopeAccountReference
type BackupPolicyScope struct {
	// The CRN for this enterprise.
	CRN *string `json:"crn,omitempty"`

	// The unique identifier for this enterprise.
	ID *string `json:"id,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the BackupPolicyScope.ResourceType property.
// The resource type.
const (
	BackupPolicyScopeResourceTypeEnterpriseConst = "enterprise"
)

func (*BackupPolicyScope) isaBackupPolicyScope() bool {
	return true
}

type BackupPolicyScopeIntf interface {
	isaBackupPolicyScope() bool
}

// UnmarshalBackupPolicyScope unmarshals an instance of BackupPolicyScope from the specified map of raw messages.
func UnmarshalBackupPolicyScope(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyScope)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyScopePrototype : The scope to use for this backup policy.
//
// If unspecified, the policy will be scoped to the account.
// Models which "extend" this model:
// - BackupPolicyScopePrototypeEnterpriseIdentity
type BackupPolicyScopePrototype struct {
	// The CRN for this enterprise.
	CRN *string `json:"crn,omitempty"`
}

func (*BackupPolicyScopePrototype) isaBackupPolicyScopePrototype() bool {
	return true
}

type BackupPolicyScopePrototypeIntf interface {
	isaBackupPolicyScopePrototype() bool
}

// UnmarshalBackupPolicyScopePrototype unmarshals an instance of BackupPolicyScopePrototype from the specified map of raw messages.
func UnmarshalBackupPolicyScopePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyScopePrototype)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServer : BareMetalServer struct
type BareMetalServer struct {
	// The total bandwidth (in megabits per second) shared across the bare metal server network interfaces.
	Bandwidth *int64 `json:"bandwidth" validate:"required"`

	// The possible resource types for this property are expected to expand in the future.
	BootTarget BareMetalServerBootTargetIntf `json:"boot_target" validate:"required"`

	// The bare metal server CPU configuration.
	Cpu *BareMetalServerCpu `json:"cpu" validate:"required"`

	// The date and time that the bare metal server was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this bare metal server.
	CRN *string `json:"crn" validate:"required"`

	// The disks for this bare metal server, including any disks that are associated with the
	// `boot_target`.
	Disks []BareMetalServerDisk `json:"disks" validate:"required"`

	// Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the server will fail to
	// boot.
	EnableSecureBoot *bool `json:"enable_secure_boot" validate:"required"`

	// The URL for this bare metal server.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current `lifecycle_state` (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []BareMetalServerLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the bare metal server.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The amount of memory, truncated to whole gibibytes.
	Memory *int64 `json:"memory" validate:"required"`

	// The name for this bare metal server. The name is unique across all bare metal servers in the region.
	Name *string `json:"name" validate:"required"`

	// The network interfaces for this bare metal server, including the primary network interface.
	NetworkInterfaces []NetworkInterfaceBareMetalServerContextReference `json:"network_interfaces" validate:"required"`

	// The primary network interface for this bare metal server.
	PrimaryNetworkInterface *NetworkInterfaceBareMetalServerContextReference `json:"primary_network_interface" validate:"required"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
	// for this bare metal server.
	Profile *BareMetalServerProfileReference `json:"profile" validate:"required"`

	// The resource group for this bare metal server.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the bare metal server.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []BareMetalServerStatusReason `json:"status_reasons" validate:"required"`

	TrustedPlatformModule *BareMetalServerTrustedPlatformModule `json:"trusted_platform_module" validate:"required"`

	// The VPC this bare metal server resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone this bare metal server resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the BareMetalServer.LifecycleState property.
// The lifecycle state of the bare metal server.
const (
	BareMetalServerLifecycleStateDeletingConst  = "deleting"
	BareMetalServerLifecycleStateFailedConst    = "failed"
	BareMetalServerLifecycleStatePendingConst   = "pending"
	BareMetalServerLifecycleStateStableConst    = "stable"
	BareMetalServerLifecycleStateSuspendedConst = "suspended"
	BareMetalServerLifecycleStateUpdatingConst  = "updating"
	BareMetalServerLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the BareMetalServer.ResourceType property.
// The resource type.
const (
	BareMetalServerResourceTypeBareMetalServerConst = "bare_metal_server"
)

// Constants associated with the BareMetalServer.Status property.
// The status of the bare metal server.
const (
	BareMetalServerStatusDeletingConst    = "deleting"
	BareMetalServerStatusFailedConst      = "failed"
	BareMetalServerStatusMaintenanceConst = "maintenance"
	BareMetalServerStatusPendingConst     = "pending"
	BareMetalServerStatusRestartingConst  = "restarting"
	BareMetalServerStatusRunningConst     = "running"
	BareMetalServerStatusStartingConst    = "starting"
	BareMetalServerStatusStoppedConst     = "stopped"
	BareMetalServerStatusStoppingConst    = "stopping"
)

// UnmarshalBareMetalServer unmarshals an instance of BareMetalServer from the specified map of raw messages.
func UnmarshalBareMetalServer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServer)
	err = core.UnmarshalPrimitive(m, "bandwidth", &obj.Bandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_target", &obj.BootTarget, UnmarshalBareMetalServerBootTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cpu", &obj.Cpu, UnmarshalBareMetalServerCpu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalBareMetalServerDisk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_secure_boot", &obj.EnableSecureBoot)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalBareMetalServerLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfaceBareMetalServerContextReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfaceBareMetalServerContextReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalBareMetalServerProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalBareMetalServerStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "trusted_platform_module", &obj.TrustedPlatformModule, UnmarshalBareMetalServerTrustedPlatformModule)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerBootTarget : The possible resource types for this property are expected to expand in the future.
// Models which "extend" this model:
// - BareMetalServerBootTargetBareMetalServerDiskReference
type BareMetalServerBootTarget struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *BareMetalServerDiskReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this bare metal server disk.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this bare metal server disk.
	ID *string `json:"id,omitempty"`

	// The name for this bare metal server disk. The name is unique across all disks on the bare metal server.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the BareMetalServerBootTarget.ResourceType property.
// The resource type.
const (
	BareMetalServerBootTargetResourceTypeBareMetalServerDiskConst = "bare_metal_server_disk"
)

func (*BareMetalServerBootTarget) isaBareMetalServerBootTarget() bool {
	return true
}

type BareMetalServerBootTargetIntf interface {
	isaBareMetalServerBootTarget() bool
}

// UnmarshalBareMetalServerBootTarget unmarshals an instance of BareMetalServerBootTarget from the specified map of raw messages.
func UnmarshalBareMetalServerBootTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerBootTarget)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalBareMetalServerDiskReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerCpu : The bare metal server CPU configuration.
type BareMetalServerCpu struct {
	// The CPU architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// The total number of cores.
	CoreCount *int64 `json:"core_count" validate:"required"`

	// The total number of CPU sockets.
	SocketCount *int64 `json:"socket_count" validate:"required"`

	// The total number of hardware threads per core.
	ThreadsPerCore *int64 `json:"threads_per_core" validate:"required"`
}

// UnmarshalBareMetalServerCpu unmarshals an instance of BareMetalServerCpu from the specified map of raw messages.
func UnmarshalBareMetalServerCpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerCpu)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "core_count", &obj.CoreCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "socket_count", &obj.SocketCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "threads_per_core", &obj.ThreadsPerCore)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerCollection : BareMetalServerCollection struct
type BareMetalServerCollection struct {
	// Collection of bare metal servers.
	BareMetalServers []BareMetalServer `json:"bare_metal_servers" validate:"required"`

	// A link to the first page of resources.
	First *BareMetalServerCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *BareMetalServerCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalBareMetalServerCollection unmarshals an instance of BareMetalServerCollection from the specified map of raw messages.
func UnmarshalBareMetalServerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerCollection)
	err = core.UnmarshalModel(m, "bare_metal_servers", &obj.BareMetalServers, UnmarshalBareMetalServer)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalBareMetalServerCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalBareMetalServerCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *BareMetalServerCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// BareMetalServerCollectionFirst : A link to the first page of resources.
type BareMetalServerCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBareMetalServerCollectionFirst unmarshals an instance of BareMetalServerCollectionFirst from the specified map of raw messages.
func UnmarshalBareMetalServerCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type BareMetalServerCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBareMetalServerCollectionNext unmarshals an instance of BareMetalServerCollectionNext from the specified map of raw messages.
func UnmarshalBareMetalServerCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerConsoleAccessToken : The bare metal server console access token information.
type BareMetalServerConsoleAccessToken struct {
	// A URL safe single-use token used to access the console WebSocket.
	AccessToken *string `json:"access_token" validate:"required"`

	// The bare metal server console type for which this token may be used.
	ConsoleType *string `json:"console_type" validate:"required"`

	// The date and time that the access token was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The date and time that the access token will expire.
	ExpiresAt *strfmt.DateTime `json:"expires_at" validate:"required"`

	// Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.  This has
	// no effect on VNC consoles.
	Force *bool `json:"force" validate:"required"`

	// The URL to access this bare metal server console.
	Href *string `json:"href" validate:"required"`
}

// Constants associated with the BareMetalServerConsoleAccessToken.ConsoleType property.
// The bare metal server console type for which this token may be used.
const (
	BareMetalServerConsoleAccessTokenConsoleTypeSerialConst = "serial"
	BareMetalServerConsoleAccessTokenConsoleTypeVncConst    = "vnc"
)

// UnmarshalBareMetalServerConsoleAccessToken unmarshals an instance of BareMetalServerConsoleAccessToken from the specified map of raw messages.
func UnmarshalBareMetalServerConsoleAccessToken(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerConsoleAccessToken)
	err = core.UnmarshalPrimitive(m, "access_token", &obj.AccessToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "console_type", &obj.ConsoleType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires_at", &obj.ExpiresAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "force", &obj.Force)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerDisk : BareMetalServerDisk struct
type BareMetalServerDisk struct {
	// The date and time that the disk was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this bare metal server disk.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server disk.
	ID *string `json:"id" validate:"required"`

	// The disk interface used for attaching the disk.
	//
	// - `fcp`: Attached using Fiber Channel Protocol
	// - `sata`: Attached using Serial Advanced Technology Attachment
	// - `nvme`: Attached using Non-Volatile Memory Express
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// The name for this bare metal server disk. The name is unique across all disks on the bare metal server.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The size of the disk in GB (gigabytes).
	Size *int64 `json:"size" validate:"required"`
}

// Constants associated with the BareMetalServerDisk.InterfaceType property.
// The disk interface used for attaching the disk.
//
// - `fcp`: Attached using Fiber Channel Protocol
// - `sata`: Attached using Serial Advanced Technology Attachment
// - `nvme`: Attached using Non-Volatile Memory Express
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerDiskInterfaceTypeFcpConst  = "fcp"
	BareMetalServerDiskInterfaceTypeNvmeConst = "nvme"
	BareMetalServerDiskInterfaceTypeSataConst = "sata"
)

// Constants associated with the BareMetalServerDisk.ResourceType property.
// The resource type.
const (
	BareMetalServerDiskResourceTypeBareMetalServerDiskConst = "bare_metal_server_disk"
)

// UnmarshalBareMetalServerDisk unmarshals an instance of BareMetalServerDisk from the specified map of raw messages.
func UnmarshalBareMetalServerDisk(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerDisk)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerDiskCollection : BareMetalServerDiskCollection struct
type BareMetalServerDiskCollection struct {
	// Collection of the bare metal server's disks.
	Disks []BareMetalServerDisk `json:"disks" validate:"required"`
}

// UnmarshalBareMetalServerDiskCollection unmarshals an instance of BareMetalServerDiskCollection from the specified map of raw messages.
func UnmarshalBareMetalServerDiskCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerDiskCollection)
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalBareMetalServerDisk)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerDiskPatch : BareMetalServerDiskPatch struct
type BareMetalServerDiskPatch struct {
	// The name for this bare metal server disk. The name must not be used by another disk on the bare metal server.
	Name *string `json:"name,omitempty"`
}

// UnmarshalBareMetalServerDiskPatch unmarshals an instance of BareMetalServerDiskPatch from the specified map of raw messages.
func UnmarshalBareMetalServerDiskPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerDiskPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the BareMetalServerDiskPatch
func (bareMetalServerDiskPatch *BareMetalServerDiskPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(bareMetalServerDiskPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// BareMetalServerDiskReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type BareMetalServerDiskReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalBareMetalServerDiskReferenceDeleted unmarshals an instance of BareMetalServerDiskReferenceDeleted from the specified map of raw messages.
func UnmarshalBareMetalServerDiskReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerDiskReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerInitialization : BareMetalServerInitialization struct
type BareMetalServerInitialization struct {
	// The image the bare metal server was provisioned from.
	Image *ImageReference `json:"image" validate:"required"`

	// The public SSH keys used at initialization.
	Keys []KeyReference `json:"keys" validate:"required"`

	// The user accounts that are created at initialization. There can be multiple account types distinguished by the
	// `resource_type` property.
	UserAccounts []BareMetalServerInitializationUserAccountIntf `json:"user_accounts" validate:"required"`
}

// UnmarshalBareMetalServerInitialization unmarshals an instance of BareMetalServerInitialization from the specified map of raw messages.
func UnmarshalBareMetalServerInitialization(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerInitialization)
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "user_accounts", &obj.UserAccounts, UnmarshalBareMetalServerInitializationUserAccount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerInitializationPrototype : BareMetalServerInitializationPrototype struct
type BareMetalServerInitializationPrototype struct {
	// The image to be used when provisioning the bare metal server.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// The public SSH keys to install on the bare metal server. Keys will be made available to the bare metal server as
	// cloud-init vendor data. For cloud-init enabled images, these keys will also be added as SSH authorized keys for the
	// administrative user.
	//
	// For Windows images, at least one key must be specified, and one will be selected to encrypt the administrator
	// password. Keys are optional for other images, but if no keys are specified, the instance will be inaccessible unless
	// the specified image provides another means of access.
	Keys []KeyIdentityIntf `json:"keys" validate:"required"`

	// User data to be made available when initializing the bare metal server.
	UserData *string `json:"user_data,omitempty"`
}

// NewBareMetalServerInitializationPrototype : Instantiate BareMetalServerInitializationPrototype (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerInitializationPrototype(image ImageIdentityIntf, keys []KeyIdentityIntf) (_model *BareMetalServerInitializationPrototype, err error) {
	_model = &BareMetalServerInitializationPrototype{
		Image: image,
		Keys:  keys,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalBareMetalServerInitializationPrototype unmarshals an instance of BareMetalServerInitializationPrototype from the specified map of raw messages.
func UnmarshalBareMetalServerInitializationPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerInitializationPrototype)
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerInitializationUserAccount : BareMetalServerInitializationUserAccount struct
// Models which "extend" this model:
// - BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount
type BareMetalServerInitializationUserAccount struct {
	// The password at initialization, encrypted using `encryption_key`, and returned base64-encoded.
	EncryptedPassword *[]byte `json:"encrypted_password,omitempty"`

	// The public SSH key used to encrypt the password.
	EncryptionKey *KeyReference `json:"encryption_key,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`

	// The username for the account created at initialization.
	Username *string `json:"username,omitempty"`
}

// Constants associated with the BareMetalServerInitializationUserAccount.ResourceType property.
// The resource type.
const (
	BareMetalServerInitializationUserAccountResourceTypeHostUserAccountConst = "host_user_account"
)

func (*BareMetalServerInitializationUserAccount) isaBareMetalServerInitializationUserAccount() bool {
	return true
}

type BareMetalServerInitializationUserAccountIntf interface {
	isaBareMetalServerInitializationUserAccount() bool
}

// UnmarshalBareMetalServerInitializationUserAccount unmarshals an instance of BareMetalServerInitializationUserAccount from the specified map of raw messages.
func UnmarshalBareMetalServerInitializationUserAccount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerInitializationUserAccount)
	err = core.UnmarshalPrimitive(m, "encrypted_password", &obj.EncryptedPassword)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerLifecycleReason : BareMetalServerLifecycleReason struct
type BareMetalServerLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the BareMetalServerLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	BareMetalServerLifecycleReasonCodeResourceSuspendedByProviderConst = "resource_suspended_by_provider"
)

// UnmarshalBareMetalServerLifecycleReason unmarshals an instance of BareMetalServerLifecycleReason from the specified map of raw messages.
func UnmarshalBareMetalServerLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterface : BareMetalServerNetworkInterface struct
// Models which "extend" this model:
// - BareMetalServerNetworkInterfaceByHiperSocket
// - BareMetalServerNetworkInterfaceByPci
// - BareMetalServerNetworkInterfaceByVlan
type BareMetalServerNetworkInterface struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing" validate:"required"`

	// The date and time that the bare metal server network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat" validate:"required"`

	// The floating IPs associated with this bare metal server network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips" validate:"required"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The interface type:
	// - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
	//   within a `s390x` based system
	// - `pci`: a physical PCI device which can only be created or deleted when the bare metal
	//   server is stopped
	//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
	//     to use the PCI interface
	//   - Cannot directly use an IEEE 802.1q VLAN tag.
	// - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
	//   array of `allowed_vlans`.
	//   - Must use an IEEE 802.1q tag.
	//   - Has its own security groups and does not inherit those of the PCI device through
	//     which traffic flows.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// The MAC address of this bare metal server network interface. If the MAC address has not yet been selected, the value
	// will be an empty string.
	MacAddress *string `json:"mac_address" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	// The bare metal server network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this bare metal server network interface.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the bare metal server network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The bare metal server network interface type.
	Type *string `json:"type" validate:"required"`

	// Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface.
	AllowedVlans []int64 `json:"allowed_vlans,omitempty"`

	// Indicates if the interface can float to any other server within the same
	// `resource_group`. The interface will float automatically if the network detects a GARP or RARP on another bare metal
	// server in the resource group.  Applies only to `vlan` type interfaces.
	AllowInterfaceToFloat *bool `json:"allow_interface_to_float,omitempty"`

	// Indicates the 802.1Q VLAN ID tag that must be used for all traffic on this interface.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the BareMetalServerNetworkInterface.InterfaceType property.
// The interface type:
//   - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
//     within a `s390x` based system
//   - `pci`: a physical PCI device which can only be created or deleted when the bare metal
//     server is stopped
//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
//     to use the PCI interface
//   - Cannot directly use an IEEE 802.1q VLAN tag.
//   - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
//     array of `allowed_vlans`.
//   - Must use an IEEE 802.1q tag.
//   - Has its own security groups and does not inherit those of the PCI device through
//     which traffic flows.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerNetworkInterfaceInterfaceTypeHipersocketConst = "hipersocket"
	BareMetalServerNetworkInterfaceInterfaceTypePciConst         = "pci"
	BareMetalServerNetworkInterfaceInterfaceTypeVlanConst        = "vlan"
)

// Constants associated with the BareMetalServerNetworkInterface.ResourceType property.
// The resource type.
const (
	BareMetalServerNetworkInterfaceResourceTypeNetworkInterfaceConst = "network_interface"
)

// Constants associated with the BareMetalServerNetworkInterface.Status property.
// The status of the bare metal server network interface.
const (
	BareMetalServerNetworkInterfaceStatusAvailableConst = "available"
	BareMetalServerNetworkInterfaceStatusDeletingConst  = "deleting"
	BareMetalServerNetworkInterfaceStatusFailedConst    = "failed"
	BareMetalServerNetworkInterfaceStatusPendingConst   = "pending"
)

// Constants associated with the BareMetalServerNetworkInterface.Type property.
// The bare metal server network interface type.
const (
	BareMetalServerNetworkInterfaceTypePrimaryConst   = "primary"
	BareMetalServerNetworkInterfaceTypeSecondaryConst = "secondary"
)

func (*BareMetalServerNetworkInterface) isaBareMetalServerNetworkInterface() bool {
	return true
}

type BareMetalServerNetworkInterfaceIntf interface {
	isaBareMetalServerNetworkInterface() bool
}

// UnmarshalBareMetalServerNetworkInterface unmarshals an instance of BareMetalServerNetworkInterface from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterface(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "interface_type", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'interface_type': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'interface_type' not found in JSON object")
		return
	}
	if discValue == "hipersocket" {
		err = core.UnmarshalModel(m, "", result, UnmarshalBareMetalServerNetworkInterfaceByHiperSocket)
	} else if discValue == "pci" {
		err = core.UnmarshalModel(m, "", result, UnmarshalBareMetalServerNetworkInterfaceByPci)
	} else if discValue == "vlan" {
		err = core.UnmarshalModel(m, "", result, UnmarshalBareMetalServerNetworkInterfaceByVlan)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'interface_type': %s", discValue)
	}
	return
}

// BareMetalServerNetworkInterfaceCollection : BareMetalServerNetworkInterfaceCollection struct
type BareMetalServerNetworkInterfaceCollection struct {
	// A link to the first page of resources.
	First *BareMetalServerNetworkInterfaceCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of bare metal server network interfaces.
	NetworkInterfaces []BareMetalServerNetworkInterfaceIntf `json:"network_interfaces" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *BareMetalServerNetworkInterfaceCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalBareMetalServerNetworkInterfaceCollection unmarshals an instance of BareMetalServerNetworkInterfaceCollection from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalBareMetalServerNetworkInterfaceCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalBareMetalServerNetworkInterface)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalBareMetalServerNetworkInterfaceCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *BareMetalServerNetworkInterfaceCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// BareMetalServerNetworkInterfaceCollectionFirst : A link to the first page of resources.
type BareMetalServerNetworkInterfaceCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBareMetalServerNetworkInterfaceCollectionFirst unmarshals an instance of BareMetalServerNetworkInterfaceCollectionFirst from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfaceCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type BareMetalServerNetworkInterfaceCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBareMetalServerNetworkInterfaceCollectionNext unmarshals an instance of BareMetalServerNetworkInterfaceCollectionNext from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfacePatch : BareMetalServerNetworkInterfacePatch struct
type BareMetalServerNetworkInterfacePatch struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface.
	AllowedVlans []int64 `json:"allowed_vlans,omitempty"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat,omitempty"`

	// The name for this bare metal server network interface. The name must not be used by another network interface on the
	// bare metal server.
	Name *string `json:"name,omitempty"`
}

// UnmarshalBareMetalServerNetworkInterfacePatch unmarshals an instance of BareMetalServerNetworkInterfacePatch from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfacePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfacePatch)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allowed_vlans", &obj.AllowedVlans)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the BareMetalServerNetworkInterfacePatch
func (bareMetalServerNetworkInterfacePatch *BareMetalServerNetworkInterfacePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(bareMetalServerNetworkInterfacePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// BareMetalServerNetworkInterfacePrototype : BareMetalServerNetworkInterfacePrototype struct
// Models which "extend" this model:
// - BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype
// - BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype
// - BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype
type BareMetalServerNetworkInterfacePrototype struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat,omitempty"`

	// The interface type:
	// - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
	//   within a `s390x` based system
	//   - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
	// - `pci`: a physical PCI device which can only be created or deleted when the bare metal
	//   server is stopped
	//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
	//     to use the PCI interface
	//   - Cannot directly use an IEEE 802.1q VLAN tag.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`
	// - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
	//   array of `allowed_vlans`.
	//   - Must use an IEEE 802.1q tag.
	//   - Has its own security groups and does not inherit those of the PCI device through
	//     which traffic flows.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// The name for this bare metal server network interface. The name must not be used by another network interface on the
	// bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the bare metal server network interface. This can be
	// specified using an existing reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must
	// be available on the bare metal server network interface's subnet. Otherwise, an
	// available address on the subnet will be automatically selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this bare metal server network interface. If unspecified, the VPC's default security
	// group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface.
	AllowedVlans []int64 `json:"allowed_vlans,omitempty"`

	// Indicates if the interface can float to any other server within the same
	// `resource_group`. The interface will float automatically if the network detects a GARP or RARP on another bare metal
	// server in the resource group.  Applies only to `vlan` type interfaces.
	AllowInterfaceToFloat *bool `json:"allow_interface_to_float,omitempty"`

	// Indicates the 802.1Q VLAN ID tag that must be used for all traffic on this interface.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the BareMetalServerNetworkInterfacePrototype.InterfaceType property.
// The interface type:
//   - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
//     within a `s390x` based system
//   - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
//   - `pci`: a physical PCI device which can only be created or deleted when the bare metal
//     server is stopped
//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
//     to use the PCI interface
//   - Cannot directly use an IEEE 802.1q VLAN tag.
//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`
//   - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its
//     array of `allowed_vlans`.
//   - Must use an IEEE 802.1q tag.
//   - Has its own security groups and does not inherit those of the PCI device through
//     which traffic flows.
//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
const (
	BareMetalServerNetworkInterfacePrototypeInterfaceTypeHipersocketConst = "hipersocket"
	BareMetalServerNetworkInterfacePrototypeInterfaceTypePciConst         = "pci"
	BareMetalServerNetworkInterfacePrototypeInterfaceTypeVlanConst        = "vlan"
)

func (*BareMetalServerNetworkInterfacePrototype) isaBareMetalServerNetworkInterfacePrototype() bool {
	return true
}

type BareMetalServerNetworkInterfacePrototypeIntf interface {
	isaBareMetalServerNetworkInterfacePrototype() bool
}

// UnmarshalBareMetalServerNetworkInterfacePrototype unmarshals an instance of BareMetalServerNetworkInterfacePrototype from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfacePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "interface_type", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'interface_type': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'interface_type' not found in JSON object")
		return
	}
	if discValue == "hipersocket" {
		err = core.UnmarshalModel(m, "", result, UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype)
	} else if discValue == "pci" {
		err = core.UnmarshalModel(m, "", result, UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype)
	} else if discValue == "vlan" {
		err = core.UnmarshalModel(m, "", result, UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'interface_type': %s", discValue)
	}
	return
}

// BareMetalServerNetworkInterfaceReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type BareMetalServerNetworkInterfaceReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalBareMetalServerNetworkInterfaceReferenceDeleted unmarshals an instance of BareMetalServerNetworkInterfaceReferenceDeleted from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfaceReferenceTargetContextDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type BareMetalServerNetworkInterfaceReferenceTargetContextDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalBareMetalServerNetworkInterfaceReferenceTargetContextDeleted unmarshals an instance of BareMetalServerNetworkInterfaceReferenceTargetContextDeleted from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceReferenceTargetContextDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceReferenceTargetContextDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerPatch : BareMetalServerPatch struct
type BareMetalServerPatch struct {
	// Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the bare metal server
	// will fail to boot.
	//
	// For `enable_secure_boot` to be changed, the bare metal server `status` must be
	// `stopped`.
	EnableSecureBoot *bool `json:"enable_secure_boot,omitempty"`

	// The name for this bare metal server. The name must not be used by another bare metal server in the region. Changing
	// the name will not affect the system hostname.
	Name *string `json:"name,omitempty"`

	TrustedPlatformModule *BareMetalServerTrustedPlatformModulePatch `json:"trusted_platform_module,omitempty"`
}

// UnmarshalBareMetalServerPatch unmarshals an instance of BareMetalServerPatch from the specified map of raw messages.
func UnmarshalBareMetalServerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerPatch)
	err = core.UnmarshalPrimitive(m, "enable_secure_boot", &obj.EnableSecureBoot)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "trusted_platform_module", &obj.TrustedPlatformModule, UnmarshalBareMetalServerTrustedPlatformModulePatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the BareMetalServerPatch
func (bareMetalServerPatch *BareMetalServerPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(bareMetalServerPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// BareMetalServerPrimaryNetworkInterfacePrototype : BareMetalServerPrimaryNetworkInterfacePrototype struct
type BareMetalServerPrimaryNetworkInterfacePrototype struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface.
	AllowedVlans []int64 `json:"allowed_vlans,omitempty"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat,omitempty"`

	// The interface type:
	// - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
	//   within a `s390x` based system.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
	// - `pci`: a physical PCI device which can only be created or deleted when the bare metal
	//   server is stopped
	//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
	//     to use the PCI interface
	//   - Cannot directly use an IEEE 802.1q VLAN tag.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
	InterfaceType *string `json:"interface_type,omitempty"`

	// The name for this bare metal server network interface. The name must not be used by another network interface on the
	// bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the bare metal server network interface. This can be
	// specified using an existing reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must
	// be available on the bare metal server network interface's subnet. Otherwise, an
	// available address on the subnet will be automatically selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this bare metal server network interface. If unspecified, the VPC's default security
	// group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`
}

// Constants associated with the BareMetalServerPrimaryNetworkInterfacePrototype.InterfaceType property.
// The interface type:
//   - `hipersocket`: a virtual device that provides high-speed TCP/IP connectivity
//     within a `s390x` based system.
//   - Not supported on bare metal servers with a `cpu.architecture` of `amd64`
//   - `pci`: a physical PCI device which can only be created or deleted when the bare metal
//     server is stopped
//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
//     to use the PCI interface
//   - Cannot directly use an IEEE 802.1q VLAN tag.
//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
const (
	BareMetalServerPrimaryNetworkInterfacePrototypeInterfaceTypeHipersocketConst = "hipersocket"
	BareMetalServerPrimaryNetworkInterfacePrototypeInterfaceTypePciConst         = "pci"
)

// NewBareMetalServerPrimaryNetworkInterfacePrototype : Instantiate BareMetalServerPrimaryNetworkInterfacePrototype (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerPrimaryNetworkInterfacePrototype(subnet SubnetIdentityIntf) (_model *BareMetalServerPrimaryNetworkInterfacePrototype, err error) {
	_model = &BareMetalServerPrimaryNetworkInterfacePrototype{
		Subnet: subnet,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalBareMetalServerPrimaryNetworkInterfacePrototype unmarshals an instance of BareMetalServerPrimaryNetworkInterfacePrototype from the specified map of raw messages.
func UnmarshalBareMetalServerPrimaryNetworkInterfacePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerPrimaryNetworkInterfacePrototype)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allowed_vlans", &obj.AllowedVlans)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalNetworkInterfaceIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfile : BareMetalServerProfile struct
type BareMetalServerProfile struct {
	Bandwidth BareMetalServerProfileBandwidthIntf `json:"bandwidth" validate:"required"`

	// The console type configuration for a bare metal server with this profile.
	ConsoleTypes *BareMetalServerProfileConsoleTypes `json:"console_types" validate:"required"`

	CpuArchitecture *BareMetalServerProfileCpuArchitecture `json:"cpu_architecture" validate:"required"`

	CpuCoreCount BareMetalServerProfileCpuCoreCountIntf `json:"cpu_core_count" validate:"required"`

	CpuSocketCount BareMetalServerProfileCpuSocketCountIntf `json:"cpu_socket_count" validate:"required"`

	// Collection of the bare metal server profile's disks.
	Disks []BareMetalServerProfileDisk `json:"disks" validate:"required"`

	// The product family this bare metal server profile belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this bare metal server profile.
	Href *string `json:"href" validate:"required"`

	Memory BareMetalServerProfileMemoryIntf `json:"memory" validate:"required"`

	// The name for this bare metal server profile.
	Name *string `json:"name" validate:"required"`

	NetworkInterfaceCount BareMetalServerProfileNetworkInterfaceCountIntf `json:"network_interface_count" validate:"required"`

	OsArchitecture *BareMetalServerProfileOsArchitecture `json:"os_architecture" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The supported trusted platform module modes for this bare metal server profile.
	SupportedTrustedPlatformModuleModes *BareMetalServerProfileSupportedTrustedPlatformModuleModes `json:"supported_trusted_platform_module_modes" validate:"required"`
}

// Constants associated with the BareMetalServerProfile.ResourceType property.
// The resource type.
const (
	BareMetalServerProfileResourceTypeBareMetalServerProfileConst = "bare_metal_server_profile"
)

// UnmarshalBareMetalServerProfile unmarshals an instance of BareMetalServerProfile from the specified map of raw messages.
func UnmarshalBareMetalServerProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfile)
	err = core.UnmarshalModel(m, "bandwidth", &obj.Bandwidth, UnmarshalBareMetalServerProfileBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "console_types", &obj.ConsoleTypes, UnmarshalBareMetalServerProfileConsoleTypes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cpu_architecture", &obj.CpuArchitecture, UnmarshalBareMetalServerProfileCpuArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cpu_core_count", &obj.CpuCoreCount, UnmarshalBareMetalServerProfileCpuCoreCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cpu_socket_count", &obj.CpuSocketCount, UnmarshalBareMetalServerProfileCpuSocketCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalBareMetalServerProfileDisk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalBareMetalServerProfileMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interface_count", &obj.NetworkInterfaceCount, UnmarshalBareMetalServerProfileNetworkInterfaceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "os_architecture", &obj.OsArchitecture, UnmarshalBareMetalServerProfileOsArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_trusted_platform_module_modes", &obj.SupportedTrustedPlatformModuleModes, UnmarshalBareMetalServerProfileSupportedTrustedPlatformModuleModes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileBandwidth : BareMetalServerProfileBandwidth struct
// Models which "extend" this model:
// - BareMetalServerProfileBandwidthFixed
// - BareMetalServerProfileBandwidthRange
// - BareMetalServerProfileBandwidthEnum
// - BareMetalServerProfileBandwidthDependent
type BareMetalServerProfileBandwidth struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the BareMetalServerProfileBandwidth.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileBandwidthTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileBandwidth) isaBareMetalServerProfileBandwidth() bool {
	return true
}

type BareMetalServerProfileBandwidthIntf interface {
	isaBareMetalServerProfileBandwidth() bool
}

// UnmarshalBareMetalServerProfileBandwidth unmarshals an instance of BareMetalServerProfileBandwidth from the specified map of raw messages.
func UnmarshalBareMetalServerProfileBandwidth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileBandwidth)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuArchitecture : BareMetalServerProfileCpuArchitecture struct
type BareMetalServerProfileCpuArchitecture struct {
	// The default CPU architecture for a bare metal server with this profile.
	Default *string `json:"default,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The CPU architecture for a bare metal server with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuArchitecture.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuArchitectureTypeFixedConst = "fixed"
)

// UnmarshalBareMetalServerProfileCpuArchitecture unmarshals an instance of BareMetalServerProfileCpuArchitecture from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuArchitecture)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuCoreCount : BareMetalServerProfileCpuCoreCount struct
// Models which "extend" this model:
// - BareMetalServerProfileCpuCoreCountFixed
// - BareMetalServerProfileCpuCoreCountRange
// - BareMetalServerProfileCpuCoreCountEnum
// - BareMetalServerProfileCpuCoreCountDependent
type BareMetalServerProfileCpuCoreCount struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the BareMetalServerProfileCpuCoreCount.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuCoreCountTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileCpuCoreCount) isaBareMetalServerProfileCpuCoreCount() bool {
	return true
}

type BareMetalServerProfileCpuCoreCountIntf interface {
	isaBareMetalServerProfileCpuCoreCount() bool
}

// UnmarshalBareMetalServerProfileCpuCoreCount unmarshals an instance of BareMetalServerProfileCpuCoreCount from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuCoreCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuCoreCount)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuSocketCount : BareMetalServerProfileCpuSocketCount struct
// Models which "extend" this model:
// - BareMetalServerProfileCpuSocketCountFixed
// - BareMetalServerProfileCpuSocketCountRange
// - BareMetalServerProfileCpuSocketCountEnum
// - BareMetalServerProfileCpuSocketCountDependent
type BareMetalServerProfileCpuSocketCount struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the BareMetalServerProfileCpuSocketCount.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuSocketCountTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileCpuSocketCount) isaBareMetalServerProfileCpuSocketCount() bool {
	return true
}

type BareMetalServerProfileCpuSocketCountIntf interface {
	isaBareMetalServerProfileCpuSocketCount() bool
}

// UnmarshalBareMetalServerProfileCpuSocketCount unmarshals an instance of BareMetalServerProfileCpuSocketCount from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuSocketCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuSocketCount)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCollection : BareMetalServerProfileCollection struct
type BareMetalServerProfileCollection struct {
	// A link to the first page of resources.
	First *BareMetalServerProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *BareMetalServerProfileCollectionNext `json:"next,omitempty"`

	// Collection of bare metal server profiles.
	Profiles []BareMetalServerProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalBareMetalServerProfileCollection unmarshals an instance of BareMetalServerProfileCollection from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalBareMetalServerProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalBareMetalServerProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalBareMetalServerProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *BareMetalServerProfileCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// BareMetalServerProfileCollectionFirst : A link to the first page of resources.
type BareMetalServerProfileCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBareMetalServerProfileCollectionFirst unmarshals an instance of BareMetalServerProfileCollectionFirst from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type BareMetalServerProfileCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalBareMetalServerProfileCollectionNext unmarshals an instance of BareMetalServerProfileCollectionNext from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileConsoleTypes : The console type configuration for a bare metal server with this profile.
type BareMetalServerProfileConsoleTypes struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The console types for a bare metal server with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileConsoleTypes.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileConsoleTypesTypeEnumConst = "enum"
)

// Constants associated with the BareMetalServerProfileConsoleTypes.Values property.
// A console type.
const (
	BareMetalServerProfileConsoleTypesValuesSerialConst = "serial"
	BareMetalServerProfileConsoleTypesValuesVncConst    = "vnc"
)

// UnmarshalBareMetalServerProfileConsoleTypes unmarshals an instance of BareMetalServerProfileConsoleTypes from the specified map of raw messages.
func UnmarshalBareMetalServerProfileConsoleTypes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileConsoleTypes)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDisk : Disks provided by this profile.
type BareMetalServerProfileDisk struct {
	Quantity BareMetalServerProfileDiskQuantityIntf `json:"quantity" validate:"required"`

	Size BareMetalServerProfileDiskSizeIntf `json:"size" validate:"required"`

	SupportedInterfaceTypes *BareMetalServerProfileDiskSupportedInterfaces `json:"supported_interface_types" validate:"required"`
}

// UnmarshalBareMetalServerProfileDisk unmarshals an instance of BareMetalServerProfileDisk from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDisk(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDisk)
	err = core.UnmarshalModel(m, "quantity", &obj.Quantity, UnmarshalBareMetalServerProfileDiskQuantity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "size", &obj.Size, UnmarshalBareMetalServerProfileDiskSize)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_interface_types", &obj.SupportedInterfaceTypes, UnmarshalBareMetalServerProfileDiskSupportedInterfaces)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskQuantity : BareMetalServerProfileDiskQuantity struct
// Models which "extend" this model:
// - BareMetalServerProfileDiskQuantityFixed
// - BareMetalServerProfileDiskQuantityRange
// - BareMetalServerProfileDiskQuantityEnum
// - BareMetalServerProfileDiskQuantityDependent
type BareMetalServerProfileDiskQuantity struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the BareMetalServerProfileDiskQuantity.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskQuantityTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileDiskQuantity) isaBareMetalServerProfileDiskQuantity() bool {
	return true
}

type BareMetalServerProfileDiskQuantityIntf interface {
	isaBareMetalServerProfileDiskQuantity() bool
}

// UnmarshalBareMetalServerProfileDiskQuantity unmarshals an instance of BareMetalServerProfileDiskQuantity from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskQuantity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskQuantity)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskSize : BareMetalServerProfileDiskSize struct
// Models which "extend" this model:
// - BareMetalServerProfileDiskSizeFixed
// - BareMetalServerProfileDiskSizeRange
// - BareMetalServerProfileDiskSizeEnum
// - BareMetalServerProfileDiskSizeDependent
type BareMetalServerProfileDiskSize struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the BareMetalServerProfileDiskSize.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskSizeTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileDiskSize) isaBareMetalServerProfileDiskSize() bool {
	return true
}

type BareMetalServerProfileDiskSizeIntf interface {
	isaBareMetalServerProfileDiskSize() bool
}

// UnmarshalBareMetalServerProfileDiskSize unmarshals an instance of BareMetalServerProfileDiskSize from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskSize(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskSize)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskSupportedInterfaces : BareMetalServerProfileDiskSupportedInterfaces struct
type BareMetalServerProfileDiskSupportedInterfaces struct {
	// The disk interface used for attaching the disk.
	//
	// - `fcp`: Attached using Fiber Channel Protocol
	// - `sata`: Attached using Serial Advanced Technology Attachment
	// - `nvme`: Attached using Non-Volatile Memory Express
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	Default *string `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported disk interfaces used for attaching the disk.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskSupportedInterfaces.Default property.
// The disk interface used for attaching the disk.
//
// - `fcp`: Attached using Fiber Channel Protocol
// - `sata`: Attached using Serial Advanced Technology Attachment
// - `nvme`: Attached using Non-Volatile Memory Express
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerProfileDiskSupportedInterfacesDefaultFcpConst  = "fcp"
	BareMetalServerProfileDiskSupportedInterfacesDefaultNvmeConst = "nvme"
	BareMetalServerProfileDiskSupportedInterfacesDefaultSataConst = "sata"
)

// Constants associated with the BareMetalServerProfileDiskSupportedInterfaces.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskSupportedInterfacesTypeEnumConst = "enum"
)

// Constants associated with the BareMetalServerProfileDiskSupportedInterfaces.Values property.
// The disk interface used for attaching the disk.
//
// - `fcp`: Attached using Fiber Channel Protocol
// - `sata`: Attached using Serial Advanced Technology Attachment
// - `nvme`: Attached using Non-Volatile Memory Express
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerProfileDiskSupportedInterfacesValuesFcpConst  = "fcp"
	BareMetalServerProfileDiskSupportedInterfacesValuesNvmeConst = "nvme"
	BareMetalServerProfileDiskSupportedInterfacesValuesSataConst = "sata"
)

// UnmarshalBareMetalServerProfileDiskSupportedInterfaces unmarshals an instance of BareMetalServerProfileDiskSupportedInterfaces from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskSupportedInterfaces(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskSupportedInterfaces)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileIdentity : Identifies a bare metal server profile by a unique property.
// Models which "extend" this model:
// - BareMetalServerProfileIdentityByName
// - BareMetalServerProfileIdentityByHref
type BareMetalServerProfileIdentity struct {
	// The name for this bare metal server profile.
	Name *string `json:"name,omitempty"`

	// The URL for this bare metal server profile.
	Href *string `json:"href,omitempty"`
}

func (*BareMetalServerProfileIdentity) isaBareMetalServerProfileIdentity() bool {
	return true
}

type BareMetalServerProfileIdentityIntf interface {
	isaBareMetalServerProfileIdentity() bool
}

// UnmarshalBareMetalServerProfileIdentity unmarshals an instance of BareMetalServerProfileIdentity from the specified map of raw messages.
func UnmarshalBareMetalServerProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileMemory : BareMetalServerProfileMemory struct
// Models which "extend" this model:
// - BareMetalServerProfileMemoryFixed
// - BareMetalServerProfileMemoryRange
// - BareMetalServerProfileMemoryEnum
// - BareMetalServerProfileMemoryDependent
type BareMetalServerProfileMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the BareMetalServerProfileMemory.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileMemoryTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileMemory) isaBareMetalServerProfileMemory() bool {
	return true
}

type BareMetalServerProfileMemoryIntf interface {
	isaBareMetalServerProfileMemory() bool
}

// UnmarshalBareMetalServerProfileMemory unmarshals an instance of BareMetalServerProfileMemory from the specified map of raw messages.
func UnmarshalBareMetalServerProfileMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileNetworkInterfaceCount : BareMetalServerProfileNetworkInterfaceCount struct
// Models which "extend" this model:
// - BareMetalServerProfileNetworkInterfaceCountRange
// - BareMetalServerProfileNetworkInterfaceCountDependent
type BareMetalServerProfileNetworkInterfaceCount struct {
	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The type for this profile field.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the BareMetalServerProfileNetworkInterfaceCount.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileNetworkInterfaceCountTypeRangeConst = "range"
)

func (*BareMetalServerProfileNetworkInterfaceCount) isaBareMetalServerProfileNetworkInterfaceCount() bool {
	return true
}

type BareMetalServerProfileNetworkInterfaceCountIntf interface {
	isaBareMetalServerProfileNetworkInterfaceCount() bool
}

// UnmarshalBareMetalServerProfileNetworkInterfaceCount unmarshals an instance of BareMetalServerProfileNetworkInterfaceCount from the specified map of raw messages.
func UnmarshalBareMetalServerProfileNetworkInterfaceCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileNetworkInterfaceCount)
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileOsArchitecture : BareMetalServerProfileOsArchitecture struct
type BareMetalServerProfileOsArchitecture struct {
	// The default OS architecture for a bare metal server with this profile.
	Default *string `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported OS architecture(s) for a bare metal server with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileOsArchitecture.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileOsArchitectureTypeEnumConst = "enum"
)

// UnmarshalBareMetalServerProfileOsArchitecture unmarshals an instance of BareMetalServerProfileOsArchitecture from the specified map of raw messages.
func UnmarshalBareMetalServerProfileOsArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileOsArchitecture)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileReference : BareMetalServerProfileReference struct
type BareMetalServerProfileReference struct {
	// The URL for this bare metal server profile.
	Href *string `json:"href" validate:"required"`

	// The name for this bare metal server profile.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileReference.ResourceType property.
// The resource type.
const (
	BareMetalServerProfileReferenceResourceTypeBareMetalServerProfileConst = "bare_metal_server_profile"
)

// UnmarshalBareMetalServerProfileReference unmarshals an instance of BareMetalServerProfileReference from the specified map of raw messages.
func UnmarshalBareMetalServerProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileSupportedTrustedPlatformModuleModes : The supported trusted platform module modes for this bare metal server profile.
type BareMetalServerProfileSupportedTrustedPlatformModuleModes struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported trusted platform module modes.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileSupportedTrustedPlatformModuleModes.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileSupportedTrustedPlatformModuleModesTypeEnumConst = "enum"
)

// Constants associated with the BareMetalServerProfileSupportedTrustedPlatformModuleModes.Values property.
// The trusted platform module (TPM) mode:
// - `disabled`: No TPM functionality
// - `tpm_2`: TPM 2.0
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerProfileSupportedTrustedPlatformModuleModesValuesDisabledConst = "disabled"
	BareMetalServerProfileSupportedTrustedPlatformModuleModesValuesTpm2Const     = "tpm_2"
)

// UnmarshalBareMetalServerProfileSupportedTrustedPlatformModuleModes unmarshals an instance of BareMetalServerProfileSupportedTrustedPlatformModuleModes from the specified map of raw messages.
func UnmarshalBareMetalServerProfileSupportedTrustedPlatformModuleModes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileSupportedTrustedPlatformModuleModes)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerStatusReason : BareMetalServerStatusReason struct
type BareMetalServerStatusReason struct {
	// The status reason code:
	// - `cannot_start`: Failed to start due to an internal error
	// - `cannot_start_capacity`: Insufficient capacity within the selected zone
	// - `cannot_start_compute`: An error occurred while allocating compute resources
	// - `cannot_start_ip_address`: An error occurred while allocating an IP address
	// - `cannot_start_network`: An error occurred while allocating network resources.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the BareMetalServerStatusReason.Code property.
// The status reason code:
// - `cannot_start`: Failed to start due to an internal error
// - `cannot_start_capacity`: Insufficient capacity within the selected zone
// - `cannot_start_compute`: An error occurred while allocating compute resources
// - `cannot_start_ip_address`: An error occurred while allocating an IP address
// - `cannot_start_network`: An error occurred while allocating network resources.
const (
	BareMetalServerStatusReasonCodeCannotStartConst          = "cannot_start"
	BareMetalServerStatusReasonCodeCannotStartCapacityConst  = "cannot_start_capacity"
	BareMetalServerStatusReasonCodeCannotStartComputeConst   = "cannot_start_compute"
	BareMetalServerStatusReasonCodeCannotStartIPAddressConst = "cannot_start_ip_address"
	BareMetalServerStatusReasonCodeCannotStartNetworkConst   = "cannot_start_network"
)

// UnmarshalBareMetalServerStatusReason unmarshals an instance of BareMetalServerStatusReason from the specified map of raw messages.
func UnmarshalBareMetalServerStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerTrustedPlatformModule : BareMetalServerTrustedPlatformModule struct
type BareMetalServerTrustedPlatformModule struct {
	// Indicates whether the trusted platform module is enabled.
	Enabled *bool `json:"enabled" validate:"required"`

	// The trusted platform module (TPM) mode:
	// - `disabled`: No TPM functionality
	// - `tpm_2`: TPM 2.0
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	Mode *string `json:"mode" validate:"required"`

	// The supported trusted platform module modes.
	SupportedModes []string `json:"supported_modes" validate:"required"`
}

// Constants associated with the BareMetalServerTrustedPlatformModule.Mode property.
// The trusted platform module (TPM) mode:
// - `disabled`: No TPM functionality
// - `tpm_2`: TPM 2.0
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerTrustedPlatformModuleModeDisabledConst = "disabled"
	BareMetalServerTrustedPlatformModuleModeTpm2Const     = "tpm_2"
)

// Constants associated with the BareMetalServerTrustedPlatformModule.SupportedModes property.
// The trusted platform module (TPM) mode:
// - `disabled`: No TPM functionality
// - `tpm_2`: TPM 2.0
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	BareMetalServerTrustedPlatformModuleSupportedModesDisabledConst = "disabled"
	BareMetalServerTrustedPlatformModuleSupportedModesTpm2Const     = "tpm_2"
)

// UnmarshalBareMetalServerTrustedPlatformModule unmarshals an instance of BareMetalServerTrustedPlatformModule from the specified map of raw messages.
func UnmarshalBareMetalServerTrustedPlatformModule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerTrustedPlatformModule)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_modes", &obj.SupportedModes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerTrustedPlatformModulePatch : BareMetalServerTrustedPlatformModulePatch struct
type BareMetalServerTrustedPlatformModulePatch struct {
	// The trusted platform module mode to use. The specified value must be listed in the bare metal server's
	// `supported_modes`.
	//
	// For the trusted platform module mode to be changed, the bare metal server `status` must be `stopped`.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the BareMetalServerTrustedPlatformModulePatch.Mode property.
// The trusted platform module mode to use. The specified value must be listed in the bare metal server's
// `supported_modes`.
//
// For the trusted platform module mode to be changed, the bare metal server `status` must be `stopped`.
const (
	BareMetalServerTrustedPlatformModulePatchModeDisabledConst = "disabled"
	BareMetalServerTrustedPlatformModulePatchModeTpm2Const     = "tpm_2"
)

// UnmarshalBareMetalServerTrustedPlatformModulePatch unmarshals an instance of BareMetalServerTrustedPlatformModulePatch from the specified map of raw messages.
func UnmarshalBareMetalServerTrustedPlatformModulePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerTrustedPlatformModulePatch)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerTrustedPlatformModulePrototype : BareMetalServerTrustedPlatformModulePrototype struct
type BareMetalServerTrustedPlatformModulePrototype struct {
	// The trusted platform module mode to use. The specified value must be listed in the bare metal server profile's
	// `supported_trusted_platform_module_modes`.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the BareMetalServerTrustedPlatformModulePrototype.Mode property.
// The trusted platform module mode to use. The specified value must be listed in the bare metal server profile's
// `supported_trusted_platform_module_modes`.
const (
	BareMetalServerTrustedPlatformModulePrototypeModeDisabledConst = "disabled"
	BareMetalServerTrustedPlatformModulePrototypeModeTpm2Const     = "tpm_2"
)

// UnmarshalBareMetalServerTrustedPlatformModulePrototype unmarshals an instance of BareMetalServerTrustedPlatformModulePrototype from the specified map of raw messages.
func UnmarshalBareMetalServerTrustedPlatformModulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerTrustedPlatformModulePrototype)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogOfferingIdentity : Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a unique
// property.
// Models which "extend" this model:
// - CatalogOfferingIdentityCatalogOfferingByCRN
type CatalogOfferingIdentity struct {
	// The CRN for this
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
	CRN *string `json:"crn,omitempty"`
}

func (*CatalogOfferingIdentity) isaCatalogOfferingIdentity() bool {
	return true
}

type CatalogOfferingIdentityIntf interface {
	isaCatalogOfferingIdentity() bool
}

// UnmarshalCatalogOfferingIdentity unmarshals an instance of CatalogOfferingIdentity from the specified map of raw messages.
func UnmarshalCatalogOfferingIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogOfferingIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogOfferingVersionIdentity : Identifies a version of a
// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a unique property.
// Models which "extend" this model:
// - CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN
type CatalogOfferingVersionIdentity struct {
	// The CRN for this version of a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
	CRN *string `json:"crn,omitempty"`
}

func (*CatalogOfferingVersionIdentity) isaCatalogOfferingVersionIdentity() bool {
	return true
}

type CatalogOfferingVersionIdentityIntf interface {
	isaCatalogOfferingVersionIdentity() bool
}

// UnmarshalCatalogOfferingVersionIdentity unmarshals an instance of CatalogOfferingVersionIdentity from the specified map of raw messages.
func UnmarshalCatalogOfferingVersionIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogOfferingVersionIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogOfferingVersionReference : CatalogOfferingVersionReference struct
type CatalogOfferingVersionReference struct {
	// The CRN for this version of a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
	CRN *string `json:"crn" validate:"required"`
}

// UnmarshalCatalogOfferingVersionReference unmarshals an instance of CatalogOfferingVersionReference from the specified map of raw messages.
func UnmarshalCatalogOfferingVersionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogOfferingVersionReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CertificateInstanceIdentity : Identifies a certificate instance by a unique property.
// Models which "extend" this model:
// - CertificateInstanceIdentityByCRN
type CertificateInstanceIdentity struct {
	// The CRN for this certificate instance.
	CRN *string `json:"crn,omitempty"`
}

func (*CertificateInstanceIdentity) isaCertificateInstanceIdentity() bool {
	return true
}

type CertificateInstanceIdentityIntf interface {
	isaCertificateInstanceIdentity() bool
}

// UnmarshalCertificateInstanceIdentity unmarshals an instance of CertificateInstanceIdentity from the specified map of raw messages.
func UnmarshalCertificateInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CertificateInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CertificateInstanceReference : CertificateInstanceReference struct
type CertificateInstanceReference struct {
	// The CRN for this certificate instance.
	CRN *string `json:"crn" validate:"required"`
}

// UnmarshalCertificateInstanceReference unmarshals an instance of CertificateInstanceReference from the specified map of raw messages.
func UnmarshalCertificateInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CertificateInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CheckVPNGatewayConnectionLocalCIDROptions : The CheckVPNGatewayConnectionLocalCIDR options.
type CheckVPNGatewayConnectionLocalCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required,ne="`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCheckVPNGatewayConnectionLocalCIDROptions : Instantiate CheckVPNGatewayConnectionLocalCIDROptions
func (*VpcV1) NewCheckVPNGatewayConnectionLocalCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *CheckVPNGatewayConnectionLocalCIDROptions {
	return &CheckVPNGatewayConnectionLocalCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *CheckVPNGatewayConnectionLocalCIDROptions) SetVPNGatewayID(vpnGatewayID string) *CheckVPNGatewayConnectionLocalCIDROptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CheckVPNGatewayConnectionLocalCIDROptions) SetID(id string) *CheckVPNGatewayConnectionLocalCIDROptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (_options *CheckVPNGatewayConnectionLocalCIDROptions) SetCIDRPrefix(cidrPrefix string) *CheckVPNGatewayConnectionLocalCIDROptions {
	_options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return _options
}

// SetPrefixLength : Allow user to set PrefixLength
func (_options *CheckVPNGatewayConnectionLocalCIDROptions) SetPrefixLength(prefixLength string) *CheckVPNGatewayConnectionLocalCIDROptions {
	_options.PrefixLength = core.StringPtr(prefixLength)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CheckVPNGatewayConnectionLocalCIDROptions) SetHeaders(param map[string]string) *CheckVPNGatewayConnectionLocalCIDROptions {
	options.Headers = param
	return options
}

// CheckVPNGatewayConnectionPeerCIDROptions : The CheckVPNGatewayConnectionPeerCIDR options.
type CheckVPNGatewayConnectionPeerCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required,ne="`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCheckVPNGatewayConnectionPeerCIDROptions : Instantiate CheckVPNGatewayConnectionPeerCIDROptions
func (*VpcV1) NewCheckVPNGatewayConnectionPeerCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *CheckVPNGatewayConnectionPeerCIDROptions {
	return &CheckVPNGatewayConnectionPeerCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *CheckVPNGatewayConnectionPeerCIDROptions) SetVPNGatewayID(vpnGatewayID string) *CheckVPNGatewayConnectionPeerCIDROptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CheckVPNGatewayConnectionPeerCIDROptions) SetID(id string) *CheckVPNGatewayConnectionPeerCIDROptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (_options *CheckVPNGatewayConnectionPeerCIDROptions) SetCIDRPrefix(cidrPrefix string) *CheckVPNGatewayConnectionPeerCIDROptions {
	_options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return _options
}

// SetPrefixLength : Allow user to set PrefixLength
func (_options *CheckVPNGatewayConnectionPeerCIDROptions) SetPrefixLength(prefixLength string) *CheckVPNGatewayConnectionPeerCIDROptions {
	_options.PrefixLength = core.StringPtr(prefixLength)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CheckVPNGatewayConnectionPeerCIDROptions) SetHeaders(param map[string]string) *CheckVPNGatewayConnectionPeerCIDROptions {
	options.Headers = param
	return options
}

// CloudObjectStorageBucketIdentity : Identifies a Cloud Object Storage bucket by a unique property.
// Models which "extend" this model:
// - CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName
// - CloudObjectStorageBucketIdentityByCRN
type CloudObjectStorageBucketIdentity struct {
	// The globally unique name of this Cloud Object Storage bucket.
	Name *string `json:"name,omitempty"`

	// The CRN of this Cloud Object Storage bucket.
	CRN *string `json:"crn,omitempty"`
}

func (*CloudObjectStorageBucketIdentity) isaCloudObjectStorageBucketIdentity() bool {
	return true
}

type CloudObjectStorageBucketIdentityIntf interface {
	isaCloudObjectStorageBucketIdentity() bool
}

// UnmarshalCloudObjectStorageBucketIdentity unmarshals an instance of CloudObjectStorageBucketIdentity from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudObjectStorageBucketReference : CloudObjectStorageBucketReference struct
type CloudObjectStorageBucketReference struct {
	// The CRN of this Cloud Object Storage bucket.
	CRN *string `json:"crn" validate:"required"`

	// The globally unique name of this Cloud Object Storage bucket.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalCloudObjectStorageBucketReference unmarshals an instance of CloudObjectStorageBucketReference from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudObjectStorageObjectReference : CloudObjectStorageObjectReference struct
type CloudObjectStorageObjectReference struct {
	// The name of this Cloud Object Storage object. Names are unique within a Cloud Object Storage bucket.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalCloudObjectStorageObjectReference unmarshals an instance of CloudObjectStorageObjectReference from the specified map of raw messages.
func UnmarshalCloudObjectStorageObjectReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageObjectReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateBackupPolicyOptions : The CreateBackupPolicy options.
type CreateBackupPolicyOptions struct {
	// The user tags this backup policy will apply to. Resources that have both a matching user tag and a matching type
	// will be subject to the backup policy.
	MatchUserTags []string `json:"match_user_tags" validate:"required"`

	// The resource types this backup policy will apply to. Resources that have both a matching type and a matching user
	// tag will be subject to the backup policy.
	MatchResourceTypes []string `json:"match_resource_types,omitempty"`

	// The name for this backup policy. The name must not be used by another backup policy in the region. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The prototype objects for backup plans to be created for this backup policy.
	Plans []BackupPolicyPlanPrototype `json:"plans,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The scope to use for this backup policy.
	//
	// If unspecified, the policy will be scoped to the account.
	Scope BackupPolicyScopePrototypeIntf `json:"scope,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateBackupPolicyOptions.MatchResourceTypes property.
// The resource type.
const (
	CreateBackupPolicyOptionsMatchResourceTypesVolumeConst = "volume"
)

// NewCreateBackupPolicyOptions : Instantiate CreateBackupPolicyOptions
func (*VpcV1) NewCreateBackupPolicyOptions(matchUserTags []string) *CreateBackupPolicyOptions {
	return &CreateBackupPolicyOptions{
		MatchUserTags: matchUserTags,
	}
}

// SetMatchUserTags : Allow user to set MatchUserTags
func (_options *CreateBackupPolicyOptions) SetMatchUserTags(matchUserTags []string) *CreateBackupPolicyOptions {
	_options.MatchUserTags = matchUserTags
	return _options
}

// SetMatchResourceTypes : Allow user to set MatchResourceTypes
func (_options *CreateBackupPolicyOptions) SetMatchResourceTypes(matchResourceTypes []string) *CreateBackupPolicyOptions {
	_options.MatchResourceTypes = matchResourceTypes
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateBackupPolicyOptions) SetName(name string) *CreateBackupPolicyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPlans : Allow user to set Plans
func (_options *CreateBackupPolicyOptions) SetPlans(plans []BackupPolicyPlanPrototype) *CreateBackupPolicyOptions {
	_options.Plans = plans
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateBackupPolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateBackupPolicyOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetScope : Allow user to set Scope
func (_options *CreateBackupPolicyOptions) SetScope(scope BackupPolicyScopePrototypeIntf) *CreateBackupPolicyOptions {
	_options.Scope = scope
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateBackupPolicyOptions) SetHeaders(param map[string]string) *CreateBackupPolicyOptions {
	options.Headers = param
	return options
}

// CreateBackupPolicyPlanOptions : The CreateBackupPolicyPlan options.
type CreateBackupPolicyPlanOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// The cron specification for the backup schedule. The backup policy jobs
	// (which create and delete backups for this plan) will not start until this time, and may start for up to 90 minutes
	// after this time.
	//
	// All backup schedules for plans in the same policy must be at least an hour apart.
	CronSpec *string `json:"cron_spec" validate:"required"`

	// Indicates whether the plan is active.
	Active *bool `json:"active,omitempty"`

	// User tags to attach to each backup (snapshot) created by this plan. If unspecified, no user tags will be attached.
	AttachUserTags []string `json:"attach_user_tags,omitempty"`

	ClonePolicy *BackupPolicyPlanClonePolicyPrototype `json:"clone_policy,omitempty"`

	// Indicates whether to copy the source's user tags to the created backups (snapshots).
	CopyUserTags *bool `json:"copy_user_tags,omitempty"`

	DeletionTrigger *BackupPolicyPlanDeletionTriggerPrototype `json:"deletion_trigger,omitempty"`

	// The name for this backup policy plan. The name must not be used by another plan for the backup policy. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The policies for additional backups in remote regions.
	RemoteRegionPolicies []BackupPolicyPlanRemoteRegionPolicyPrototype `json:"remote_region_policies,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateBackupPolicyPlanOptions : Instantiate CreateBackupPolicyPlanOptions
func (*VpcV1) NewCreateBackupPolicyPlanOptions(backupPolicyID string, cronSpec string) *CreateBackupPolicyPlanOptions {
	return &CreateBackupPolicyPlanOptions{
		BackupPolicyID: core.StringPtr(backupPolicyID),
		CronSpec:       core.StringPtr(cronSpec),
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *CreateBackupPolicyPlanOptions) SetBackupPolicyID(backupPolicyID string) *CreateBackupPolicyPlanOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetCronSpec : Allow user to set CronSpec
func (_options *CreateBackupPolicyPlanOptions) SetCronSpec(cronSpec string) *CreateBackupPolicyPlanOptions {
	_options.CronSpec = core.StringPtr(cronSpec)
	return _options
}

// SetActive : Allow user to set Active
func (_options *CreateBackupPolicyPlanOptions) SetActive(active bool) *CreateBackupPolicyPlanOptions {
	_options.Active = core.BoolPtr(active)
	return _options
}

// SetAttachUserTags : Allow user to set AttachUserTags
func (_options *CreateBackupPolicyPlanOptions) SetAttachUserTags(attachUserTags []string) *CreateBackupPolicyPlanOptions {
	_options.AttachUserTags = attachUserTags
	return _options
}

// SetClonePolicy : Allow user to set ClonePolicy
func (_options *CreateBackupPolicyPlanOptions) SetClonePolicy(clonePolicy *BackupPolicyPlanClonePolicyPrototype) *CreateBackupPolicyPlanOptions {
	_options.ClonePolicy = clonePolicy
	return _options
}

// SetCopyUserTags : Allow user to set CopyUserTags
func (_options *CreateBackupPolicyPlanOptions) SetCopyUserTags(copyUserTags bool) *CreateBackupPolicyPlanOptions {
	_options.CopyUserTags = core.BoolPtr(copyUserTags)
	return _options
}

// SetDeletionTrigger : Allow user to set DeletionTrigger
func (_options *CreateBackupPolicyPlanOptions) SetDeletionTrigger(deletionTrigger *BackupPolicyPlanDeletionTriggerPrototype) *CreateBackupPolicyPlanOptions {
	_options.DeletionTrigger = deletionTrigger
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateBackupPolicyPlanOptions) SetName(name string) *CreateBackupPolicyPlanOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRemoteRegionPolicies : Allow user to set RemoteRegionPolicies
func (_options *CreateBackupPolicyPlanOptions) SetRemoteRegionPolicies(remoteRegionPolicies []BackupPolicyPlanRemoteRegionPolicyPrototype) *CreateBackupPolicyPlanOptions {
	_options.RemoteRegionPolicies = remoteRegionPolicies
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateBackupPolicyPlanOptions) SetHeaders(param map[string]string) *CreateBackupPolicyPlanOptions {
	options.Headers = param
	return options
}

// CreateBareMetalServerConsoleAccessTokenOptions : The CreateBareMetalServerConsoleAccessToken options.
type CreateBareMetalServerConsoleAccessTokenOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server console type for which this token may be used
	//
	// Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`.
	ConsoleType *string `json:"console_type" validate:"required"`

	// Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.  This has
	// no effect on VNC consoles.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateBareMetalServerConsoleAccessTokenOptions.ConsoleType property.
// The bare metal server console type for which this token may be used
//
// Must be `serial` for bare metal servers with a `cpu.architecture` of `s390x`.
const (
	CreateBareMetalServerConsoleAccessTokenOptionsConsoleTypeSerialConst = "serial"
	CreateBareMetalServerConsoleAccessTokenOptionsConsoleTypeVncConst    = "vnc"
)

// NewCreateBareMetalServerConsoleAccessTokenOptions : Instantiate CreateBareMetalServerConsoleAccessTokenOptions
func (*VpcV1) NewCreateBareMetalServerConsoleAccessTokenOptions(bareMetalServerID string, consoleType string) *CreateBareMetalServerConsoleAccessTokenOptions {
	return &CreateBareMetalServerConsoleAccessTokenOptions{
		BareMetalServerID: core.StringPtr(bareMetalServerID),
		ConsoleType:       core.StringPtr(consoleType),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *CreateBareMetalServerConsoleAccessTokenOptions) SetBareMetalServerID(bareMetalServerID string) *CreateBareMetalServerConsoleAccessTokenOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetConsoleType : Allow user to set ConsoleType
func (_options *CreateBareMetalServerConsoleAccessTokenOptions) SetConsoleType(consoleType string) *CreateBareMetalServerConsoleAccessTokenOptions {
	_options.ConsoleType = core.StringPtr(consoleType)
	return _options
}

// SetForce : Allow user to set Force
func (_options *CreateBareMetalServerConsoleAccessTokenOptions) SetForce(force bool) *CreateBareMetalServerConsoleAccessTokenOptions {
	_options.Force = core.BoolPtr(force)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateBareMetalServerConsoleAccessTokenOptions) SetHeaders(param map[string]string) *CreateBareMetalServerConsoleAccessTokenOptions {
	options.Headers = param
	return options
}

// CreateBareMetalServerNetworkInterfaceOptions : The CreateBareMetalServerNetworkInterface options.
type CreateBareMetalServerNetworkInterfaceOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface prototype object.
	BareMetalServerNetworkInterfacePrototype BareMetalServerNetworkInterfacePrototypeIntf `json:"BareMetalServerNetworkInterfacePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateBareMetalServerNetworkInterfaceOptions : Instantiate CreateBareMetalServerNetworkInterfaceOptions
func (*VpcV1) NewCreateBareMetalServerNetworkInterfaceOptions(bareMetalServerID string, bareMetalServerNetworkInterfacePrototype BareMetalServerNetworkInterfacePrototypeIntf) *CreateBareMetalServerNetworkInterfaceOptions {
	return &CreateBareMetalServerNetworkInterfaceOptions{
		BareMetalServerID:                        core.StringPtr(bareMetalServerID),
		BareMetalServerNetworkInterfacePrototype: bareMetalServerNetworkInterfacePrototype,
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *CreateBareMetalServerNetworkInterfaceOptions) SetBareMetalServerID(bareMetalServerID string) *CreateBareMetalServerNetworkInterfaceOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetBareMetalServerNetworkInterfacePrototype : Allow user to set BareMetalServerNetworkInterfacePrototype
func (_options *CreateBareMetalServerNetworkInterfaceOptions) SetBareMetalServerNetworkInterfacePrototype(bareMetalServerNetworkInterfacePrototype BareMetalServerNetworkInterfacePrototypeIntf) *CreateBareMetalServerNetworkInterfaceOptions {
	_options.BareMetalServerNetworkInterfacePrototype = bareMetalServerNetworkInterfacePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateBareMetalServerNetworkInterfaceOptions) SetHeaders(param map[string]string) *CreateBareMetalServerNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// CreateBareMetalServerOptions : The CreateBareMetalServer options.
type CreateBareMetalServerOptions struct {
	Initialization *BareMetalServerInitializationPrototype `json:"initialization" validate:"required"`

	// The primary bare metal server network interface to create.
	PrimaryNetworkInterface *BareMetalServerPrimaryNetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-bare-metal-servers-profile)
	// to use for this bare metal server.
	Profile BareMetalServerProfileIdentityIntf `json:"profile" validate:"required"`

	// The zone this bare metal server will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// Indicates whether secure boot is enabled. If enabled, the image must support secure boot or the server will fail to
	// boot.
	EnableSecureBoot *bool `json:"enable_secure_boot,omitempty"`

	// The name for this bare metal server. The name must not be used by another bare metal server in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The additional bare metal server network interfaces to create.
	NetworkInterfaces []BareMetalServerNetworkInterfacePrototypeIntf `json:"network_interfaces,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	TrustedPlatformModule *BareMetalServerTrustedPlatformModulePrototype `json:"trusted_platform_module,omitempty"`

	// The VPC this bare metal server will reside in.
	//
	// If specified, it must match the VPC for the subnets that the network interfaces of
	// the bare metal server are attached to.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateBareMetalServerOptions : Instantiate CreateBareMetalServerOptions
func (*VpcV1) NewCreateBareMetalServerOptions(initialization *BareMetalServerInitializationPrototype, primaryNetworkInterface *BareMetalServerPrimaryNetworkInterfacePrototype, profile BareMetalServerProfileIdentityIntf, zone ZoneIdentityIntf) *CreateBareMetalServerOptions {
	return &CreateBareMetalServerOptions{
		Initialization:          initialization,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Profile:                 profile,
		Zone:                    zone,
	}
}

// SetInitialization : Allow user to set Initialization
func (_options *CreateBareMetalServerOptions) SetInitialization(initialization *BareMetalServerInitializationPrototype) *CreateBareMetalServerOptions {
	_options.Initialization = initialization
	return _options
}

// SetPrimaryNetworkInterface : Allow user to set PrimaryNetworkInterface
func (_options *CreateBareMetalServerOptions) SetPrimaryNetworkInterface(primaryNetworkInterface *BareMetalServerPrimaryNetworkInterfacePrototype) *CreateBareMetalServerOptions {
	_options.PrimaryNetworkInterface = primaryNetworkInterface
	return _options
}

// SetProfile : Allow user to set Profile
func (_options *CreateBareMetalServerOptions) SetProfile(profile BareMetalServerProfileIdentityIntf) *CreateBareMetalServerOptions {
	_options.Profile = profile
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateBareMetalServerOptions) SetZone(zone ZoneIdentityIntf) *CreateBareMetalServerOptions {
	_options.Zone = zone
	return _options
}

// SetEnableSecureBoot : Allow user to set EnableSecureBoot
func (_options *CreateBareMetalServerOptions) SetEnableSecureBoot(enableSecureBoot bool) *CreateBareMetalServerOptions {
	_options.EnableSecureBoot = core.BoolPtr(enableSecureBoot)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateBareMetalServerOptions) SetName(name string) *CreateBareMetalServerOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworkInterfaces : Allow user to set NetworkInterfaces
func (_options *CreateBareMetalServerOptions) SetNetworkInterfaces(networkInterfaces []BareMetalServerNetworkInterfacePrototypeIntf) *CreateBareMetalServerOptions {
	_options.NetworkInterfaces = networkInterfaces
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateBareMetalServerOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateBareMetalServerOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetTrustedPlatformModule : Allow user to set TrustedPlatformModule
func (_options *CreateBareMetalServerOptions) SetTrustedPlatformModule(trustedPlatformModule *BareMetalServerTrustedPlatformModulePrototype) *CreateBareMetalServerOptions {
	_options.TrustedPlatformModule = trustedPlatformModule
	return _options
}

// SetVPC : Allow user to set VPC
func (_options *CreateBareMetalServerOptions) SetVPC(vpc VPCIdentityIntf) *CreateBareMetalServerOptions {
	_options.VPC = vpc
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateBareMetalServerOptions) SetHeaders(param map[string]string) *CreateBareMetalServerOptions {
	options.Headers = param
	return options
}

// CreateDedicatedHostGroupOptions : The CreateDedicatedHostGroup options.
type CreateDedicatedHostGroupOptions struct {
	// The dedicated host profile class for hosts in this group.
	Class *string `json:"class" validate:"required"`

	// The dedicated host profile family for hosts in this group.
	Family *string `json:"family" validate:"required"`

	// The zone this dedicated host group will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The name for this dedicated host group. The name must not be used by another dedicated host group in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDedicatedHostGroupOptions.Family property.
// The dedicated host profile family for hosts in this group.
const (
	CreateDedicatedHostGroupOptionsFamilyBalancedConst = "balanced"
	CreateDedicatedHostGroupOptionsFamilyComputeConst  = "compute"
	CreateDedicatedHostGroupOptionsFamilyMemoryConst   = "memory"
)

// NewCreateDedicatedHostGroupOptions : Instantiate CreateDedicatedHostGroupOptions
func (*VpcV1) NewCreateDedicatedHostGroupOptions(class string, family string, zone ZoneIdentityIntf) *CreateDedicatedHostGroupOptions {
	return &CreateDedicatedHostGroupOptions{
		Class:  core.StringPtr(class),
		Family: core.StringPtr(family),
		Zone:   zone,
	}
}

// SetClass : Allow user to set Class
func (_options *CreateDedicatedHostGroupOptions) SetClass(class string) *CreateDedicatedHostGroupOptions {
	_options.Class = core.StringPtr(class)
	return _options
}

// SetFamily : Allow user to set Family
func (_options *CreateDedicatedHostGroupOptions) SetFamily(family string) *CreateDedicatedHostGroupOptions {
	_options.Family = core.StringPtr(family)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateDedicatedHostGroupOptions) SetZone(zone ZoneIdentityIntf) *CreateDedicatedHostGroupOptions {
	_options.Zone = zone
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDedicatedHostGroupOptions) SetName(name string) *CreateDedicatedHostGroupOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateDedicatedHostGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateDedicatedHostGroupOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDedicatedHostGroupOptions) SetHeaders(param map[string]string) *CreateDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// CreateDedicatedHostOptions : The CreateDedicatedHost options.
type CreateDedicatedHostOptions struct {
	// The dedicated host prototype object.
	DedicatedHostPrototype DedicatedHostPrototypeIntf `json:"DedicatedHostPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateDedicatedHostOptions : Instantiate CreateDedicatedHostOptions
func (*VpcV1) NewCreateDedicatedHostOptions(dedicatedHostPrototype DedicatedHostPrototypeIntf) *CreateDedicatedHostOptions {
	return &CreateDedicatedHostOptions{
		DedicatedHostPrototype: dedicatedHostPrototype,
	}
}

// SetDedicatedHostPrototype : Allow user to set DedicatedHostPrototype
func (_options *CreateDedicatedHostOptions) SetDedicatedHostPrototype(dedicatedHostPrototype DedicatedHostPrototypeIntf) *CreateDedicatedHostOptions {
	_options.DedicatedHostPrototype = dedicatedHostPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDedicatedHostOptions) SetHeaders(param map[string]string) *CreateDedicatedHostOptions {
	options.Headers = param
	return options
}

// CreateEndpointGatewayOptions : The CreateEndpointGateway options.
type CreateEndpointGatewayOptions struct {
	// The target to use for this endpoint gateway. Must not already be the target of another
	// endpoint gateway in the VPC.
	Target EndpointGatewayTargetPrototypeIntf `json:"target" validate:"required"`

	// The VPC this endpoint gateway will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// Indicates whether to allow DNS resolution for this endpoint gateway when the VPC this endpoint gateway resides in
	// has a DNS resolution binding to a VPC with `dns.enable_hub` set to `true`.
	//
	// Must be `true` if the VPC this endpoint gateway resides in has `dns.enable_hub` set to
	// `true`.
	AllowDnsResolutionBinding *bool `json:"allow_dns_resolution_binding,omitempty"`

	// The reserved IPs to bind to this endpoint gateway. At most one reserved IP per zone is allowed.
	Ips []EndpointGatewayReservedIPIntf `json:"ips,omitempty"`

	// The name for this endpoint gateway. The name must not be used by another endpoint gateway in the VPC. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The security groups to use for this endpoint gateway. If unspecified, the VPC's default security group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateEndpointGatewayOptions : Instantiate CreateEndpointGatewayOptions
func (*VpcV1) NewCreateEndpointGatewayOptions(target EndpointGatewayTargetPrototypeIntf, vpc VPCIdentityIntf) *CreateEndpointGatewayOptions {
	return &CreateEndpointGatewayOptions{
		Target: target,
		VPC:    vpc,
	}
}

// SetTarget : Allow user to set Target
func (_options *CreateEndpointGatewayOptions) SetTarget(target EndpointGatewayTargetPrototypeIntf) *CreateEndpointGatewayOptions {
	_options.Target = target
	return _options
}

// SetVPC : Allow user to set VPC
func (_options *CreateEndpointGatewayOptions) SetVPC(vpc VPCIdentityIntf) *CreateEndpointGatewayOptions {
	_options.VPC = vpc
	return _options
}

// SetAllowDnsResolutionBinding : Allow user to set AllowDnsResolutionBinding
func (_options *CreateEndpointGatewayOptions) SetAllowDnsResolutionBinding(allowDnsResolutionBinding bool) *CreateEndpointGatewayOptions {
	_options.AllowDnsResolutionBinding = core.BoolPtr(allowDnsResolutionBinding)
	return _options
}

// SetIps : Allow user to set Ips
func (_options *CreateEndpointGatewayOptions) SetIps(ips []EndpointGatewayReservedIPIntf) *CreateEndpointGatewayOptions {
	_options.Ips = ips
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateEndpointGatewayOptions) SetName(name string) *CreateEndpointGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateEndpointGatewayOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateEndpointGatewayOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (_options *CreateEndpointGatewayOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateEndpointGatewayOptions {
	_options.SecurityGroups = securityGroups
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateEndpointGatewayOptions) SetHeaders(param map[string]string) *CreateEndpointGatewayOptions {
	options.Headers = param
	return options
}

// CreateFloatingIPOptions : The CreateFloatingIP options.
type CreateFloatingIPOptions struct {
	// The floating IP prototype object.
	FloatingIPPrototype FloatingIPPrototypeIntf `json:"FloatingIPPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateFloatingIPOptions : Instantiate CreateFloatingIPOptions
func (*VpcV1) NewCreateFloatingIPOptions(floatingIPPrototype FloatingIPPrototypeIntf) *CreateFloatingIPOptions {
	return &CreateFloatingIPOptions{
		FloatingIPPrototype: floatingIPPrototype,
	}
}

// SetFloatingIPPrototype : Allow user to set FloatingIPPrototype
func (_options *CreateFloatingIPOptions) SetFloatingIPPrototype(floatingIPPrototype FloatingIPPrototypeIntf) *CreateFloatingIPOptions {
	_options.FloatingIPPrototype = floatingIPPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateFloatingIPOptions) SetHeaders(param map[string]string) *CreateFloatingIPOptions {
	options.Headers = param
	return options
}

// CreateFlowLogCollectorOptions : The CreateFlowLogCollector options.
type CreateFlowLogCollectorOptions struct {
	// The Cloud Object Storage bucket where the collected flows will be logged.
	// The bucket must exist and an IAM service authorization must grant
	// `IBM Cloud Flow Logs` resources of `VPC Infrastructure Services` writer
	// access to the bucket.
	StorageBucket LegacyCloudObjectStorageBucketIdentityIntf `json:"storage_bucket" validate:"required"`

	// The target this collector will collect flow logs for. If the target is an instance,
	// subnet, or VPC, flow logs will not be collected for any instance network interfaces within
	// the target that are themselves the target of a more specific flow log collector.
	Target FlowLogCollectorTargetPrototypeIntf `json:"target" validate:"required"`

	// Indicates whether this collector will be active upon creation.
	Active *bool `json:"active,omitempty"`

	// The name for this flow log collector. The name must not be used by another flow log collector in the VPC. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateFlowLogCollectorOptions : Instantiate CreateFlowLogCollectorOptions
func (*VpcV1) NewCreateFlowLogCollectorOptions(storageBucket LegacyCloudObjectStorageBucketIdentityIntf, target FlowLogCollectorTargetPrototypeIntf) *CreateFlowLogCollectorOptions {
	return &CreateFlowLogCollectorOptions{
		StorageBucket: storageBucket,
		Target:        target,
	}
}

// SetStorageBucket : Allow user to set StorageBucket
func (_options *CreateFlowLogCollectorOptions) SetStorageBucket(storageBucket LegacyCloudObjectStorageBucketIdentityIntf) *CreateFlowLogCollectorOptions {
	_options.StorageBucket = storageBucket
	return _options
}

// SetTarget : Allow user to set Target
func (_options *CreateFlowLogCollectorOptions) SetTarget(target FlowLogCollectorTargetPrototypeIntf) *CreateFlowLogCollectorOptions {
	_options.Target = target
	return _options
}

// SetActive : Allow user to set Active
func (_options *CreateFlowLogCollectorOptions) SetActive(active bool) *CreateFlowLogCollectorOptions {
	_options.Active = core.BoolPtr(active)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateFlowLogCollectorOptions) SetName(name string) *CreateFlowLogCollectorOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateFlowLogCollectorOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateFlowLogCollectorOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateFlowLogCollectorOptions) SetHeaders(param map[string]string) *CreateFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// CreateIkePolicyOptions : The CreateIkePolicy options.
type CreateIkePolicyOptions struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The name for this IKE policy. The name must not be used by another IKE policies in the region. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIkePolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	CreateIkePolicyOptionsAuthenticationAlgorithmSha256Const = "sha256"
	CreateIkePolicyOptionsAuthenticationAlgorithmSha384Const = "sha384"
	CreateIkePolicyOptionsAuthenticationAlgorithmSha512Const = "sha512"
)

// Constants associated with the CreateIkePolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	CreateIkePolicyOptionsEncryptionAlgorithmAes128Const = "aes128"
	CreateIkePolicyOptionsEncryptionAlgorithmAes192Const = "aes192"
	CreateIkePolicyOptionsEncryptionAlgorithmAes256Const = "aes256"
)

// NewCreateIkePolicyOptions : Instantiate CreateIkePolicyOptions
func (*VpcV1) NewCreateIkePolicyOptions(authenticationAlgorithm string, dhGroup int64, encryptionAlgorithm string, ikeVersion int64) *CreateIkePolicyOptions {
	return &CreateIkePolicyOptions{
		AuthenticationAlgorithm: core.StringPtr(authenticationAlgorithm),
		DhGroup:                 core.Int64Ptr(dhGroup),
		EncryptionAlgorithm:     core.StringPtr(encryptionAlgorithm),
		IkeVersion:              core.Int64Ptr(ikeVersion),
	}
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (_options *CreateIkePolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *CreateIkePolicyOptions {
	_options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return _options
}

// SetDhGroup : Allow user to set DhGroup
func (_options *CreateIkePolicyOptions) SetDhGroup(dhGroup int64) *CreateIkePolicyOptions {
	_options.DhGroup = core.Int64Ptr(dhGroup)
	return _options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (_options *CreateIkePolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *CreateIkePolicyOptions {
	_options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return _options
}

// SetIkeVersion : Allow user to set IkeVersion
func (_options *CreateIkePolicyOptions) SetIkeVersion(ikeVersion int64) *CreateIkePolicyOptions {
	_options.IkeVersion = core.Int64Ptr(ikeVersion)
	return _options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (_options *CreateIkePolicyOptions) SetKeyLifetime(keyLifetime int64) *CreateIkePolicyOptions {
	_options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateIkePolicyOptions) SetName(name string) *CreateIkePolicyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateIkePolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateIkePolicyOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIkePolicyOptions) SetHeaders(param map[string]string) *CreateIkePolicyOptions {
	options.Headers = param
	return options
}

// CreateImageExportJobOptions : The CreateImageExportJob options.
type CreateImageExportJobOptions struct {
	// The image identifier.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// The Cloud Object Storage bucket to export the image to. The bucket must exist and an IAM
	// service authorization must grant `Image Service for VPC` of
	// `VPC Infrastructure Services` writer access to the bucket.
	StorageBucket CloudObjectStorageBucketIdentityIntf `json:"storage_bucket" validate:"required"`

	// The format to use for the exported image. If the image is encrypted, only `qcow2` is supported.
	Format *string `json:"format,omitempty"`

	// The name for this image export job. The name must not be used by another export job for the image. If unspecified,
	// the name will be a hyphenated list of randomly-selected words prefixed with the first 16 characters of the parent
	// image name.
	//
	// The exported image object name in Cloud Object Storage (`storage_object.name` in the response) will be based on this
	// name. The object name will be unique within the bucket.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateImageExportJobOptions.Format property.
// The format to use for the exported image. If the image is encrypted, only `qcow2` is supported.
const (
	CreateImageExportJobOptionsFormatQcow2Const = "qcow2"
	CreateImageExportJobOptionsFormatVhdConst   = "vhd"
)

// NewCreateImageExportJobOptions : Instantiate CreateImageExportJobOptions
func (*VpcV1) NewCreateImageExportJobOptions(imageID string, storageBucket CloudObjectStorageBucketIdentityIntf) *CreateImageExportJobOptions {
	return &CreateImageExportJobOptions{
		ImageID:       core.StringPtr(imageID),
		StorageBucket: storageBucket,
	}
}

// SetImageID : Allow user to set ImageID
func (_options *CreateImageExportJobOptions) SetImageID(imageID string) *CreateImageExportJobOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetStorageBucket : Allow user to set StorageBucket
func (_options *CreateImageExportJobOptions) SetStorageBucket(storageBucket CloudObjectStorageBucketIdentityIntf) *CreateImageExportJobOptions {
	_options.StorageBucket = storageBucket
	return _options
}

// SetFormat : Allow user to set Format
func (_options *CreateImageExportJobOptions) SetFormat(format string) *CreateImageExportJobOptions {
	_options.Format = core.StringPtr(format)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateImageExportJobOptions) SetName(name string) *CreateImageExportJobOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateImageExportJobOptions) SetHeaders(param map[string]string) *CreateImageExportJobOptions {
	options.Headers = param
	return options
}

// CreateImageOptions : The CreateImage options.
type CreateImageOptions struct {
	// The image prototype object.
	ImagePrototype ImagePrototypeIntf `json:"ImagePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateImageOptions : Instantiate CreateImageOptions
func (*VpcV1) NewCreateImageOptions(imagePrototype ImagePrototypeIntf) *CreateImageOptions {
	return &CreateImageOptions{
		ImagePrototype: imagePrototype,
	}
}

// SetImagePrototype : Allow user to set ImagePrototype
func (_options *CreateImageOptions) SetImagePrototype(imagePrototype ImagePrototypeIntf) *CreateImageOptions {
	_options.ImagePrototype = imagePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateImageOptions) SetHeaders(param map[string]string) *CreateImageOptions {
	options.Headers = param
	return options
}

// CreateInstanceActionOptions : The CreateInstanceAction options.
type CreateInstanceActionOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The type of action.
	Type *string `json:"type" validate:"required"`

	// If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start action.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateInstanceActionOptions.Type property.
// The type of action.
const (
	CreateInstanceActionOptionsTypeRebootConst = "reboot"
	CreateInstanceActionOptionsTypeStartConst  = "start"
	CreateInstanceActionOptionsTypeStopConst   = "stop"
)

// NewCreateInstanceActionOptions : Instantiate CreateInstanceActionOptions
func (*VpcV1) NewCreateInstanceActionOptions(instanceID string, typeVar string) *CreateInstanceActionOptions {
	return &CreateInstanceActionOptions{
		InstanceID: core.StringPtr(instanceID),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateInstanceActionOptions) SetInstanceID(instanceID string) *CreateInstanceActionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateInstanceActionOptions) SetType(typeVar string) *CreateInstanceActionOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetForce : Allow user to set Force
func (_options *CreateInstanceActionOptions) SetForce(force bool) *CreateInstanceActionOptions {
	_options.Force = core.BoolPtr(force)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceActionOptions) SetHeaders(param map[string]string) *CreateInstanceActionOptions {
	options.Headers = param
	return options
}

// CreateInstanceConsoleAccessTokenOptions : The CreateInstanceConsoleAccessToken options.
type CreateInstanceConsoleAccessTokenOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance console type for which this token may be used.
	ConsoleType *string `json:"console_type" validate:"required"`

	// Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.  This has
	// no effect on VNC consoles.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateInstanceConsoleAccessTokenOptions.ConsoleType property.
// The instance console type for which this token may be used.
const (
	CreateInstanceConsoleAccessTokenOptionsConsoleTypeSerialConst = "serial"
	CreateInstanceConsoleAccessTokenOptionsConsoleTypeVncConst    = "vnc"
)

// NewCreateInstanceConsoleAccessTokenOptions : Instantiate CreateInstanceConsoleAccessTokenOptions
func (*VpcV1) NewCreateInstanceConsoleAccessTokenOptions(instanceID string, consoleType string) *CreateInstanceConsoleAccessTokenOptions {
	return &CreateInstanceConsoleAccessTokenOptions{
		InstanceID:  core.StringPtr(instanceID),
		ConsoleType: core.StringPtr(consoleType),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateInstanceConsoleAccessTokenOptions) SetInstanceID(instanceID string) *CreateInstanceConsoleAccessTokenOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetConsoleType : Allow user to set ConsoleType
func (_options *CreateInstanceConsoleAccessTokenOptions) SetConsoleType(consoleType string) *CreateInstanceConsoleAccessTokenOptions {
	_options.ConsoleType = core.StringPtr(consoleType)
	return _options
}

// SetForce : Allow user to set Force
func (_options *CreateInstanceConsoleAccessTokenOptions) SetForce(force bool) *CreateInstanceConsoleAccessTokenOptions {
	_options.Force = core.BoolPtr(force)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceConsoleAccessTokenOptions) SetHeaders(param map[string]string) *CreateInstanceConsoleAccessTokenOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupManagerActionOptions : The CreateInstanceGroupManagerAction options.
type CreateInstanceGroupManagerActionOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager action prototype object.
	InstanceGroupManagerActionPrototype InstanceGroupManagerActionPrototypeIntf `json:"InstanceGroupManagerActionPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupManagerActionOptions : Instantiate CreateInstanceGroupManagerActionOptions
func (*VpcV1) NewCreateInstanceGroupManagerActionOptions(instanceGroupID string, instanceGroupManagerID string, instanceGroupManagerActionPrototype InstanceGroupManagerActionPrototypeIntf) *CreateInstanceGroupManagerActionOptions {
	return &CreateInstanceGroupManagerActionOptions{
		InstanceGroupID:                     core.StringPtr(instanceGroupID),
		InstanceGroupManagerID:              core.StringPtr(instanceGroupManagerID),
		InstanceGroupManagerActionPrototype: instanceGroupManagerActionPrototype,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *CreateInstanceGroupManagerActionOptions) SetInstanceGroupID(instanceGroupID string) *CreateInstanceGroupManagerActionOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *CreateInstanceGroupManagerActionOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *CreateInstanceGroupManagerActionOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetInstanceGroupManagerActionPrototype : Allow user to set InstanceGroupManagerActionPrototype
func (_options *CreateInstanceGroupManagerActionOptions) SetInstanceGroupManagerActionPrototype(instanceGroupManagerActionPrototype InstanceGroupManagerActionPrototypeIntf) *CreateInstanceGroupManagerActionOptions {
	_options.InstanceGroupManagerActionPrototype = instanceGroupManagerActionPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupManagerActionOptions) SetHeaders(param map[string]string) *CreateInstanceGroupManagerActionOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupManagerOptions : The CreateInstanceGroupManager options.
type CreateInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager prototype object.
	InstanceGroupManagerPrototype InstanceGroupManagerPrototypeIntf `json:"InstanceGroupManagerPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupManagerOptions : Instantiate CreateInstanceGroupManagerOptions
func (*VpcV1) NewCreateInstanceGroupManagerOptions(instanceGroupID string, instanceGroupManagerPrototype InstanceGroupManagerPrototypeIntf) *CreateInstanceGroupManagerOptions {
	return &CreateInstanceGroupManagerOptions{
		InstanceGroupID:               core.StringPtr(instanceGroupID),
		InstanceGroupManagerPrototype: instanceGroupManagerPrototype,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *CreateInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *CreateInstanceGroupManagerOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerPrototype : Allow user to set InstanceGroupManagerPrototype
func (_options *CreateInstanceGroupManagerOptions) SetInstanceGroupManagerPrototype(instanceGroupManagerPrototype InstanceGroupManagerPrototypeIntf) *CreateInstanceGroupManagerOptions {
	_options.InstanceGroupManagerPrototype = instanceGroupManagerPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupManagerOptions) SetHeaders(param map[string]string) *CreateInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupManagerPolicyOptions : The CreateInstanceGroupManagerPolicy options.
type CreateInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager policy prototype object.
	InstanceGroupManagerPolicyPrototype InstanceGroupManagerPolicyPrototypeIntf `json:"InstanceGroupManagerPolicyPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupManagerPolicyOptions : Instantiate CreateInstanceGroupManagerPolicyOptions
func (*VpcV1) NewCreateInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, instanceGroupManagerPolicyPrototype InstanceGroupManagerPolicyPrototypeIntf) *CreateInstanceGroupManagerPolicyOptions {
	return &CreateInstanceGroupManagerPolicyOptions{
		InstanceGroupID:                     core.StringPtr(instanceGroupID),
		InstanceGroupManagerID:              core.StringPtr(instanceGroupManagerID),
		InstanceGroupManagerPolicyPrototype: instanceGroupManagerPolicyPrototype,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *CreateInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *CreateInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *CreateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *CreateInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetInstanceGroupManagerPolicyPrototype : Allow user to set InstanceGroupManagerPolicyPrototype
func (_options *CreateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerPolicyPrototype(instanceGroupManagerPolicyPrototype InstanceGroupManagerPolicyPrototypeIntf) *CreateInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupManagerPolicyPrototype = instanceGroupManagerPolicyPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *CreateInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupOptions : The CreateInstanceGroup options.
type CreateInstanceGroupOptions struct {
	// Instance template to use when creating new instances.
	//
	// Instance groups are not compatible with instance templates that specify `true` for
	// `default_trusted_profile.auto_link`.
	InstanceTemplate InstanceTemplateIdentityIntf `json:"instance_template" validate:"required"`

	// The subnets to use when creating new instances.
	Subnets []SubnetIdentityIntf `json:"subnets" validate:"required"`

	// The port to use for new load balancer pool members created by this instance group. The load balancer pool member
	// will receive load balancer traffic on this port, unless the load balancer listener is using a port range. (Traffic
	// received on a listener using a port range will be sent to members using the same port the listener received it on.)
	//
	// This port will also be used for health checks unless the port property of
	// `health_monitor` property is specified.
	//
	// This property must be specified if and only if `load_balancer_pool` has been specified.
	ApplicationPort *int64 `json:"application_port,omitempty"`

	// The load balancer associated with the specified load balancer pool.
	// Required if `load_balancer_pool` is specified. The load balancer must have
	// `instance_groups_supported` set to `true`.
	LoadBalancer LoadBalancerIdentityIntf `json:"load_balancer,omitempty"`

	// If specified, this instance group will manage the load balancer pool. A pool member
	// will be created for each instance created by this group.  The specified load
	// balancer pool must not be used by another instance group in the VPC.
	//
	// If specified, `load_balancer` and `application_port` must also be specified.
	LoadBalancerPool LoadBalancerPoolIdentityIntf `json:"load_balancer_pool,omitempty"`

	// The number of instances in the instance group.
	MembershipCount *int64 `json:"membership_count,omitempty"`

	// The name for this instance group. The name must not be used by another instance group in the region. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupOptions : Instantiate CreateInstanceGroupOptions
func (*VpcV1) NewCreateInstanceGroupOptions(instanceTemplate InstanceTemplateIdentityIntf, subnets []SubnetIdentityIntf) *CreateInstanceGroupOptions {
	return &CreateInstanceGroupOptions{
		InstanceTemplate: instanceTemplate,
		Subnets:          subnets,
	}
}

// SetInstanceTemplate : Allow user to set InstanceTemplate
func (_options *CreateInstanceGroupOptions) SetInstanceTemplate(instanceTemplate InstanceTemplateIdentityIntf) *CreateInstanceGroupOptions {
	_options.InstanceTemplate = instanceTemplate
	return _options
}

// SetSubnets : Allow user to set Subnets
func (_options *CreateInstanceGroupOptions) SetSubnets(subnets []SubnetIdentityIntf) *CreateInstanceGroupOptions {
	_options.Subnets = subnets
	return _options
}

// SetApplicationPort : Allow user to set ApplicationPort
func (_options *CreateInstanceGroupOptions) SetApplicationPort(applicationPort int64) *CreateInstanceGroupOptions {
	_options.ApplicationPort = core.Int64Ptr(applicationPort)
	return _options
}

// SetLoadBalancer : Allow user to set LoadBalancer
func (_options *CreateInstanceGroupOptions) SetLoadBalancer(loadBalancer LoadBalancerIdentityIntf) *CreateInstanceGroupOptions {
	_options.LoadBalancer = loadBalancer
	return _options
}

// SetLoadBalancerPool : Allow user to set LoadBalancerPool
func (_options *CreateInstanceGroupOptions) SetLoadBalancerPool(loadBalancerPool LoadBalancerPoolIdentityIntf) *CreateInstanceGroupOptions {
	_options.LoadBalancerPool = loadBalancerPool
	return _options
}

// SetMembershipCount : Allow user to set MembershipCount
func (_options *CreateInstanceGroupOptions) SetMembershipCount(membershipCount int64) *CreateInstanceGroupOptions {
	_options.MembershipCount = core.Int64Ptr(membershipCount)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateInstanceGroupOptions) SetName(name string) *CreateInstanceGroupOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateInstanceGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateInstanceGroupOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupOptions) SetHeaders(param map[string]string) *CreateInstanceGroupOptions {
	options.Headers = param
	return options
}

// CreateInstanceNetworkInterfaceOptions : The CreateInstanceNetworkInterface options.
type CreateInstanceNetworkInterfaceOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Indicates whether source IP spoofing is allowed on this instance interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// The name for the instance network interface. The name must not be used by another network interface on the virtual
	// server instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the instance network interface. This can be
	// specified using an existing reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must
	// be available on the instance network interface's subnet. Otherwise, an
	// available address on the subnet will be automatically selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this instance network interface. If unspecified, the VPC's default security group is
	// used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceNetworkInterfaceOptions : Instantiate CreateInstanceNetworkInterfaceOptions
func (*VpcV1) NewCreateInstanceNetworkInterfaceOptions(instanceID string, subnet SubnetIdentityIntf) *CreateInstanceNetworkInterfaceOptions {
	return &CreateInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		Subnet:     subnet,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *CreateInstanceNetworkInterfaceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetSubnet : Allow user to set Subnet
func (_options *CreateInstanceNetworkInterfaceOptions) SetSubnet(subnet SubnetIdentityIntf) *CreateInstanceNetworkInterfaceOptions {
	_options.Subnet = subnet
	return _options
}

// SetAllowIPSpoofing : Allow user to set AllowIPSpoofing
func (_options *CreateInstanceNetworkInterfaceOptions) SetAllowIPSpoofing(allowIPSpoofing bool) *CreateInstanceNetworkInterfaceOptions {
	_options.AllowIPSpoofing = core.BoolPtr(allowIPSpoofing)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateInstanceNetworkInterfaceOptions) SetName(name string) *CreateInstanceNetworkInterfaceOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPrimaryIP : Allow user to set PrimaryIP
func (_options *CreateInstanceNetworkInterfaceOptions) SetPrimaryIP(primaryIP NetworkInterfaceIPPrototypeIntf) *CreateInstanceNetworkInterfaceOptions {
	_options.PrimaryIP = primaryIP
	return _options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (_options *CreateInstanceNetworkInterfaceOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateInstanceNetworkInterfaceOptions {
	_options.SecurityGroups = securityGroups
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *CreateInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// CreateInstanceOptions : The CreateInstance options.
type CreateInstanceOptions struct {
	// The instance prototype object.
	InstancePrototype InstancePrototypeIntf `json:"InstancePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceOptions : Instantiate CreateInstanceOptions
func (*VpcV1) NewCreateInstanceOptions(instancePrototype InstancePrototypeIntf) *CreateInstanceOptions {
	return &CreateInstanceOptions{
		InstancePrototype: instancePrototype,
	}
}

// SetInstancePrototype : Allow user to set InstancePrototype
func (_options *CreateInstanceOptions) SetInstancePrototype(instancePrototype InstancePrototypeIntf) *CreateInstanceOptions {
	_options.InstancePrototype = instancePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceOptions) SetHeaders(param map[string]string) *CreateInstanceOptions {
	options.Headers = param
	return options
}

// CreateInstanceTemplateOptions : The CreateInstanceTemplate options.
type CreateInstanceTemplateOptions struct {
	// The instance template prototype object.
	InstanceTemplatePrototype InstanceTemplatePrototypeIntf `json:"InstanceTemplatePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceTemplateOptions : Instantiate CreateInstanceTemplateOptions
func (*VpcV1) NewCreateInstanceTemplateOptions(instanceTemplatePrototype InstanceTemplatePrototypeIntf) *CreateInstanceTemplateOptions {
	return &CreateInstanceTemplateOptions{
		InstanceTemplatePrototype: instanceTemplatePrototype,
	}
}

// SetInstanceTemplatePrototype : Allow user to set InstanceTemplatePrototype
func (_options *CreateInstanceTemplateOptions) SetInstanceTemplatePrototype(instanceTemplatePrototype InstanceTemplatePrototypeIntf) *CreateInstanceTemplateOptions {
	_options.InstanceTemplatePrototype = instanceTemplatePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceTemplateOptions) SetHeaders(param map[string]string) *CreateInstanceTemplateOptions {
	options.Headers = param
	return options
}

// CreateInstanceVolumeAttachmentOptions : The CreateInstanceVolumeAttachment options.
type CreateInstanceVolumeAttachmentOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// An existing volume to attach to the instance, or a prototype object for a new volume.
	Volume VolumeAttachmentPrototypeVolumeIntf `json:"volume" validate:"required"`

	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The name for this volume attachment. The name must not be used by another volume attachment on the instance. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceVolumeAttachmentOptions : Instantiate CreateInstanceVolumeAttachmentOptions
func (*VpcV1) NewCreateInstanceVolumeAttachmentOptions(instanceID string, volume VolumeAttachmentPrototypeVolumeIntf) *CreateInstanceVolumeAttachmentOptions {
	return &CreateInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		Volume:     volume,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *CreateInstanceVolumeAttachmentOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetVolume : Allow user to set Volume
func (_options *CreateInstanceVolumeAttachmentOptions) SetVolume(volume VolumeAttachmentPrototypeVolumeIntf) *CreateInstanceVolumeAttachmentOptions {
	_options.Volume = volume
	return _options
}

// SetDeleteVolumeOnInstanceDelete : Allow user to set DeleteVolumeOnInstanceDelete
func (_options *CreateInstanceVolumeAttachmentOptions) SetDeleteVolumeOnInstanceDelete(deleteVolumeOnInstanceDelete bool) *CreateInstanceVolumeAttachmentOptions {
	_options.DeleteVolumeOnInstanceDelete = core.BoolPtr(deleteVolumeOnInstanceDelete)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateInstanceVolumeAttachmentOptions) SetName(name string) *CreateInstanceVolumeAttachmentOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *CreateInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// CreateIpsecPolicyOptions : The CreateIpsecPolicy options.
type CreateIpsecPolicyOptions struct {
	// The authentication algorithm
	//
	// Must be `disabled` if and only if the `encryption_algorithm` is
	// `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The encryption algorithm
	//
	// The `authentication_algorithm` must be `disabled` if and only if
	// `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
	// `aes256gcm16`.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The name for this IPsec policy. The name must not be used by another IPsec policies in the region. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIpsecPolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm
//
// Must be `disabled` if and only if the `encryption_algorithm` is
// `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
const (
	CreateIpsecPolicyOptionsAuthenticationAlgorithmDisabledConst = "disabled"
	CreateIpsecPolicyOptionsAuthenticationAlgorithmSha256Const   = "sha256"
	CreateIpsecPolicyOptionsAuthenticationAlgorithmSha384Const   = "sha384"
	CreateIpsecPolicyOptionsAuthenticationAlgorithmSha512Const   = "sha512"
)

// Constants associated with the CreateIpsecPolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm
//
// The `authentication_algorithm` must be `disabled` if and only if
// `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
// `aes256gcm16`.
const (
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes128Const      = "aes128"
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes128gcm16Const = "aes128gcm16"
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes192Const      = "aes192"
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes192gcm16Const = "aes192gcm16"
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes256Const      = "aes256"
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes256gcm16Const = "aes256gcm16"
)

// Constants associated with the CreateIpsecPolicyOptions.Pfs property.
// Perfect Forward Secrecy.
const (
	CreateIpsecPolicyOptionsPfsDisabledConst = "disabled"
	CreateIpsecPolicyOptionsPfsGroup14Const  = "group_14"
	CreateIpsecPolicyOptionsPfsGroup15Const  = "group_15"
	CreateIpsecPolicyOptionsPfsGroup16Const  = "group_16"
	CreateIpsecPolicyOptionsPfsGroup17Const  = "group_17"
	CreateIpsecPolicyOptionsPfsGroup18Const  = "group_18"
	CreateIpsecPolicyOptionsPfsGroup19Const  = "group_19"
	CreateIpsecPolicyOptionsPfsGroup20Const  = "group_20"
	CreateIpsecPolicyOptionsPfsGroup21Const  = "group_21"
	CreateIpsecPolicyOptionsPfsGroup22Const  = "group_22"
	CreateIpsecPolicyOptionsPfsGroup23Const  = "group_23"
	CreateIpsecPolicyOptionsPfsGroup24Const  = "group_24"
	CreateIpsecPolicyOptionsPfsGroup31Const  = "group_31"
)

// NewCreateIpsecPolicyOptions : Instantiate CreateIpsecPolicyOptions
func (*VpcV1) NewCreateIpsecPolicyOptions(authenticationAlgorithm string, encryptionAlgorithm string, pfs string) *CreateIpsecPolicyOptions {
	return &CreateIpsecPolicyOptions{
		AuthenticationAlgorithm: core.StringPtr(authenticationAlgorithm),
		EncryptionAlgorithm:     core.StringPtr(encryptionAlgorithm),
		Pfs:                     core.StringPtr(pfs),
	}
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (_options *CreateIpsecPolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *CreateIpsecPolicyOptions {
	_options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return _options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (_options *CreateIpsecPolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *CreateIpsecPolicyOptions {
	_options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return _options
}

// SetPfs : Allow user to set Pfs
func (_options *CreateIpsecPolicyOptions) SetPfs(pfs string) *CreateIpsecPolicyOptions {
	_options.Pfs = core.StringPtr(pfs)
	return _options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (_options *CreateIpsecPolicyOptions) SetKeyLifetime(keyLifetime int64) *CreateIpsecPolicyOptions {
	_options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateIpsecPolicyOptions) SetName(name string) *CreateIpsecPolicyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateIpsecPolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateIpsecPolicyOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIpsecPolicyOptions) SetHeaders(param map[string]string) *CreateIpsecPolicyOptions {
	options.Headers = param
	return options
}

// CreateKeyOptions : The CreateKey options.
type CreateKeyOptions struct {
	// A unique public SSH key to import, in OpenSSH format (consisting of three space-separated fields: the algorithm
	// name, base64-encoded key, and a comment). The algorithm and comment fields may be omitted, as only the key field is
	// imported.
	//
	// Keys of type `rsa` may be 2048 or 4096 bits in length, however 4096 is recommended. Keys of type `ed25519` are 256
	// bits in length.
	PublicKey *string `json:"public_key" validate:"required"`

	// The name for this key. The name must not be used by another key in the region. If unspecified, the name will be a
	// hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The crypto-system used by this key.
	Type *string `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateKeyOptions.Type property.
// The crypto-system used by this key.
const (
	CreateKeyOptionsTypeEd25519Const = "ed25519"
	CreateKeyOptionsTypeRsaConst     = "rsa"
)

// NewCreateKeyOptions : Instantiate CreateKeyOptions
func (*VpcV1) NewCreateKeyOptions(publicKey string) *CreateKeyOptions {
	return &CreateKeyOptions{
		PublicKey: core.StringPtr(publicKey),
	}
}

// SetPublicKey : Allow user to set PublicKey
func (_options *CreateKeyOptions) SetPublicKey(publicKey string) *CreateKeyOptions {
	_options.PublicKey = core.StringPtr(publicKey)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateKeyOptions) SetName(name string) *CreateKeyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateKeyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateKeyOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateKeyOptions) SetType(typeVar string) *CreateKeyOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateKeyOptions) SetHeaders(param map[string]string) *CreateKeyOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerOptions : The CreateLoadBalancerListener options.
type CreateLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination.
	//
	// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
	// `application` family support `tcp`, `http` and
	// `https`.
	//
	// Additional restrictions:
	// - If `default_pool` is set, the pool's protocol must match, or be compatible with
	//   the listener's protocol. At present, the compatible protocols are `http` and
	//   `https`.
	// - If `https_redirect` is set, the protocol must be `http`.
	Protocol *string `json:"protocol" validate:"required"`

	// If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load balancers in
	// the `application` family (otherwise always `false`). Additional restrictions:
	// - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
	//   match the `accept_proxy_protocol` value of the `https_redirect` listener.
	// - If this listener is the target of another listener's `https_redirect`, its
	//   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
	AcceptProxyProtocol *bool `json:"accept_proxy_protocol,omitempty"`

	// The certificate instance to use for SSL termination. The listener must have a
	// `protocol` of `https`.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool for this listener. If specified, the pool must:
	// - Belong to this load balancer.
	// - Have the same `protocol` as this listener, or have a compatible protocol.
	//   At present, the compatible protocols are `http` and `https`.
	// - Not already be the `default_pool` for another listener.
	//
	// If unspecified, this listener will be created with no default pool, but one may be
	// subsequently set.
	DefaultPool LoadBalancerPoolIdentityIntf `json:"default_pool,omitempty"`

	// The target listener that requests will be redirected to. This listener must have a
	// `protocol` of `http`, and the target listener must have a `protocol` of `https`.
	HTTPSRedirect *LoadBalancerListenerHTTPSRedirectPrototype `json:"https_redirect,omitempty"`

	// The idle connection timeout of the listener in seconds. Supported for load balancers in the `application` family.
	IdleConnectionTimeout *int64 `json:"idle_connection_timeout,omitempty"`

	// The policy prototype objects for this listener. The load balancer must be in the
	// `application` family.
	Policies []LoadBalancerListenerPolicyPrototype `json:"policies,omitempty"`

	// The listener port number, or the inclusive lower bound of the port range. Each listener in the load balancer must
	// have a unique `port` and `protocol` combination.
	//
	// Not supported for load balancers operating with route mode enabled.
	Port *int64 `json:"port,omitempty"`

	// The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
	//
	// At present, only load balancers operating with route mode enabled, and public load balancers in the `network` family
	// support different values for `port_min` and
	// `port_max`. When route mode is enabled, the value `65535` must be specified.
	//
	// The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
	// same protocol.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
	//
	// At present, only load balancers operating with route mode enabled, and public load balancers in the `network` family
	// support different values for `port_min` and
	// `port_max`. When route mode is enabled, the value `1` must be specified.
	//
	// The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
	// same protocol.
	PortMin *int64 `json:"port_min,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerOptions.Protocol property.
// The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination.
//
// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
// `application` family support `tcp`, `http` and
// `https`.
//
// Additional restrictions:
//   - If `default_pool` is set, the pool's protocol must match, or be compatible with
//     the listener's protocol. At present, the compatible protocols are `http` and
//     `https`.
//   - If `https_redirect` is set, the protocol must be `http`.
const (
	CreateLoadBalancerListenerOptionsProtocolHTTPConst  = "http"
	CreateLoadBalancerListenerOptionsProtocolHTTPSConst = "https"
	CreateLoadBalancerListenerOptionsProtocolTCPConst   = "tcp"
	CreateLoadBalancerListenerOptionsProtocolUDPConst   = "udp"
)

// NewCreateLoadBalancerListenerOptions : Instantiate CreateLoadBalancerListenerOptions
func (*VpcV1) NewCreateLoadBalancerListenerOptions(loadBalancerID string, protocol string) *CreateLoadBalancerListenerOptions {
	return &CreateLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		Protocol:       core.StringPtr(protocol),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *CreateLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetProtocol : Allow user to set Protocol
func (_options *CreateLoadBalancerListenerOptions) SetProtocol(protocol string) *CreateLoadBalancerListenerOptions {
	_options.Protocol = core.StringPtr(protocol)
	return _options
}

// SetAcceptProxyProtocol : Allow user to set AcceptProxyProtocol
func (_options *CreateLoadBalancerListenerOptions) SetAcceptProxyProtocol(acceptProxyProtocol bool) *CreateLoadBalancerListenerOptions {
	_options.AcceptProxyProtocol = core.BoolPtr(acceptProxyProtocol)
	return _options
}

// SetCertificateInstance : Allow user to set CertificateInstance
func (_options *CreateLoadBalancerListenerOptions) SetCertificateInstance(certificateInstance CertificateInstanceIdentityIntf) *CreateLoadBalancerListenerOptions {
	_options.CertificateInstance = certificateInstance
	return _options
}

// SetConnectionLimit : Allow user to set ConnectionLimit
func (_options *CreateLoadBalancerListenerOptions) SetConnectionLimit(connectionLimit int64) *CreateLoadBalancerListenerOptions {
	_options.ConnectionLimit = core.Int64Ptr(connectionLimit)
	return _options
}

// SetDefaultPool : Allow user to set DefaultPool
func (_options *CreateLoadBalancerListenerOptions) SetDefaultPool(defaultPool LoadBalancerPoolIdentityIntf) *CreateLoadBalancerListenerOptions {
	_options.DefaultPool = defaultPool
	return _options
}

// SetHTTPSRedirect : Allow user to set HTTPSRedirect
func (_options *CreateLoadBalancerListenerOptions) SetHTTPSRedirect(httpsRedirect *LoadBalancerListenerHTTPSRedirectPrototype) *CreateLoadBalancerListenerOptions {
	_options.HTTPSRedirect = httpsRedirect
	return _options
}

// SetIdleConnectionTimeout : Allow user to set IdleConnectionTimeout
func (_options *CreateLoadBalancerListenerOptions) SetIdleConnectionTimeout(idleConnectionTimeout int64) *CreateLoadBalancerListenerOptions {
	_options.IdleConnectionTimeout = core.Int64Ptr(idleConnectionTimeout)
	return _options
}

// SetPolicies : Allow user to set Policies
func (_options *CreateLoadBalancerListenerOptions) SetPolicies(policies []LoadBalancerListenerPolicyPrototype) *CreateLoadBalancerListenerOptions {
	_options.Policies = policies
	return _options
}

// SetPort : Allow user to set Port
func (_options *CreateLoadBalancerListenerOptions) SetPort(port int64) *CreateLoadBalancerListenerOptions {
	_options.Port = core.Int64Ptr(port)
	return _options
}

// SetPortMax : Allow user to set PortMax
func (_options *CreateLoadBalancerListenerOptions) SetPortMax(portMax int64) *CreateLoadBalancerListenerOptions {
	_options.PortMax = core.Int64Ptr(portMax)
	return _options
}

// SetPortMin : Allow user to set PortMin
func (_options *CreateLoadBalancerListenerOptions) SetPortMin(portMin int64) *CreateLoadBalancerListenerOptions {
	_options.PortMin = core.Int64Ptr(portMin)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerPolicyOptions : The CreateLoadBalancerListenerPolicy options.
type CreateLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy action.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
	// unexpected property value was encountered.
	Action *string `json:"action" validate:"required"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The name for this policy. The name must not be used by another policy for the load balancer listener. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The rule prototype objects for this policy.
	Rules []LoadBalancerListenerPolicyRulePrototype `json:"rules,omitempty"`

	// - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
	// - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`.
	// - If `action` is `https_redirect`, specify a
	//   `LoadBalancerListenerPolicyHTTPSRedirectPrototype`.
	Target LoadBalancerListenerPolicyTargetPrototypeIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerPolicyOptions.Action property.
// The policy action.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
// unexpected property value was encountered.
const (
	CreateLoadBalancerListenerPolicyOptionsActionForwardConst       = "forward"
	CreateLoadBalancerListenerPolicyOptionsActionHTTPSRedirectConst = "https_redirect"
	CreateLoadBalancerListenerPolicyOptionsActionRedirectConst      = "redirect"
	CreateLoadBalancerListenerPolicyOptionsActionRejectConst        = "reject"
)

// NewCreateLoadBalancerListenerPolicyOptions : Instantiate CreateLoadBalancerListenerPolicyOptions
func (*VpcV1) NewCreateLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, action string, priority int64) *CreateLoadBalancerListenerPolicyOptions {
	return &CreateLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		Action:         core.StringPtr(action),
		Priority:       core.Int64Ptr(priority),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *CreateLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerPolicyOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *CreateLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *CreateLoadBalancerListenerPolicyOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateLoadBalancerListenerPolicyOptions) SetAction(action string) *CreateLoadBalancerListenerPolicyOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPriority : Allow user to set Priority
func (_options *CreateLoadBalancerListenerPolicyOptions) SetPriority(priority int64) *CreateLoadBalancerListenerPolicyOptions {
	_options.Priority = core.Int64Ptr(priority)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateLoadBalancerListenerPolicyOptions) SetName(name string) *CreateLoadBalancerListenerPolicyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRules : Allow user to set Rules
func (_options *CreateLoadBalancerListenerPolicyOptions) SetRules(rules []LoadBalancerListenerPolicyRulePrototype) *CreateLoadBalancerListenerPolicyOptions {
	_options.Rules = rules
	return _options
}

// SetTarget : Allow user to set Target
func (_options *CreateLoadBalancerListenerPolicyOptions) SetTarget(target LoadBalancerListenerPolicyTargetPrototypeIntf) *CreateLoadBalancerListenerPolicyOptions {
	_options.Target = target
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerPolicyRuleOptions : The CreateLoadBalancerListenerPolicyRule options.
type CreateLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required,ne="`

	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The type of the rule.
	//
	// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	//
	// If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
	Value *string `json:"value" validate:"required"`

	// The field. This is applicable to `header`, `query`, and `body` rule types.
	//
	// If the rule type is `header`, this property is required.
	//
	// If the rule type is `query`, this is optional. If specified and the rule condition is not
	// `matches_regex`, the value must be percent-encoded.
	//
	// If the rule type is `body`, this is optional.
	Field *string `json:"field,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerPolicyRuleOptions.Condition property.
// The condition of the rule.
const (
	CreateLoadBalancerListenerPolicyRuleOptionsConditionContainsConst     = "contains"
	CreateLoadBalancerListenerPolicyRuleOptionsConditionEqualsConst       = "equals"
	CreateLoadBalancerListenerPolicyRuleOptionsConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the CreateLoadBalancerListenerPolicyRuleOptions.Type property.
// The type of the rule.
//
// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
const (
	CreateLoadBalancerListenerPolicyRuleOptionsTypeBodyConst     = "body"
	CreateLoadBalancerListenerPolicyRuleOptionsTypeHeaderConst   = "header"
	CreateLoadBalancerListenerPolicyRuleOptionsTypeHostnameConst = "hostname"
	CreateLoadBalancerListenerPolicyRuleOptionsTypePathConst     = "path"
	CreateLoadBalancerListenerPolicyRuleOptionsTypeQueryConst    = "query"
)

// NewCreateLoadBalancerListenerPolicyRuleOptions : Instantiate CreateLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewCreateLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, condition string, typeVar string, value string) *CreateLoadBalancerListenerPolicyRuleOptions {
	return &CreateLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		Condition:      core.StringPtr(condition),
		Type:           core.StringPtr(typeVar),
		Value:          core.StringPtr(value),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetCondition : Allow user to set Condition
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetCondition(condition string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.Condition = core.StringPtr(condition)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetType(typeVar string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetValue : Allow user to set Value
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetValue(value string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.Value = core.StringPtr(value)
	return _options
}

// SetField : Allow user to set Field
func (_options *CreateLoadBalancerListenerPolicyRuleOptions) SetField(field string) *CreateLoadBalancerListenerPolicyRuleOptions {
	_options.Field = core.StringPtr(field)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerOptions : The CreateLoadBalancer options.
type CreateLoadBalancerOptions struct {
	// Indicates whether this load balancer is public.
	//
	// At present, if route mode is enabled, the load balancer must not be public.
	IsPublic *bool `json:"is_public" validate:"required"`

	// The subnets to provision this load balancer in. The subnets must be in the same VPC. The load balancer's
	// availability will depend on the availability of the zones that the subnets reside in.
	//
	// Load balancers in the `network` family allow only one subnet to be specified.
	Subnets []SubnetIdentityIntf `json:"subnets" validate:"required"`

	// The datapath logging configuration for this load balancer.
	Datapath *LoadBalancerLoggingDatapathPrototype `json:"datapath,omitempty"`

	// The DNS configuration for this load balancer.
	//
	// If unspecified, DNS `A` records for this load balancer's `hostname` property will be added
	// to the public DNS zone `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be
	// added to the specified `zone`.
	Dns *LoadBalancerDnsPrototype `json:"dns,omitempty"`

	// The listeners of this load balancer.
	Listeners []LoadBalancerListenerPrototypeLoadBalancerContext `json:"listeners,omitempty"`

	// The logging configuration to use for this load balancer. See [VPC Datapath
	// Logging](https://cloud.ibm.com/docs/vpc?topic=vpc-datapath-logging) on the logging
	// format, fields and permitted values.
	//
	// To activate logging, the load balancer profile must support the specified logging type.
	Logging *LoadBalancerLoggingPrototype `json:"logging,omitempty"`

	// The name for this load balancer. The name must not be used by another load balancer in the VPC.  If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The pools of this load balancer.
	Pools []LoadBalancerPoolPrototype `json:"pools,omitempty"`

	// The profile to use for this load balancer.
	//
	// If unspecified, `application` will be used.
	Profile LoadBalancerProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Indicates whether route mode is enabled for this load balancer.
	//
	// At present, public load balancers are not supported with route mode enabled.
	RouteMode *bool `json:"route_mode,omitempty"`

	// The security groups to use for this load balancer. If unspecified, the VPC's default security group is used.
	//
	// The load balancer profile must support security groups.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoadBalancerOptions : Instantiate CreateLoadBalancerOptions
func (*VpcV1) NewCreateLoadBalancerOptions(isPublic bool, subnets []SubnetIdentityIntf) *CreateLoadBalancerOptions {
	return &CreateLoadBalancerOptions{
		IsPublic: core.BoolPtr(isPublic),
		Subnets:  subnets,
	}
}

// SetIsPublic : Allow user to set IsPublic
func (_options *CreateLoadBalancerOptions) SetIsPublic(isPublic bool) *CreateLoadBalancerOptions {
	_options.IsPublic = core.BoolPtr(isPublic)
	return _options
}

// SetSubnets : Allow user to set Subnets
func (_options *CreateLoadBalancerOptions) SetSubnets(subnets []SubnetIdentityIntf) *CreateLoadBalancerOptions {
	_options.Subnets = subnets
	return _options
}

// SetDatapath : Allow user to set Datapath
func (_options *CreateLoadBalancerOptions) SetDatapath(datapath *LoadBalancerLoggingDatapathPrototype) *CreateLoadBalancerOptions {
	_options.Datapath = datapath
	return _options
}

// SetDns : Allow user to set Dns
func (_options *CreateLoadBalancerOptions) SetDns(dns *LoadBalancerDnsPrototype) *CreateLoadBalancerOptions {
	_options.Dns = dns
	return _options
}

// SetListeners : Allow user to set Listeners
func (_options *CreateLoadBalancerOptions) SetListeners(listeners []LoadBalancerListenerPrototypeLoadBalancerContext) *CreateLoadBalancerOptions {
	_options.Listeners = listeners
	return _options
}

// SetLogging : Allow user to set Logging
func (_options *CreateLoadBalancerOptions) SetLogging(logging *LoadBalancerLoggingPrototype) *CreateLoadBalancerOptions {
	_options.Logging = logging
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateLoadBalancerOptions) SetName(name string) *CreateLoadBalancerOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPools : Allow user to set Pools
func (_options *CreateLoadBalancerOptions) SetPools(pools []LoadBalancerPoolPrototype) *CreateLoadBalancerOptions {
	_options.Pools = pools
	return _options
}

// SetProfile : Allow user to set Profile
func (_options *CreateLoadBalancerOptions) SetProfile(profile LoadBalancerProfileIdentityIntf) *CreateLoadBalancerOptions {
	_options.Profile = profile
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateLoadBalancerOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateLoadBalancerOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetRouteMode : Allow user to set RouteMode
func (_options *CreateLoadBalancerOptions) SetRouteMode(routeMode bool) *CreateLoadBalancerOptions {
	_options.RouteMode = core.BoolPtr(routeMode)
	return _options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (_options *CreateLoadBalancerOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateLoadBalancerOptions {
	_options.SecurityGroups = securityGroups
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerOptions) SetHeaders(param map[string]string) *CreateLoadBalancerOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerPoolMemberOptions : The CreateLoadBalancerPoolMember options.
type CreateLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required,ne="`

	// The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on a
	// listener with a single port. (If the traffic is received on a listener with a port range, the member will receive
	// the traffic on the same port the listener received it on.)
	//
	// This port will also be used for health checks unless the `port` property of
	// `health_monitor` property is specified.
	//
	// The port must be unique across all members for all pools associated with this pool's listener.
	Port *int64 `json:"port" validate:"required"`

	// The pool member target. Load balancers in the `network` family support virtual server
	// instances. Load balancers in the `application` family support IP addresses. If the load
	// balancer has route mode enabled, the member must be in a zone the load balancer has a
	// subnet in.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target" validate:"required"`

	// Weight of the server member. Applicable only if the pool algorithm is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoadBalancerPoolMemberOptions : Instantiate CreateLoadBalancerPoolMemberOptions
func (*VpcV1) NewCreateLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, port int64, target LoadBalancerPoolMemberTargetPrototypeIntf) *CreateLoadBalancerPoolMemberOptions {
	return &CreateLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		Port:           core.Int64Ptr(port),
		Target:         target,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *CreateLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerPoolMemberOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetPoolID : Allow user to set PoolID
func (_options *CreateLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *CreateLoadBalancerPoolMemberOptions {
	_options.PoolID = core.StringPtr(poolID)
	return _options
}

// SetPort : Allow user to set Port
func (_options *CreateLoadBalancerPoolMemberOptions) SetPort(port int64) *CreateLoadBalancerPoolMemberOptions {
	_options.Port = core.Int64Ptr(port)
	return _options
}

// SetTarget : Allow user to set Target
func (_options *CreateLoadBalancerPoolMemberOptions) SetTarget(target LoadBalancerPoolMemberTargetPrototypeIntf) *CreateLoadBalancerPoolMemberOptions {
	_options.Target = target
	return _options
}

// SetWeight : Allow user to set Weight
func (_options *CreateLoadBalancerPoolMemberOptions) SetWeight(weight int64) *CreateLoadBalancerPoolMemberOptions {
	_options.Weight = core.Int64Ptr(weight)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *CreateLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerPoolOptions : The CreateLoadBalancerPool options.
type CreateLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPrototype `json:"health_monitor" validate:"required"`

	// The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if
	// `udp_supported` is `true`). Load balancers in the
	// `application` family support `tcp`, `http`, and `https`.
	Protocol *string `json:"protocol" validate:"required"`

	// The members for this load balancer pool. For load balancers in the `network` family, the same `port` and `target`
	// tuple cannot be shared by a pool member of any other load balancer in the same VPC.
	Members []LoadBalancerPoolMemberPrototype `json:"members,omitempty"`

	// The name for this load balancer pool. The name must not be used by another pool for the load balancer. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The PROXY protocol setting for this pool:
	// - `v1`: Enabled with version 1 (human-readable header format)
	// - `v2`: Enabled with version 2 (binary header format)
	// - `disabled`: Disabled
	//
	// Supported by load balancers in the `application` family (otherwise always `disabled`).
	ProxyProtocol *string `json:"proxy_protocol,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePrototype `json:"session_persistence,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerPoolOptions.Algorithm property.
// The load balancing algorithm.
const (
	CreateLoadBalancerPoolOptionsAlgorithmLeastConnectionsConst   = "least_connections"
	CreateLoadBalancerPoolOptionsAlgorithmRoundRobinConst         = "round_robin"
	CreateLoadBalancerPoolOptionsAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the CreateLoadBalancerPoolOptions.Protocol property.
// The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if
// `udp_supported` is `true`). Load balancers in the
// `application` family support `tcp`, `http`, and `https`.
const (
	CreateLoadBalancerPoolOptionsProtocolHTTPConst  = "http"
	CreateLoadBalancerPoolOptionsProtocolHTTPSConst = "https"
	CreateLoadBalancerPoolOptionsProtocolTCPConst   = "tcp"
	CreateLoadBalancerPoolOptionsProtocolUDPConst   = "udp"
)

// Constants associated with the CreateLoadBalancerPoolOptions.ProxyProtocol property.
// The PROXY protocol setting for this pool:
// - `v1`: Enabled with version 1 (human-readable header format)
// - `v2`: Enabled with version 2 (binary header format)
// - `disabled`: Disabled
//
// Supported by load balancers in the `application` family (otherwise always `disabled`).
const (
	CreateLoadBalancerPoolOptionsProxyProtocolDisabledConst = "disabled"
	CreateLoadBalancerPoolOptionsProxyProtocolV1Const       = "v1"
	CreateLoadBalancerPoolOptionsProxyProtocolV2Const       = "v2"
)

// NewCreateLoadBalancerPoolOptions : Instantiate CreateLoadBalancerPoolOptions
func (*VpcV1) NewCreateLoadBalancerPoolOptions(loadBalancerID string, algorithm string, healthMonitor *LoadBalancerPoolHealthMonitorPrototype, protocol string) *CreateLoadBalancerPoolOptions {
	return &CreateLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		Algorithm:      core.StringPtr(algorithm),
		HealthMonitor:  healthMonitor,
		Protocol:       core.StringPtr(protocol),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *CreateLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerPoolOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetAlgorithm : Allow user to set Algorithm
func (_options *CreateLoadBalancerPoolOptions) SetAlgorithm(algorithm string) *CreateLoadBalancerPoolOptions {
	_options.Algorithm = core.StringPtr(algorithm)
	return _options
}

// SetHealthMonitor : Allow user to set HealthMonitor
func (_options *CreateLoadBalancerPoolOptions) SetHealthMonitor(healthMonitor *LoadBalancerPoolHealthMonitorPrototype) *CreateLoadBalancerPoolOptions {
	_options.HealthMonitor = healthMonitor
	return _options
}

// SetProtocol : Allow user to set Protocol
func (_options *CreateLoadBalancerPoolOptions) SetProtocol(protocol string) *CreateLoadBalancerPoolOptions {
	_options.Protocol = core.StringPtr(protocol)
	return _options
}

// SetMembers : Allow user to set Members
func (_options *CreateLoadBalancerPoolOptions) SetMembers(members []LoadBalancerPoolMemberPrototype) *CreateLoadBalancerPoolOptions {
	_options.Members = members
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateLoadBalancerPoolOptions) SetName(name string) *CreateLoadBalancerPoolOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetProxyProtocol : Allow user to set ProxyProtocol
func (_options *CreateLoadBalancerPoolOptions) SetProxyProtocol(proxyProtocol string) *CreateLoadBalancerPoolOptions {
	_options.ProxyProtocol = core.StringPtr(proxyProtocol)
	return _options
}

// SetSessionPersistence : Allow user to set SessionPersistence
func (_options *CreateLoadBalancerPoolOptions) SetSessionPersistence(sessionPersistence *LoadBalancerPoolSessionPersistencePrototype) *CreateLoadBalancerPoolOptions {
	_options.SessionPersistence = sessionPersistence
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerPoolOptions) SetHeaders(param map[string]string) *CreateLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// CreateNetworkACLOptions : The CreateNetworkACL options.
type CreateNetworkACLOptions struct {
	// The network ACL prototype object.
	NetworkACLPrototype NetworkACLPrototypeIntf `json:"NetworkACLPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkACLOptions : Instantiate CreateNetworkACLOptions
func (*VpcV1) NewCreateNetworkACLOptions(networkACLPrototype NetworkACLPrototypeIntf) *CreateNetworkACLOptions {
	return &CreateNetworkACLOptions{
		NetworkACLPrototype: networkACLPrototype,
	}
}

// SetNetworkACLPrototype : Allow user to set NetworkACLPrototype
func (_options *CreateNetworkACLOptions) SetNetworkACLPrototype(networkACLPrototype NetworkACLPrototypeIntf) *CreateNetworkACLOptions {
	_options.NetworkACLPrototype = networkACLPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkACLOptions) SetHeaders(param map[string]string) *CreateNetworkACLOptions {
	options.Headers = param
	return options
}

// CreateNetworkACLRuleOptions : The CreateNetworkACLRule options.
type CreateNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required,ne="`

	// The network ACL rule prototype object.
	NetworkACLRulePrototype NetworkACLRulePrototypeIntf `json:"NetworkACLRulePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkACLRuleOptions : Instantiate CreateNetworkACLRuleOptions
func (*VpcV1) NewCreateNetworkACLRuleOptions(networkACLID string, networkACLRulePrototype NetworkACLRulePrototypeIntf) *CreateNetworkACLRuleOptions {
	return &CreateNetworkACLRuleOptions{
		NetworkACLID:            core.StringPtr(networkACLID),
		NetworkACLRulePrototype: networkACLRulePrototype,
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (_options *CreateNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *CreateNetworkACLRuleOptions {
	_options.NetworkACLID = core.StringPtr(networkACLID)
	return _options
}

// SetNetworkACLRulePrototype : Allow user to set NetworkACLRulePrototype
func (_options *CreateNetworkACLRuleOptions) SetNetworkACLRulePrototype(networkACLRulePrototype NetworkACLRulePrototypeIntf) *CreateNetworkACLRuleOptions {
	_options.NetworkACLRulePrototype = networkACLRulePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkACLRuleOptions) SetHeaders(param map[string]string) *CreateNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// CreatePlacementGroupOptions : The CreatePlacementGroup options.
type CreatePlacementGroupOptions struct {
	// The strategy for this placement group
	// - `host_spread`: place on different compute hosts
	// - `power_spread`: place on compute hosts that use different power sources
	//
	// The enumerated values for this property may expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
	// unexpected strategy was encountered.
	Strategy *string `json:"strategy" validate:"required"`

	// The name for this placement group. The name must not be used by another placement group in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreatePlacementGroupOptions.Strategy property.
// The strategy for this placement group
// - `host_spread`: place on different compute hosts
// - `power_spread`: place on compute hosts that use different power sources
//
// The enumerated values for this property may expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
// unexpected strategy was encountered.
const (
	CreatePlacementGroupOptionsStrategyHostSpreadConst  = "host_spread"
	CreatePlacementGroupOptionsStrategyPowerSpreadConst = "power_spread"
)

// NewCreatePlacementGroupOptions : Instantiate CreatePlacementGroupOptions
func (*VpcV1) NewCreatePlacementGroupOptions(strategy string) *CreatePlacementGroupOptions {
	return &CreatePlacementGroupOptions{
		Strategy: core.StringPtr(strategy),
	}
}

// SetStrategy : Allow user to set Strategy
func (_options *CreatePlacementGroupOptions) SetStrategy(strategy string) *CreatePlacementGroupOptions {
	_options.Strategy = core.StringPtr(strategy)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreatePlacementGroupOptions) SetName(name string) *CreatePlacementGroupOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreatePlacementGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreatePlacementGroupOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreatePlacementGroupOptions) SetHeaders(param map[string]string) *CreatePlacementGroupOptions {
	options.Headers = param
	return options
}

// CreatePublicGatewayOptions : The CreatePublicGateway options.
type CreatePublicGatewayOptions struct {
	// The VPC this public gateway will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The zone this public gateway will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	FloatingIP PublicGatewayFloatingIPPrototypeIntf `json:"floating_ip,omitempty"`

	// The name for this public gateway. The name must not be used by another public gateway in the VPC. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreatePublicGatewayOptions : Instantiate CreatePublicGatewayOptions
func (*VpcV1) NewCreatePublicGatewayOptions(vpc VPCIdentityIntf, zone ZoneIdentityIntf) *CreatePublicGatewayOptions {
	return &CreatePublicGatewayOptions{
		VPC:  vpc,
		Zone: zone,
	}
}

// SetVPC : Allow user to set VPC
func (_options *CreatePublicGatewayOptions) SetVPC(vpc VPCIdentityIntf) *CreatePublicGatewayOptions {
	_options.VPC = vpc
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreatePublicGatewayOptions) SetZone(zone ZoneIdentityIntf) *CreatePublicGatewayOptions {
	_options.Zone = zone
	return _options
}

// SetFloatingIP : Allow user to set FloatingIP
func (_options *CreatePublicGatewayOptions) SetFloatingIP(floatingIP PublicGatewayFloatingIPPrototypeIntf) *CreatePublicGatewayOptions {
	_options.FloatingIP = floatingIP
	return _options
}

// SetName : Allow user to set Name
func (_options *CreatePublicGatewayOptions) SetName(name string) *CreatePublicGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreatePublicGatewayOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreatePublicGatewayOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreatePublicGatewayOptions) SetHeaders(param map[string]string) *CreatePublicGatewayOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupOptions : The CreateSecurityGroup options.
type CreateSecurityGroupOptions struct {
	// The VPC this security group will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The name for this security group. The name must not be used by another security group for the VPC. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The prototype objects for rules to be created for this security group. If unspecified, no rules will be created,
	// resulting in all traffic being denied.
	Rules []SecurityGroupRulePrototypeIntf `json:"rules,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupOptions : Instantiate CreateSecurityGroupOptions
func (*VpcV1) NewCreateSecurityGroupOptions(vpc VPCIdentityIntf) *CreateSecurityGroupOptions {
	return &CreateSecurityGroupOptions{
		VPC: vpc,
	}
}

// SetVPC : Allow user to set VPC
func (_options *CreateSecurityGroupOptions) SetVPC(vpc VPCIdentityIntf) *CreateSecurityGroupOptions {
	_options.VPC = vpc
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSecurityGroupOptions) SetName(name string) *CreateSecurityGroupOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateSecurityGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateSecurityGroupOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetRules : Allow user to set Rules
func (_options *CreateSecurityGroupOptions) SetRules(rules []SecurityGroupRulePrototypeIntf) *CreateSecurityGroupOptions {
	_options.Rules = rules
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupOptions) SetHeaders(param map[string]string) *CreateSecurityGroupOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupRuleOptions : The CreateSecurityGroupRule options.
type CreateSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The properties of the security group rule to be created.
	SecurityGroupRulePrototype SecurityGroupRulePrototypeIntf `json:"SecurityGroupRulePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupRuleOptions : Instantiate CreateSecurityGroupRuleOptions
func (*VpcV1) NewCreateSecurityGroupRuleOptions(securityGroupID string, securityGroupRulePrototype SecurityGroupRulePrototypeIntf) *CreateSecurityGroupRuleOptions {
	return &CreateSecurityGroupRuleOptions{
		SecurityGroupID:            core.StringPtr(securityGroupID),
		SecurityGroupRulePrototype: securityGroupRulePrototype,
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *CreateSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *CreateSecurityGroupRuleOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetSecurityGroupRulePrototype : Allow user to set SecurityGroupRulePrototype
func (_options *CreateSecurityGroupRuleOptions) SetSecurityGroupRulePrototype(securityGroupRulePrototype SecurityGroupRulePrototypeIntf) *CreateSecurityGroupRuleOptions {
	_options.SecurityGroupRulePrototype = securityGroupRulePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupRuleOptions) SetHeaders(param map[string]string) *CreateSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupTargetBindingOptions : The CreateSecurityGroupTargetBinding options.
type CreateSecurityGroupTargetBindingOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The security group target identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupTargetBindingOptions : Instantiate CreateSecurityGroupTargetBindingOptions
func (*VpcV1) NewCreateSecurityGroupTargetBindingOptions(securityGroupID string, id string) *CreateSecurityGroupTargetBindingOptions {
	return &CreateSecurityGroupTargetBindingOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *CreateSecurityGroupTargetBindingOptions) SetSecurityGroupID(securityGroupID string) *CreateSecurityGroupTargetBindingOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateSecurityGroupTargetBindingOptions) SetID(id string) *CreateSecurityGroupTargetBindingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupTargetBindingOptions) SetHeaders(param map[string]string) *CreateSecurityGroupTargetBindingOptions {
	options.Headers = param
	return options
}

// CreateShareMountTargetOptions : The CreateShareMountTarget options.
type CreateShareMountTargetOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// The share mount target prototype object.
	ShareMountTargetPrototype ShareMountTargetPrototypeIntf `json:"ShareMountTargetPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateShareMountTargetOptions : Instantiate CreateShareMountTargetOptions
func (*VpcV1) NewCreateShareMountTargetOptions(shareID string, shareMountTargetPrototype ShareMountTargetPrototypeIntf) *CreateShareMountTargetOptions {
	return &CreateShareMountTargetOptions{
		ShareID:                   core.StringPtr(shareID),
		ShareMountTargetPrototype: shareMountTargetPrototype,
	}
}

// SetShareID : Allow user to set ShareID
func (_options *CreateShareMountTargetOptions) SetShareID(shareID string) *CreateShareMountTargetOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetShareMountTargetPrototype : Allow user to set ShareMountTargetPrototype
func (_options *CreateShareMountTargetOptions) SetShareMountTargetPrototype(shareMountTargetPrototype ShareMountTargetPrototypeIntf) *CreateShareMountTargetOptions {
	_options.ShareMountTargetPrototype = shareMountTargetPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateShareMountTargetOptions) SetHeaders(param map[string]string) *CreateShareMountTargetOptions {
	options.Headers = param
	return options
}

// CreateShareOptions : The CreateShare options.
type CreateShareOptions struct {
	// The file share prototype object.
	SharePrototype SharePrototypeIntf `json:"SharePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateShareOptions : Instantiate CreateShareOptions
func (*VpcV1) NewCreateShareOptions(sharePrototype SharePrototypeIntf) *CreateShareOptions {
	return &CreateShareOptions{
		SharePrototype: sharePrototype,
	}
}

// SetSharePrototype : Allow user to set SharePrototype
func (_options *CreateShareOptions) SetSharePrototype(sharePrototype SharePrototypeIntf) *CreateShareOptions {
	_options.SharePrototype = sharePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateShareOptions) SetHeaders(param map[string]string) *CreateShareOptions {
	options.Headers = param
	return options
}

// CreateSnapshotCloneOptions : The CreateSnapshotClone options.
type CreateSnapshotCloneOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The zone name.
	ZoneName *string `json:"zone_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSnapshotCloneOptions : Instantiate CreateSnapshotCloneOptions
func (*VpcV1) NewCreateSnapshotCloneOptions(id string, zoneName string) *CreateSnapshotCloneOptions {
	return &CreateSnapshotCloneOptions{
		ID:       core.StringPtr(id),
		ZoneName: core.StringPtr(zoneName),
	}
}

// SetID : Allow user to set ID
func (_options *CreateSnapshotCloneOptions) SetID(id string) *CreateSnapshotCloneOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *CreateSnapshotCloneOptions) SetZoneName(zoneName string) *CreateSnapshotCloneOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSnapshotCloneOptions) SetHeaders(param map[string]string) *CreateSnapshotCloneOptions {
	options.Headers = param
	return options
}

// CreateSnapshotOptions : The CreateSnapshot options.
type CreateSnapshotOptions struct {
	// The snapshot prototype object.
	SnapshotPrototype SnapshotPrototypeIntf `json:"SnapshotPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSnapshotOptions : Instantiate CreateSnapshotOptions
func (*VpcV1) NewCreateSnapshotOptions(snapshotPrototype SnapshotPrototypeIntf) *CreateSnapshotOptions {
	return &CreateSnapshotOptions{
		SnapshotPrototype: snapshotPrototype,
	}
}

// SetSnapshotPrototype : Allow user to set SnapshotPrototype
func (_options *CreateSnapshotOptions) SetSnapshotPrototype(snapshotPrototype SnapshotPrototypeIntf) *CreateSnapshotOptions {
	_options.SnapshotPrototype = snapshotPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSnapshotOptions) SetHeaders(param map[string]string) *CreateSnapshotOptions {
	options.Headers = param
	return options
}

// CreateSubnetOptions : The CreateSubnet options.
type CreateSubnetOptions struct {
	// The subnet prototype object.
	SubnetPrototype SubnetPrototypeIntf `json:"SubnetPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubnetOptions : Instantiate CreateSubnetOptions
func (*VpcV1) NewCreateSubnetOptions(subnetPrototype SubnetPrototypeIntf) *CreateSubnetOptions {
	return &CreateSubnetOptions{
		SubnetPrototype: subnetPrototype,
	}
}

// SetSubnetPrototype : Allow user to set SubnetPrototype
func (_options *CreateSubnetOptions) SetSubnetPrototype(subnetPrototype SubnetPrototypeIntf) *CreateSubnetOptions {
	_options.SubnetPrototype = subnetPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubnetOptions) SetHeaders(param map[string]string) *CreateSubnetOptions {
	options.Headers = param
	return options
}

// CreateSubnetReservedIPOptions : The CreateSubnetReservedIP options.
type CreateSubnetReservedIPOptions struct {
	// The subnet identifier.
	SubnetID *string `json:"subnet_id" validate:"required,ne="`

	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The target to bind this reserved IP to.  The target must be in the same VPC.
	//
	// At present, only endpoint gateway targets are supported.  The endpoint gateway must
	// not be already bound to a reserved IP in the subnet's zone.
	//
	// If unspecified, the reserved IP will be created unbound.
	Target ReservedIPTargetPrototypeIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubnetReservedIPOptions : Instantiate CreateSubnetReservedIPOptions
func (*VpcV1) NewCreateSubnetReservedIPOptions(subnetID string) *CreateSubnetReservedIPOptions {
	return &CreateSubnetReservedIPOptions{
		SubnetID: core.StringPtr(subnetID),
	}
}

// SetSubnetID : Allow user to set SubnetID
func (_options *CreateSubnetReservedIPOptions) SetSubnetID(subnetID string) *CreateSubnetReservedIPOptions {
	_options.SubnetID = core.StringPtr(subnetID)
	return _options
}

// SetAddress : Allow user to set Address
func (_options *CreateSubnetReservedIPOptions) SetAddress(address string) *CreateSubnetReservedIPOptions {
	_options.Address = core.StringPtr(address)
	return _options
}

// SetAutoDelete : Allow user to set AutoDelete
func (_options *CreateSubnetReservedIPOptions) SetAutoDelete(autoDelete bool) *CreateSubnetReservedIPOptions {
	_options.AutoDelete = core.BoolPtr(autoDelete)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSubnetReservedIPOptions) SetName(name string) *CreateSubnetReservedIPOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetTarget : Allow user to set Target
func (_options *CreateSubnetReservedIPOptions) SetTarget(target ReservedIPTargetPrototypeIntf) *CreateSubnetReservedIPOptions {
	_options.Target = target
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubnetReservedIPOptions) SetHeaders(param map[string]string) *CreateSubnetReservedIPOptions {
	options.Headers = param
	return options
}

// CreateVolumeOptions : The CreateVolume options.
type CreateVolumeOptions struct {
	// The volume prototype object.
	VolumePrototype VolumePrototypeIntf `json:"VolumePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVolumeOptions : Instantiate CreateVolumeOptions
func (*VpcV1) NewCreateVolumeOptions(volumePrototype VolumePrototypeIntf) *CreateVolumeOptions {
	return &CreateVolumeOptions{
		VolumePrototype: volumePrototype,
	}
}

// SetVolumePrototype : Allow user to set VolumePrototype
func (_options *CreateVolumeOptions) SetVolumePrototype(volumePrototype VolumePrototypeIntf) *CreateVolumeOptions {
	_options.VolumePrototype = volumePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVolumeOptions) SetHeaders(param map[string]string) *CreateVolumeOptions {
	options.Headers = param
	return options
}

// CreateVPCAddressPrefixOptions : The CreateVPCAddressPrefix options.
type CreateVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The IPv4 range of the address prefix, expressed in CIDR format. The range must not overlap with any existing address
	// prefixes in the VPC or any of the following reserved address ranges:
	//
	//   - `127.0.0.0/8` (IPv4 loopback addresses)
	//   - `161.26.0.0/16` (IBM services)
	//   - `166.8.0.0/14` (Cloud Service Endpoints)
	//   - `169.254.0.0/16` (IPv4 link-local addresses)
	//   - `224.0.0.0/4` (IPv4 multicast addresses)
	//
	// The prefix length of the address prefix's CIDR must be between `/9` (8,388,608 addresses) and `/29` (8 addresses).
	CIDR *string `json:"cidr" validate:"required"`

	// The zone this address prefix will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// Indicates whether this will be the default address prefix for this zone in this VPC. If `true`, the VPC must not
	// have a default address prefix for this zone.
	IsDefault *bool `json:"is_default,omitempty"`

	// The name for this address prefix. The name must not be used by another address prefix for the VPC. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPCAddressPrefixOptions : Instantiate CreateVPCAddressPrefixOptions
func (*VpcV1) NewCreateVPCAddressPrefixOptions(vpcID string, cidr string, zone ZoneIdentityIntf) *CreateVPCAddressPrefixOptions {
	return &CreateVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		CIDR:  core.StringPtr(cidr),
		Zone:  zone,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *CreateVPCAddressPrefixOptions) SetVPCID(vpcID string) *CreateVPCAddressPrefixOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetCIDR : Allow user to set CIDR
func (_options *CreateVPCAddressPrefixOptions) SetCIDR(cidr string) *CreateVPCAddressPrefixOptions {
	_options.CIDR = core.StringPtr(cidr)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateVPCAddressPrefixOptions) SetZone(zone ZoneIdentityIntf) *CreateVPCAddressPrefixOptions {
	_options.Zone = zone
	return _options
}

// SetIsDefault : Allow user to set IsDefault
func (_options *CreateVPCAddressPrefixOptions) SetIsDefault(isDefault bool) *CreateVPCAddressPrefixOptions {
	_options.IsDefault = core.BoolPtr(isDefault)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPCAddressPrefixOptions) SetName(name string) *CreateVPCAddressPrefixOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCAddressPrefixOptions) SetHeaders(param map[string]string) *CreateVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// CreateVPCDnsResolutionBindingOptions : The CreateVPCDnsResolutionBinding options.
type CreateVPCDnsResolutionBindingOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// Another VPC to bind this VPC to for DNS resolution. The VPC must have
	// `dns.enable_hub` set to `true`, and may be in a different account (subject to
	// IAM policies).
	//
	// Additionally, the VPC specified in the URL (this VPC) must have `dns.enable_hub`
	// set to `false` and a `dns.resolution_binding_count` of zero.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The name for this DNS resolution binding. The name must not be used by another DNS resolution binding for the VPC.
	// If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPCDnsResolutionBindingOptions : Instantiate CreateVPCDnsResolutionBindingOptions
func (*VpcV1) NewCreateVPCDnsResolutionBindingOptions(vpcID string, vpc VPCIdentityIntf) *CreateVPCDnsResolutionBindingOptions {
	return &CreateVPCDnsResolutionBindingOptions{
		VPCID: core.StringPtr(vpcID),
		VPC:   vpc,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *CreateVPCDnsResolutionBindingOptions) SetVPCID(vpcID string) *CreateVPCDnsResolutionBindingOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPC : Allow user to set VPC
func (_options *CreateVPCDnsResolutionBindingOptions) SetVPC(vpc VPCIdentityIntf) *CreateVPCDnsResolutionBindingOptions {
	_options.VPC = vpc
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPCDnsResolutionBindingOptions) SetName(name string) *CreateVPCDnsResolutionBindingOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCDnsResolutionBindingOptions) SetHeaders(param map[string]string) *CreateVPCDnsResolutionBindingOptions {
	options.Headers = param
	return options
}

// CreateVPCOptions : The CreateVPC options.
type CreateVPCOptions struct {
	// Indicates whether a [default address prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes)
	// will be automatically created for each zone in this VPC. If `manual`, this VPC will be created with no default
	// address prefixes.
	//
	// Since address prefixes are managed identically regardless of whether they were automatically created, the value is
	// not preserved as a VPC property.
	AddressPrefixManagement *string `json:"address_prefix_management,omitempty"`

	// Indicates whether this VPC will be connected to Classic Infrastructure. If true, this VPC's resources will have
	// private network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be
	// connected in this way. This value is set at creation and subsequently immutable.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// The DNS configuration for this VPC.
	//
	// If unspecified, the system will assign DNS servers capable of resolving hosts and endpoint
	// gateways within this VPC, and hosts on the internet.
	Dns *VpcdnsPrototype `json:"dns,omitempty"`

	// The name for this VPC. The name must not be used by another VPC in the region. If unspecified, the name will be a
	// hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPCOptions.AddressPrefixManagement property.
// Indicates whether a [default address prefix](https://cloud.ibm.com/docs/vpc?topic=vpc-configuring-address-prefixes)
// will be automatically created for each zone in this VPC. If `manual`, this VPC will be created with no default
// address prefixes.
//
// Since address prefixes are managed identically regardless of whether they were automatically created, the value is
// not preserved as a VPC property.
const (
	CreateVPCOptionsAddressPrefixManagementAutoConst   = "auto"
	CreateVPCOptionsAddressPrefixManagementManualConst = "manual"
)

// NewCreateVPCOptions : Instantiate CreateVPCOptions
func (*VpcV1) NewCreateVPCOptions() *CreateVPCOptions {
	return &CreateVPCOptions{}
}

// SetAddressPrefixManagement : Allow user to set AddressPrefixManagement
func (_options *CreateVPCOptions) SetAddressPrefixManagement(addressPrefixManagement string) *CreateVPCOptions {
	_options.AddressPrefixManagement = core.StringPtr(addressPrefixManagement)
	return _options
}

// SetClassicAccess : Allow user to set ClassicAccess
func (_options *CreateVPCOptions) SetClassicAccess(classicAccess bool) *CreateVPCOptions {
	_options.ClassicAccess = core.BoolPtr(classicAccess)
	return _options
}

// SetDns : Allow user to set Dns
func (_options *CreateVPCOptions) SetDns(dns *VpcdnsPrototype) *CreateVPCOptions {
	_options.Dns = dns
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPCOptions) SetName(name string) *CreateVPCOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateVPCOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateVPCOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCOptions) SetHeaders(param map[string]string) *CreateVPCOptions {
	options.Headers = param
	return options
}

// CreateVPCRouteOptions : The CreateVPCRoute options.
type CreateVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The destination CIDR of the route. The host identifier in the CIDR must be zero.
	//
	// At most two routes per `zone` in a table can have the same `destination` and
	// `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
	Destination *string `json:"destination" validate:"required"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to system-provided routes
	// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action,omitempty"`

	// The name for this route. The name must not be used by another route in the routing table. Names starting with `ibm-`
	// are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to. For other
	// `action` values, it must be omitted or specified as `0.0.0.0`.
	//
	// At most two routes per `zone` in a table can have the same `destination` and `priority`,
	// and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
	NextHop RoutePrototypeNextHopIntf `json:"next_hop,omitempty"`

	// The priority of this route. Smaller values have higher priority.
	//
	// If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
	// priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
	// distributed between them.
	Priority *int64 `json:"priority,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPCRouteOptions.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to system-provided routes
// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	CreateVPCRouteOptionsActionDelegateConst    = "delegate"
	CreateVPCRouteOptionsActionDelegateVPCConst = "delegate_vpc"
	CreateVPCRouteOptionsActionDeliverConst     = "deliver"
	CreateVPCRouteOptionsActionDropConst        = "drop"
)

// NewCreateVPCRouteOptions : Instantiate CreateVPCRouteOptions
func (*VpcV1) NewCreateVPCRouteOptions(vpcID string, destination string, zone ZoneIdentityIntf) *CreateVPCRouteOptions {
	return &CreateVPCRouteOptions{
		VPCID:       core.StringPtr(vpcID),
		Destination: core.StringPtr(destination),
		Zone:        zone,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *CreateVPCRouteOptions) SetVPCID(vpcID string) *CreateVPCRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetDestination : Allow user to set Destination
func (_options *CreateVPCRouteOptions) SetDestination(destination string) *CreateVPCRouteOptions {
	_options.Destination = core.StringPtr(destination)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateVPCRouteOptions) SetZone(zone ZoneIdentityIntf) *CreateVPCRouteOptions {
	_options.Zone = zone
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateVPCRouteOptions) SetAction(action string) *CreateVPCRouteOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPCRouteOptions) SetName(name string) *CreateVPCRouteOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNextHop : Allow user to set NextHop
func (_options *CreateVPCRouteOptions) SetNextHop(nextHop RoutePrototypeNextHopIntf) *CreateVPCRouteOptions {
	_options.NextHop = nextHop
	return _options
}

// SetPriority : Allow user to set Priority
func (_options *CreateVPCRouteOptions) SetPriority(priority int64) *CreateVPCRouteOptions {
	_options.Priority = core.Int64Ptr(priority)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCRouteOptions) SetHeaders(param map[string]string) *CreateVPCRouteOptions {
	options.Headers = param
	return options
}

// CreateVPCRoutingTableOptions : The CreateVPCRoutingTable options.
type CreateVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The filters specifying the resources that may create routes in this routing table.
	//
	// At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but filter
	// support is expected to expand in the future.
	AcceptRoutesFrom []ResourceFilter `json:"accept_routes_from,omitempty"`

	// The name for this routing table. The name must not be used by another routing table in the VPC. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// If set to `true`, this routing table will be used to route traffic that originates from [Direct
	// Link](https://cloud.ibm.com/docs/dl) to this VPC. The VPC must not already have a routing table with this property
	// set to `true`.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	//
	// If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is enabled
	// for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to this routing
	// table.
	RouteDirectLinkIngress *bool `json:"route_direct_link_ingress,omitempty"`

	// If set to `true`, this routing table will be used to route traffic that originates from the internet. For this to
	// succeed, the VPC must not already have a routing table with this property set to `true`.
	//
	// Incoming traffic will be routed according to the routing table with two exceptions:
	// - Traffic destined for IP addresses associated with public gateways will not be
	//   subject to routes in this routing table.
	// - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
	//   an IP address in a subnet in the route's `zone` that is able to accept traffic.
	//   Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	//   connection, the packet will be dropped.
	RouteInternetIngress *bool `json:"route_internet_ingress,omitempty"`

	// If set to `true`, this routing table will be used to route traffic that originates from [Transit
	// Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. The VPC must not already have a routing table with
	// this property set to `true`.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteTransitGatewayIngress *bool `json:"route_transit_gateway_ingress,omitempty"`

	// If set to `true`, this routing table will be used to route traffic that originates from subnets in other zones in
	// this VPC. The VPC must not already have a routing table with this property set to `true`.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteVPCZoneIngress *bool `json:"route_vpc_zone_ingress,omitempty"`

	// The prototype objects for routes to create for this routing table. If unspecified, the routing table will be created
	// with no routes.
	Routes []RoutePrototype `json:"routes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPCRoutingTableOptions : Instantiate CreateVPCRoutingTableOptions
func (*VpcV1) NewCreateVPCRoutingTableOptions(vpcID string) *CreateVPCRoutingTableOptions {
	return &CreateVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *CreateVPCRoutingTableOptions) SetVPCID(vpcID string) *CreateVPCRoutingTableOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetAcceptRoutesFrom : Allow user to set AcceptRoutesFrom
func (_options *CreateVPCRoutingTableOptions) SetAcceptRoutesFrom(acceptRoutesFrom []ResourceFilter) *CreateVPCRoutingTableOptions {
	_options.AcceptRoutesFrom = acceptRoutesFrom
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPCRoutingTableOptions) SetName(name string) *CreateVPCRoutingTableOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRouteDirectLinkIngress : Allow user to set RouteDirectLinkIngress
func (_options *CreateVPCRoutingTableOptions) SetRouteDirectLinkIngress(routeDirectLinkIngress bool) *CreateVPCRoutingTableOptions {
	_options.RouteDirectLinkIngress = core.BoolPtr(routeDirectLinkIngress)
	return _options
}

// SetRouteInternetIngress : Allow user to set RouteInternetIngress
func (_options *CreateVPCRoutingTableOptions) SetRouteInternetIngress(routeInternetIngress bool) *CreateVPCRoutingTableOptions {
	_options.RouteInternetIngress = core.BoolPtr(routeInternetIngress)
	return _options
}

// SetRouteTransitGatewayIngress : Allow user to set RouteTransitGatewayIngress
func (_options *CreateVPCRoutingTableOptions) SetRouteTransitGatewayIngress(routeTransitGatewayIngress bool) *CreateVPCRoutingTableOptions {
	_options.RouteTransitGatewayIngress = core.BoolPtr(routeTransitGatewayIngress)
	return _options
}

// SetRouteVPCZoneIngress : Allow user to set RouteVPCZoneIngress
func (_options *CreateVPCRoutingTableOptions) SetRouteVPCZoneIngress(routeVPCZoneIngress bool) *CreateVPCRoutingTableOptions {
	_options.RouteVPCZoneIngress = core.BoolPtr(routeVPCZoneIngress)
	return _options
}

// SetRoutes : Allow user to set Routes
func (_options *CreateVPCRoutingTableOptions) SetRoutes(routes []RoutePrototype) *CreateVPCRoutingTableOptions {
	_options.Routes = routes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCRoutingTableOptions) SetHeaders(param map[string]string) *CreateVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// CreateVPCRoutingTableRouteOptions : The CreateVPCRoutingTableRoute options.
type CreateVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required,ne="`

	// The destination CIDR of the route. The host identifier in the CIDR must be zero.
	//
	// At most two routes per `zone` in a table can have the same `destination` and
	// `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
	Destination *string `json:"destination" validate:"required"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to system-provided routes
	// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action,omitempty"`

	// The name for this route. The name must not be used by another route in the routing table. Names starting with `ibm-`
	// are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to. For other
	// `action` values, it must be omitted or specified as `0.0.0.0`.
	//
	// At most two routes per `zone` in a table can have the same `destination` and `priority`,
	// and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
	NextHop RoutePrototypeNextHopIntf `json:"next_hop,omitempty"`

	// The priority of this route. Smaller values have higher priority.
	//
	// If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
	// priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
	// distributed between them.
	Priority *int64 `json:"priority,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPCRoutingTableRouteOptions.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to system-provided routes
// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	CreateVPCRoutingTableRouteOptionsActionDelegateConst    = "delegate"
	CreateVPCRoutingTableRouteOptionsActionDelegateVPCConst = "delegate_vpc"
	CreateVPCRoutingTableRouteOptionsActionDeliverConst     = "deliver"
	CreateVPCRoutingTableRouteOptionsActionDropConst        = "drop"
)

// NewCreateVPCRoutingTableRouteOptions : Instantiate CreateVPCRoutingTableRouteOptions
func (*VpcV1) NewCreateVPCRoutingTableRouteOptions(vpcID string, routingTableID string, destination string, zone ZoneIdentityIntf) *CreateVPCRoutingTableRouteOptions {
	return &CreateVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		Destination:    core.StringPtr(destination),
		Zone:           zone,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *CreateVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *CreateVPCRoutingTableRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (_options *CreateVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *CreateVPCRoutingTableRouteOptions {
	_options.RoutingTableID = core.StringPtr(routingTableID)
	return _options
}

// SetDestination : Allow user to set Destination
func (_options *CreateVPCRoutingTableRouteOptions) SetDestination(destination string) *CreateVPCRoutingTableRouteOptions {
	_options.Destination = core.StringPtr(destination)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateVPCRoutingTableRouteOptions) SetZone(zone ZoneIdentityIntf) *CreateVPCRoutingTableRouteOptions {
	_options.Zone = zone
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateVPCRoutingTableRouteOptions) SetAction(action string) *CreateVPCRoutingTableRouteOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPCRoutingTableRouteOptions) SetName(name string) *CreateVPCRoutingTableRouteOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNextHop : Allow user to set NextHop
func (_options *CreateVPCRoutingTableRouteOptions) SetNextHop(nextHop RoutePrototypeNextHopIntf) *CreateVPCRoutingTableRouteOptions {
	_options.NextHop = nextHop
	return _options
}

// SetPriority : Allow user to set Priority
func (_options *CreateVPCRoutingTableRouteOptions) SetPriority(priority int64) *CreateVPCRoutingTableRouteOptions {
	_options.Priority = core.Int64Ptr(priority)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *CreateVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// CreateVPNGatewayConnectionOptions : The CreateVPNGatewayConnection options.
type CreateVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection prototype object.
	VPNGatewayConnectionPrototype VPNGatewayConnectionPrototypeIntf `json:"VPNGatewayConnectionPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPNGatewayConnectionOptions : Instantiate CreateVPNGatewayConnectionOptions
func (*VpcV1) NewCreateVPNGatewayConnectionOptions(vpnGatewayID string, vpnGatewayConnectionPrototype VPNGatewayConnectionPrototypeIntf) *CreateVPNGatewayConnectionOptions {
	return &CreateVPNGatewayConnectionOptions{
		VPNGatewayID:                  core.StringPtr(vpnGatewayID),
		VPNGatewayConnectionPrototype: vpnGatewayConnectionPrototype,
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *CreateVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *CreateVPNGatewayConnectionOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetVPNGatewayConnectionPrototype : Allow user to set VPNGatewayConnectionPrototype
func (_options *CreateVPNGatewayConnectionOptions) SetVPNGatewayConnectionPrototype(vpnGatewayConnectionPrototype VPNGatewayConnectionPrototypeIntf) *CreateVPNGatewayConnectionOptions {
	_options.VPNGatewayConnectionPrototype = vpnGatewayConnectionPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *CreateVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// CreateVPNGatewayOptions : The CreateVPNGateway options.
type CreateVPNGatewayOptions struct {
	// The VPN gateway prototype object.
	VPNGatewayPrototype VPNGatewayPrototypeIntf `json:"VPNGatewayPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPNGatewayOptions : Instantiate CreateVPNGatewayOptions
func (*VpcV1) NewCreateVPNGatewayOptions(vpnGatewayPrototype VPNGatewayPrototypeIntf) *CreateVPNGatewayOptions {
	return &CreateVPNGatewayOptions{
		VPNGatewayPrototype: vpnGatewayPrototype,
	}
}

// SetVPNGatewayPrototype : Allow user to set VPNGatewayPrototype
func (_options *CreateVPNGatewayOptions) SetVPNGatewayPrototype(vpnGatewayPrototype VPNGatewayPrototypeIntf) *CreateVPNGatewayOptions {
	_options.VPNGatewayPrototype = vpnGatewayPrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPNGatewayOptions) SetHeaders(param map[string]string) *CreateVPNGatewayOptions {
	options.Headers = param
	return options
}

// CreateVPNServerOptions : The CreateVPNServer options.
type CreateVPNServerOptions struct {
	// The certificate instance for this VPN server.
	Certificate CertificateInstanceIdentityIntf `json:"certificate" validate:"required"`

	// The methods used to authenticate VPN clients to this VPN server. VPN clients must authenticate against all specified
	// methods.
	ClientAuthentication []VPNServerAuthenticationPrototypeIntf `json:"client_authentication" validate:"required"`

	// The VPN client IPv4 address pool, expressed in CIDR format. The request must not overlap with any existing address
	// prefixes in the VPC or any of the following reserved address ranges:
	//   - `127.0.0.0/8` (IPv4 loopback addresses)
	//   - `161.26.0.0/16` (IBM services)
	//   - `166.8.0.0/14` (Cloud Service Endpoints)
	//   - `169.254.0.0/16` (IPv4 link-local addresses)
	//   - `224.0.0.0/4` (IPv4 multicast addresses)
	//
	// The prefix length of the client IP address pool's CIDR must be between
	// `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP addresses
	// that are required to enable the maximum number of concurrent connections is recommended.
	ClientIPPool *string `json:"client_ip_pool" validate:"required"`

	// The subnets to provision this VPN server in.  Use subnets in different zones for high availability.
	Subnets []SubnetIdentityIntf `json:"subnets" validate:"required"`

	// The DNS server addresses that will be provided to VPN clients connected to this VPN server.
	ClientDnsServerIps []IP `json:"client_dns_server_ips,omitempty"`

	// The seconds a VPN client can be idle before this VPN server will disconnect it.   Specify `0` to prevent the server
	// from disconnecting idle clients.
	ClientIdleTimeout *int64 `json:"client_idle_timeout,omitempty"`

	// Indicates whether the split tunneling is enabled on this VPN server.
	EnableSplitTunneling *bool `json:"enable_split_tunneling,omitempty"`

	// The name for this VPN server. The name must not be used by another VPN server in the VPC. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The port number to use for this VPN server.
	Port *int64 `json:"port,omitempty"`

	// The transport protocol to use for this VPN server.
	Protocol *string `json:"protocol,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The security groups to use for this VPN server. If unspecified, the VPC's default security group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPNServerOptions.Protocol property.
// The transport protocol to use for this VPN server.
const (
	CreateVPNServerOptionsProtocolTCPConst = "tcp"
	CreateVPNServerOptionsProtocolUDPConst = "udp"
)

// NewCreateVPNServerOptions : Instantiate CreateVPNServerOptions
func (*VpcV1) NewCreateVPNServerOptions(certificate CertificateInstanceIdentityIntf, clientAuthentication []VPNServerAuthenticationPrototypeIntf, clientIPPool string, subnets []SubnetIdentityIntf) *CreateVPNServerOptions {
	return &CreateVPNServerOptions{
		Certificate:          certificate,
		ClientAuthentication: clientAuthentication,
		ClientIPPool:         core.StringPtr(clientIPPool),
		Subnets:              subnets,
	}
}

// SetCertificate : Allow user to set Certificate
func (_options *CreateVPNServerOptions) SetCertificate(certificate CertificateInstanceIdentityIntf) *CreateVPNServerOptions {
	_options.Certificate = certificate
	return _options
}

// SetClientAuthentication : Allow user to set ClientAuthentication
func (_options *CreateVPNServerOptions) SetClientAuthentication(clientAuthentication []VPNServerAuthenticationPrototypeIntf) *CreateVPNServerOptions {
	_options.ClientAuthentication = clientAuthentication
	return _options
}

// SetClientIPPool : Allow user to set ClientIPPool
func (_options *CreateVPNServerOptions) SetClientIPPool(clientIPPool string) *CreateVPNServerOptions {
	_options.ClientIPPool = core.StringPtr(clientIPPool)
	return _options
}

// SetSubnets : Allow user to set Subnets
func (_options *CreateVPNServerOptions) SetSubnets(subnets []SubnetIdentityIntf) *CreateVPNServerOptions {
	_options.Subnets = subnets
	return _options
}

// SetClientDnsServerIps : Allow user to set ClientDnsServerIps
func (_options *CreateVPNServerOptions) SetClientDnsServerIps(clientDnsServerIps []IP) *CreateVPNServerOptions {
	_options.ClientDnsServerIps = clientDnsServerIps
	return _options
}

// SetClientIdleTimeout : Allow user to set ClientIdleTimeout
func (_options *CreateVPNServerOptions) SetClientIdleTimeout(clientIdleTimeout int64) *CreateVPNServerOptions {
	_options.ClientIdleTimeout = core.Int64Ptr(clientIdleTimeout)
	return _options
}

// SetEnableSplitTunneling : Allow user to set EnableSplitTunneling
func (_options *CreateVPNServerOptions) SetEnableSplitTunneling(enableSplitTunneling bool) *CreateVPNServerOptions {
	_options.EnableSplitTunneling = core.BoolPtr(enableSplitTunneling)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPNServerOptions) SetName(name string) *CreateVPNServerOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPort : Allow user to set Port
func (_options *CreateVPNServerOptions) SetPort(port int64) *CreateVPNServerOptions {
	_options.Port = core.Int64Ptr(port)
	return _options
}

// SetProtocol : Allow user to set Protocol
func (_options *CreateVPNServerOptions) SetProtocol(protocol string) *CreateVPNServerOptions {
	_options.Protocol = core.StringPtr(protocol)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateVPNServerOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateVPNServerOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (_options *CreateVPNServerOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateVPNServerOptions {
	_options.SecurityGroups = securityGroups
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPNServerOptions) SetHeaders(param map[string]string) *CreateVPNServerOptions {
	options.Headers = param
	return options
}

// CreateVPNServerRouteOptions : The CreateVPNServerRoute options.
type CreateVPNServerRouteOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The destination to use for this VPN route in the VPN server. Must be unique within the VPN server. If an incoming
	// packet does not match any destination, it will be dropped.
	Destination *string `json:"destination" validate:"required"`

	// The action to perform with a packet matching the VPN route:
	// - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then deliver
	// the packet to target.
	// - `deliver`: deliver the packet to the target.
	// - `drop`: drop the packet
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on which the
	// unexpected property value was encountered.
	Action *string `json:"action,omitempty"`

	// The name for this VPN server route. The name must not be used by another route for the VPN server. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPNServerRouteOptions.Action property.
// The action to perform with a packet matching the VPN route:
// - `translate`: translate the source IP address to one of the private IP addresses of the VPN server, then deliver the
// packet to target.
// - `deliver`: deliver the packet to the target.
// - `drop`: drop the packet
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on which the
// unexpected property value was encountered.
const (
	CreateVPNServerRouteOptionsActionDeliverConst   = "deliver"
	CreateVPNServerRouteOptionsActionDropConst      = "drop"
	CreateVPNServerRouteOptionsActionTranslateConst = "translate"
)

// NewCreateVPNServerRouteOptions : Instantiate CreateVPNServerRouteOptions
func (*VpcV1) NewCreateVPNServerRouteOptions(vpnServerID string, destination string) *CreateVPNServerRouteOptions {
	return &CreateVPNServerRouteOptions{
		VPNServerID: core.StringPtr(vpnServerID),
		Destination: core.StringPtr(destination),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *CreateVPNServerRouteOptions) SetVPNServerID(vpnServerID string) *CreateVPNServerRouteOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetDestination : Allow user to set Destination
func (_options *CreateVPNServerRouteOptions) SetDestination(destination string) *CreateVPNServerRouteOptions {
	_options.Destination = core.StringPtr(destination)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateVPNServerRouteOptions) SetAction(action string) *CreateVPNServerRouteOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateVPNServerRouteOptions) SetName(name string) *CreateVPNServerRouteOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPNServerRouteOptions) SetHeaders(param map[string]string) *CreateVPNServerRouteOptions {
	options.Headers = param
	return options
}

// DnsInstanceIdentity : Identifies a DNS instance by a unique property.
// Models which "extend" this model:
// - DnsInstanceIdentityByCRN
type DnsInstanceIdentity struct {
	// The CRN for this DNS instance.
	CRN *string `json:"crn,omitempty"`
}

func (*DnsInstanceIdentity) isaDnsInstanceIdentity() bool {
	return true
}

type DnsInstanceIdentityIntf interface {
	isaDnsInstanceIdentity() bool
}

// UnmarshalDnsInstanceIdentity unmarshals an instance of DnsInstanceIdentity from the specified map of raw messages.
func UnmarshalDnsInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsInstanceReference : DnsInstanceReference struct
type DnsInstanceReference struct {
	// The CRN for this DNS instance.
	CRN *string `json:"crn" validate:"required"`
}

// UnmarshalDnsInstanceReference unmarshals an instance of DnsInstanceReference from the specified map of raw messages.
func UnmarshalDnsInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsServer : A DNS server.
type DnsServer struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`

	// If present, DHCP configuration for this zone will have this DNS server listed first.
	ZoneAffinity *ZoneReference `json:"zone_affinity,omitempty"`
}

// UnmarshalDnsServer unmarshals an instance of DnsServer from the specified map of raw messages.
func UnmarshalDnsServer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsServer)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone_affinity", &obj.ZoneAffinity, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsServerPrototype : DnsServerPrototype struct
type DnsServerPrototype struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`

	// DHCP configuration for the specified zone will have this DNS server listed first.
	ZoneAffinity ZoneIdentityIntf `json:"zone_affinity,omitempty"`
}

// NewDnsServerPrototype : Instantiate DnsServerPrototype (Generic Model Constructor)
func (*VpcV1) NewDnsServerPrototype(address string) (_model *DnsServerPrototype, err error) {
	_model = &DnsServerPrototype{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalDnsServerPrototype unmarshals an instance of DnsServerPrototype from the specified map of raw messages.
func UnmarshalDnsServerPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsServerPrototype)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone_affinity", &obj.ZoneAffinity, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsZoneIdentity : Identifies a DNS zone by a unique property.
// Models which "extend" this model:
// - DnsZoneIdentityByID
type DnsZoneIdentity struct {
	ID *string `json:"id,omitempty"`
}

func (*DnsZoneIdentity) isaDnsZoneIdentity() bool {
	return true
}

type DnsZoneIdentityIntf interface {
	isaDnsZoneIdentity() bool
}

// UnmarshalDnsZoneIdentity unmarshals an instance of DnsZoneIdentity from the specified map of raw messages.
func UnmarshalDnsZoneIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsZoneIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsZoneReference : DnsZoneReference struct
type DnsZoneReference struct {
	ID *string `json:"id" validate:"required"`
}

// UnmarshalDnsZoneReference unmarshals an instance of DnsZoneReference from the specified map of raw messages.
func UnmarshalDnsZoneReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsZoneReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHost : DedicatedHost struct
type DedicatedHost struct {
	// The amount of memory in gibibytes that is currently available for instances.
	AvailableMemory *int64 `json:"available_memory" validate:"required"`

	// The available VCPU for the dedicated host.
	AvailableVcpu *Vcpu `json:"available_vcpu" validate:"required"`

	// The date and time that the dedicated host was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`

	// Collection of the dedicated host's disks.
	Disks []DedicatedHostDisk `json:"disks" validate:"required"`

	// The dedicated host group this dedicated host is in.
	Group *DedicatedHostGroupReference `json:"group" validate:"required"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`

	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled" validate:"required"`

	// The instances that are allocated to this dedicated host.
	Instances []InstanceReference `json:"instances" validate:"required"`

	// The lifecycle state of the dedicated host.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The total amount of memory in gibibytes for this host.
	Memory *int64 `json:"memory" validate:"required"`

	// The name for this dedicated host. The name is unique across all dedicated hosts in the region.
	Name *string `json:"name" validate:"required"`

	// The dedicated host NUMA configuration.
	Numa *DedicatedHostNuma `json:"numa" validate:"required"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) for this
	// dedicated host.
	Profile *DedicatedHostProfileReference `json:"profile" validate:"required"`

	// Indicates whether this dedicated host is available for instance creation.
	Provisionable *bool `json:"provisionable" validate:"required"`

	// The resource group for this dedicated host.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The total number of sockets for this host.
	SocketCount *int64 `json:"socket_count" validate:"required"`

	// The administrative state of the dedicated host.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the dedicated host on which
	// the unexpected property value was encountered.
	State *string `json:"state" validate:"required"`

	// The instance profiles usable by instances placed on this dedicated host.
	SupportedInstanceProfiles []InstanceProfileReference `json:"supported_instance_profiles" validate:"required"`

	// The total VCPU of the dedicated host.
	Vcpu *Vcpu `json:"vcpu" validate:"required"`

	// The zone this dedicated host resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the DedicatedHost.LifecycleState property.
// The lifecycle state of the dedicated host.
const (
	DedicatedHostLifecycleStateDeletingConst  = "deleting"
	DedicatedHostLifecycleStateFailedConst    = "failed"
	DedicatedHostLifecycleStatePendingConst   = "pending"
	DedicatedHostLifecycleStateStableConst    = "stable"
	DedicatedHostLifecycleStateSuspendedConst = "suspended"
	DedicatedHostLifecycleStateUpdatingConst  = "updating"
	DedicatedHostLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the DedicatedHost.ResourceType property.
// The resource type.
const (
	DedicatedHostResourceTypeDedicatedHostConst = "dedicated_host"
)

// Constants associated with the DedicatedHost.State property.
// The administrative state of the dedicated host.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the dedicated host on which
// the unexpected property value was encountered.
const (
	DedicatedHostStateAvailableConst   = "available"
	DedicatedHostStateDegradedConst    = "degraded"
	DedicatedHostStateMigratingConst   = "migrating"
	DedicatedHostStateUnavailableConst = "unavailable"
)

// UnmarshalDedicatedHost unmarshals an instance of DedicatedHost from the specified map of raw messages.
func UnmarshalDedicatedHost(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHost)
	err = core.UnmarshalPrimitive(m, "available_memory", &obj.AvailableMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "available_vcpu", &obj.AvailableVcpu, UnmarshalVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalDedicatedHostDisk)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalDedicatedHostGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_placement_enabled", &obj.InstancePlacementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instances", &obj.Instances, UnmarshalInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "numa", &obj.Numa, UnmarshalDedicatedHostNuma)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalDedicatedHostProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisionable", &obj.Provisionable)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "socket_count", &obj.SocketCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_instance_profiles", &obj.SupportedInstanceProfiles, UnmarshalInstanceProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu", &obj.Vcpu, UnmarshalVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostCollection : DedicatedHostCollection struct
type DedicatedHostCollection struct {
	// Collection of dedicated hosts.
	DedicatedHosts []DedicatedHost `json:"dedicated_hosts" validate:"required"`

	// A link to the first page of resources.
	First *DedicatedHostCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *DedicatedHostCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalDedicatedHostCollection unmarshals an instance of DedicatedHostCollection from the specified map of raw messages.
func UnmarshalDedicatedHostCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostCollection)
	err = core.UnmarshalModel(m, "dedicated_hosts", &obj.DedicatedHosts, UnmarshalDedicatedHost)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalDedicatedHostCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalDedicatedHostCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *DedicatedHostCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// DedicatedHostCollectionFirst : A link to the first page of resources.
type DedicatedHostCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostCollectionFirst unmarshals an instance of DedicatedHostCollectionFirst from the specified map of raw messages.
func UnmarshalDedicatedHostCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type DedicatedHostCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostCollectionNext unmarshals an instance of DedicatedHostCollectionNext from the specified map of raw messages.
func UnmarshalDedicatedHostCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostDisk : DedicatedHostDisk struct
type DedicatedHostDisk struct {
	// The remaining space left for instance placement in GB (gigabytes).
	Available *int64 `json:"available" validate:"required"`

	// The date and time that the disk was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this disk.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this disk.
	ID *string `json:"id" validate:"required"`

	// Instance disks that are on this dedicated host disk.
	InstanceDisks []InstanceDiskReference `json:"instance_disks" validate:"required"`

	// The disk interface used for attaching the disk
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// The lifecycle state of this dedicated host disk.
	LifecycleState *string `json:"lifecycle_state,omitempty"`

	// The name for this dedicated host disk. The name is unique across all disks on the dedicated host.
	Name *string `json:"name" validate:"required"`

	// Indicates whether this dedicated host disk is available for instance disk creation.
	Provisionable *bool `json:"provisionable" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The size of the disk in GB (gigabytes).
	Size *int64 `json:"size" validate:"required"`

	// The instance disk interfaces supported for this dedicated host disk.
	SupportedInstanceInterfaceTypes []string `json:"supported_instance_interface_types" validate:"required"`
}

// Constants associated with the DedicatedHostDisk.InterfaceType property.
// The disk interface used for attaching the disk
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	DedicatedHostDiskInterfaceTypeNvmeConst = "nvme"
)

// Constants associated with the DedicatedHostDisk.LifecycleState property.
// The lifecycle state of this dedicated host disk.
const (
	DedicatedHostDiskLifecycleStateDeletingConst  = "deleting"
	DedicatedHostDiskLifecycleStateFailedConst    = "failed"
	DedicatedHostDiskLifecycleStatePendingConst   = "pending"
	DedicatedHostDiskLifecycleStateStableConst    = "stable"
	DedicatedHostDiskLifecycleStateSuspendedConst = "suspended"
	DedicatedHostDiskLifecycleStateUpdatingConst  = "updating"
	DedicatedHostDiskLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the DedicatedHostDisk.ResourceType property.
// The resource type.
const (
	DedicatedHostDiskResourceTypeDedicatedHostDiskConst = "dedicated_host_disk"
)

// Constants associated with the DedicatedHostDisk.SupportedInstanceInterfaceTypes property.
// The disk interface used for attaching the disk.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	DedicatedHostDiskSupportedInstanceInterfaceTypesNvmeConst      = "nvme"
	DedicatedHostDiskSupportedInstanceInterfaceTypesVirtioBlkConst = "virtio_blk"
)

// UnmarshalDedicatedHostDisk unmarshals an instance of DedicatedHostDisk from the specified map of raw messages.
func UnmarshalDedicatedHostDisk(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostDisk)
	err = core.UnmarshalPrimitive(m, "available", &obj.Available)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_disks", &obj.InstanceDisks, UnmarshalInstanceDiskReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisionable", &obj.Provisionable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_instance_interface_types", &obj.SupportedInstanceInterfaceTypes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostDiskCollection : DedicatedHostDiskCollection struct
type DedicatedHostDiskCollection struct {
	// Collection of the dedicated host's disks.
	Disks []DedicatedHostDisk `json:"disks" validate:"required"`
}

// UnmarshalDedicatedHostDiskCollection unmarshals an instance of DedicatedHostDiskCollection from the specified map of raw messages.
func UnmarshalDedicatedHostDiskCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostDiskCollection)
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalDedicatedHostDisk)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostDiskPatch : DedicatedHostDiskPatch struct
type DedicatedHostDiskPatch struct {
	// The name for this dedicated host disk. The name must not be used by another disk on the dedicated host.
	Name *string `json:"name,omitempty"`
}

// UnmarshalDedicatedHostDiskPatch unmarshals an instance of DedicatedHostDiskPatch from the specified map of raw messages.
func UnmarshalDedicatedHostDiskPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostDiskPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the DedicatedHostDiskPatch
func (dedicatedHostDiskPatch *DedicatedHostDiskPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(dedicatedHostDiskPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// DedicatedHostGroup : DedicatedHostGroup struct
type DedicatedHostGroup struct {
	// The dedicated host profile class for hosts in this group.
	Class *string `json:"class" validate:"required"`

	// The date and time that the dedicated host group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`

	// The dedicated hosts that are in this dedicated host group.
	DedicatedHosts []DedicatedHostReference `json:"dedicated_hosts" validate:"required"`

	// The dedicated host profile family for hosts in this group.
	Family *string `json:"family" validate:"required"`

	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`

	// The name for this dedicated host group. The name is unique across all dedicated host groups in the region.
	Name *string `json:"name" validate:"required"`

	// The resource group for this dedicated host group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The instance profiles usable by instances placed on this dedicated host group.
	SupportedInstanceProfiles []InstanceProfileReference `json:"supported_instance_profiles" validate:"required"`

	// The zone this dedicated host group resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the DedicatedHostGroup.Family property.
// The dedicated host profile family for hosts in this group.
const (
	DedicatedHostGroupFamilyBalancedConst = "balanced"
	DedicatedHostGroupFamilyComputeConst  = "compute"
	DedicatedHostGroupFamilyMemoryConst   = "memory"
)

// Constants associated with the DedicatedHostGroup.ResourceType property.
// The resource type.
const (
	DedicatedHostGroupResourceTypeDedicatedHostGroupConst = "dedicated_host_group"
)

// UnmarshalDedicatedHostGroup unmarshals an instance of DedicatedHostGroup from the specified map of raw messages.
func UnmarshalDedicatedHostGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroup)
	err = core.UnmarshalPrimitive(m, "class", &obj.Class)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dedicated_hosts", &obj.DedicatedHosts, UnmarshalDedicatedHostReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_instance_profiles", &obj.SupportedInstanceProfiles, UnmarshalInstanceProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupCollection : DedicatedHostGroupCollection struct
type DedicatedHostGroupCollection struct {
	// A link to the first page of resources.
	First *DedicatedHostGroupCollectionFirst `json:"first" validate:"required"`

	// Collection of dedicated host groups.
	Groups []DedicatedHostGroup `json:"groups" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *DedicatedHostGroupCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalDedicatedHostGroupCollection unmarshals an instance of DedicatedHostGroupCollection from the specified map of raw messages.
func UnmarshalDedicatedHostGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalDedicatedHostGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "groups", &obj.Groups, UnmarshalDedicatedHostGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalDedicatedHostGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *DedicatedHostGroupCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// DedicatedHostGroupCollectionFirst : A link to the first page of resources.
type DedicatedHostGroupCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostGroupCollectionFirst unmarshals an instance of DedicatedHostGroupCollectionFirst from the specified map of raw messages.
func UnmarshalDedicatedHostGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type DedicatedHostGroupCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostGroupCollectionNext unmarshals an instance of DedicatedHostGroupCollectionNext from the specified map of raw messages.
func UnmarshalDedicatedHostGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupIdentity : Identifies a dedicated host group by a unique property.
// Models which "extend" this model:
// - DedicatedHostGroupIdentityByID
// - DedicatedHostGroupIdentityByCRN
// - DedicatedHostGroupIdentityByHref
type DedicatedHostGroupIdentity struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`
}

func (*DedicatedHostGroupIdentity) isaDedicatedHostGroupIdentity() bool {
	return true
}

type DedicatedHostGroupIdentityIntf interface {
	isaDedicatedHostGroupIdentity() bool
}

// UnmarshalDedicatedHostGroupIdentity unmarshals an instance of DedicatedHostGroupIdentity from the specified map of raw messages.
func UnmarshalDedicatedHostGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupPatch : DedicatedHostGroupPatch struct
type DedicatedHostGroupPatch struct {
	// The name for this dedicated host group. The name must not be used by another dedicated host group in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalDedicatedHostGroupPatch unmarshals an instance of DedicatedHostGroupPatch from the specified map of raw messages.
func UnmarshalDedicatedHostGroupPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the DedicatedHostGroupPatch
func (dedicatedHostGroupPatch *DedicatedHostGroupPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(dedicatedHostGroupPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// DedicatedHostGroupPrototypeDedicatedHostByZoneContext : DedicatedHostGroupPrototypeDedicatedHostByZoneContext struct
type DedicatedHostGroupPrototypeDedicatedHostByZoneContext struct {
	// The name for this dedicated host group. The name must not be used by another dedicated host group in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the host's resource group is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

// UnmarshalDedicatedHostGroupPrototypeDedicatedHostByZoneContext unmarshals an instance of DedicatedHostGroupPrototypeDedicatedHostByZoneContext from the specified map of raw messages.
func UnmarshalDedicatedHostGroupPrototypeDedicatedHostByZoneContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupPrototypeDedicatedHostByZoneContext)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupReference : DedicatedHostGroupReference struct
type DedicatedHostGroupReference struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *DedicatedHostGroupReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`

	// The name for this dedicated host group. The name is unique across all dedicated host groups in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the DedicatedHostGroupReference.ResourceType property.
// The resource type.
const (
	DedicatedHostGroupReferenceResourceTypeDedicatedHostGroupConst = "dedicated_host_group"
)

// UnmarshalDedicatedHostGroupReference unmarshals an instance of DedicatedHostGroupReference from the specified map of raw messages.
func UnmarshalDedicatedHostGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalDedicatedHostGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type DedicatedHostGroupReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalDedicatedHostGroupReferenceDeleted unmarshals an instance of DedicatedHostGroupReferenceDeleted from the specified map of raw messages.
func UnmarshalDedicatedHostGroupReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostNuma : The dedicated host NUMA configuration.
type DedicatedHostNuma struct {
	// The total number of NUMA nodes for this dedicated host.
	Count *int64 `json:"count" validate:"required"`

	// The NUMA nodes for this dedicated host.
	Nodes []DedicatedHostNumaNode `json:"nodes" validate:"required"`
}

// UnmarshalDedicatedHostNuma unmarshals an instance of DedicatedHostNuma from the specified map of raw messages.
func UnmarshalDedicatedHostNuma(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostNuma)
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "nodes", &obj.Nodes, UnmarshalDedicatedHostNumaNode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostNumaNode : The dedicated host NUMA node configuration.
type DedicatedHostNumaNode struct {
	// The available VCPU for this NUMA node.
	AvailableVcpu *int64 `json:"available_vcpu" validate:"required"`

	// The total VCPU capacity for this NUMA node.
	Vcpu *int64 `json:"vcpu" validate:"required"`
}

// UnmarshalDedicatedHostNumaNode unmarshals an instance of DedicatedHostNumaNode from the specified map of raw messages.
func UnmarshalDedicatedHostNumaNode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostNumaNode)
	err = core.UnmarshalPrimitive(m, "available_vcpu", &obj.AvailableVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vcpu", &obj.Vcpu)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPatch : DedicatedHostPatch struct
type DedicatedHostPatch struct {
	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled,omitempty"`

	// The name for this dedicated host. The name must not be used by another dedicated host in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalDedicatedHostPatch unmarshals an instance of DedicatedHostPatch from the specified map of raw messages.
func UnmarshalDedicatedHostPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPatch)
	err = core.UnmarshalPrimitive(m, "instance_placement_enabled", &obj.InstancePlacementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the DedicatedHostPatch
func (dedicatedHostPatch *DedicatedHostPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(dedicatedHostPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// DedicatedHostProfile : DedicatedHostProfile struct
type DedicatedHostProfile struct {
	// The product class this dedicated host profile belongs to.
	Class *string `json:"class" validate:"required"`

	// Collection of the dedicated host profile's disks.
	Disks []DedicatedHostProfileDisk `json:"disks" validate:"required"`

	// The product family this dedicated host profile belongs to
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	Family *string `json:"family" validate:"required"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	Memory DedicatedHostProfileMemoryIntf `json:"memory" validate:"required"`

	// The globally unique name for this dedicated host profile.
	Name *string `json:"name" validate:"required"`

	SocketCount DedicatedHostProfileSocketIntf `json:"socket_count" validate:"required"`

	// The status of the dedicated host profile:
	//   - `previous`:  This dedicated host profile is an older revision, but remains provisionable
	//   and usable.
	//   - `current`:  This profile is the latest revision.
	//
	// Note that revisions are indicated by the generation of a dedicated host profile.  Refer to the [profile naming
	// conventions]
	// (https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles&interface=ui#profiles-naming-rule) for information on how
	// generations are defined within a dedicated host profile.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the profile on which the
	// unexpected property value was encountered.
	Status *string `json:"status" validate:"required"`

	// The instance profiles usable by instances placed on dedicated hosts with this profile.
	SupportedInstanceProfiles []InstanceProfileReference `json:"supported_instance_profiles" validate:"required"`

	VcpuArchitecture *DedicatedHostProfileVcpuArchitecture `json:"vcpu_architecture" validate:"required"`

	VcpuCount DedicatedHostProfileVcpuIntf `json:"vcpu_count" validate:"required"`

	VcpuManufacturer *DedicatedHostProfileVcpuManufacturer `json:"vcpu_manufacturer" validate:"required"`
}

// Constants associated with the DedicatedHostProfile.Family property.
// The product family this dedicated host profile belongs to
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	DedicatedHostProfileFamilyBalancedConst = "balanced"
	DedicatedHostProfileFamilyComputeConst  = "compute"
	DedicatedHostProfileFamilyMemoryConst   = "memory"
)

// Constants associated with the DedicatedHostProfile.Status property.
// The status of the dedicated host profile:
//   - `previous`:  This dedicated host profile is an older revision, but remains provisionable
//     and usable.
//   - `current`:  This profile is the latest revision.
//
// Note that revisions are indicated by the generation of a dedicated host profile.  Refer to the [profile naming
// conventions]
// (https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles&interface=ui#profiles-naming-rule) for information on how
// generations are defined within a dedicated host profile.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the profile on which the
// unexpected property value was encountered.
const (
	DedicatedHostProfileStatusCurrentConst  = "current"
	DedicatedHostProfileStatusPreviousConst = "previous"
)

// UnmarshalDedicatedHostProfile unmarshals an instance of DedicatedHostProfile from the specified map of raw messages.
func UnmarshalDedicatedHostProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfile)
	err = core.UnmarshalPrimitive(m, "class", &obj.Class)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalDedicatedHostProfileDisk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalDedicatedHostProfileMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "socket_count", &obj.SocketCount, UnmarshalDedicatedHostProfileSocket)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_instance_profiles", &obj.SupportedInstanceProfiles, UnmarshalInstanceProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_architecture", &obj.VcpuArchitecture, UnmarshalDedicatedHostProfileVcpuArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_count", &obj.VcpuCount, UnmarshalDedicatedHostProfileVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_manufacturer", &obj.VcpuManufacturer, UnmarshalDedicatedHostProfileVcpuManufacturer)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileCollection : DedicatedHostProfileCollection struct
type DedicatedHostProfileCollection struct {
	// A link to the first page of resources.
	First *DedicatedHostProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *DedicatedHostProfileCollectionNext `json:"next,omitempty"`

	// Collection of dedicated host profiles.
	Profiles []DedicatedHostProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalDedicatedHostProfileCollection unmarshals an instance of DedicatedHostProfileCollection from the specified map of raw messages.
func UnmarshalDedicatedHostProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalDedicatedHostProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalDedicatedHostProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalDedicatedHostProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *DedicatedHostProfileCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// DedicatedHostProfileCollectionFirst : A link to the first page of resources.
type DedicatedHostProfileCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostProfileCollectionFirst unmarshals an instance of DedicatedHostProfileCollectionFirst from the specified map of raw messages.
func UnmarshalDedicatedHostProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type DedicatedHostProfileCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostProfileCollectionNext unmarshals an instance of DedicatedHostProfileCollectionNext from the specified map of raw messages.
func UnmarshalDedicatedHostProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileDisk : Disks provided by this profile.
type DedicatedHostProfileDisk struct {
	InterfaceType *DedicatedHostProfileDiskInterface `json:"interface_type" validate:"required"`

	// The number of disks of this type for a dedicated host with this profile.
	Quantity *DedicatedHostProfileDiskQuantity `json:"quantity" validate:"required"`

	// The size of the disk in GB (gigabytes).
	Size *DedicatedHostProfileDiskSize `json:"size" validate:"required"`

	SupportedInstanceInterfaceTypes *DedicatedHostProfileDiskSupportedInterfaces `json:"supported_instance_interface_types" validate:"required"`
}

// UnmarshalDedicatedHostProfileDisk unmarshals an instance of DedicatedHostProfileDisk from the specified map of raw messages.
func UnmarshalDedicatedHostProfileDisk(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileDisk)
	err = core.UnmarshalModel(m, "interface_type", &obj.InterfaceType, UnmarshalDedicatedHostProfileDiskInterface)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "quantity", &obj.Quantity, UnmarshalDedicatedHostProfileDiskQuantity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "size", &obj.Size, UnmarshalDedicatedHostProfileDiskSize)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_instance_interface_types", &obj.SupportedInstanceInterfaceTypes, UnmarshalDedicatedHostProfileDiskSupportedInterfaces)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileDiskInterface : DedicatedHostProfileDiskInterface struct
type DedicatedHostProfileDiskInterface struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The interface of the disk for a dedicated host with this profile
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileDiskInterface.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileDiskInterfaceTypeFixedConst = "fixed"
)

// Constants associated with the DedicatedHostProfileDiskInterface.Value property.
// The interface of the disk for a dedicated host with this profile
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	DedicatedHostProfileDiskInterfaceValueNvmeConst = "nvme"
)

// UnmarshalDedicatedHostProfileDiskInterface unmarshals an instance of DedicatedHostProfileDiskInterface from the specified map of raw messages.
func UnmarshalDedicatedHostProfileDiskInterface(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileDiskInterface)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileDiskQuantity : The number of disks of this type for a dedicated host with this profile.
type DedicatedHostProfileDiskQuantity struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileDiskQuantity.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileDiskQuantityTypeFixedConst = "fixed"
)

// UnmarshalDedicatedHostProfileDiskQuantity unmarshals an instance of DedicatedHostProfileDiskQuantity from the specified map of raw messages.
func UnmarshalDedicatedHostProfileDiskQuantity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileDiskQuantity)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileDiskSize : The size of the disk in GB (gigabytes).
type DedicatedHostProfileDiskSize struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The size of the disk in GB (gigabytes).
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileDiskSize.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileDiskSizeTypeFixedConst = "fixed"
)

// UnmarshalDedicatedHostProfileDiskSize unmarshals an instance of DedicatedHostProfileDiskSize from the specified map of raw messages.
func UnmarshalDedicatedHostProfileDiskSize(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileDiskSize)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileDiskSupportedInterfaces : DedicatedHostProfileDiskSupportedInterfaces struct
type DedicatedHostProfileDiskSupportedInterfaces struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The instance disk interfaces supported for a dedicated host with this profile.
	Value []string `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileDiskSupportedInterfaces.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileDiskSupportedInterfacesTypeFixedConst = "fixed"
)

// Constants associated with the DedicatedHostProfileDiskSupportedInterfaces.Value property.
// The disk interface used for attaching the disk.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	DedicatedHostProfileDiskSupportedInterfacesValueNvmeConst      = "nvme"
	DedicatedHostProfileDiskSupportedInterfacesValueVirtioBlkConst = "virtio_blk"
)

// UnmarshalDedicatedHostProfileDiskSupportedInterfaces unmarshals an instance of DedicatedHostProfileDiskSupportedInterfaces from the specified map of raw messages.
func UnmarshalDedicatedHostProfileDiskSupportedInterfaces(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileDiskSupportedInterfaces)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileIdentity : Identifies a dedicated host profile by a unique property.
// Models which "extend" this model:
// - DedicatedHostProfileIdentityByName
// - DedicatedHostProfileIdentityByHref
type DedicatedHostProfileIdentity struct {
	// The globally unique name for this dedicated host profile.
	Name *string `json:"name,omitempty"`

	// The URL for this dedicated host profile.
	Href *string `json:"href,omitempty"`
}

func (*DedicatedHostProfileIdentity) isaDedicatedHostProfileIdentity() bool {
	return true
}

type DedicatedHostProfileIdentityIntf interface {
	isaDedicatedHostProfileIdentity() bool
}

// UnmarshalDedicatedHostProfileIdentity unmarshals an instance of DedicatedHostProfileIdentity from the specified map of raw messages.
func UnmarshalDedicatedHostProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemory : DedicatedHostProfileMemory struct
// Models which "extend" this model:
// - DedicatedHostProfileMemoryFixed
// - DedicatedHostProfileMemoryRange
// - DedicatedHostProfileMemoryEnum
// - DedicatedHostProfileMemoryDependent
type DedicatedHostProfileMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the DedicatedHostProfileMemory.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileMemory) isaDedicatedHostProfileMemory() bool {
	return true
}

type DedicatedHostProfileMemoryIntf interface {
	isaDedicatedHostProfileMemory() bool
}

// UnmarshalDedicatedHostProfileMemory unmarshals an instance of DedicatedHostProfileMemory from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileReference : DedicatedHostProfileReference struct
type DedicatedHostProfileReference struct {
	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this dedicated host profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDedicatedHostProfileReference unmarshals an instance of DedicatedHostProfileReference from the specified map of raw messages.
func UnmarshalDedicatedHostProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocket : DedicatedHostProfileSocket struct
// Models which "extend" this model:
// - DedicatedHostProfileSocketFixed
// - DedicatedHostProfileSocketRange
// - DedicatedHostProfileSocketEnum
// - DedicatedHostProfileSocketDependent
type DedicatedHostProfileSocket struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the DedicatedHostProfileSocket.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileSocket) isaDedicatedHostProfileSocket() bool {
	return true
}

type DedicatedHostProfileSocketIntf interface {
	isaDedicatedHostProfileSocket() bool
}

// UnmarshalDedicatedHostProfileSocket unmarshals an instance of DedicatedHostProfileSocket from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocket(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocket)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpu : DedicatedHostProfileVcpu struct
// Models which "extend" this model:
// - DedicatedHostProfileVcpuFixed
// - DedicatedHostProfileVcpuRange
// - DedicatedHostProfileVcpuEnum
// - DedicatedHostProfileVcpuDependent
type DedicatedHostProfileVcpu struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the DedicatedHostProfileVcpu.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileVcpu) isaDedicatedHostProfileVcpu() bool {
	return true
}

type DedicatedHostProfileVcpuIntf interface {
	isaDedicatedHostProfileVcpu() bool
}

// UnmarshalDedicatedHostProfileVcpu unmarshals an instance of DedicatedHostProfileVcpu from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpu)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuArchitecture : DedicatedHostProfileVcpuArchitecture struct
type DedicatedHostProfileVcpuArchitecture struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU architecture for a dedicated host with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuArchitecture.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuArchitectureTypeFixedConst = "fixed"
)

// UnmarshalDedicatedHostProfileVcpuArchitecture unmarshals an instance of DedicatedHostProfileVcpuArchitecture from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuArchitecture)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuManufacturer : DedicatedHostProfileVcpuManufacturer struct
type DedicatedHostProfileVcpuManufacturer struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU manufacturer for a dedicated host with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuManufacturer.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuManufacturerTypeFixedConst = "fixed"
)

// UnmarshalDedicatedHostProfileVcpuManufacturer unmarshals an instance of DedicatedHostProfileVcpuManufacturer from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuManufacturer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuManufacturer)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototype : DedicatedHostPrototype struct
// Models which "extend" this model:
// - DedicatedHostPrototypeDedicatedHostByGroup
// - DedicatedHostPrototypeDedicatedHostByZone
type DedicatedHostPrototype struct {
	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled,omitempty"`

	// The name for this dedicated host. The name must not be used by another dedicated host in the region. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) to use for this
	// dedicated host.
	Profile DedicatedHostProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The dedicated host group for this dedicated host.
	Group DedicatedHostGroupIdentityIntf `json:"group,omitempty"`

	// The zone this dedicated host will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

func (*DedicatedHostPrototype) isaDedicatedHostPrototype() bool {
	return true
}

type DedicatedHostPrototypeIntf interface {
	isaDedicatedHostPrototype() bool
}

// UnmarshalDedicatedHostPrototype unmarshals an instance of DedicatedHostPrototype from the specified map of raw messages.
func UnmarshalDedicatedHostPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototype)
	err = core.UnmarshalPrimitive(m, "instance_placement_enabled", &obj.InstancePlacementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalDedicatedHostProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalDedicatedHostGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostReference : DedicatedHostReference struct
type DedicatedHostReference struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *DedicatedHostReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`

	// The name for this dedicated host. The name is unique across all dedicated hosts in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the DedicatedHostReference.ResourceType property.
// The resource type.
const (
	DedicatedHostReferenceResourceTypeDedicatedHostConst = "dedicated_host"
)

// UnmarshalDedicatedHostReference unmarshals an instance of DedicatedHostReference from the specified map of raw messages.
func UnmarshalDedicatedHostReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalDedicatedHostReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type DedicatedHostReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalDedicatedHostReferenceDeleted unmarshals an instance of DedicatedHostReferenceDeleted from the specified map of raw messages.
func UnmarshalDedicatedHostReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultNetworkACL : DefaultNetworkACL struct
type DefaultNetworkACL struct {
	// The date and time that the network ACL was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The name of the default network ACL created for a VPC. The name will be a hyphenated list of randomly-selected words
	// at creation, but may be changed.
	Name *string `json:"name" validate:"required"`

	// The resource group for the default network ACL for a VPC. Set to the VPC's
	// resource group at creation.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The ordered rules for the default network ACL for a VPC. Defaults to two rules which allow all inbound and outbound
	// traffic, respectively. Rules for the default network ACL may be changed, added, or removed.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The subnets to which this network ACL is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this network ACL resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalDefaultNetworkACL unmarshals an instance of DefaultNetworkACL from the specified map of raw messages.
func UnmarshalDefaultNetworkACL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultNetworkACL)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRuleItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultRoutingTable : DefaultRoutingTable struct
type DefaultRoutingTable struct {
	// The filters specifying the resources that may create routes in this routing table.
	//
	// At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but filter
	// support is expected to expand in the future.
	AcceptRoutesFrom []ResourceFilter `json:"accept_routes_from" validate:"required"`

	// The date and time that this routing table was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default routing table for this VPC.
	IsDefault *bool `json:"is_default" validate:"required"`

	// The lifecycle state of the routing table.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name of the default routing table created for this VPC. The name will be a hyphenated list of randomly-selected
	// words at creation, but may be changed.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from
	// [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteDirectLinkIngress *bool `json:"route_direct_link_ingress" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from the internet.
	//
	// Incoming traffic will be routed according to the routing table with two exceptions:
	// - Traffic destined for IP addresses associated with public gateways will not be
	//   subject to routes in this routing table.
	// - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
	//   an IP address in a subnet in the route's `zone` that is able to accept traffic.
	//   Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	//   connection, the packet will be dropped.
	RouteInternetIngress *bool `json:"route_internet_ingress" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from from [Transit
	// Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteTransitGatewayIngress *bool `json:"route_transit_gateway_ingress" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from subnets in other zones in this
	// VPC.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteVPCZoneIngress *bool `json:"route_vpc_zone_ingress" validate:"required"`

	// The routes for the default routing table for this VPC. The table is created with no routes, but routes may be added,
	// changed, or removed with a subsequent request.
	Routes []RouteReference `json:"routes" validate:"required"`

	// The subnets to which this routing table is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`
}

// Constants associated with the DefaultRoutingTable.LifecycleState property.
// The lifecycle state of the routing table.
const (
	DefaultRoutingTableLifecycleStateDeletingConst  = "deleting"
	DefaultRoutingTableLifecycleStateFailedConst    = "failed"
	DefaultRoutingTableLifecycleStatePendingConst   = "pending"
	DefaultRoutingTableLifecycleStateStableConst    = "stable"
	DefaultRoutingTableLifecycleStateSuspendedConst = "suspended"
	DefaultRoutingTableLifecycleStateUpdatingConst  = "updating"
	DefaultRoutingTableLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the DefaultRoutingTable.ResourceType property.
// The resource type.
const (
	DefaultRoutingTableResourceTypeRoutingTableConst = "routing_table"
)

// UnmarshalDefaultRoutingTable unmarshals an instance of DefaultRoutingTable from the specified map of raw messages.
func UnmarshalDefaultRoutingTable(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultRoutingTable)
	err = core.UnmarshalModel(m, "accept_routes_from", &obj.AcceptRoutesFrom, UnmarshalResourceFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_default", &obj.IsDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_direct_link_ingress", &obj.RouteDirectLinkIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_internet_ingress", &obj.RouteInternetIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_transit_gateway_ingress", &obj.RouteTransitGatewayIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_vpc_zone_ingress", &obj.RouteVPCZoneIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultSecurityGroup : DefaultSecurityGroup struct
type DefaultSecurityGroup struct {
	// The date and time that this security group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name for the default security group for a VPC. The name will be a hyphenated list of randomly-selected words at
	// creation, but may changed.
	Name *string `json:"name" validate:"required"`

	// The resource group for this security group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The rules for the default security group for a VPC. Defaults to allowing all outbound traffic, and allowing all
	// inbound traffic from other interfaces in the VPC's default security group. Rules for the default security group may
	// be changed, added or removed.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`

	// The targets for this security group.
	Targets []SecurityGroupTargetReferenceIntf `json:"targets" validate:"required"`

	// The VPC this security group resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalDefaultSecurityGroup unmarshals an instance of DefaultSecurityGroup from the specified map of raw messages.
func UnmarshalDefaultSecurityGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultSecurityGroup)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "targets", &obj.Targets, UnmarshalSecurityGroupTargetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteBackupPolicyOptions : The DeleteBackupPolicy options.
type DeleteBackupPolicyOptions struct {
	// The backup policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteBackupPolicyOptions : Instantiate DeleteBackupPolicyOptions
func (*VpcV1) NewDeleteBackupPolicyOptions(id string) *DeleteBackupPolicyOptions {
	return &DeleteBackupPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteBackupPolicyOptions) SetID(id string) *DeleteBackupPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteBackupPolicyOptions) SetIfMatch(ifMatch string) *DeleteBackupPolicyOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteBackupPolicyOptions) SetHeaders(param map[string]string) *DeleteBackupPolicyOptions {
	options.Headers = param
	return options
}

// DeleteBackupPolicyPlanOptions : The DeleteBackupPolicyPlan options.
type DeleteBackupPolicyPlanOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// The backup policy plan identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteBackupPolicyPlanOptions : Instantiate DeleteBackupPolicyPlanOptions
func (*VpcV1) NewDeleteBackupPolicyPlanOptions(backupPolicyID string, id string) *DeleteBackupPolicyPlanOptions {
	return &DeleteBackupPolicyPlanOptions{
		BackupPolicyID: core.StringPtr(backupPolicyID),
		ID:             core.StringPtr(id),
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *DeleteBackupPolicyPlanOptions) SetBackupPolicyID(backupPolicyID string) *DeleteBackupPolicyPlanOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteBackupPolicyPlanOptions) SetID(id string) *DeleteBackupPolicyPlanOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteBackupPolicyPlanOptions) SetIfMatch(ifMatch string) *DeleteBackupPolicyPlanOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteBackupPolicyPlanOptions) SetHeaders(param map[string]string) *DeleteBackupPolicyPlanOptions {
	options.Headers = param
	return options
}

// DeleteBareMetalServerNetworkInterfaceOptions : The DeleteBareMetalServerNetworkInterface options.
type DeleteBareMetalServerNetworkInterfaceOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteBareMetalServerNetworkInterfaceOptions : Instantiate DeleteBareMetalServerNetworkInterfaceOptions
func (*VpcV1) NewDeleteBareMetalServerNetworkInterfaceOptions(bareMetalServerID string, id string) *DeleteBareMetalServerNetworkInterfaceOptions {
	return &DeleteBareMetalServerNetworkInterfaceOptions{
		BareMetalServerID: core.StringPtr(bareMetalServerID),
		ID:                core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *DeleteBareMetalServerNetworkInterfaceOptions) SetBareMetalServerID(bareMetalServerID string) *DeleteBareMetalServerNetworkInterfaceOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteBareMetalServerNetworkInterfaceOptions) SetID(id string) *DeleteBareMetalServerNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteBareMetalServerNetworkInterfaceOptions) SetHeaders(param map[string]string) *DeleteBareMetalServerNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// DeleteBareMetalServerOptions : The DeleteBareMetalServer options.
type DeleteBareMetalServerOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteBareMetalServerOptions : Instantiate DeleteBareMetalServerOptions
func (*VpcV1) NewDeleteBareMetalServerOptions(id string) *DeleteBareMetalServerOptions {
	return &DeleteBareMetalServerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteBareMetalServerOptions) SetID(id string) *DeleteBareMetalServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteBareMetalServerOptions) SetHeaders(param map[string]string) *DeleteBareMetalServerOptions {
	options.Headers = param
	return options
}

// DeleteDedicatedHostGroupOptions : The DeleteDedicatedHostGroup options.
type DeleteDedicatedHostGroupOptions struct {
	// The dedicated host group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDedicatedHostGroupOptions : Instantiate DeleteDedicatedHostGroupOptions
func (*VpcV1) NewDeleteDedicatedHostGroupOptions(id string) *DeleteDedicatedHostGroupOptions {
	return &DeleteDedicatedHostGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteDedicatedHostGroupOptions) SetID(id string) *DeleteDedicatedHostGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDedicatedHostGroupOptions) SetHeaders(param map[string]string) *DeleteDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// DeleteDedicatedHostOptions : The DeleteDedicatedHost options.
type DeleteDedicatedHostOptions struct {
	// The dedicated host identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDedicatedHostOptions : Instantiate DeleteDedicatedHostOptions
func (*VpcV1) NewDeleteDedicatedHostOptions(id string) *DeleteDedicatedHostOptions {
	return &DeleteDedicatedHostOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteDedicatedHostOptions) SetID(id string) *DeleteDedicatedHostOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDedicatedHostOptions) SetHeaders(param map[string]string) *DeleteDedicatedHostOptions {
	options.Headers = param
	return options
}

// DeleteEndpointGatewayOptions : The DeleteEndpointGateway options.
type DeleteEndpointGatewayOptions struct {
	// The endpoint gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteEndpointGatewayOptions : Instantiate DeleteEndpointGatewayOptions
func (*VpcV1) NewDeleteEndpointGatewayOptions(id string) *DeleteEndpointGatewayOptions {
	return &DeleteEndpointGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteEndpointGatewayOptions) SetID(id string) *DeleteEndpointGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteEndpointGatewayOptions) SetHeaders(param map[string]string) *DeleteEndpointGatewayOptions {
	options.Headers = param
	return options
}

// DeleteFloatingIPOptions : The DeleteFloatingIP options.
type DeleteFloatingIPOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFloatingIPOptions : Instantiate DeleteFloatingIPOptions
func (*VpcV1) NewDeleteFloatingIPOptions(id string) *DeleteFloatingIPOptions {
	return &DeleteFloatingIPOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteFloatingIPOptions) SetID(id string) *DeleteFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFloatingIPOptions) SetHeaders(param map[string]string) *DeleteFloatingIPOptions {
	options.Headers = param
	return options
}

// DeleteFlowLogCollectorOptions : The DeleteFlowLogCollector options.
type DeleteFlowLogCollectorOptions struct {
	// The flow log collector identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFlowLogCollectorOptions : Instantiate DeleteFlowLogCollectorOptions
func (*VpcV1) NewDeleteFlowLogCollectorOptions(id string) *DeleteFlowLogCollectorOptions {
	return &DeleteFlowLogCollectorOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteFlowLogCollectorOptions) SetID(id string) *DeleteFlowLogCollectorOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFlowLogCollectorOptions) SetHeaders(param map[string]string) *DeleteFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// DeleteIkePolicyOptions : The DeleteIkePolicy options.
type DeleteIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIkePolicyOptions : Instantiate DeleteIkePolicyOptions
func (*VpcV1) NewDeleteIkePolicyOptions(id string) *DeleteIkePolicyOptions {
	return &DeleteIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteIkePolicyOptions) SetID(id string) *DeleteIkePolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIkePolicyOptions) SetHeaders(param map[string]string) *DeleteIkePolicyOptions {
	options.Headers = param
	return options
}

// DeleteImageExportJobOptions : The DeleteImageExportJob options.
type DeleteImageExportJobOptions struct {
	// The image identifier.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// The image export job identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteImageExportJobOptions : Instantiate DeleteImageExportJobOptions
func (*VpcV1) NewDeleteImageExportJobOptions(imageID string, id string) *DeleteImageExportJobOptions {
	return &DeleteImageExportJobOptions{
		ImageID: core.StringPtr(imageID),
		ID:      core.StringPtr(id),
	}
}

// SetImageID : Allow user to set ImageID
func (_options *DeleteImageExportJobOptions) SetImageID(imageID string) *DeleteImageExportJobOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteImageExportJobOptions) SetID(id string) *DeleteImageExportJobOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteImageExportJobOptions) SetHeaders(param map[string]string) *DeleteImageExportJobOptions {
	options.Headers = param
	return options
}

// DeleteImageOptions : The DeleteImage options.
type DeleteImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteImageOptions : Instantiate DeleteImageOptions
func (*VpcV1) NewDeleteImageOptions(id string) *DeleteImageOptions {
	return &DeleteImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteImageOptions) SetID(id string) *DeleteImageOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteImageOptions) SetHeaders(param map[string]string) *DeleteImageOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupLoadBalancerOptions : The DeleteInstanceGroupLoadBalancer options.
type DeleteInstanceGroupLoadBalancerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupLoadBalancerOptions : Instantiate DeleteInstanceGroupLoadBalancerOptions
func (*VpcV1) NewDeleteInstanceGroupLoadBalancerOptions(instanceGroupID string) *DeleteInstanceGroupLoadBalancerOptions {
	return &DeleteInstanceGroupLoadBalancerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *DeleteInstanceGroupLoadBalancerOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupLoadBalancerOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupLoadBalancerOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupLoadBalancerOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupManagerActionOptions : The DeleteInstanceGroupManagerAction options.
type DeleteInstanceGroupManagerActionOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager action identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupManagerActionOptions : Instantiate DeleteInstanceGroupManagerActionOptions
func (*VpcV1) NewDeleteInstanceGroupManagerActionOptions(instanceGroupID string, instanceGroupManagerID string, id string) *DeleteInstanceGroupManagerActionOptions {
	return &DeleteInstanceGroupManagerActionOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *DeleteInstanceGroupManagerActionOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupManagerActionOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *DeleteInstanceGroupManagerActionOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *DeleteInstanceGroupManagerActionOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceGroupManagerActionOptions) SetID(id string) *DeleteInstanceGroupManagerActionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupManagerActionOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupManagerActionOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupManagerOptions : The DeleteInstanceGroupManager options.
type DeleteInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupManagerOptions : Instantiate DeleteInstanceGroupManagerOptions
func (*VpcV1) NewDeleteInstanceGroupManagerOptions(instanceGroupID string, id string) *DeleteInstanceGroupManagerOptions {
	return &DeleteInstanceGroupManagerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *DeleteInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupManagerOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceGroupManagerOptions) SetID(id string) *DeleteInstanceGroupManagerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupManagerOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupManagerPolicyOptions : The DeleteInstanceGroupManagerPolicy options.
type DeleteInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupManagerPolicyOptions : Instantiate DeleteInstanceGroupManagerPolicyOptions
func (*VpcV1) NewDeleteInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, id string) *DeleteInstanceGroupManagerPolicyOptions {
	return &DeleteInstanceGroupManagerPolicyOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *DeleteInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *DeleteInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *DeleteInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceGroupManagerPolicyOptions) SetID(id string) *DeleteInstanceGroupManagerPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupMembershipOptions : The DeleteInstanceGroupMembership options.
type DeleteInstanceGroupMembershipOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group membership identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupMembershipOptions : Instantiate DeleteInstanceGroupMembershipOptions
func (*VpcV1) NewDeleteInstanceGroupMembershipOptions(instanceGroupID string, id string) *DeleteInstanceGroupMembershipOptions {
	return &DeleteInstanceGroupMembershipOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *DeleteInstanceGroupMembershipOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupMembershipOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceGroupMembershipOptions) SetID(id string) *DeleteInstanceGroupMembershipOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupMembershipOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupMembershipOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupMembershipsOptions : The DeleteInstanceGroupMemberships options.
type DeleteInstanceGroupMembershipsOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupMembershipsOptions : Instantiate DeleteInstanceGroupMembershipsOptions
func (*VpcV1) NewDeleteInstanceGroupMembershipsOptions(instanceGroupID string) *DeleteInstanceGroupMembershipsOptions {
	return &DeleteInstanceGroupMembershipsOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *DeleteInstanceGroupMembershipsOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupMembershipsOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupMembershipsOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupMembershipsOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupOptions : The DeleteInstanceGroup options.
type DeleteInstanceGroupOptions struct {
	// The instance group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupOptions : Instantiate DeleteInstanceGroupOptions
func (*VpcV1) NewDeleteInstanceGroupOptions(id string) *DeleteInstanceGroupOptions {
	return &DeleteInstanceGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceGroupOptions) SetID(id string) *DeleteInstanceGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupOptions {
	options.Headers = param
	return options
}

// DeleteInstanceNetworkInterfaceOptions : The DeleteInstanceNetworkInterface options.
type DeleteInstanceNetworkInterfaceOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceNetworkInterfaceOptions : Instantiate DeleteInstanceNetworkInterfaceOptions
func (*VpcV1) NewDeleteInstanceNetworkInterfaceOptions(instanceID string, id string) *DeleteInstanceNetworkInterfaceOptions {
	return &DeleteInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *DeleteInstanceNetworkInterfaceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceNetworkInterfaceOptions) SetID(id string) *DeleteInstanceNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *DeleteInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// DeleteInstanceOptions : The DeleteInstance options.
type DeleteInstanceOptions struct {
	// The virtual server instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceOptions : Instantiate DeleteInstanceOptions
func (*VpcV1) NewDeleteInstanceOptions(id string) *DeleteInstanceOptions {
	return &DeleteInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceOptions) SetID(id string) *DeleteInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceOptions) SetHeaders(param map[string]string) *DeleteInstanceOptions {
	options.Headers = param
	return options
}

// DeleteInstanceTemplateOptions : The DeleteInstanceTemplate options.
type DeleteInstanceTemplateOptions struct {
	// The instance template identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceTemplateOptions : Instantiate DeleteInstanceTemplateOptions
func (*VpcV1) NewDeleteInstanceTemplateOptions(id string) *DeleteInstanceTemplateOptions {
	return &DeleteInstanceTemplateOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceTemplateOptions) SetID(id string) *DeleteInstanceTemplateOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceTemplateOptions) SetHeaders(param map[string]string) *DeleteInstanceTemplateOptions {
	options.Headers = param
	return options
}

// DeleteInstanceVolumeAttachmentOptions : The DeleteInstanceVolumeAttachment options.
type DeleteInstanceVolumeAttachmentOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceVolumeAttachmentOptions : Instantiate DeleteInstanceVolumeAttachmentOptions
func (*VpcV1) NewDeleteInstanceVolumeAttachmentOptions(instanceID string, id string) *DeleteInstanceVolumeAttachmentOptions {
	return &DeleteInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *DeleteInstanceVolumeAttachmentOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteInstanceVolumeAttachmentOptions) SetID(id string) *DeleteInstanceVolumeAttachmentOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *DeleteInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// DeleteIpsecPolicyOptions : The DeleteIpsecPolicy options.
type DeleteIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIpsecPolicyOptions : Instantiate DeleteIpsecPolicyOptions
func (*VpcV1) NewDeleteIpsecPolicyOptions(id string) *DeleteIpsecPolicyOptions {
	return &DeleteIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteIpsecPolicyOptions) SetID(id string) *DeleteIpsecPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIpsecPolicyOptions) SetHeaders(param map[string]string) *DeleteIpsecPolicyOptions {
	options.Headers = param
	return options
}

// DeleteKeyOptions : The DeleteKey options.
type DeleteKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteKeyOptions : Instantiate DeleteKeyOptions
func (*VpcV1) NewDeleteKeyOptions(id string) *DeleteKeyOptions {
	return &DeleteKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteKeyOptions) SetID(id string) *DeleteKeyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteKeyOptions) SetHeaders(param map[string]string) *DeleteKeyOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerOptions : The DeleteLoadBalancerListener options.
type DeleteLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerOptions : Instantiate DeleteLoadBalancerListenerOptions
func (*VpcV1) NewDeleteLoadBalancerListenerOptions(loadBalancerID string, id string) *DeleteLoadBalancerListenerOptions {
	return &DeleteLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *DeleteLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteLoadBalancerListenerOptions) SetID(id string) *DeleteLoadBalancerListenerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerPolicyOptions : The DeleteLoadBalancerListenerPolicy options.
type DeleteLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerPolicyOptions : Instantiate DeleteLoadBalancerListenerPolicyOptions
func (*VpcV1) NewDeleteLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *DeleteLoadBalancerListenerPolicyOptions {
	return &DeleteLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *DeleteLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerPolicyOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *DeleteLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *DeleteLoadBalancerListenerPolicyOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteLoadBalancerListenerPolicyOptions) SetID(id string) *DeleteLoadBalancerListenerPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerPolicyRuleOptions : The DeleteLoadBalancerListenerPolicyRule options.
type DeleteLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerPolicyRuleOptions : Instantiate DeleteLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewDeleteLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	return &DeleteLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *DeleteLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *DeleteLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *DeleteLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteLoadBalancerListenerPolicyRuleOptions) SetID(id string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerOptions : The DeleteLoadBalancer options.
type DeleteLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerOptions : Instantiate DeleteLoadBalancerOptions
func (*VpcV1) NewDeleteLoadBalancerOptions(id string) *DeleteLoadBalancerOptions {
	return &DeleteLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteLoadBalancerOptions) SetID(id string) *DeleteLoadBalancerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteLoadBalancerOptions) SetIfMatch(ifMatch string) *DeleteLoadBalancerOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerPoolMemberOptions : The DeleteLoadBalancerPoolMember options.
type DeleteLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required,ne="`

	// The member identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerPoolMemberOptions : Instantiate DeleteLoadBalancerPoolMemberOptions
func (*VpcV1) NewDeleteLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *DeleteLoadBalancerPoolMemberOptions {
	return &DeleteLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *DeleteLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerPoolMemberOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetPoolID : Allow user to set PoolID
func (_options *DeleteLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *DeleteLoadBalancerPoolMemberOptions {
	_options.PoolID = core.StringPtr(poolID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteLoadBalancerPoolMemberOptions) SetID(id string) *DeleteLoadBalancerPoolMemberOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerPoolOptions : The DeleteLoadBalancerPool options.
type DeleteLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerPoolOptions : Instantiate DeleteLoadBalancerPoolOptions
func (*VpcV1) NewDeleteLoadBalancerPoolOptions(loadBalancerID string, id string) *DeleteLoadBalancerPoolOptions {
	return &DeleteLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *DeleteLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerPoolOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteLoadBalancerPoolOptions) SetID(id string) *DeleteLoadBalancerPoolOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerPoolOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// DeleteNetworkACLOptions : The DeleteNetworkACL options.
type DeleteNetworkACLOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkACLOptions : Instantiate DeleteNetworkACLOptions
func (*VpcV1) NewDeleteNetworkACLOptions(id string) *DeleteNetworkACLOptions {
	return &DeleteNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteNetworkACLOptions) SetID(id string) *DeleteNetworkACLOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkACLOptions) SetHeaders(param map[string]string) *DeleteNetworkACLOptions {
	options.Headers = param
	return options
}

// DeleteNetworkACLRuleOptions : The DeleteNetworkACLRule options.
type DeleteNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkACLRuleOptions : Instantiate DeleteNetworkACLRuleOptions
func (*VpcV1) NewDeleteNetworkACLRuleOptions(networkACLID string, id string) *DeleteNetworkACLRuleOptions {
	return &DeleteNetworkACLRuleOptions{
		NetworkACLID: core.StringPtr(networkACLID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (_options *DeleteNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *DeleteNetworkACLRuleOptions {
	_options.NetworkACLID = core.StringPtr(networkACLID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteNetworkACLRuleOptions) SetID(id string) *DeleteNetworkACLRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkACLRuleOptions) SetHeaders(param map[string]string) *DeleteNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// DeletePlacementGroupOptions : The DeletePlacementGroup options.
type DeletePlacementGroupOptions struct {
	// The placement group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeletePlacementGroupOptions : Instantiate DeletePlacementGroupOptions
func (*VpcV1) NewDeletePlacementGroupOptions(id string) *DeletePlacementGroupOptions {
	return &DeletePlacementGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeletePlacementGroupOptions) SetID(id string) *DeletePlacementGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeletePlacementGroupOptions) SetHeaders(param map[string]string) *DeletePlacementGroupOptions {
	options.Headers = param
	return options
}

// DeletePublicGatewayOptions : The DeletePublicGateway options.
type DeletePublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeletePublicGatewayOptions : Instantiate DeletePublicGatewayOptions
func (*VpcV1) NewDeletePublicGatewayOptions(id string) *DeletePublicGatewayOptions {
	return &DeletePublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeletePublicGatewayOptions) SetID(id string) *DeletePublicGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeletePublicGatewayOptions) SetHeaders(param map[string]string) *DeletePublicGatewayOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupOptions : The DeleteSecurityGroup options.
type DeleteSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupOptions : Instantiate DeleteSecurityGroupOptions
func (*VpcV1) NewDeleteSecurityGroupOptions(id string) *DeleteSecurityGroupOptions {
	return &DeleteSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteSecurityGroupOptions) SetID(id string) *DeleteSecurityGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupRuleOptions : The DeleteSecurityGroupRule options.
type DeleteSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupRuleOptions : Instantiate DeleteSecurityGroupRuleOptions
func (*VpcV1) NewDeleteSecurityGroupRuleOptions(securityGroupID string, id string) *DeleteSecurityGroupRuleOptions {
	return &DeleteSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *DeleteSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *DeleteSecurityGroupRuleOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSecurityGroupRuleOptions) SetID(id string) *DeleteSecurityGroupRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupRuleOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupTargetBindingOptions : The DeleteSecurityGroupTargetBinding options.
type DeleteSecurityGroupTargetBindingOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The security group target identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupTargetBindingOptions : Instantiate DeleteSecurityGroupTargetBindingOptions
func (*VpcV1) NewDeleteSecurityGroupTargetBindingOptions(securityGroupID string, id string) *DeleteSecurityGroupTargetBindingOptions {
	return &DeleteSecurityGroupTargetBindingOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *DeleteSecurityGroupTargetBindingOptions) SetSecurityGroupID(securityGroupID string) *DeleteSecurityGroupTargetBindingOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSecurityGroupTargetBindingOptions) SetID(id string) *DeleteSecurityGroupTargetBindingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupTargetBindingOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupTargetBindingOptions {
	options.Headers = param
	return options
}

// DeleteShareMountTargetOptions : The DeleteShareMountTarget options.
type DeleteShareMountTargetOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// The share mount target identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteShareMountTargetOptions : Instantiate DeleteShareMountTargetOptions
func (*VpcV1) NewDeleteShareMountTargetOptions(shareID string, id string) *DeleteShareMountTargetOptions {
	return &DeleteShareMountTargetOptions{
		ShareID: core.StringPtr(shareID),
		ID:      core.StringPtr(id),
	}
}

// SetShareID : Allow user to set ShareID
func (_options *DeleteShareMountTargetOptions) SetShareID(shareID string) *DeleteShareMountTargetOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteShareMountTargetOptions) SetID(id string) *DeleteShareMountTargetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteShareMountTargetOptions) SetHeaders(param map[string]string) *DeleteShareMountTargetOptions {
	options.Headers = param
	return options
}

// DeleteShareOptions : The DeleteShare options.
type DeleteShareOptions struct {
	// The file share identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteShareOptions : Instantiate DeleteShareOptions
func (*VpcV1) NewDeleteShareOptions(id string) *DeleteShareOptions {
	return &DeleteShareOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteShareOptions) SetID(id string) *DeleteShareOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteShareOptions) SetIfMatch(ifMatch string) *DeleteShareOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteShareOptions) SetHeaders(param map[string]string) *DeleteShareOptions {
	options.Headers = param
	return options
}

// DeleteShareSourceOptions : The DeleteShareSource options.
type DeleteShareSourceOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteShareSourceOptions : Instantiate DeleteShareSourceOptions
func (*VpcV1) NewDeleteShareSourceOptions(shareID string) *DeleteShareSourceOptions {
	return &DeleteShareSourceOptions{
		ShareID: core.StringPtr(shareID),
	}
}

// SetShareID : Allow user to set ShareID
func (_options *DeleteShareSourceOptions) SetShareID(shareID string) *DeleteShareSourceOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteShareSourceOptions) SetHeaders(param map[string]string) *DeleteShareSourceOptions {
	options.Headers = param
	return options
}

// DeleteSnapshotCloneOptions : The DeleteSnapshotClone options.
type DeleteSnapshotCloneOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The zone name.
	ZoneName *string `json:"zone_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSnapshotCloneOptions : Instantiate DeleteSnapshotCloneOptions
func (*VpcV1) NewDeleteSnapshotCloneOptions(id string, zoneName string) *DeleteSnapshotCloneOptions {
	return &DeleteSnapshotCloneOptions{
		ID:       core.StringPtr(id),
		ZoneName: core.StringPtr(zoneName),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteSnapshotCloneOptions) SetID(id string) *DeleteSnapshotCloneOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *DeleteSnapshotCloneOptions) SetZoneName(zoneName string) *DeleteSnapshotCloneOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSnapshotCloneOptions) SetHeaders(param map[string]string) *DeleteSnapshotCloneOptions {
	options.Headers = param
	return options
}

// DeleteSnapshotOptions : The DeleteSnapshot options.
type DeleteSnapshotOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSnapshotOptions : Instantiate DeleteSnapshotOptions
func (*VpcV1) NewDeleteSnapshotOptions(id string) *DeleteSnapshotOptions {
	return &DeleteSnapshotOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteSnapshotOptions) SetID(id string) *DeleteSnapshotOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteSnapshotOptions) SetIfMatch(ifMatch string) *DeleteSnapshotOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSnapshotOptions) SetHeaders(param map[string]string) *DeleteSnapshotOptions {
	options.Headers = param
	return options
}

// DeleteSnapshotsOptions : The DeleteSnapshots options.
type DeleteSnapshotsOptions struct {
	// Filters the collection to resources with a `source_volume.id` property matching the specified identifier.
	SourceVolumeID *string `json:"source_volume.id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSnapshotsOptions : Instantiate DeleteSnapshotsOptions
func (*VpcV1) NewDeleteSnapshotsOptions(sourceVolumeID string) *DeleteSnapshotsOptions {
	return &DeleteSnapshotsOptions{
		SourceVolumeID: core.StringPtr(sourceVolumeID),
	}
}

// SetSourceVolumeID : Allow user to set SourceVolumeID
func (_options *DeleteSnapshotsOptions) SetSourceVolumeID(sourceVolumeID string) *DeleteSnapshotsOptions {
	_options.SourceVolumeID = core.StringPtr(sourceVolumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSnapshotsOptions) SetHeaders(param map[string]string) *DeleteSnapshotsOptions {
	options.Headers = param
	return options
}

// DeleteSubnetOptions : The DeleteSubnet options.
type DeleteSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubnetOptions : Instantiate DeleteSubnetOptions
func (*VpcV1) NewDeleteSubnetOptions(id string) *DeleteSubnetOptions {
	return &DeleteSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteSubnetOptions) SetID(id string) *DeleteSubnetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubnetOptions) SetHeaders(param map[string]string) *DeleteSubnetOptions {
	options.Headers = param
	return options
}

// DeleteSubnetReservedIPOptions : The DeleteSubnetReservedIP options.
type DeleteSubnetReservedIPOptions struct {
	// The subnet identifier.
	SubnetID *string `json:"subnet_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubnetReservedIPOptions : Instantiate DeleteSubnetReservedIPOptions
func (*VpcV1) NewDeleteSubnetReservedIPOptions(subnetID string, id string) *DeleteSubnetReservedIPOptions {
	return &DeleteSubnetReservedIPOptions{
		SubnetID: core.StringPtr(subnetID),
		ID:       core.StringPtr(id),
	}
}

// SetSubnetID : Allow user to set SubnetID
func (_options *DeleteSubnetReservedIPOptions) SetSubnetID(subnetID string) *DeleteSubnetReservedIPOptions {
	_options.SubnetID = core.StringPtr(subnetID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSubnetReservedIPOptions) SetID(id string) *DeleteSubnetReservedIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubnetReservedIPOptions) SetHeaders(param map[string]string) *DeleteSubnetReservedIPOptions {
	options.Headers = param
	return options
}

// DeleteVolumeOptions : The DeleteVolume options.
type DeleteVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVolumeOptions : Instantiate DeleteVolumeOptions
func (*VpcV1) NewDeleteVolumeOptions(id string) *DeleteVolumeOptions {
	return &DeleteVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteVolumeOptions) SetID(id string) *DeleteVolumeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteVolumeOptions) SetIfMatch(ifMatch string) *DeleteVolumeOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVolumeOptions) SetHeaders(param map[string]string) *DeleteVolumeOptions {
	options.Headers = param
	return options
}

// DeleteVPCAddressPrefixOptions : The DeleteVPCAddressPrefix options.
type DeleteVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The prefix identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCAddressPrefixOptions : Instantiate DeleteVPCAddressPrefixOptions
func (*VpcV1) NewDeleteVPCAddressPrefixOptions(vpcID string, id string) *DeleteVPCAddressPrefixOptions {
	return &DeleteVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *DeleteVPCAddressPrefixOptions) SetVPCID(vpcID string) *DeleteVPCAddressPrefixOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPCAddressPrefixOptions) SetID(id string) *DeleteVPCAddressPrefixOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCAddressPrefixOptions) SetHeaders(param map[string]string) *DeleteVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// DeleteVPCDnsResolutionBindingOptions : The DeleteVPCDnsResolutionBinding options.
type DeleteVPCDnsResolutionBindingOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The DNS resolution binding identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCDnsResolutionBindingOptions : Instantiate DeleteVPCDnsResolutionBindingOptions
func (*VpcV1) NewDeleteVPCDnsResolutionBindingOptions(vpcID string, id string) *DeleteVPCDnsResolutionBindingOptions {
	return &DeleteVPCDnsResolutionBindingOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *DeleteVPCDnsResolutionBindingOptions) SetVPCID(vpcID string) *DeleteVPCDnsResolutionBindingOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPCDnsResolutionBindingOptions) SetID(id string) *DeleteVPCDnsResolutionBindingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCDnsResolutionBindingOptions) SetHeaders(param map[string]string) *DeleteVPCDnsResolutionBindingOptions {
	options.Headers = param
	return options
}

// DeleteVPCOptions : The DeleteVPC options.
type DeleteVPCOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCOptions : Instantiate DeleteVPCOptions
func (*VpcV1) NewDeleteVPCOptions(id string) *DeleteVPCOptions {
	return &DeleteVPCOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteVPCOptions) SetID(id string) *DeleteVPCOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteVPCOptions) SetIfMatch(ifMatch string) *DeleteVPCOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCOptions) SetHeaders(param map[string]string) *DeleteVPCOptions {
	options.Headers = param
	return options
}

// DeleteVPCRouteOptions : The DeleteVPCRoute options.
type DeleteVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCRouteOptions : Instantiate DeleteVPCRouteOptions
func (*VpcV1) NewDeleteVPCRouteOptions(vpcID string, id string) *DeleteVPCRouteOptions {
	return &DeleteVPCRouteOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *DeleteVPCRouteOptions) SetVPCID(vpcID string) *DeleteVPCRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPCRouteOptions) SetID(id string) *DeleteVPCRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCRouteOptions) SetHeaders(param map[string]string) *DeleteVPCRouteOptions {
	options.Headers = param
	return options
}

// DeleteVPCRoutingTableOptions : The DeleteVPCRoutingTable options.
type DeleteVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCRoutingTableOptions : Instantiate DeleteVPCRoutingTableOptions
func (*VpcV1) NewDeleteVPCRoutingTableOptions(vpcID string, id string) *DeleteVPCRoutingTableOptions {
	return &DeleteVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *DeleteVPCRoutingTableOptions) SetVPCID(vpcID string) *DeleteVPCRoutingTableOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPCRoutingTableOptions) SetID(id string) *DeleteVPCRoutingTableOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteVPCRoutingTableOptions) SetIfMatch(ifMatch string) *DeleteVPCRoutingTableOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCRoutingTableOptions) SetHeaders(param map[string]string) *DeleteVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// DeleteVPCRoutingTableRouteOptions : The DeleteVPCRoutingTableRoute options.
type DeleteVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required,ne="`

	// The VPC routing table route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCRoutingTableRouteOptions : Instantiate DeleteVPCRoutingTableRouteOptions
func (*VpcV1) NewDeleteVPCRoutingTableRouteOptions(vpcID string, routingTableID string, id string) *DeleteVPCRoutingTableRouteOptions {
	return &DeleteVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		ID:             core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *DeleteVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *DeleteVPCRoutingTableRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (_options *DeleteVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *DeleteVPCRoutingTableRouteOptions {
	_options.RoutingTableID = core.StringPtr(routingTableID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPCRoutingTableRouteOptions) SetID(id string) *DeleteVPCRoutingTableRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *DeleteVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// DeleteVPNGatewayConnectionOptions : The DeleteVPNGatewayConnection options.
type DeleteVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNGatewayConnectionOptions : Instantiate DeleteVPNGatewayConnectionOptions
func (*VpcV1) NewDeleteVPNGatewayConnectionOptions(vpnGatewayID string, id string) *DeleteVPNGatewayConnectionOptions {
	return &DeleteVPNGatewayConnectionOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *DeleteVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *DeleteVPNGatewayConnectionOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPNGatewayConnectionOptions) SetID(id string) *DeleteVPNGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *DeleteVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// DeleteVPNGatewayOptions : The DeleteVPNGateway options.
type DeleteVPNGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNGatewayOptions : Instantiate DeleteVPNGatewayOptions
func (*VpcV1) NewDeleteVPNGatewayOptions(id string) *DeleteVPNGatewayOptions {
	return &DeleteVPNGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteVPNGatewayOptions) SetID(id string) *DeleteVPNGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNGatewayOptions) SetHeaders(param map[string]string) *DeleteVPNGatewayOptions {
	options.Headers = param
	return options
}

// DeleteVPNServerClientOptions : The DeleteVPNServerClient options.
type DeleteVPNServerClientOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The VPN client identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNServerClientOptions : Instantiate DeleteVPNServerClientOptions
func (*VpcV1) NewDeleteVPNServerClientOptions(vpnServerID string, id string) *DeleteVPNServerClientOptions {
	return &DeleteVPNServerClientOptions{
		VPNServerID: core.StringPtr(vpnServerID),
		ID:          core.StringPtr(id),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *DeleteVPNServerClientOptions) SetVPNServerID(vpnServerID string) *DeleteVPNServerClientOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPNServerClientOptions) SetID(id string) *DeleteVPNServerClientOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNServerClientOptions) SetHeaders(param map[string]string) *DeleteVPNServerClientOptions {
	options.Headers = param
	return options
}

// DeleteVPNServerOptions : The DeleteVPNServer options.
type DeleteVPNServerOptions struct {
	// The VPN server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNServerOptions : Instantiate DeleteVPNServerOptions
func (*VpcV1) NewDeleteVPNServerOptions(id string) *DeleteVPNServerOptions {
	return &DeleteVPNServerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteVPNServerOptions) SetID(id string) *DeleteVPNServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteVPNServerOptions) SetIfMatch(ifMatch string) *DeleteVPNServerOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNServerOptions) SetHeaders(param map[string]string) *DeleteVPNServerOptions {
	options.Headers = param
	return options
}

// DeleteVPNServerRouteOptions : The DeleteVPNServerRoute options.
type DeleteVPNServerRouteOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The VPN route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNServerRouteOptions : Instantiate DeleteVPNServerRouteOptions
func (*VpcV1) NewDeleteVPNServerRouteOptions(vpnServerID string, id string) *DeleteVPNServerRouteOptions {
	return &DeleteVPNServerRouteOptions{
		VPNServerID: core.StringPtr(vpnServerID),
		ID:          core.StringPtr(id),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *DeleteVPNServerRouteOptions) SetVPNServerID(vpnServerID string) *DeleteVPNServerRouteOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteVPNServerRouteOptions) SetID(id string) *DeleteVPNServerRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNServerRouteOptions) SetHeaders(param map[string]string) *DeleteVPNServerRouteOptions {
	options.Headers = param
	return options
}

// DeprecateImageOptions : The DeprecateImage options.
type DeprecateImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeprecateImageOptions : Instantiate DeprecateImageOptions
func (*VpcV1) NewDeprecateImageOptions(id string) *DeprecateImageOptions {
	return &DeprecateImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeprecateImageOptions) SetID(id string) *DeprecateImageOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeprecateImageOptions) SetHeaders(param map[string]string) *DeprecateImageOptions {
	options.Headers = param
	return options
}

// DisconnectVPNClientOptions : The DisconnectVPNClient options.
type DisconnectVPNClientOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The VPN client identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDisconnectVPNClientOptions : Instantiate DisconnectVPNClientOptions
func (*VpcV1) NewDisconnectVPNClientOptions(vpnServerID string, id string) *DisconnectVPNClientOptions {
	return &DisconnectVPNClientOptions{
		VPNServerID: core.StringPtr(vpnServerID),
		ID:          core.StringPtr(id),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *DisconnectVPNClientOptions) SetVPNServerID(vpnServerID string) *DisconnectVPNClientOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DisconnectVPNClientOptions) SetID(id string) *DisconnectVPNClientOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DisconnectVPNClientOptions) SetHeaders(param map[string]string) *DisconnectVPNClientOptions {
	options.Headers = param
	return options
}

// EncryptionKeyIdentity : Identifies an encryption key by a unique property.
// Models which "extend" this model:
// - EncryptionKeyIdentityByCRN
type EncryptionKeyIdentity struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	CRN *string `json:"crn,omitempty"`
}

func (*EncryptionKeyIdentity) isaEncryptionKeyIdentity() bool {
	return true
}

type EncryptionKeyIdentityIntf interface {
	isaEncryptionKeyIdentity() bool
}

// UnmarshalEncryptionKeyIdentity unmarshals an instance of EncryptionKeyIdentity from the specified map of raw messages.
func UnmarshalEncryptionKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EncryptionKeyReference : EncryptionKeyReference struct
type EncryptionKeyReference struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	CRN *string `json:"crn" validate:"required"`
}

// UnmarshalEncryptionKeyReference unmarshals an instance of EncryptionKeyReference from the specified map of raw messages.
func UnmarshalEncryptionKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGateway : EndpointGateway struct
type EndpointGateway struct {
	// Indicates whether to allow DNS resolution for this endpoint gateway when the VPC this endpoint gateway resides in
	// has a DNS resolution binding to a VPC with `dns.enable_hub` set to `true`.
	AllowDnsResolutionBinding *bool `json:"allow_dns_resolution_binding" validate:"required"`

	// The date and time that the endpoint gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this endpoint gateway.
	CRN *string `json:"crn" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this endpoint gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this endpoint gateway.
	ID *string `json:"id" validate:"required"`

	// The reserved IPs bound to this endpoint gateway.
	Ips []ReservedIPReference `json:"ips" validate:"required"`

	// The lifecycle state of the endpoint gateway.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this endpoint gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this endpoint gateway.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The fully qualified domain name for the target service.
	// Deprecated: this field is deprecated and may be removed in a future release.
	ServiceEndpoint *string `json:"service_endpoint,omitempty"`

	// The fully qualified domain names for the target service.
	ServiceEndpoints []string `json:"service_endpoints" validate:"required"`

	// The target for this endpoint gateway.
	Target EndpointGatewayTargetIntf `json:"target" validate:"required"`

	// The VPC this endpoint gateway resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the EndpointGateway.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	EndpointGatewayHealthStateDegradedConst     = "degraded"
	EndpointGatewayHealthStateFaultedConst      = "faulted"
	EndpointGatewayHealthStateInapplicableConst = "inapplicable"
	EndpointGatewayHealthStateOkConst           = "ok"
)

// Constants associated with the EndpointGateway.LifecycleState property.
// The lifecycle state of the endpoint gateway.
const (
	EndpointGatewayLifecycleStateDeletingConst  = "deleting"
	EndpointGatewayLifecycleStateFailedConst    = "failed"
	EndpointGatewayLifecycleStatePendingConst   = "pending"
	EndpointGatewayLifecycleStateStableConst    = "stable"
	EndpointGatewayLifecycleStateSuspendedConst = "suspended"
	EndpointGatewayLifecycleStateUpdatingConst  = "updating"
	EndpointGatewayLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the EndpointGateway.ResourceType property.
// The resource type.
const (
	EndpointGatewayResourceTypeEndpointGatewayConst = "endpoint_gateway"
)

// UnmarshalEndpointGateway unmarshals an instance of EndpointGateway from the specified map of raw messages.
func UnmarshalEndpointGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGateway)
	err = core.UnmarshalPrimitive(m, "allow_dns_resolution_binding", &obj.AllowDnsResolutionBinding)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ips", &obj.Ips, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_endpoint", &obj.ServiceEndpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_endpoints", &obj.ServiceEndpoints)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalEndpointGatewayTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayCollection : EndpointGatewayCollection struct
type EndpointGatewayCollection struct {
	// Collection of endpoint gateways.
	EndpointGateways []EndpointGateway `json:"endpoint_gateways" validate:"required"`

	// A link to the first page of resources.
	First *EndpointGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *EndpointGatewayCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalEndpointGatewayCollection unmarshals an instance of EndpointGatewayCollection from the specified map of raw messages.
func UnmarshalEndpointGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayCollection)
	err = core.UnmarshalModel(m, "endpoint_gateways", &obj.EndpointGateways, UnmarshalEndpointGateway)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalEndpointGatewayCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalEndpointGatewayCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *EndpointGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// EndpointGatewayCollectionFirst : A link to the first page of resources.
type EndpointGatewayCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalEndpointGatewayCollectionFirst unmarshals an instance of EndpointGatewayCollectionFirst from the specified map of raw messages.
func UnmarshalEndpointGatewayCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type EndpointGatewayCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalEndpointGatewayCollectionNext unmarshals an instance of EndpointGatewayCollectionNext from the specified map of raw messages.
func UnmarshalEndpointGatewayCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayPatch : EndpointGatewayPatch struct
type EndpointGatewayPatch struct {
	// Indicates whether to allow DNS resolution for this endpoint gateway when the VPC this endpoint gateway resides in
	// has a DNS resolution binding to a VPC with `dns.enable_hub` set to `true`.
	//
	// Must be `true` if the VPC this endpoint gateway resides in has `dns.enable_hub` set to
	// `true`.
	AllowDnsResolutionBinding *bool `json:"allow_dns_resolution_binding,omitempty"`

	// The name for this endpoint gateway. The name must not be used by another endpoint gateway in the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalEndpointGatewayPatch unmarshals an instance of EndpointGatewayPatch from the specified map of raw messages.
func UnmarshalEndpointGatewayPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayPatch)
	err = core.UnmarshalPrimitive(m, "allow_dns_resolution_binding", &obj.AllowDnsResolutionBinding)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the EndpointGatewayPatch
func (endpointGatewayPatch *EndpointGatewayPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(endpointGatewayPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// EndpointGatewayReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type EndpointGatewayReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalEndpointGatewayReferenceDeleted unmarshals an instance of EndpointGatewayReferenceDeleted from the specified map of raw messages.
func UnmarshalEndpointGatewayReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayReferenceRemote : EndpointGatewayReferenceRemote struct
type EndpointGatewayReferenceRemote struct {
	// The CRN for this endpoint gateway.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this endpoint gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this endpoint gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *EndpointGatewayRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the EndpointGatewayReferenceRemote.ResourceType property.
// The resource type.
const (
	EndpointGatewayReferenceRemoteResourceTypeEndpointGatewayConst = "endpoint_gateway"
)

// UnmarshalEndpointGatewayReferenceRemote unmarshals an instance of EndpointGatewayReferenceRemote from the specified map of raw messages.
func UnmarshalEndpointGatewayReferenceRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReferenceRemote)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalEndpointGatewayRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayRemote : If present, this property indicates that the resource associated with this reference is remote and therefore may not
// be directly retrievable.
type EndpointGatewayRemote struct {
	// If present, this property indicates that the referenced resource is remote to this
	// account, and identifies the owning account.
	Account *AccountReference `json:"account,omitempty"`

	// If present, this property indicates that the referenced resource is remote to this
	// region, and identifies the native region.
	Region *RegionReference `json:"region,omitempty"`
}

// UnmarshalEndpointGatewayRemote unmarshals an instance of EndpointGatewayRemote from the specified map of raw messages.
func UnmarshalEndpointGatewayRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayRemote)
	err = core.UnmarshalModel(m, "account", &obj.Account, UnmarshalAccountReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayReservedIP : A reserved IP to bind to the endpoint gateway. This can be specified using an existing reserved IP, or a prototype
// object for a new reserved IP. The reserved IP will be bound to the endpoint gateway to function as a virtual private
// endpoint for the service.
// Models which "extend" this model:
// - EndpointGatewayReservedIPReservedIPIdentity
// - EndpointGatewayReservedIPReservedIPPrototypeTargetContext
type EndpointGatewayReservedIP struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href,omitempty"`

	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The subnet in which to create this reserved IP.
	Subnet SubnetIdentityIntf `json:"subnet,omitempty"`
}

func (*EndpointGatewayReservedIP) isaEndpointGatewayReservedIP() bool {
	return true
}

type EndpointGatewayReservedIPIntf interface {
	isaEndpointGatewayReservedIP() bool
}

// UnmarshalEndpointGatewayReservedIP unmarshals an instance of EndpointGatewayReservedIP from the specified map of raw messages.
func UnmarshalEndpointGatewayReservedIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReservedIP)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTarget : The target for this endpoint gateway.
// Models which "extend" this model:
// - EndpointGatewayTargetProviderCloudServiceReference
// - EndpointGatewayTargetProviderInfrastructureServiceReference
type EndpointGatewayTarget struct {
	// The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service.
	CRN *string `json:"crn,omitempty"`

	// The type of target.
	ResourceType *string `json:"resource_type,omitempty"`

	// The name of a provider infrastructure service. Must be:
	// - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
	Name *string `json:"name,omitempty"`
}

// Constants associated with the EndpointGatewayTarget.ResourceType property.
// The type of target.
const (
	EndpointGatewayTargetResourceTypeProviderCloudServiceConst = "provider_cloud_service"
)

func (*EndpointGatewayTarget) isaEndpointGatewayTarget() bool {
	return true
}

type EndpointGatewayTargetIntf interface {
	isaEndpointGatewayTarget() bool
}

// UnmarshalEndpointGatewayTarget unmarshals an instance of EndpointGatewayTarget from the specified map of raw messages.
func UnmarshalEndpointGatewayTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTarget)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetPrototype : The target to use for this endpoint gateway. Must not already be the target of another endpoint gateway in the VPC.
// Models which "extend" this model:
// - EndpointGatewayTargetPrototypeProviderCloudServiceIdentity
// - EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity
type EndpointGatewayTargetPrototype struct {
	// The type of target for this endpoint gateway.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service.
	CRN *string `json:"crn,omitempty"`

	// The name of a provider infrastructure service. Must be:
	// - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
	Name *string `json:"name,omitempty"`
}

// Constants associated with the EndpointGatewayTargetPrototype.ResourceType property.
// The type of target for this endpoint gateway.
const (
	EndpointGatewayTargetPrototypeResourceTypeProviderCloudServiceConst          = "provider_cloud_service"
	EndpointGatewayTargetPrototypeResourceTypeProviderInfrastructureServiceConst = "provider_infrastructure_service"
)

func (*EndpointGatewayTargetPrototype) isaEndpointGatewayTargetPrototype() bool {
	return true
}

type EndpointGatewayTargetPrototypeIntf interface {
	isaEndpointGatewayTargetPrototype() bool
}

// UnmarshalEndpointGatewayTargetPrototype unmarshals an instance of EndpointGatewayTargetPrototype from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "resource_type", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'resource_type': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'resource_type' not found in JSON object")
		return
	}
	if discValue == "provider_cloud_service" {
		err = core.UnmarshalModel(m, "", result, UnmarshalEndpointGatewayTargetPrototypeProviderCloudServiceIdentity)
	} else if discValue == "provider_infrastructure_service" {
		err = core.UnmarshalModel(m, "", result, UnmarshalEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'resource_type': %s", discValue)
	}
	return
}

// FailoverShareOptions : The FailoverShare options.
type FailoverShareOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// The action to take if the failover request is accepted but cannot be performed or times out:
	// - `fail`: Fail the operation, resulting in the replication relationship being unchanged.
	// - `split`: Split the replica from its source, resulting in two individual read-write
	//     file shares. Because the final sync was not completed, the replica may be
	//     out-of-date. This is useful in disaster recovery scenarios where the source is known
	//     to be unreachable.
	FallbackPolicy *string `json:"fallback_policy,omitempty"`

	// The failover timeout in seconds.
	//
	// If the timeout is reached, the `fallback_policy` will be triggered.
	Timeout *int64 `json:"timeout,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the FailoverShareOptions.FallbackPolicy property.
// The action to take if the failover request is accepted but cannot be performed or times out:
//   - `fail`: Fail the operation, resulting in the replication relationship being unchanged.
//   - `split`: Split the replica from its source, resulting in two individual read-write
//     file shares. Because the final sync was not completed, the replica may be
//     out-of-date. This is useful in disaster recovery scenarios where the source is known
//     to be unreachable.
const (
	FailoverShareOptionsFallbackPolicyFailConst  = "fail"
	FailoverShareOptionsFallbackPolicySplitConst = "split"
)

// NewFailoverShareOptions : Instantiate FailoverShareOptions
func (*VpcV1) NewFailoverShareOptions(shareID string) *FailoverShareOptions {
	return &FailoverShareOptions{
		ShareID: core.StringPtr(shareID),
	}
}

// SetShareID : Allow user to set ShareID
func (_options *FailoverShareOptions) SetShareID(shareID string) *FailoverShareOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetFallbackPolicy : Allow user to set FallbackPolicy
func (_options *FailoverShareOptions) SetFallbackPolicy(fallbackPolicy string) *FailoverShareOptions {
	_options.FallbackPolicy = core.StringPtr(fallbackPolicy)
	return _options
}

// SetTimeout : Allow user to set Timeout
func (_options *FailoverShareOptions) SetTimeout(timeout int64) *FailoverShareOptions {
	_options.Timeout = core.Int64Ptr(timeout)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *FailoverShareOptions) SetHeaders(param map[string]string) *FailoverShareOptions {
	options.Headers = param
	return options
}

// FloatingIP : FloatingIP struct
type FloatingIP struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The date and time that the floating IP was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The name for this floating IP. The name is unique across all floating IPs in the region.
	Name *string `json:"name" validate:"required"`

	// The resource group for this floating IP.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the floating IP.
	Status *string `json:"status" validate:"required"`

	// The target of this floating IP.
	Target FloatingIPTargetIntf `json:"target,omitempty"`

	// The zone this floating IP resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the FloatingIP.Status property.
// The status of the floating IP.
const (
	FloatingIPStatusAvailableConst = "available"
	FloatingIPStatusDeletingConst  = "deleting"
	FloatingIPStatusFailedConst    = "failed"
	FloatingIPStatusPendingConst   = "pending"
)

// UnmarshalFloatingIP unmarshals an instance of FloatingIP from the specified map of raw messages.
func UnmarshalFloatingIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFloatingIPTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPCollection : FloatingIPCollection struct
type FloatingIPCollection struct {
	// A link to the first page of resources.
	First *FloatingIPCollectionFirst `json:"first" validate:"required"`

	// Collection of floating IPs.
	FloatingIps []FloatingIP `json:"floating_ips" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *FloatingIPCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalFloatingIPCollection unmarshals an instance of FloatingIPCollection from the specified map of raw messages.
func UnmarshalFloatingIPCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFloatingIPCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalFloatingIPCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *FloatingIPCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// FloatingIPCollectionFirst : A link to the first page of resources.
type FloatingIPCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFloatingIPCollectionFirst unmarshals an instance of FloatingIPCollectionFirst from the specified map of raw messages.
func UnmarshalFloatingIPCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type FloatingIPCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFloatingIPCollectionNext unmarshals an instance of FloatingIPCollectionNext from the specified map of raw messages.
func UnmarshalFloatingIPCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPPatch : FloatingIPPatch struct
type FloatingIPPatch struct {
	// The name for this floating IP. The name must not be used by another floating IP in the region.
	Name *string `json:"name,omitempty"`

	// The target resource to bind this floating IP to, replacing any existing binding.
	// The floating IP must not be required by another resource, such as a public gateway.
	//
	// The target resource must not already have a floating IP bound to it if the target
	// resource is:
	//
	// - an instance network interface
	// - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
	Target FloatingIPTargetPatchIntf `json:"target,omitempty"`
}

// UnmarshalFloatingIPPatch unmarshals an instance of FloatingIPPatch from the specified map of raw messages.
func UnmarshalFloatingIPPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFloatingIPTargetPatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the FloatingIPPatch
func (floatingIPPatch *FloatingIPPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(floatingIPPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// FloatingIPPrototype : FloatingIPPrototype struct
// Models which "extend" this model:
// - FloatingIPPrototypeFloatingIPByZone
// - FloatingIPPrototypeFloatingIPByTarget
type FloatingIPPrototype struct {
	// The name for this floating IP. The name must not be used by another floating IP in the region. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The zone this floating IP will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The target resource to bind this floating IP to.
	//
	// The target resource must not already have a floating IP bound to it if the target
	// resource is:
	//
	// - an instance network interface
	// - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
	Target FloatingIPTargetPrototypeIntf `json:"target,omitempty"`
}

func (*FloatingIPPrototype) isaFloatingIPPrototype() bool {
	return true
}

type FloatingIPPrototypeIntf interface {
	isaFloatingIPPrototype() bool
}

// UnmarshalFloatingIPPrototype unmarshals an instance of FloatingIPPrototype from the specified map of raw messages.
func UnmarshalFloatingIPPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFloatingIPTargetPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPReference : FloatingIPReference struct
type FloatingIPReference struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *FloatingIPReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The name for this floating IP. The name is unique across all floating IPs in the region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalFloatingIPReference unmarshals an instance of FloatingIPReference from the specified map of raw messages.
func UnmarshalFloatingIPReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPReference)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalFloatingIPReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type FloatingIPReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalFloatingIPReferenceDeleted unmarshals an instance of FloatingIPReferenceDeleted from the specified map of raw messages.
func UnmarshalFloatingIPReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTarget : The target of this floating IP.
// Models which "extend" this model:
// - FloatingIPTargetNetworkInterfaceReference
// - FloatingIPTargetBareMetalServerNetworkInterfaceReference
// - FloatingIPTargetPublicGatewayReference
type FloatingIPTarget struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The name for this instance network interface.
	Name *string `json:"name,omitempty"`

	PrimaryIP *ReservedIPReference `json:"primary_ip,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`

	// The CRN for this public gateway.
	CRN *string `json:"crn,omitempty"`
}

// Constants associated with the FloatingIPTarget.ResourceType property.
// The resource type.
const (
	FloatingIPTargetResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FloatingIPTarget) isaFloatingIPTarget() bool {
	return true
}

type FloatingIPTargetIntf interface {
	isaFloatingIPTarget() bool
}

// UnmarshalFloatingIPTarget unmarshals an instance of FloatingIPTarget from the specified map of raw messages.
func UnmarshalFloatingIPTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTarget)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatch : The target resource to bind this floating IP to, replacing any existing binding. The floating IP must not be required
// by another resource, such as a public gateway.
//
// The target resource must not already have a floating IP bound to it if the target resource is:
//
// - an instance network interface
// - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
// Models which "extend" this model:
// - FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity
// - FloatingIPTargetPatchNetworkInterfaceIdentity
type FloatingIPTargetPatch struct {
	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href,omitempty"`
}

func (*FloatingIPTargetPatch) isaFloatingIPTargetPatch() bool {
	return true
}

type FloatingIPTargetPatchIntf interface {
	isaFloatingIPTargetPatch() bool
}

// UnmarshalFloatingIPTargetPatch unmarshals an instance of FloatingIPTargetPatch from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototype : The target resource to bind this floating IP to.
//
// The target resource must not already have a floating IP bound to it if the target resource is:
//
// - an instance network interface
// - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
// Models which "extend" this model:
// - FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity
// - FloatingIPTargetPrototypeNetworkInterfaceIdentity
type FloatingIPTargetPrototype struct {
	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href,omitempty"`
}

func (*FloatingIPTargetPrototype) isaFloatingIPTargetPrototype() bool {
	return true
}

type FloatingIPTargetPrototypeIntf interface {
	isaFloatingIPTargetPrototype() bool
}

// UnmarshalFloatingIPTargetPrototype unmarshals an instance of FloatingIPTargetPrototype from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPUnpaginatedCollection : FloatingIPUnpaginatedCollection struct
type FloatingIPUnpaginatedCollection struct {
	// Collection of floating IPs.
	FloatingIps []FloatingIP `json:"floating_ips" validate:"required"`
}

// UnmarshalFloatingIPUnpaginatedCollection unmarshals an instance of FloatingIPUnpaginatedCollection from the specified map of raw messages.
func UnmarshalFloatingIPUnpaginatedCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPUnpaginatedCollection)
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollector : FlowLogCollector struct
type FlowLogCollector struct {
	// Indicates whether this collector is active.
	Active *bool `json:"active" validate:"required"`

	// Indicates whether this flow log collector will be automatically deleted when `target` is deleted. At present, this
	// is always `true`, but may be modifiable in the future.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// The date and time that the flow log collector was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this flow log collector.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this flow log collector.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this flow log collector.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the flow log collector.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this flow log collector. The name is unique across all flow log collectors in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this flow log collector.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The Cloud Object Storage bucket where the collected flows are logged.
	StorageBucket *LegacyCloudObjectStorageBucketReference `json:"storage_bucket" validate:"required"`

	// The target this collector is collecting flow logs for.
	// - If the target is an instance network interface, flow logs will be collected
	//   for that instance network interface.
	// - If the target is a virtual server instance, flow logs will be collected
	//   for all network interfaces on that instance.
	// - If the target is a subnet, flow logs will be collected
	//   for all instance network interfaces attached to that subnet.
	// - If the target is a VPC, flow logs will be collected for instance network interfaces
	//   attached to all subnets within that VPC.
	// If the target is an instance, subnet, or VPC, flow logs will not be collected
	// for any instance network interfaces within the target that are themselves the target of
	// a more specific flow log collector.
	Target FlowLogCollectorTargetIntf `json:"target" validate:"required"`

	// The VPC this flow log collector resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the FlowLogCollector.LifecycleState property.
// The lifecycle state of the flow log collector.
const (
	FlowLogCollectorLifecycleStateDeletingConst  = "deleting"
	FlowLogCollectorLifecycleStateFailedConst    = "failed"
	FlowLogCollectorLifecycleStatePendingConst   = "pending"
	FlowLogCollectorLifecycleStateStableConst    = "stable"
	FlowLogCollectorLifecycleStateSuspendedConst = "suspended"
	FlowLogCollectorLifecycleStateUpdatingConst  = "updating"
	FlowLogCollectorLifecycleStateWaitingConst   = "waiting"
)

// UnmarshalFlowLogCollector unmarshals an instance of FlowLogCollector from the specified map of raw messages.
func UnmarshalFlowLogCollector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollector)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_bucket", &obj.StorageBucket, UnmarshalLegacyCloudObjectStorageBucketReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFlowLogCollectorTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorCollection : FlowLogCollectorCollection struct
type FlowLogCollectorCollection struct {
	// A link to the first page of resources.
	First *FlowLogCollectorCollectionFirst `json:"first" validate:"required"`

	// Collection of flow log collectors.
	FlowLogCollectors []FlowLogCollector `json:"flow_log_collectors" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *FlowLogCollectorCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalFlowLogCollectorCollection unmarshals an instance of FlowLogCollectorCollection from the specified map of raw messages.
func UnmarshalFlowLogCollectorCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFlowLogCollectorCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "flow_log_collectors", &obj.FlowLogCollectors, UnmarshalFlowLogCollector)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalFlowLogCollectorCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *FlowLogCollectorCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// FlowLogCollectorCollectionFirst : A link to the first page of resources.
type FlowLogCollectorCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFlowLogCollectorCollectionFirst unmarshals an instance of FlowLogCollectorCollectionFirst from the specified map of raw messages.
func UnmarshalFlowLogCollectorCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type FlowLogCollectorCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFlowLogCollectorCollectionNext unmarshals an instance of FlowLogCollectorCollectionNext from the specified map of raw messages.
func UnmarshalFlowLogCollectorCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPatch : FlowLogCollectorPatch struct
type FlowLogCollectorPatch struct {
	// Indicates whether this collector is active. Updating to false deactivates the collector and updating to true
	// activates the collector.
	Active *bool `json:"active,omitempty"`

	// The name for this flow log collector. The name must not be used by another flow log collector in the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalFlowLogCollectorPatch unmarshals an instance of FlowLogCollectorPatch from the specified map of raw messages.
func UnmarshalFlowLogCollectorPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPatch)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the FlowLogCollectorPatch
func (flowLogCollectorPatch *FlowLogCollectorPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(flowLogCollectorPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// FlowLogCollectorTarget : The target this collector is collecting flow logs for.
//   - If the target is an instance network interface, flow logs will be collected
//     for that instance network interface.
//   - If the target is a virtual server instance, flow logs will be collected
//     for all network interfaces on that instance.
//   - If the target is a subnet, flow logs will be collected
//     for all instance network interfaces attached to that subnet.
//   - If the target is a VPC, flow logs will be collected for instance network interfaces
//     attached to all subnets within that VPC. If the target is an instance, subnet, or VPC, flow logs will not be
//
// collected for any instance network interfaces within the target that are themselves the target of a more specific
// flow log collector.
// Models which "extend" this model:
// - FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext
// - FlowLogCollectorTargetInstanceReference
// - FlowLogCollectorTargetSubnetReference
// - FlowLogCollectorTargetVPCReference
type FlowLogCollectorTarget struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The name for this instance network interface.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`
}

// Constants associated with the FlowLogCollectorTarget.ResourceType property.
// The resource type.
const (
	FlowLogCollectorTargetResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FlowLogCollectorTarget) isaFlowLogCollectorTarget() bool {
	return true
}

type FlowLogCollectorTargetIntf interface {
	isaFlowLogCollectorTarget() bool
}

// UnmarshalFlowLogCollectorTarget unmarshals an instance of FlowLogCollectorTarget from the specified map of raw messages.
func UnmarshalFlowLogCollectorTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTarget)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototype : The target this collector will collect flow logs for. If the target is an instance, subnet, or VPC, flow logs will
// not be collected for any instance network interfaces within the target that are themselves the target of a more
// specific flow log collector.
// Models which "extend" this model:
// - FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity
// - FlowLogCollectorTargetPrototypeInstanceIdentity
// - FlowLogCollectorTargetPrototypeSubnetIdentity
// - FlowLogCollectorTargetPrototypeVPCIdentity
type FlowLogCollectorTargetPrototype struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`
}

func (*FlowLogCollectorTargetPrototype) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

type FlowLogCollectorTargetPrototypeIntf interface {
	isaFlowLogCollectorTargetPrototype() bool
}

// UnmarshalFlowLogCollectorTargetPrototype unmarshals an instance of FlowLogCollectorTargetPrototype from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GenericResourceReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type GenericResourceReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalGenericResourceReferenceDeleted unmarshals an instance of GenericResourceReferenceDeleted from the specified map of raw messages.
func UnmarshalGenericResourceReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GenericResourceReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetBackupPolicyJobOptions : The GetBackupPolicyJob options.
type GetBackupPolicyJobOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// The backup policy job identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBackupPolicyJobOptions : Instantiate GetBackupPolicyJobOptions
func (*VpcV1) NewGetBackupPolicyJobOptions(backupPolicyID string, id string) *GetBackupPolicyJobOptions {
	return &GetBackupPolicyJobOptions{
		BackupPolicyID: core.StringPtr(backupPolicyID),
		ID:             core.StringPtr(id),
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *GetBackupPolicyJobOptions) SetBackupPolicyID(backupPolicyID string) *GetBackupPolicyJobOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetBackupPolicyJobOptions) SetID(id string) *GetBackupPolicyJobOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBackupPolicyJobOptions) SetHeaders(param map[string]string) *GetBackupPolicyJobOptions {
	options.Headers = param
	return options
}

// GetBackupPolicyOptions : The GetBackupPolicy options.
type GetBackupPolicyOptions struct {
	// The backup policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBackupPolicyOptions : Instantiate GetBackupPolicyOptions
func (*VpcV1) NewGetBackupPolicyOptions(id string) *GetBackupPolicyOptions {
	return &GetBackupPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetBackupPolicyOptions) SetID(id string) *GetBackupPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBackupPolicyOptions) SetHeaders(param map[string]string) *GetBackupPolicyOptions {
	options.Headers = param
	return options
}

// GetBackupPolicyPlanOptions : The GetBackupPolicyPlan options.
type GetBackupPolicyPlanOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// The backup policy plan identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBackupPolicyPlanOptions : Instantiate GetBackupPolicyPlanOptions
func (*VpcV1) NewGetBackupPolicyPlanOptions(backupPolicyID string, id string) *GetBackupPolicyPlanOptions {
	return &GetBackupPolicyPlanOptions{
		BackupPolicyID: core.StringPtr(backupPolicyID),
		ID:             core.StringPtr(id),
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *GetBackupPolicyPlanOptions) SetBackupPolicyID(backupPolicyID string) *GetBackupPolicyPlanOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetBackupPolicyPlanOptions) SetID(id string) *GetBackupPolicyPlanOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBackupPolicyPlanOptions) SetHeaders(param map[string]string) *GetBackupPolicyPlanOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerDiskOptions : The GetBareMetalServerDisk options.
type GetBareMetalServerDiskOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server disk identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerDiskOptions : Instantiate GetBareMetalServerDiskOptions
func (*VpcV1) NewGetBareMetalServerDiskOptions(bareMetalServerID string, id string) *GetBareMetalServerDiskOptions {
	return &GetBareMetalServerDiskOptions{
		BareMetalServerID: core.StringPtr(bareMetalServerID),
		ID:                core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *GetBareMetalServerDiskOptions) SetBareMetalServerID(bareMetalServerID string) *GetBareMetalServerDiskOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetBareMetalServerDiskOptions) SetID(id string) *GetBareMetalServerDiskOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerDiskOptions) SetHeaders(param map[string]string) *GetBareMetalServerDiskOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerInitializationOptions : The GetBareMetalServerInitialization options.
type GetBareMetalServerInitializationOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerInitializationOptions : Instantiate GetBareMetalServerInitializationOptions
func (*VpcV1) NewGetBareMetalServerInitializationOptions(id string) *GetBareMetalServerInitializationOptions {
	return &GetBareMetalServerInitializationOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetBareMetalServerInitializationOptions) SetID(id string) *GetBareMetalServerInitializationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerInitializationOptions) SetHeaders(param map[string]string) *GetBareMetalServerInitializationOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerNetworkInterfaceFloatingIPOptions : The GetBareMetalServerNetworkInterfaceFloatingIP options.
type GetBareMetalServerNetworkInterfaceFloatingIPOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerNetworkInterfaceFloatingIPOptions : Instantiate GetBareMetalServerNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewGetBareMetalServerNetworkInterfaceFloatingIPOptions(bareMetalServerID string, networkInterfaceID string, id string) *GetBareMetalServerNetworkInterfaceFloatingIPOptions {
	return &GetBareMetalServerNetworkInterfaceFloatingIPOptions{
		BareMetalServerID:  core.StringPtr(bareMetalServerID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *GetBareMetalServerNetworkInterfaceFloatingIPOptions) SetBareMetalServerID(bareMetalServerID string) *GetBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *GetBareMetalServerNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *GetBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetBareMetalServerNetworkInterfaceFloatingIPOptions) SetID(id string) *GetBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *GetBareMetalServerNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerNetworkInterfaceIPOptions : The GetBareMetalServerNetworkInterfaceIP options.
type GetBareMetalServerNetworkInterfaceIPOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerNetworkInterfaceIPOptions : Instantiate GetBareMetalServerNetworkInterfaceIPOptions
func (*VpcV1) NewGetBareMetalServerNetworkInterfaceIPOptions(bareMetalServerID string, networkInterfaceID string, id string) *GetBareMetalServerNetworkInterfaceIPOptions {
	return &GetBareMetalServerNetworkInterfaceIPOptions{
		BareMetalServerID:  core.StringPtr(bareMetalServerID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *GetBareMetalServerNetworkInterfaceIPOptions) SetBareMetalServerID(bareMetalServerID string) *GetBareMetalServerNetworkInterfaceIPOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *GetBareMetalServerNetworkInterfaceIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *GetBareMetalServerNetworkInterfaceIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetBareMetalServerNetworkInterfaceIPOptions) SetID(id string) *GetBareMetalServerNetworkInterfaceIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerNetworkInterfaceIPOptions) SetHeaders(param map[string]string) *GetBareMetalServerNetworkInterfaceIPOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerNetworkInterfaceOptions : The GetBareMetalServerNetworkInterface options.
type GetBareMetalServerNetworkInterfaceOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerNetworkInterfaceOptions : Instantiate GetBareMetalServerNetworkInterfaceOptions
func (*VpcV1) NewGetBareMetalServerNetworkInterfaceOptions(bareMetalServerID string, id string) *GetBareMetalServerNetworkInterfaceOptions {
	return &GetBareMetalServerNetworkInterfaceOptions{
		BareMetalServerID: core.StringPtr(bareMetalServerID),
		ID:                core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *GetBareMetalServerNetworkInterfaceOptions) SetBareMetalServerID(bareMetalServerID string) *GetBareMetalServerNetworkInterfaceOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetBareMetalServerNetworkInterfaceOptions) SetID(id string) *GetBareMetalServerNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetBareMetalServerNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerOptions : The GetBareMetalServer options.
type GetBareMetalServerOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerOptions : Instantiate GetBareMetalServerOptions
func (*VpcV1) NewGetBareMetalServerOptions(id string) *GetBareMetalServerOptions {
	return &GetBareMetalServerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetBareMetalServerOptions) SetID(id string) *GetBareMetalServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerOptions) SetHeaders(param map[string]string) *GetBareMetalServerOptions {
	options.Headers = param
	return options
}

// GetBareMetalServerProfileOptions : The GetBareMetalServerProfile options.
type GetBareMetalServerProfileOptions struct {
	// The bare metal server profile name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBareMetalServerProfileOptions : Instantiate GetBareMetalServerProfileOptions
func (*VpcV1) NewGetBareMetalServerProfileOptions(name string) *GetBareMetalServerProfileOptions {
	return &GetBareMetalServerProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetBareMetalServerProfileOptions) SetName(name string) *GetBareMetalServerProfileOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetBareMetalServerProfileOptions) SetHeaders(param map[string]string) *GetBareMetalServerProfileOptions {
	options.Headers = param
	return options
}

// GetDedicatedHostDiskOptions : The GetDedicatedHostDisk options.
type GetDedicatedHostDiskOptions struct {
	// The dedicated host identifier.
	DedicatedHostID *string `json:"dedicated_host_id" validate:"required,ne="`

	// The dedicated host disk identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostDiskOptions : Instantiate GetDedicatedHostDiskOptions
func (*VpcV1) NewGetDedicatedHostDiskOptions(dedicatedHostID string, id string) *GetDedicatedHostDiskOptions {
	return &GetDedicatedHostDiskOptions{
		DedicatedHostID: core.StringPtr(dedicatedHostID),
		ID:              core.StringPtr(id),
	}
}

// SetDedicatedHostID : Allow user to set DedicatedHostID
func (_options *GetDedicatedHostDiskOptions) SetDedicatedHostID(dedicatedHostID string) *GetDedicatedHostDiskOptions {
	_options.DedicatedHostID = core.StringPtr(dedicatedHostID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDedicatedHostDiskOptions) SetID(id string) *GetDedicatedHostDiskOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostDiskOptions) SetHeaders(param map[string]string) *GetDedicatedHostDiskOptions {
	options.Headers = param
	return options
}

// GetDedicatedHostGroupOptions : The GetDedicatedHostGroup options.
type GetDedicatedHostGroupOptions struct {
	// The dedicated host group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostGroupOptions : Instantiate GetDedicatedHostGroupOptions
func (*VpcV1) NewGetDedicatedHostGroupOptions(id string) *GetDedicatedHostGroupOptions {
	return &GetDedicatedHostGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetDedicatedHostGroupOptions) SetID(id string) *GetDedicatedHostGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostGroupOptions) SetHeaders(param map[string]string) *GetDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// GetDedicatedHostOptions : The GetDedicatedHost options.
type GetDedicatedHostOptions struct {
	// The dedicated host identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostOptions : Instantiate GetDedicatedHostOptions
func (*VpcV1) NewGetDedicatedHostOptions(id string) *GetDedicatedHostOptions {
	return &GetDedicatedHostOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetDedicatedHostOptions) SetID(id string) *GetDedicatedHostOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostOptions) SetHeaders(param map[string]string) *GetDedicatedHostOptions {
	options.Headers = param
	return options
}

// GetDedicatedHostProfileOptions : The GetDedicatedHostProfile options.
type GetDedicatedHostProfileOptions struct {
	// The dedicated host profile name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostProfileOptions : Instantiate GetDedicatedHostProfileOptions
func (*VpcV1) NewGetDedicatedHostProfileOptions(name string) *GetDedicatedHostProfileOptions {
	return &GetDedicatedHostProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetDedicatedHostProfileOptions) SetName(name string) *GetDedicatedHostProfileOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostProfileOptions) SetHeaders(param map[string]string) *GetDedicatedHostProfileOptions {
	options.Headers = param
	return options
}

// GetEndpointGatewayIPOptions : The GetEndpointGatewayIP options.
type GetEndpointGatewayIPOptions struct {
	// The endpoint gateway identifier.
	EndpointGatewayID *string `json:"endpoint_gateway_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetEndpointGatewayIPOptions : Instantiate GetEndpointGatewayIPOptions
func (*VpcV1) NewGetEndpointGatewayIPOptions(endpointGatewayID string, id string) *GetEndpointGatewayIPOptions {
	return &GetEndpointGatewayIPOptions{
		EndpointGatewayID: core.StringPtr(endpointGatewayID),
		ID:                core.StringPtr(id),
	}
}

// SetEndpointGatewayID : Allow user to set EndpointGatewayID
func (_options *GetEndpointGatewayIPOptions) SetEndpointGatewayID(endpointGatewayID string) *GetEndpointGatewayIPOptions {
	_options.EndpointGatewayID = core.StringPtr(endpointGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetEndpointGatewayIPOptions) SetID(id string) *GetEndpointGatewayIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetEndpointGatewayIPOptions) SetHeaders(param map[string]string) *GetEndpointGatewayIPOptions {
	options.Headers = param
	return options
}

// GetEndpointGatewayOptions : The GetEndpointGateway options.
type GetEndpointGatewayOptions struct {
	// The endpoint gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetEndpointGatewayOptions : Instantiate GetEndpointGatewayOptions
func (*VpcV1) NewGetEndpointGatewayOptions(id string) *GetEndpointGatewayOptions {
	return &GetEndpointGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetEndpointGatewayOptions) SetID(id string) *GetEndpointGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetEndpointGatewayOptions) SetHeaders(param map[string]string) *GetEndpointGatewayOptions {
	options.Headers = param
	return options
}

// GetFloatingIPOptions : The GetFloatingIP options.
type GetFloatingIPOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFloatingIPOptions : Instantiate GetFloatingIPOptions
func (*VpcV1) NewGetFloatingIPOptions(id string) *GetFloatingIPOptions {
	return &GetFloatingIPOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetFloatingIPOptions) SetID(id string) *GetFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetFloatingIPOptions) SetHeaders(param map[string]string) *GetFloatingIPOptions {
	options.Headers = param
	return options
}

// GetFlowLogCollectorOptions : The GetFlowLogCollector options.
type GetFlowLogCollectorOptions struct {
	// The flow log collector identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFlowLogCollectorOptions : Instantiate GetFlowLogCollectorOptions
func (*VpcV1) NewGetFlowLogCollectorOptions(id string) *GetFlowLogCollectorOptions {
	return &GetFlowLogCollectorOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetFlowLogCollectorOptions) SetID(id string) *GetFlowLogCollectorOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetFlowLogCollectorOptions) SetHeaders(param map[string]string) *GetFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// GetIkePolicyOptions : The GetIkePolicy options.
type GetIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIkePolicyOptions : Instantiate GetIkePolicyOptions
func (*VpcV1) NewGetIkePolicyOptions(id string) *GetIkePolicyOptions {
	return &GetIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetIkePolicyOptions) SetID(id string) *GetIkePolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetIkePolicyOptions) SetHeaders(param map[string]string) *GetIkePolicyOptions {
	options.Headers = param
	return options
}

// GetImageExportJobOptions : The GetImageExportJob options.
type GetImageExportJobOptions struct {
	// The image identifier.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// The image export job identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetImageExportJobOptions : Instantiate GetImageExportJobOptions
func (*VpcV1) NewGetImageExportJobOptions(imageID string, id string) *GetImageExportJobOptions {
	return &GetImageExportJobOptions{
		ImageID: core.StringPtr(imageID),
		ID:      core.StringPtr(id),
	}
}

// SetImageID : Allow user to set ImageID
func (_options *GetImageExportJobOptions) SetImageID(imageID string) *GetImageExportJobOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetImageExportJobOptions) SetID(id string) *GetImageExportJobOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetImageExportJobOptions) SetHeaders(param map[string]string) *GetImageExportJobOptions {
	options.Headers = param
	return options
}

// GetImageOptions : The GetImage options.
type GetImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetImageOptions : Instantiate GetImageOptions
func (*VpcV1) NewGetImageOptions(id string) *GetImageOptions {
	return &GetImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetImageOptions) SetID(id string) *GetImageOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetImageOptions) SetHeaders(param map[string]string) *GetImageOptions {
	options.Headers = param
	return options
}

// GetInstanceDiskOptions : The GetInstanceDisk options.
type GetInstanceDiskOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance disk identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceDiskOptions : Instantiate GetInstanceDiskOptions
func (*VpcV1) NewGetInstanceDiskOptions(instanceID string, id string) *GetInstanceDiskOptions {
	return &GetInstanceDiskOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetInstanceDiskOptions) SetInstanceID(instanceID string) *GetInstanceDiskOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceDiskOptions) SetID(id string) *GetInstanceDiskOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceDiskOptions) SetHeaders(param map[string]string) *GetInstanceDiskOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupManagerActionOptions : The GetInstanceGroupManagerAction options.
type GetInstanceGroupManagerActionOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager action identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupManagerActionOptions : Instantiate GetInstanceGroupManagerActionOptions
func (*VpcV1) NewGetInstanceGroupManagerActionOptions(instanceGroupID string, instanceGroupManagerID string, id string) *GetInstanceGroupManagerActionOptions {
	return &GetInstanceGroupManagerActionOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *GetInstanceGroupManagerActionOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupManagerActionOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *GetInstanceGroupManagerActionOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *GetInstanceGroupManagerActionOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceGroupManagerActionOptions) SetID(id string) *GetInstanceGroupManagerActionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupManagerActionOptions) SetHeaders(param map[string]string) *GetInstanceGroupManagerActionOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupManagerOptions : The GetInstanceGroupManager options.
type GetInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupManagerOptions : Instantiate GetInstanceGroupManagerOptions
func (*VpcV1) NewGetInstanceGroupManagerOptions(instanceGroupID string, id string) *GetInstanceGroupManagerOptions {
	return &GetInstanceGroupManagerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *GetInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupManagerOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceGroupManagerOptions) SetID(id string) *GetInstanceGroupManagerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupManagerOptions) SetHeaders(param map[string]string) *GetInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupManagerPolicyOptions : The GetInstanceGroupManagerPolicy options.
type GetInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupManagerPolicyOptions : Instantiate GetInstanceGroupManagerPolicyOptions
func (*VpcV1) NewGetInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, id string) *GetInstanceGroupManagerPolicyOptions {
	return &GetInstanceGroupManagerPolicyOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *GetInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *GetInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *GetInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceGroupManagerPolicyOptions) SetID(id string) *GetInstanceGroupManagerPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *GetInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupMembershipOptions : The GetInstanceGroupMembership options.
type GetInstanceGroupMembershipOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group membership identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupMembershipOptions : Instantiate GetInstanceGroupMembershipOptions
func (*VpcV1) NewGetInstanceGroupMembershipOptions(instanceGroupID string, id string) *GetInstanceGroupMembershipOptions {
	return &GetInstanceGroupMembershipOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *GetInstanceGroupMembershipOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupMembershipOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceGroupMembershipOptions) SetID(id string) *GetInstanceGroupMembershipOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupMembershipOptions) SetHeaders(param map[string]string) *GetInstanceGroupMembershipOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupOptions : The GetInstanceGroup options.
type GetInstanceGroupOptions struct {
	// The instance group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupOptions : Instantiate GetInstanceGroupOptions
func (*VpcV1) NewGetInstanceGroupOptions(id string) *GetInstanceGroupOptions {
	return &GetInstanceGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetInstanceGroupOptions) SetID(id string) *GetInstanceGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupOptions) SetHeaders(param map[string]string) *GetInstanceGroupOptions {
	options.Headers = param
	return options
}

// GetInstanceInitializationOptions : The GetInstanceInitialization options.
type GetInstanceInitializationOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceInitializationOptions : Instantiate GetInstanceInitializationOptions
func (*VpcV1) NewGetInstanceInitializationOptions(id string) *GetInstanceInitializationOptions {
	return &GetInstanceInitializationOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetInstanceInitializationOptions) SetID(id string) *GetInstanceInitializationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceInitializationOptions) SetHeaders(param map[string]string) *GetInstanceInitializationOptions {
	options.Headers = param
	return options
}

// GetInstanceNetworkInterfaceFloatingIPOptions : The GetInstanceNetworkInterfaceFloatingIP options.
type GetInstanceNetworkInterfaceFloatingIPOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceNetworkInterfaceFloatingIPOptions : Instantiate GetInstanceNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewGetInstanceNetworkInterfaceFloatingIPOptions(instanceID string, networkInterfaceID string, id string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	return &GetInstanceNetworkInterfaceFloatingIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetInstanceNetworkInterfaceFloatingIPOptions) SetInstanceID(instanceID string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *GetInstanceNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceNetworkInterfaceFloatingIPOptions) SetID(id string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// GetInstanceNetworkInterfaceIPOptions : The GetInstanceNetworkInterfaceIP options.
type GetInstanceNetworkInterfaceIPOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceNetworkInterfaceIPOptions : Instantiate GetInstanceNetworkInterfaceIPOptions
func (*VpcV1) NewGetInstanceNetworkInterfaceIPOptions(instanceID string, networkInterfaceID string, id string) *GetInstanceNetworkInterfaceIPOptions {
	return &GetInstanceNetworkInterfaceIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetInstanceNetworkInterfaceIPOptions) SetInstanceID(instanceID string) *GetInstanceNetworkInterfaceIPOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *GetInstanceNetworkInterfaceIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *GetInstanceNetworkInterfaceIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceNetworkInterfaceIPOptions) SetID(id string) *GetInstanceNetworkInterfaceIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceNetworkInterfaceIPOptions) SetHeaders(param map[string]string) *GetInstanceNetworkInterfaceIPOptions {
	options.Headers = param
	return options
}

// GetInstanceNetworkInterfaceOptions : The GetInstanceNetworkInterface options.
type GetInstanceNetworkInterfaceOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceNetworkInterfaceOptions : Instantiate GetInstanceNetworkInterfaceOptions
func (*VpcV1) NewGetInstanceNetworkInterfaceOptions(instanceID string, id string) *GetInstanceNetworkInterfaceOptions {
	return &GetInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *GetInstanceNetworkInterfaceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceNetworkInterfaceOptions) SetID(id string) *GetInstanceNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetInstanceOptions : The GetInstance options.
type GetInstanceOptions struct {
	// The virtual server instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceOptions : Instantiate GetInstanceOptions
func (*VpcV1) NewGetInstanceOptions(id string) *GetInstanceOptions {
	return &GetInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetInstanceOptions) SetID(id string) *GetInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceOptions) SetHeaders(param map[string]string) *GetInstanceOptions {
	options.Headers = param
	return options
}

// GetInstanceProfileOptions : The GetInstanceProfile options.
type GetInstanceProfileOptions struct {
	// The instance profile name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceProfileOptions : Instantiate GetInstanceProfileOptions
func (*VpcV1) NewGetInstanceProfileOptions(name string) *GetInstanceProfileOptions {
	return &GetInstanceProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetInstanceProfileOptions) SetName(name string) *GetInstanceProfileOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceProfileOptions) SetHeaders(param map[string]string) *GetInstanceProfileOptions {
	options.Headers = param
	return options
}

// GetInstanceTemplateOptions : The GetInstanceTemplate options.
type GetInstanceTemplateOptions struct {
	// The instance template identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceTemplateOptions : Instantiate GetInstanceTemplateOptions
func (*VpcV1) NewGetInstanceTemplateOptions(id string) *GetInstanceTemplateOptions {
	return &GetInstanceTemplateOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetInstanceTemplateOptions) SetID(id string) *GetInstanceTemplateOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceTemplateOptions) SetHeaders(param map[string]string) *GetInstanceTemplateOptions {
	options.Headers = param
	return options
}

// GetInstanceVolumeAttachmentOptions : The GetInstanceVolumeAttachment options.
type GetInstanceVolumeAttachmentOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceVolumeAttachmentOptions : Instantiate GetInstanceVolumeAttachmentOptions
func (*VpcV1) NewGetInstanceVolumeAttachmentOptions(instanceID string, id string) *GetInstanceVolumeAttachmentOptions {
	return &GetInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *GetInstanceVolumeAttachmentOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetInstanceVolumeAttachmentOptions) SetID(id string) *GetInstanceVolumeAttachmentOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *GetInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// GetIpsecPolicyOptions : The GetIpsecPolicy options.
type GetIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIpsecPolicyOptions : Instantiate GetIpsecPolicyOptions
func (*VpcV1) NewGetIpsecPolicyOptions(id string) *GetIpsecPolicyOptions {
	return &GetIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetIpsecPolicyOptions) SetID(id string) *GetIpsecPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetIpsecPolicyOptions) SetHeaders(param map[string]string) *GetIpsecPolicyOptions {
	options.Headers = param
	return options
}

// GetKeyOptions : The GetKey options.
type GetKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetKeyOptions : Instantiate GetKeyOptions
func (*VpcV1) NewGetKeyOptions(id string) *GetKeyOptions {
	return &GetKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetKeyOptions) SetID(id string) *GetKeyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetKeyOptions) SetHeaders(param map[string]string) *GetKeyOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerOptions : The GetLoadBalancerListener options.
type GetLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerOptions : Instantiate GetLoadBalancerListenerOptions
func (*VpcV1) NewGetLoadBalancerListenerOptions(loadBalancerID string, id string) *GetLoadBalancerListenerOptions {
	return &GetLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *GetLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerListenerOptions) SetID(id string) *GetLoadBalancerListenerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerPolicyOptions : The GetLoadBalancerListenerPolicy options.
type GetLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerPolicyOptions : Instantiate GetLoadBalancerListenerPolicyOptions
func (*VpcV1) NewGetLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *GetLoadBalancerListenerPolicyOptions {
	return &GetLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *GetLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerPolicyOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *GetLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *GetLoadBalancerListenerPolicyOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerListenerPolicyOptions) SetID(id string) *GetLoadBalancerListenerPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerPolicyRuleOptions : The GetLoadBalancerListenerPolicyRule options.
type GetLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerPolicyRuleOptions : Instantiate GetLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewGetLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *GetLoadBalancerListenerPolicyRuleOptions {
	return &GetLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *GetLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerPolicyRuleOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *GetLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *GetLoadBalancerListenerPolicyRuleOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *GetLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *GetLoadBalancerListenerPolicyRuleOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerListenerPolicyRuleOptions) SetID(id string) *GetLoadBalancerListenerPolicyRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerOptions : The GetLoadBalancer options.
type GetLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerOptions : Instantiate GetLoadBalancerOptions
func (*VpcV1) NewGetLoadBalancerOptions(id string) *GetLoadBalancerOptions {
	return &GetLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerOptions) SetID(id string) *GetLoadBalancerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerOptions) SetHeaders(param map[string]string) *GetLoadBalancerOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerPoolMemberOptions : The GetLoadBalancerPoolMember options.
type GetLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required,ne="`

	// The member identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerPoolMemberOptions : Instantiate GetLoadBalancerPoolMemberOptions
func (*VpcV1) NewGetLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *GetLoadBalancerPoolMemberOptions {
	return &GetLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *GetLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerPoolMemberOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetPoolID : Allow user to set PoolID
func (_options *GetLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *GetLoadBalancerPoolMemberOptions {
	_options.PoolID = core.StringPtr(poolID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerPoolMemberOptions) SetID(id string) *GetLoadBalancerPoolMemberOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *GetLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerPoolOptions : The GetLoadBalancerPool options.
type GetLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerPoolOptions : Instantiate GetLoadBalancerPoolOptions
func (*VpcV1) NewGetLoadBalancerPoolOptions(loadBalancerID string, id string) *GetLoadBalancerPoolOptions {
	return &GetLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *GetLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerPoolOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerPoolOptions) SetID(id string) *GetLoadBalancerPoolOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerPoolOptions) SetHeaders(param map[string]string) *GetLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerProfileOptions : The GetLoadBalancerProfile options.
type GetLoadBalancerProfileOptions struct {
	// The load balancer profile name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerProfileOptions : Instantiate GetLoadBalancerProfileOptions
func (*VpcV1) NewGetLoadBalancerProfileOptions(name string) *GetLoadBalancerProfileOptions {
	return &GetLoadBalancerProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetLoadBalancerProfileOptions) SetName(name string) *GetLoadBalancerProfileOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerProfileOptions) SetHeaders(param map[string]string) *GetLoadBalancerProfileOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerStatisticsOptions : The GetLoadBalancerStatistics options.
type GetLoadBalancerStatisticsOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerStatisticsOptions : Instantiate GetLoadBalancerStatisticsOptions
func (*VpcV1) NewGetLoadBalancerStatisticsOptions(id string) *GetLoadBalancerStatisticsOptions {
	return &GetLoadBalancerStatisticsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetLoadBalancerStatisticsOptions) SetID(id string) *GetLoadBalancerStatisticsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerStatisticsOptions) SetHeaders(param map[string]string) *GetLoadBalancerStatisticsOptions {
	options.Headers = param
	return options
}

// GetNetworkACLOptions : The GetNetworkACL options.
type GetNetworkACLOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkACLOptions : Instantiate GetNetworkACLOptions
func (*VpcV1) NewGetNetworkACLOptions(id string) *GetNetworkACLOptions {
	return &GetNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetNetworkACLOptions) SetID(id string) *GetNetworkACLOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkACLOptions) SetHeaders(param map[string]string) *GetNetworkACLOptions {
	options.Headers = param
	return options
}

// GetNetworkACLRuleOptions : The GetNetworkACLRule options.
type GetNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkACLRuleOptions : Instantiate GetNetworkACLRuleOptions
func (*VpcV1) NewGetNetworkACLRuleOptions(networkACLID string, id string) *GetNetworkACLRuleOptions {
	return &GetNetworkACLRuleOptions{
		NetworkACLID: core.StringPtr(networkACLID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (_options *GetNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *GetNetworkACLRuleOptions {
	_options.NetworkACLID = core.StringPtr(networkACLID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetNetworkACLRuleOptions) SetID(id string) *GetNetworkACLRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkACLRuleOptions) SetHeaders(param map[string]string) *GetNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// GetOperatingSystemOptions : The GetOperatingSystem options.
type GetOperatingSystemOptions struct {
	// The operating system name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetOperatingSystemOptions : Instantiate GetOperatingSystemOptions
func (*VpcV1) NewGetOperatingSystemOptions(name string) *GetOperatingSystemOptions {
	return &GetOperatingSystemOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetOperatingSystemOptions) SetName(name string) *GetOperatingSystemOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetOperatingSystemOptions) SetHeaders(param map[string]string) *GetOperatingSystemOptions {
	options.Headers = param
	return options
}

// GetPlacementGroupOptions : The GetPlacementGroup options.
type GetPlacementGroupOptions struct {
	// The placement group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetPlacementGroupOptions : Instantiate GetPlacementGroupOptions
func (*VpcV1) NewGetPlacementGroupOptions(id string) *GetPlacementGroupOptions {
	return &GetPlacementGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetPlacementGroupOptions) SetID(id string) *GetPlacementGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetPlacementGroupOptions) SetHeaders(param map[string]string) *GetPlacementGroupOptions {
	options.Headers = param
	return options
}

// GetPublicGatewayOptions : The GetPublicGateway options.
type GetPublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetPublicGatewayOptions : Instantiate GetPublicGatewayOptions
func (*VpcV1) NewGetPublicGatewayOptions(id string) *GetPublicGatewayOptions {
	return &GetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetPublicGatewayOptions) SetID(id string) *GetPublicGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetPublicGatewayOptions) SetHeaders(param map[string]string) *GetPublicGatewayOptions {
	options.Headers = param
	return options
}

// GetRegionOptions : The GetRegion options.
type GetRegionOptions struct {
	// The region name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRegionOptions : Instantiate GetRegionOptions
func (*VpcV1) NewGetRegionOptions(name string) *GetRegionOptions {
	return &GetRegionOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetRegionOptions) SetName(name string) *GetRegionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetRegionOptions) SetHeaders(param map[string]string) *GetRegionOptions {
	options.Headers = param
	return options
}

// GetRegionZoneOptions : The GetRegionZone options.
type GetRegionZoneOptions struct {
	// The region name.
	RegionName *string `json:"region_name" validate:"required,ne="`

	// The zone name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRegionZoneOptions : Instantiate GetRegionZoneOptions
func (*VpcV1) NewGetRegionZoneOptions(regionName string, name string) *GetRegionZoneOptions {
	return &GetRegionZoneOptions{
		RegionName: core.StringPtr(regionName),
		Name:       core.StringPtr(name),
	}
}

// SetRegionName : Allow user to set RegionName
func (_options *GetRegionZoneOptions) SetRegionName(regionName string) *GetRegionZoneOptions {
	_options.RegionName = core.StringPtr(regionName)
	return _options
}

// SetName : Allow user to set Name
func (_options *GetRegionZoneOptions) SetName(name string) *GetRegionZoneOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetRegionZoneOptions) SetHeaders(param map[string]string) *GetRegionZoneOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupOptions : The GetSecurityGroup options.
type GetSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupOptions : Instantiate GetSecurityGroupOptions
func (*VpcV1) NewGetSecurityGroupOptions(id string) *GetSecurityGroupOptions {
	return &GetSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetSecurityGroupOptions) SetID(id string) *GetSecurityGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupOptions) SetHeaders(param map[string]string) *GetSecurityGroupOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupRuleOptions : The GetSecurityGroupRule options.
type GetSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupRuleOptions : Instantiate GetSecurityGroupRuleOptions
func (*VpcV1) NewGetSecurityGroupRuleOptions(securityGroupID string, id string) *GetSecurityGroupRuleOptions {
	return &GetSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *GetSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *GetSecurityGroupRuleOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSecurityGroupRuleOptions) SetID(id string) *GetSecurityGroupRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupRuleOptions) SetHeaders(param map[string]string) *GetSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupTargetOptions : The GetSecurityGroupTarget options.
type GetSecurityGroupTargetOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The security group target identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupTargetOptions : Instantiate GetSecurityGroupTargetOptions
func (*VpcV1) NewGetSecurityGroupTargetOptions(securityGroupID string, id string) *GetSecurityGroupTargetOptions {
	return &GetSecurityGroupTargetOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *GetSecurityGroupTargetOptions) SetSecurityGroupID(securityGroupID string) *GetSecurityGroupTargetOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSecurityGroupTargetOptions) SetID(id string) *GetSecurityGroupTargetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupTargetOptions) SetHeaders(param map[string]string) *GetSecurityGroupTargetOptions {
	options.Headers = param
	return options
}

// GetShareMountTargetOptions : The GetShareMountTarget options.
type GetShareMountTargetOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// The share mount target identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetShareMountTargetOptions : Instantiate GetShareMountTargetOptions
func (*VpcV1) NewGetShareMountTargetOptions(shareID string, id string) *GetShareMountTargetOptions {
	return &GetShareMountTargetOptions{
		ShareID: core.StringPtr(shareID),
		ID:      core.StringPtr(id),
	}
}

// SetShareID : Allow user to set ShareID
func (_options *GetShareMountTargetOptions) SetShareID(shareID string) *GetShareMountTargetOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetShareMountTargetOptions) SetID(id string) *GetShareMountTargetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetShareMountTargetOptions) SetHeaders(param map[string]string) *GetShareMountTargetOptions {
	options.Headers = param
	return options
}

// GetShareOptions : The GetShare options.
type GetShareOptions struct {
	// The file share identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetShareOptions : Instantiate GetShareOptions
func (*VpcV1) NewGetShareOptions(id string) *GetShareOptions {
	return &GetShareOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetShareOptions) SetID(id string) *GetShareOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetShareOptions) SetHeaders(param map[string]string) *GetShareOptions {
	options.Headers = param
	return options
}

// GetShareProfileOptions : The GetShareProfile options.
type GetShareProfileOptions struct {
	// The file share profile name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetShareProfileOptions : Instantiate GetShareProfileOptions
func (*VpcV1) NewGetShareProfileOptions(name string) *GetShareProfileOptions {
	return &GetShareProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetShareProfileOptions) SetName(name string) *GetShareProfileOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetShareProfileOptions) SetHeaders(param map[string]string) *GetShareProfileOptions {
	options.Headers = param
	return options
}

// GetShareSourceOptions : The GetShareSource options.
type GetShareSourceOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetShareSourceOptions : Instantiate GetShareSourceOptions
func (*VpcV1) NewGetShareSourceOptions(shareID string) *GetShareSourceOptions {
	return &GetShareSourceOptions{
		ShareID: core.StringPtr(shareID),
	}
}

// SetShareID : Allow user to set ShareID
func (_options *GetShareSourceOptions) SetShareID(shareID string) *GetShareSourceOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetShareSourceOptions) SetHeaders(param map[string]string) *GetShareSourceOptions {
	options.Headers = param
	return options
}

// GetSnapshotCloneOptions : The GetSnapshotClone options.
type GetSnapshotCloneOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The zone name.
	ZoneName *string `json:"zone_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSnapshotCloneOptions : Instantiate GetSnapshotCloneOptions
func (*VpcV1) NewGetSnapshotCloneOptions(id string, zoneName string) *GetSnapshotCloneOptions {
	return &GetSnapshotCloneOptions{
		ID:       core.StringPtr(id),
		ZoneName: core.StringPtr(zoneName),
	}
}

// SetID : Allow user to set ID
func (_options *GetSnapshotCloneOptions) SetID(id string) *GetSnapshotCloneOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *GetSnapshotCloneOptions) SetZoneName(zoneName string) *GetSnapshotCloneOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSnapshotCloneOptions) SetHeaders(param map[string]string) *GetSnapshotCloneOptions {
	options.Headers = param
	return options
}

// GetSnapshotOptions : The GetSnapshot options.
type GetSnapshotOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSnapshotOptions : Instantiate GetSnapshotOptions
func (*VpcV1) NewGetSnapshotOptions(id string) *GetSnapshotOptions {
	return &GetSnapshotOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetSnapshotOptions) SetID(id string) *GetSnapshotOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSnapshotOptions) SetHeaders(param map[string]string) *GetSnapshotOptions {
	options.Headers = param
	return options
}

// GetSubnetNetworkACLOptions : The GetSubnetNetworkACL options.
type GetSubnetNetworkACLOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetNetworkACLOptions : Instantiate GetSubnetNetworkACLOptions
func (*VpcV1) NewGetSubnetNetworkACLOptions(id string) *GetSubnetNetworkACLOptions {
	return &GetSubnetNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetSubnetNetworkACLOptions) SetID(id string) *GetSubnetNetworkACLOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetNetworkACLOptions) SetHeaders(param map[string]string) *GetSubnetNetworkACLOptions {
	options.Headers = param
	return options
}

// GetSubnetOptions : The GetSubnet options.
type GetSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetOptions : Instantiate GetSubnetOptions
func (*VpcV1) NewGetSubnetOptions(id string) *GetSubnetOptions {
	return &GetSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetSubnetOptions) SetID(id string) *GetSubnetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetOptions) SetHeaders(param map[string]string) *GetSubnetOptions {
	options.Headers = param
	return options
}

// GetSubnetPublicGatewayOptions : The GetSubnetPublicGateway options.
type GetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetPublicGatewayOptions : Instantiate GetSubnetPublicGatewayOptions
func (*VpcV1) NewGetSubnetPublicGatewayOptions(id string) *GetSubnetPublicGatewayOptions {
	return &GetSubnetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetSubnetPublicGatewayOptions) SetID(id string) *GetSubnetPublicGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *GetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// GetSubnetReservedIPOptions : The GetSubnetReservedIP options.
type GetSubnetReservedIPOptions struct {
	// The subnet identifier.
	SubnetID *string `json:"subnet_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetReservedIPOptions : Instantiate GetSubnetReservedIPOptions
func (*VpcV1) NewGetSubnetReservedIPOptions(subnetID string, id string) *GetSubnetReservedIPOptions {
	return &GetSubnetReservedIPOptions{
		SubnetID: core.StringPtr(subnetID),
		ID:       core.StringPtr(id),
	}
}

// SetSubnetID : Allow user to set SubnetID
func (_options *GetSubnetReservedIPOptions) SetSubnetID(subnetID string) *GetSubnetReservedIPOptions {
	_options.SubnetID = core.StringPtr(subnetID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSubnetReservedIPOptions) SetID(id string) *GetSubnetReservedIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetReservedIPOptions) SetHeaders(param map[string]string) *GetSubnetReservedIPOptions {
	options.Headers = param
	return options
}

// GetSubnetRoutingTableOptions : The GetSubnetRoutingTable options.
type GetSubnetRoutingTableOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetRoutingTableOptions : Instantiate GetSubnetRoutingTableOptions
func (*VpcV1) NewGetSubnetRoutingTableOptions(id string) *GetSubnetRoutingTableOptions {
	return &GetSubnetRoutingTableOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetSubnetRoutingTableOptions) SetID(id string) *GetSubnetRoutingTableOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetRoutingTableOptions) SetHeaders(param map[string]string) *GetSubnetRoutingTableOptions {
	options.Headers = param
	return options
}

// GetVirtualNetworkInterfaceOptions : The GetVirtualNetworkInterface options.
type GetVirtualNetworkInterfaceOptions struct {
	// The virtual network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVirtualNetworkInterfaceOptions : Instantiate GetVirtualNetworkInterfaceOptions
func (*VpcV1) NewGetVirtualNetworkInterfaceOptions(id string) *GetVirtualNetworkInterfaceOptions {
	return &GetVirtualNetworkInterfaceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVirtualNetworkInterfaceOptions) SetID(id string) *GetVirtualNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVirtualNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetVirtualNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetVolumeOptions : The GetVolume options.
type GetVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeOptions : Instantiate GetVolumeOptions
func (*VpcV1) NewGetVolumeOptions(id string) *GetVolumeOptions {
	return &GetVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVolumeOptions) SetID(id string) *GetVolumeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeOptions) SetHeaders(param map[string]string) *GetVolumeOptions {
	options.Headers = param
	return options
}

// GetVolumeProfileOptions : The GetVolumeProfile options.
type GetVolumeProfileOptions struct {
	// The volume profile name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeProfileOptions : Instantiate GetVolumeProfileOptions
func (*VpcV1) NewGetVolumeProfileOptions(name string) *GetVolumeProfileOptions {
	return &GetVolumeProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetVolumeProfileOptions) SetName(name string) *GetVolumeProfileOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeProfileOptions) SetHeaders(param map[string]string) *GetVolumeProfileOptions {
	options.Headers = param
	return options
}

// GetVPCAddressPrefixOptions : The GetVPCAddressPrefix options.
type GetVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The prefix identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCAddressPrefixOptions : Instantiate GetVPCAddressPrefixOptions
func (*VpcV1) NewGetVPCAddressPrefixOptions(vpcID string, id string) *GetVPCAddressPrefixOptions {
	return &GetVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *GetVPCAddressPrefixOptions) SetVPCID(vpcID string) *GetVPCAddressPrefixOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPCAddressPrefixOptions) SetID(id string) *GetVPCAddressPrefixOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCAddressPrefixOptions) SetHeaders(param map[string]string) *GetVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// GetVPCDefaultNetworkACLOptions : The GetVPCDefaultNetworkACL options.
type GetVPCDefaultNetworkACLOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDefaultNetworkACLOptions : Instantiate GetVPCDefaultNetworkACLOptions
func (*VpcV1) NewGetVPCDefaultNetworkACLOptions(id string) *GetVPCDefaultNetworkACLOptions {
	return &GetVPCDefaultNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPCDefaultNetworkACLOptions) SetID(id string) *GetVPCDefaultNetworkACLOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDefaultNetworkACLOptions) SetHeaders(param map[string]string) *GetVPCDefaultNetworkACLOptions {
	options.Headers = param
	return options
}

// GetVPCDefaultRoutingTableOptions : The GetVPCDefaultRoutingTable options.
type GetVPCDefaultRoutingTableOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDefaultRoutingTableOptions : Instantiate GetVPCDefaultRoutingTableOptions
func (*VpcV1) NewGetVPCDefaultRoutingTableOptions(id string) *GetVPCDefaultRoutingTableOptions {
	return &GetVPCDefaultRoutingTableOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPCDefaultRoutingTableOptions) SetID(id string) *GetVPCDefaultRoutingTableOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDefaultRoutingTableOptions) SetHeaders(param map[string]string) *GetVPCDefaultRoutingTableOptions {
	options.Headers = param
	return options
}

// GetVPCDefaultSecurityGroupOptions : The GetVPCDefaultSecurityGroup options.
type GetVPCDefaultSecurityGroupOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDefaultSecurityGroupOptions : Instantiate GetVPCDefaultSecurityGroupOptions
func (*VpcV1) NewGetVPCDefaultSecurityGroupOptions(id string) *GetVPCDefaultSecurityGroupOptions {
	return &GetVPCDefaultSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPCDefaultSecurityGroupOptions) SetID(id string) *GetVPCDefaultSecurityGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDefaultSecurityGroupOptions) SetHeaders(param map[string]string) *GetVPCDefaultSecurityGroupOptions {
	options.Headers = param
	return options
}

// GetVPCDnsResolutionBindingOptions : The GetVPCDnsResolutionBinding options.
type GetVPCDnsResolutionBindingOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The DNS resolution binding identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDnsResolutionBindingOptions : Instantiate GetVPCDnsResolutionBindingOptions
func (*VpcV1) NewGetVPCDnsResolutionBindingOptions(vpcID string, id string) *GetVPCDnsResolutionBindingOptions {
	return &GetVPCDnsResolutionBindingOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *GetVPCDnsResolutionBindingOptions) SetVPCID(vpcID string) *GetVPCDnsResolutionBindingOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPCDnsResolutionBindingOptions) SetID(id string) *GetVPCDnsResolutionBindingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDnsResolutionBindingOptions) SetHeaders(param map[string]string) *GetVPCDnsResolutionBindingOptions {
	options.Headers = param
	return options
}

// GetVPCOptions : The GetVPC options.
type GetVPCOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCOptions : Instantiate GetVPCOptions
func (*VpcV1) NewGetVPCOptions(id string) *GetVPCOptions {
	return &GetVPCOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPCOptions) SetID(id string) *GetVPCOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCOptions) SetHeaders(param map[string]string) *GetVPCOptions {
	options.Headers = param
	return options
}

// GetVPCRouteOptions : The GetVPCRoute options.
type GetVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCRouteOptions : Instantiate GetVPCRouteOptions
func (*VpcV1) NewGetVPCRouteOptions(vpcID string, id string) *GetVPCRouteOptions {
	return &GetVPCRouteOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *GetVPCRouteOptions) SetVPCID(vpcID string) *GetVPCRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPCRouteOptions) SetID(id string) *GetVPCRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCRouteOptions) SetHeaders(param map[string]string) *GetVPCRouteOptions {
	options.Headers = param
	return options
}

// GetVPCRoutingTableOptions : The GetVPCRoutingTable options.
type GetVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCRoutingTableOptions : Instantiate GetVPCRoutingTableOptions
func (*VpcV1) NewGetVPCRoutingTableOptions(vpcID string, id string) *GetVPCRoutingTableOptions {
	return &GetVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *GetVPCRoutingTableOptions) SetVPCID(vpcID string) *GetVPCRoutingTableOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPCRoutingTableOptions) SetID(id string) *GetVPCRoutingTableOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCRoutingTableOptions) SetHeaders(param map[string]string) *GetVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// GetVPCRoutingTableRouteOptions : The GetVPCRoutingTableRoute options.
type GetVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required,ne="`

	// The VPC routing table route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCRoutingTableRouteOptions : Instantiate GetVPCRoutingTableRouteOptions
func (*VpcV1) NewGetVPCRoutingTableRouteOptions(vpcID string, routingTableID string, id string) *GetVPCRoutingTableRouteOptions {
	return &GetVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		ID:             core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *GetVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *GetVPCRoutingTableRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (_options *GetVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *GetVPCRoutingTableRouteOptions {
	_options.RoutingTableID = core.StringPtr(routingTableID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPCRoutingTableRouteOptions) SetID(id string) *GetVPCRoutingTableRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *GetVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// GetVPNGatewayConnectionOptions : The GetVPNGatewayConnection options.
type GetVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNGatewayConnectionOptions : Instantiate GetVPNGatewayConnectionOptions
func (*VpcV1) NewGetVPNGatewayConnectionOptions(vpnGatewayID string, id string) *GetVPNGatewayConnectionOptions {
	return &GetVPNGatewayConnectionOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *GetVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *GetVPNGatewayConnectionOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPNGatewayConnectionOptions) SetID(id string) *GetVPNGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *GetVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// GetVPNGatewayOptions : The GetVPNGateway options.
type GetVPNGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNGatewayOptions : Instantiate GetVPNGatewayOptions
func (*VpcV1) NewGetVPNGatewayOptions(id string) *GetVPNGatewayOptions {
	return &GetVPNGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPNGatewayOptions) SetID(id string) *GetVPNGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNGatewayOptions) SetHeaders(param map[string]string) *GetVPNGatewayOptions {
	options.Headers = param
	return options
}

// GetVPNServerClientConfigurationOptions : The GetVPNServerClientConfiguration options.
type GetVPNServerClientConfigurationOptions struct {
	// The VPN server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNServerClientConfigurationOptions : Instantiate GetVPNServerClientConfigurationOptions
func (*VpcV1) NewGetVPNServerClientConfigurationOptions(id string) *GetVPNServerClientConfigurationOptions {
	return &GetVPNServerClientConfigurationOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPNServerClientConfigurationOptions) SetID(id string) *GetVPNServerClientConfigurationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNServerClientConfigurationOptions) SetHeaders(param map[string]string) *GetVPNServerClientConfigurationOptions {
	options.Headers = param
	return options
}

// GetVPNServerClientOptions : The GetVPNServerClient options.
type GetVPNServerClientOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The VPN client identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNServerClientOptions : Instantiate GetVPNServerClientOptions
func (*VpcV1) NewGetVPNServerClientOptions(vpnServerID string, id string) *GetVPNServerClientOptions {
	return &GetVPNServerClientOptions{
		VPNServerID: core.StringPtr(vpnServerID),
		ID:          core.StringPtr(id),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *GetVPNServerClientOptions) SetVPNServerID(vpnServerID string) *GetVPNServerClientOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPNServerClientOptions) SetID(id string) *GetVPNServerClientOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNServerClientOptions) SetHeaders(param map[string]string) *GetVPNServerClientOptions {
	options.Headers = param
	return options
}

// GetVPNServerOptions : The GetVPNServer options.
type GetVPNServerOptions struct {
	// The VPN server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNServerOptions : Instantiate GetVPNServerOptions
func (*VpcV1) NewGetVPNServerOptions(id string) *GetVPNServerOptions {
	return &GetVPNServerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetVPNServerOptions) SetID(id string) *GetVPNServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNServerOptions) SetHeaders(param map[string]string) *GetVPNServerOptions {
	options.Headers = param
	return options
}

// GetVPNServerRouteOptions : The GetVPNServerRoute options.
type GetVPNServerRouteOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The VPN route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNServerRouteOptions : Instantiate GetVPNServerRouteOptions
func (*VpcV1) NewGetVPNServerRouteOptions(vpnServerID string, id string) *GetVPNServerRouteOptions {
	return &GetVPNServerRouteOptions{
		VPNServerID: core.StringPtr(vpnServerID),
		ID:          core.StringPtr(id),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *GetVPNServerRouteOptions) SetVPNServerID(vpnServerID string) *GetVPNServerRouteOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetVPNServerRouteOptions) SetID(id string) *GetVPNServerRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNServerRouteOptions) SetHeaders(param map[string]string) *GetVPNServerRouteOptions {
	options.Headers = param
	return options
}

// IkePolicy : IkePolicy struct
type IkePolicy struct {
	// The authentication algorithm
	//
	// The `md5` and `sha1` algorithms have been deprecated.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The VPN gateway connections that use this IKE policy.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this IKE policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The Diffie-Hellman group
	//
	// Groups `2` and `5` have been deprecated.
	DhGroup *int64 `json:"dh_group" validate:"required"`

	// The encryption algorithm
	//
	// The `triple_des` algorithm has been deprecated.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime" validate:"required"`

	// The name for this IKE policy. The name is unique across all IKE policies in the region.
	Name *string `json:"name" validate:"required"`

	// The IKE negotiation mode. Only `main` is supported.
	NegotiationMode *string `json:"negotiation_mode" validate:"required"`

	// The resource group for this IKE policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the IkePolicy.AuthenticationAlgorithm property.
// The authentication algorithm
//
// The `md5` and `sha1` algorithms have been deprecated.
const (
	IkePolicyAuthenticationAlgorithmMd5Const    = "md5"
	IkePolicyAuthenticationAlgorithmSha1Const   = "sha1"
	IkePolicyAuthenticationAlgorithmSha256Const = "sha256"
	IkePolicyAuthenticationAlgorithmSha384Const = "sha384"
	IkePolicyAuthenticationAlgorithmSha512Const = "sha512"
)

// Constants associated with the IkePolicy.EncryptionAlgorithm property.
// The encryption algorithm
//
// The `triple_des` algorithm has been deprecated.
const (
	IkePolicyEncryptionAlgorithmAes128Const    = "aes128"
	IkePolicyEncryptionAlgorithmAes192Const    = "aes192"
	IkePolicyEncryptionAlgorithmAes256Const    = "aes256"
	IkePolicyEncryptionAlgorithmTripleDesConst = "triple_des"
)

// Constants associated with the IkePolicy.NegotiationMode property.
// The IKE negotiation mode. Only `main` is supported.
const (
	IkePolicyNegotiationModeMainConst = "main"
)

// Constants associated with the IkePolicy.ResourceType property.
// The resource type.
const (
	IkePolicyResourceTypeIkePolicyConst = "ike_policy"
)

// UnmarshalIkePolicy unmarshals an instance of IkePolicy from the specified map of raw messages.
func UnmarshalIkePolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicy)
	err = core.UnmarshalPrimitive(m, "authentication_algorithm", &obj.AuthenticationAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dh_group", &obj.DhGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption_algorithm", &obj.EncryptionAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ike_version", &obj.IkeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_lifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "negotiation_mode", &obj.NegotiationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyCollection : IkePolicyCollection struct
type IkePolicyCollection struct {
	// A link to the first page of resources.
	First *IkePolicyCollectionFirst `json:"first" validate:"required"`

	// Collection of IKE policies.
	IkePolicies []IkePolicy `json:"ike_policies" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *IkePolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalIkePolicyCollection unmarshals an instance of IkePolicyCollection from the specified map of raw messages.
func UnmarshalIkePolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalIkePolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policies", &obj.IkePolicies, UnmarshalIkePolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalIkePolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *IkePolicyCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// IkePolicyPatch : IkePolicyPatch struct
type IkePolicyPatch struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm,omitempty"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group,omitempty"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm,omitempty"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version,omitempty"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The name for this IKE policy. The name must not be used by another IKE policy in the region.
	Name *string `json:"name,omitempty"`
}

// Constants associated with the IkePolicyPatch.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	IkePolicyPatchAuthenticationAlgorithmSha256Const = "sha256"
	IkePolicyPatchAuthenticationAlgorithmSha384Const = "sha384"
	IkePolicyPatchAuthenticationAlgorithmSha512Const = "sha512"
)

// Constants associated with the IkePolicyPatch.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	IkePolicyPatchEncryptionAlgorithmAes128Const = "aes128"
	IkePolicyPatchEncryptionAlgorithmAes192Const = "aes192"
	IkePolicyPatchEncryptionAlgorithmAes256Const = "aes256"
)

// UnmarshalIkePolicyPatch unmarshals an instance of IkePolicyPatch from the specified map of raw messages.
func UnmarshalIkePolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyPatch)
	err = core.UnmarshalPrimitive(m, "authentication_algorithm", &obj.AuthenticationAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dh_group", &obj.DhGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption_algorithm", &obj.EncryptionAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ike_version", &obj.IkeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_lifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the IkePolicyPatch
func (ikePolicyPatch *IkePolicyPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(ikePolicyPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// IkePolicyReference : IkePolicyReference struct
type IkePolicyReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *IkePolicyReferenceDeleted `json:"deleted,omitempty"`

	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`

	// The name for this IKE policy. The name is unique across all IKE policies in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the IkePolicyReference.ResourceType property.
// The resource type.
const (
	IkePolicyReferenceResourceTypeIkePolicyConst = "ike_policy"
)

// UnmarshalIkePolicyReference unmarshals an instance of IkePolicyReference from the specified map of raw messages.
func UnmarshalIkePolicyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalIkePolicyReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IP : IP struct
type IP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewIP : Instantiate IP (Generic Model Constructor)
func (*VpcV1) NewIP(address string) (_model *IP, err error) {
	_model = &IP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalIP unmarshals an instance of IP from the specified map of raw messages.
func UnmarshalIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicy : IPsecPolicy struct
type IPsecPolicy struct {
	// The authentication algorithm
	//
	// The `md5` and `sha1` algorithms have been deprecated
	//
	// Must be `disabled` if and only if the `encryption_algorithm` is
	// `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The VPN gateway connections that use this IPsec policy.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this IPsec policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The encapsulation mode used. Only `tunnel` is supported.
	EncapsulationMode *string `json:"encapsulation_mode" validate:"required"`

	// The encryption algorithm
	//
	// The `triple_des` algorithm has been deprecated
	//
	// The `authentication_algorithm` must be `disabled` if and only if
	// `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
	// `aes256gcm16`.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime" validate:"required"`

	// The name for this IPsec policy. The name is unique across all IPsec policies in the region.
	Name *string `json:"name" validate:"required"`

	// Perfect Forward Secrecy
	//
	// Groups `group_2` and `group_5` have been deprecated.
	Pfs *string `json:"pfs" validate:"required"`

	// The resource group for this IPsec policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The transform protocol used. Only `esp` is supported.
	TransformProtocol *string `json:"transform_protocol" validate:"required"`
}

// Constants associated with the IPsecPolicy.AuthenticationAlgorithm property.
// The authentication algorithm
//
// # The `md5` and `sha1` algorithms have been deprecated
//
// Must be `disabled` if and only if the `encryption_algorithm` is
// `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
const (
	IPsecPolicyAuthenticationAlgorithmDisabledConst = "disabled"
	IPsecPolicyAuthenticationAlgorithmMd5Const      = "md5"
	IPsecPolicyAuthenticationAlgorithmSha1Const     = "sha1"
	IPsecPolicyAuthenticationAlgorithmSha256Const   = "sha256"
	IPsecPolicyAuthenticationAlgorithmSha384Const   = "sha384"
	IPsecPolicyAuthenticationAlgorithmSha512Const   = "sha512"
)

// Constants associated with the IPsecPolicy.EncapsulationMode property.
// The encapsulation mode used. Only `tunnel` is supported.
const (
	IPsecPolicyEncapsulationModeTunnelConst = "tunnel"
)

// Constants associated with the IPsecPolicy.EncryptionAlgorithm property.
// The encryption algorithm
//
// The `triple_des` algorithm has been deprecated
//
// The `authentication_algorithm` must be `disabled` if and only if
// `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
// `aes256gcm16`.
const (
	IPsecPolicyEncryptionAlgorithmAes128Const      = "aes128"
	IPsecPolicyEncryptionAlgorithmAes128gcm16Const = "aes128gcm16"
	IPsecPolicyEncryptionAlgorithmAes192Const      = "aes192"
	IPsecPolicyEncryptionAlgorithmAes192gcm16Const = "aes192gcm16"
	IPsecPolicyEncryptionAlgorithmAes256Const      = "aes256"
	IPsecPolicyEncryptionAlgorithmAes256gcm16Const = "aes256gcm16"
	IPsecPolicyEncryptionAlgorithmTripleDesConst   = "triple_des"
)

// Constants associated with the IPsecPolicy.Pfs property.
// Perfect Forward Secrecy
//
// Groups `group_2` and `group_5` have been deprecated.
const (
	IPsecPolicyPfsDisabledConst = "disabled"
	IPsecPolicyPfsGroup14Const  = "group_14"
	IPsecPolicyPfsGroup15Const  = "group_15"
	IPsecPolicyPfsGroup16Const  = "group_16"
	IPsecPolicyPfsGroup17Const  = "group_17"
	IPsecPolicyPfsGroup18Const  = "group_18"
	IPsecPolicyPfsGroup19Const  = "group_19"
	IPsecPolicyPfsGroup2Const   = "group_2"
	IPsecPolicyPfsGroup20Const  = "group_20"
	IPsecPolicyPfsGroup21Const  = "group_21"
	IPsecPolicyPfsGroup22Const  = "group_22"
	IPsecPolicyPfsGroup23Const  = "group_23"
	IPsecPolicyPfsGroup24Const  = "group_24"
	IPsecPolicyPfsGroup31Const  = "group_31"
	IPsecPolicyPfsGroup5Const   = "group_5"
)

// Constants associated with the IPsecPolicy.ResourceType property.
// The resource type.
const (
	IPsecPolicyResourceTypeIpsecPolicyConst = "ipsec_policy"
)

// Constants associated with the IPsecPolicy.TransformProtocol property.
// The transform protocol used. Only `esp` is supported.
const (
	IPsecPolicyTransformProtocolEspConst = "esp"
)

// UnmarshalIPsecPolicy unmarshals an instance of IPsecPolicy from the specified map of raw messages.
func UnmarshalIPsecPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicy)
	err = core.UnmarshalPrimitive(m, "authentication_algorithm", &obj.AuthenticationAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encapsulation_mode", &obj.EncapsulationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption_algorithm", &obj.EncryptionAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_lifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pfs", &obj.Pfs)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "transform_protocol", &obj.TransformProtocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyCollection : IPsecPolicyCollection struct
type IPsecPolicyCollection struct {
	// A link to the first page of resources.
	First *IPsecPolicyCollectionFirst `json:"first" validate:"required"`

	// Collection of IPsec policies.
	IpsecPolicies []IPsecPolicy `json:"ipsec_policies" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *IPsecPolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalIPsecPolicyCollection unmarshals an instance of IPsecPolicyCollection from the specified map of raw messages.
func UnmarshalIPsecPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalIPsecPolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policies", &obj.IpsecPolicies, UnmarshalIPsecPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalIPsecPolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *IPsecPolicyCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// IPsecPolicyCollectionFirst : A link to the first page of resources.
type IPsecPolicyCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIPsecPolicyCollectionFirst unmarshals an instance of IPsecPolicyCollectionFirst from the specified map of raw messages.
func UnmarshalIPsecPolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type IPsecPolicyCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIPsecPolicyCollectionNext unmarshals an instance of IPsecPolicyCollectionNext from the specified map of raw messages.
func UnmarshalIPsecPolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyPatch : IPsecPolicyPatch struct
type IPsecPolicyPatch struct {
	// The authentication algorithm
	//
	// Must be `disabled` if and only if the `encryption_algorithm` is
	// `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
	AuthenticationAlgorithm *string `json:"authentication_algorithm,omitempty"`

	// The encryption algorithm
	//
	// The `authentication_algorithm` must be `disabled` if and only if
	// `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
	// `aes256gcm16`.
	EncryptionAlgorithm *string `json:"encryption_algorithm,omitempty"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The name for this IPsec policy. The name must not be used by another IPsec policy in the region.
	Name *string `json:"name,omitempty"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs,omitempty"`
}

// Constants associated with the IPsecPolicyPatch.AuthenticationAlgorithm property.
// The authentication algorithm
//
// Must be `disabled` if and only if the `encryption_algorithm` is
// `aes128gcm16`, `aes192gcm16`, or `aes256gcm16`.
const (
	IPsecPolicyPatchAuthenticationAlgorithmDisabledConst = "disabled"
	IPsecPolicyPatchAuthenticationAlgorithmSha256Const   = "sha256"
	IPsecPolicyPatchAuthenticationAlgorithmSha384Const   = "sha384"
	IPsecPolicyPatchAuthenticationAlgorithmSha512Const   = "sha512"
)

// Constants associated with the IPsecPolicyPatch.EncryptionAlgorithm property.
// The encryption algorithm
//
// The `authentication_algorithm` must be `disabled` if and only if
// `encryption_algorithm` is `aes128gcm16`, `aes192gcm16`, or
// `aes256gcm16`.
const (
	IPsecPolicyPatchEncryptionAlgorithmAes128Const      = "aes128"
	IPsecPolicyPatchEncryptionAlgorithmAes128gcm16Const = "aes128gcm16"
	IPsecPolicyPatchEncryptionAlgorithmAes192Const      = "aes192"
	IPsecPolicyPatchEncryptionAlgorithmAes192gcm16Const = "aes192gcm16"
	IPsecPolicyPatchEncryptionAlgorithmAes256Const      = "aes256"
	IPsecPolicyPatchEncryptionAlgorithmAes256gcm16Const = "aes256gcm16"
)

// Constants associated with the IPsecPolicyPatch.Pfs property.
// Perfect Forward Secrecy.
const (
	IPsecPolicyPatchPfsDisabledConst = "disabled"
	IPsecPolicyPatchPfsGroup14Const  = "group_14"
	IPsecPolicyPatchPfsGroup15Const  = "group_15"
	IPsecPolicyPatchPfsGroup16Const  = "group_16"
	IPsecPolicyPatchPfsGroup17Const  = "group_17"
	IPsecPolicyPatchPfsGroup18Const  = "group_18"
	IPsecPolicyPatchPfsGroup19Const  = "group_19"
	IPsecPolicyPatchPfsGroup20Const  = "group_20"
	IPsecPolicyPatchPfsGroup21Const  = "group_21"
	IPsecPolicyPatchPfsGroup22Const  = "group_22"
	IPsecPolicyPatchPfsGroup23Const  = "group_23"
	IPsecPolicyPatchPfsGroup24Const  = "group_24"
	IPsecPolicyPatchPfsGroup31Const  = "group_31"
)

// UnmarshalIPsecPolicyPatch unmarshals an instance of IPsecPolicyPatch from the specified map of raw messages.
func UnmarshalIPsecPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyPatch)
	err = core.UnmarshalPrimitive(m, "authentication_algorithm", &obj.AuthenticationAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption_algorithm", &obj.EncryptionAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_lifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pfs", &obj.Pfs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the IPsecPolicyPatch
func (iPsecPolicyPatch *IPsecPolicyPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(iPsecPolicyPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// IPsecPolicyReference : IPsecPolicyReference struct
type IPsecPolicyReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *IPsecPolicyReferenceDeleted `json:"deleted,omitempty"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`

	// The name for this IPsec policy. The name is unique across all IPsec policies in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the IPsecPolicyReference.ResourceType property.
// The resource type.
const (
	IPsecPolicyReferenceResourceTypeIpsecPolicyConst = "ipsec_policy"
)

// UnmarshalIPsecPolicyReference unmarshals an instance of IPsecPolicyReference from the specified map of raw messages.
func UnmarshalIPsecPolicyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalIPsecPolicyReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type IPsecPolicyReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalIPsecPolicyReferenceDeleted unmarshals an instance of IPsecPolicyReferenceDeleted from the specified map of raw messages.
func UnmarshalIPsecPolicyReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyCollectionFirst : A link to the first page of resources.
type IkePolicyCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIkePolicyCollectionFirst unmarshals an instance of IkePolicyCollectionFirst from the specified map of raw messages.
func UnmarshalIkePolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type IkePolicyCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIkePolicyCollectionNext unmarshals an instance of IkePolicyCollectionNext from the specified map of raw messages.
func UnmarshalIkePolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type IkePolicyReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalIkePolicyReferenceDeleted unmarshals an instance of IkePolicyReferenceDeleted from the specified map of raw messages.
func UnmarshalIkePolicyReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Image : Image struct
type Image struct {
	CatalogOffering *ImageCatalogOffering `json:"catalog_offering" validate:"required"`

	// The date and time that the image was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this image.
	CRN *string `json:"crn" validate:"required"`

	// The deprecation date and time (UTC) for this image.
	//
	// If absent, no deprecation date and time has been set.
	DeprecationAt *strfmt.DateTime `json:"deprecation_at,omitempty"`

	// The type of encryption used on the image.
	Encryption *string `json:"encryption" validate:"required"`

	// The key that will be used to encrypt volumes created from this image (unless an
	// alternate `encryption_key` is specified at volume creation).
	//
	// This property will be present for images with an `encryption` type of `user_managed`.
	EncryptionKey *EncryptionKeyReference `json:"encryption_key,omitempty"`

	// Details for the stored image file.
	File *ImageFile `json:"file" validate:"required"`

	// The URL for this image.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`

	// The minimum size (in gigabytes) of a volume onto which this image may be provisioned.
	//
	// This property may be absent if the image has a `status` of `pending` or `failed`.
	MinimumProvisionedSize *int64 `json:"minimum_provisioned_size,omitempty"`

	// The name for this image. The name is unique across all images in the region.
	Name *string `json:"name" validate:"required"`

	// The obsolescence date and time (UTC) for this image.
	//
	// If absent, no obsolescence date and time has been set.
	ObsolescenceAt *strfmt.DateTime `json:"obsolescence_at,omitempty"`

	// The operating system included in this image.
	OperatingSystem *OperatingSystem `json:"operating_system,omitempty"`

	// The resource group for this image.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The volume used to create this image (this may be
	// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
	// If absent, this image was not created from a volume.
	SourceVolume *VolumeReference `json:"source_volume,omitempty"`

	// The status of this image
	// - available: image can be used (provisionable)
	// - deleting: image is being deleted, and can no longer be used to provision new
	//   resources
	// - deprecated: image is administratively slated to become `obsolete`
	// - failed: image is corrupt or did not pass validation
	// - obsolete: image administratively set to not be used for new resources
	// - pending: image is being imported and is not yet `available`
	// - unusable: image cannot be used (see `status_reasons[]` for possible remediation)
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the image on which the
	// unexpected property value was encountered.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current status (if any):
	// - `encrypted_data_key_invalid`: image cannot be decrypted with the specified
	//   `encryption_key`
	// - `encryption_key_deleted`: image unusable because its `encryption_key` was deleted
	// - `encryption_key_disabled`: image unusable until its `encryption_key` is re-enabled
	// - `image_data_corrupted`: image data is corrupt, or is not in the specified format
	// - `image_provisioned_size_unsupported`: image requires a boot volume size greater
	//   than the maximum supported value
	// - `image_request_in_progress`: image operation is in progress (such as an import from
	//    Cloud Object Storage)
	// - `image_request_queued`: image request has been accepted but the requested
	//   operation has not started
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []ImageStatusReason `json:"status_reasons" validate:"required"`

	// The visibility of this image.
	// - `private`: Visible only to this account
	// - `public`: Visible to all accounts.
	Visibility *string `json:"visibility" validate:"required"`
}

// Constants associated with the Image.Encryption property.
// The type of encryption used on the image.
const (
	ImageEncryptionNoneConst        = "none"
	ImageEncryptionUserManagedConst = "user_managed"
)

// Constants associated with the Image.ResourceType property.
// The resource type.
const (
	ImageResourceTypeImageConst = "image"
)

// Constants associated with the Image.Status property.
// The status of this image
//   - available: image can be used (provisionable)
//   - deleting: image is being deleted, and can no longer be used to provision new
//     resources
//   - deprecated: image is administratively slated to become `obsolete`
//   - failed: image is corrupt or did not pass validation
//   - obsolete: image administratively set to not be used for new resources
//   - pending: image is being imported and is not yet `available`
//   - unusable: image cannot be used (see `status_reasons[]` for possible remediation)
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the image on which the
// unexpected property value was encountered.
const (
	ImageStatusAvailableConst  = "available"
	ImageStatusDeletingConst   = "deleting"
	ImageStatusDeprecatedConst = "deprecated"
	ImageStatusFailedConst     = "failed"
	ImageStatusObsoleteConst   = "obsolete"
	ImageStatusPendingConst    = "pending"
	ImageStatusUnusableConst   = "unusable"
)

// Constants associated with the Image.Visibility property.
// The visibility of this image.
// - `private`: Visible only to this account
// - `public`: Visible to all accounts.
const (
	ImageVisibilityPrivateConst = "private"
	ImageVisibilityPublicConst  = "public"
)

// UnmarshalImage unmarshals an instance of Image from the specified map of raw messages.
func UnmarshalImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Image)
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalImageCatalogOffering)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deprecation_at", &obj.DeprecationAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "file", &obj.File, UnmarshalImageFile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minimum_provisioned_size", &obj.MinimumProvisionedSize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "obsolescence_at", &obj.ObsolescenceAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_volume", &obj.SourceVolume, UnmarshalVolumeReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalImageStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "visibility", &obj.Visibility)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageCatalogOffering : ImageCatalogOffering struct
type ImageCatalogOffering struct {
	// Indicates whether this image is managed as part of a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering. If an image is managed,
	// accounts in the same
	// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise) with access to that catalog can
	// specify the image's catalog offering version CRN to provision virtual server instances using the image.
	Managed *bool `json:"managed" validate:"required"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
	// offering version associated with this image.
	//
	// If absent, this image is not associated with a cloud catalog offering.
	Version *CatalogOfferingVersionReference `json:"version,omitempty"`
}

// UnmarshalImageCatalogOffering unmarshals an instance of ImageCatalogOffering from the specified map of raw messages.
func UnmarshalImageCatalogOffering(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCatalogOffering)
	err = core.UnmarshalPrimitive(m, "managed", &obj.Managed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "version", &obj.Version, UnmarshalCatalogOfferingVersionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageCollection : ImageCollection struct
type ImageCollection struct {
	// A link to the first page of resources.
	First *ImageCollectionFirst `json:"first" validate:"required"`

	// Collection of images.
	Images []Image `json:"images" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ImageCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalImageCollection unmarshals an instance of ImageCollection from the specified map of raw messages.
func UnmarshalImageCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalImageCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "images", &obj.Images, UnmarshalImage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalImageCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ImageCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ImageCollectionFirst : A link to the first page of resources.
type ImageCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalImageCollectionFirst unmarshals an instance of ImageCollectionFirst from the specified map of raw messages.
func UnmarshalImageCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type ImageCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalImageCollectionNext unmarshals an instance of ImageCollectionNext from the specified map of raw messages.
func UnmarshalImageCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageExportJob : ImageExportJob struct
type ImageExportJob struct {
	// The date and time that the image export job was completed.
	//
	// If absent, the export job has not yet completed.
	CompletedAt *strfmt.DateTime `json:"completed_at,omitempty"`

	// The date and time that the image export job was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// A base64-encoded, encrypted representation of the key that was used to encrypt the data for the exported image. This
	// key can be unwrapped with the image's `encryption_key` root key using either Key Protect or Hyper Protect Crypto
	// Services.
	//
	// If absent, the export job is for an unencrypted image.
	EncryptedDataKey *[]byte `json:"encrypted_data_key,omitempty"`

	// The format of the exported image.
	Format *string `json:"format" validate:"required"`

	// The URL for this image export job.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image export job.
	ID *string `json:"id" validate:"required"`

	// The name for this image export job. The name must not be used by another export job for the image. Changing the name
	// will not affect the exported image name,
	// `storage_object.name`, or `storage_href` values.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The date and time that the image export job started running.
	//
	// If absent, the export job has not yet started.
	StartedAt *strfmt.DateTime `json:"started_at,omitempty"`

	// The status of this image export job:
	// - `deleting`: Export job is being deleted
	// - `failed`: Export job could not be completed successfully
	// - `queued`: Export job is queued
	// - `running`: Export job is in progress
	// - `succeeded`: Export job was completed successfully
	//
	// The exported image object is automatically deleted for `failed` jobs.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []ImageExportJobStatusReason `json:"status_reasons" validate:"required"`

	// The Cloud Object Storage bucket of the exported image object.
	StorageBucket *CloudObjectStorageBucketReference `json:"storage_bucket" validate:"required"`

	// The Cloud Object Storage location of the exported image object. The object at this location will not exist until the
	// job completes successfully. The exported image object is not managed by the IBM VPC service, and may be removed or
	// replaced with a different object by any user or service with IAM authorization to the storage bucket.
	StorageHref *string `json:"storage_href" validate:"required"`

	// The Cloud Object Storage object for the exported image. This object will not exist until
	// the job completes successfully. The exported image object is not managed by the IBM VPC
	// service, and may be removed or replaced with a different object by any user or service
	// with IAM authorization to the storage bucket.
	StorageObject *CloudObjectStorageObjectReference `json:"storage_object" validate:"required"`
}

// Constants associated with the ImageExportJob.Format property.
// The format of the exported image.
const (
	ImageExportJobFormatQcow2Const = "qcow2"
	ImageExportJobFormatVhdConst   = "vhd"
)

// Constants associated with the ImageExportJob.ResourceType property.
// The type of resource referenced.
const (
	ImageExportJobResourceTypeImageExportJobConst = "image_export_job"
)

// Constants associated with the ImageExportJob.Status property.
// The status of this image export job:
// - `deleting`: Export job is being deleted
// - `failed`: Export job could not be completed successfully
// - `queued`: Export job is queued
// - `running`: Export job is in progress
// - `succeeded`: Export job was completed successfully
//
// The exported image object is automatically deleted for `failed` jobs.
const (
	ImageExportJobStatusDeletingConst  = "deleting"
	ImageExportJobStatusFailedConst    = "failed"
	ImageExportJobStatusQueuedConst    = "queued"
	ImageExportJobStatusRunningConst   = "running"
	ImageExportJobStatusSucceededConst = "succeeded"
)

// UnmarshalImageExportJob unmarshals an instance of ImageExportJob from the specified map of raw messages.
func UnmarshalImageExportJob(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageExportJob)
	err = core.UnmarshalPrimitive(m, "completed_at", &obj.CompletedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encrypted_data_key", &obj.EncryptedDataKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "format", &obj.Format)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "started_at", &obj.StartedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalImageExportJobStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_bucket", &obj.StorageBucket, UnmarshalCloudObjectStorageBucketReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage_href", &obj.StorageHref)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_object", &obj.StorageObject, UnmarshalCloudObjectStorageObjectReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageExportJobPatch : ImageExportJobPatch struct
type ImageExportJobPatch struct {
	// The name for this image export job. The name must not be used by another export job for the image. Changing the name
	// will not affect the exported image name,
	// `storage_object.name`, or `storage_href` values.
	Name *string `json:"name,omitempty"`
}

// UnmarshalImageExportJobPatch unmarshals an instance of ImageExportJobPatch from the specified map of raw messages.
func UnmarshalImageExportJobPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageExportJobPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the ImageExportJobPatch
func (imageExportJobPatch *ImageExportJobPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(imageExportJobPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// ImageExportJobStatusReason : ImageExportJobStatusReason struct
type ImageExportJobStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the ImageExportJobStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	ImageExportJobStatusReasonCodeCannotAccessStorageBucketConst = "cannot_access_storage_bucket"
	ImageExportJobStatusReasonCodeInternalErrorConst             = "internal_error"
)

// UnmarshalImageExportJobStatusReason unmarshals an instance of ImageExportJobStatusReason from the specified map of raw messages.
func UnmarshalImageExportJobStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageExportJobStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageExportJobUnpaginatedCollection : ImageExportJobUnpaginatedCollection struct
type ImageExportJobUnpaginatedCollection struct {
	// Collection of image export jobs.
	ExportJobs []ImageExportJob `json:"export_jobs" validate:"required"`
}

// UnmarshalImageExportJobUnpaginatedCollection unmarshals an instance of ImageExportJobUnpaginatedCollection from the specified map of raw messages.
func UnmarshalImageExportJobUnpaginatedCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageExportJobUnpaginatedCollection)
	err = core.UnmarshalModel(m, "export_jobs", &obj.ExportJobs, UnmarshalImageExportJob)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageFile : ImageFile struct
type ImageFile struct {
	// Checksums for this image file.
	//
	// This property may be absent if the associated image has a `status` of `pending` or
	// `failed`.
	Checksums *ImageFileChecksums `json:"checksums,omitempty"`

	// The size of the stored image file rounded up to the next gigabyte.
	//
	// This property may be absent if the associated image has a `status` of `pending` or
	// `failed`.
	Size *int64 `json:"size,omitempty"`
}

// UnmarshalImageFile unmarshals an instance of ImageFile from the specified map of raw messages.
func UnmarshalImageFile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageFile)
	err = core.UnmarshalModel(m, "checksums", &obj.Checksums, UnmarshalImageFileChecksums)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageFileChecksums : ImageFileChecksums struct
type ImageFileChecksums struct {
	// The SHA256 fingerprint of the image file.
	Sha256 *string `json:"sha256,omitempty"`
}

// UnmarshalImageFileChecksums unmarshals an instance of ImageFileChecksums from the specified map of raw messages.
func UnmarshalImageFileChecksums(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageFileChecksums)
	err = core.UnmarshalPrimitive(m, "sha256", &obj.Sha256)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageFilePrototype : ImageFilePrototype struct
type ImageFilePrototype struct {
	// The Cloud Object Storage location of the image file.
	//
	// The image file format is specified by the file's extension, which must be either
	// `qcow2` or `vhd`.
	Href *string `json:"href" validate:"required"`
}

// NewImageFilePrototype : Instantiate ImageFilePrototype (Generic Model Constructor)
func (*VpcV1) NewImageFilePrototype(href string) (_model *ImageFilePrototype, err error) {
	_model = &ImageFilePrototype{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalImageFilePrototype unmarshals an instance of ImageFilePrototype from the specified map of raw messages.
func UnmarshalImageFilePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageFilePrototype)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentity : Identifies an image by a unique property.
// Models which "extend" this model:
// - ImageIdentityByID
// - ImageIdentityByCRN
// - ImageIdentityByHref
type ImageIdentity struct {
	// The unique identifier for this image.
	ID *string `json:"id,omitempty"`

	// The CRN for this image.
	CRN *string `json:"crn,omitempty"`

	// The URL for this image.
	Href *string `json:"href,omitempty"`
}

func (*ImageIdentity) isaImageIdentity() bool {
	return true
}

type ImageIdentityIntf interface {
	isaImageIdentity() bool
}

// UnmarshalImageIdentity unmarshals an instance of ImageIdentity from the specified map of raw messages.
func UnmarshalImageIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImagePatch : ImagePatch struct
type ImagePatch struct {
	// The deprecation date and time to set for this image.
	//
	// This cannot be set if the image has a `status` of `failed` or `deleting`, or if
	// `catalog_offering.managed` is `true`.
	//
	// The date and time must not be in the past, and must be earlier than `obsolescence_at`
	// (if `obsolescence_at` is set). Additionally, if the image status is currently
	// `deprecated`, the value cannot be changed (but may be removed).
	//
	// Specify `null` to remove an existing deprecation date and time. If the image status is currently `deprecated`, it
	// will become `available`.
	//
	// If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
	// transition to `deprecated` upon its successful creation (or
	// `obsolete` if the obsolescence date and time was also reached).
	DeprecationAt *strfmt.DateTime `json:"deprecation_at,omitempty"`

	// The name for this image. The name must not be used by another image in the region. Names starting with `ibm-` are
	// reserved for system-provided images, and are not allowed.
	Name *string `json:"name,omitempty"`

	// The obsolescence date and time to set for this image.
	//
	// This cannot be set if the image has a `status` of `failed` or `deleting`, or if
	// `catalog_offering.managed` is `true`.
	//
	// The date and time must not be in the past, and must be later than `deprecation_at` (if
	// `deprecation_at` is set). Additionally, if the image status is currently `obsolete`, the value cannot be changed
	// (but may be removed).
	//
	// Specify `null` to remove an existing obsolescence date and time. If the image status is currently `obsolete`, it
	// will become `deprecated` if `deprecation_at` is in the past. Otherwise, it will become `available`.
	//
	// If the obsolescence date and time is reached while the image has a status of `pending`, the image's status will
	// transition to `obsolete` upon its successful creation.
	ObsolescenceAt *strfmt.DateTime `json:"obsolescence_at,omitempty"`
}

// UnmarshalImagePatch unmarshals an instance of ImagePatch from the specified map of raw messages.
func UnmarshalImagePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImagePatch)
	err = core.UnmarshalPrimitive(m, "deprecation_at", &obj.DeprecationAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "obsolescence_at", &obj.ObsolescenceAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the ImagePatch
func (imagePatch *ImagePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(imagePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// ImagePrototype : ImagePrototype struct
// Models which "extend" this model:
// - ImagePrototypeImageByFile
// - ImagePrototypeImageBySourceVolume
type ImagePrototype struct {
	// The deprecation date and time to set for this image.
	//
	// The date and time must not be in the past, and must be earlier than `obsolescence_at`
	// (if `obsolescence_at` is set).
	//
	// If unspecified, no deprecation date and time will be set.
	//
	// If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
	// transition to `deprecated` upon its successful creation (or
	// `obsolete` if the obsolescence date and time was also reached).
	DeprecationAt *strfmt.DateTime `json:"deprecation_at,omitempty"`

	// The name for this image. The name must not be used by another image in the region. Names starting with `ibm-` are
	// reserved for system-provided images, and are not allowed. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The obsolescence date and time to set for this image.
	//
	// The date and time must not be in the past, and must be later than `deprecation_at` (if
	// `deprecation_at` is set).
	//
	// If unspecified, no obsolescence date and time will be set.
	//
	// If the obsolescence date and time is reached while the image has a status of
	// `pending`, the image's status will transition to `obsolete` upon its successful creation.
	ObsolescenceAt *strfmt.DateTime `json:"obsolescence_at,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// A base64-encoded, encrypted representation of the key that was used to encrypt the data for this image.
	//
	// That representation is created by wrapping the key's value with the `encryption_key` root key (which must also be
	// specified), using either [Key Protect](https://cloud.ibm.com/docs/key-protect?topic=key-protect-wrap-keys) or the
	// [Hyper Protect Crypto Services](https://cloud.ibm.com/docs/services/hs-crypto?topic=hs-crypto-wrap-keys).
	//
	// If unspecified, the imported image is treated as unencrypted.
	EncryptedDataKey *string `json:"encrypted_data_key,omitempty"`

	// The root key that was used to wrap the data key (which is ultimately represented as
	// `encrypted_data_key`). Additionally, the root key will be used to encrypt volumes
	// created from this image (unless an alternate `encryption_key` is specified at volume
	// creation).
	//
	// If unspecified, the imported image is treated as unencrypted.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The file from which to create the image.
	File *ImageFilePrototype `json:"file,omitempty"`

	// The [supported operating
	// system](https://cloud.ibm.com/apidocs/vpc#list-operating-systems) included in this
	// image.
	OperatingSystem OperatingSystemIdentityIntf `json:"operating_system,omitempty"`

	// The volume from which to create the image. The specified volume must:
	// - Have an `operating_system`, which will be used to populate this image's
	//   operating system information.
	// - Not be `active` or `busy`.
	//
	// During image creation, the specified volume may briefly become `busy`.
	SourceVolume VolumeIdentityIntf `json:"source_volume,omitempty"`
}

func (*ImagePrototype) isaImagePrototype() bool {
	return true
}

type ImagePrototypeIntf interface {
	isaImagePrototype() bool
}

// UnmarshalImagePrototype unmarshals an instance of ImagePrototype from the specified map of raw messages.
func UnmarshalImagePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImagePrototype)
	err = core.UnmarshalPrimitive(m, "deprecation_at", &obj.DeprecationAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "obsolescence_at", &obj.ObsolescenceAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encrypted_data_key", &obj.EncryptedDataKey)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "file", &obj.File, UnmarshalImageFilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystemIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_volume", &obj.SourceVolume, UnmarshalVolumeIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageReference : ImageReference struct
type ImageReference struct {
	// The CRN for this image.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ImageReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this image.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`

	// The name for this image. The name is unique across all images in the region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *ImageRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ImageReference.ResourceType property.
// The resource type.
const (
	ImageReferenceResourceTypeImageConst = "image"
)

// UnmarshalImageReference unmarshals an instance of ImageReference from the specified map of raw messages.
func UnmarshalImageReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalImageReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalImageRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type ImageReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalImageReferenceDeleted unmarshals an instance of ImageReferenceDeleted from the specified map of raw messages.
func UnmarshalImageReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageRemote : If present, this property indicates that the resource associated with this reference is remote and therefore may not
// be directly retrievable.
type ImageRemote struct {
	// If present, this property indicates that the referenced resource is remote to this
	// account, and identifies the owning account.
	Account *AccountReference `json:"account,omitempty"`

	// If present, this property indicates that the referenced resource is remote to this
	// region, and identifies the native region.
	Region *RegionReference `json:"region,omitempty"`
}

// UnmarshalImageRemote unmarshals an instance of ImageRemote from the specified map of raw messages.
func UnmarshalImageRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageRemote)
	err = core.UnmarshalModel(m, "account", &obj.Account, UnmarshalAccountReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageStatusReason : ImageStatusReason struct
type ImageStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the ImageStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	ImageStatusReasonCodeEncryptedDataKeyInvalidConst         = "encrypted_data_key_invalid"
	ImageStatusReasonCodeEncryptionKeyDeletedConst            = "encryption_key_deleted"
	ImageStatusReasonCodeEncryptionKeyDisabledConst           = "encryption_key_disabled"
	ImageStatusReasonCodeImageDataCorruptedConst              = "image_data_corrupted"
	ImageStatusReasonCodeImageProvisionedSizeUnsupportedConst = "image_provisioned_size_unsupported"
	ImageStatusReasonCodeImageRequestInProgressConst          = "image_request_in_progress"
	ImageStatusReasonCodeImageRequestQueuedConst              = "image_request_queued"
)

// UnmarshalImageStatusReason unmarshals an instance of ImageStatusReason from the specified map of raw messages.
func UnmarshalImageStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Instance : Instance struct
type Instance struct {
	// The availability policy for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicy `json:"availability_policy" validate:"required"`

	// The total bandwidth (in megabits per second) shared across the instance network interfaces and storage volumes of
	// virtual server instance.
	Bandwidth *int64 `json:"bandwidth" validate:"required"`

	// Boot volume attachment.
	BootVolumeAttachment *VolumeAttachmentReferenceInstanceContext `json:"boot_volume_attachment" validate:"required"`

	// If present, this virtual server instance was provisioned from a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user).
	CatalogOffering *InstanceCatalogOffering `json:"catalog_offering,omitempty"`

	// The date and time that the virtual server instance was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// If present, the dedicated host this virtual server instance has been placed on.
	DedicatedHost *DedicatedHostReference `json:"dedicated_host,omitempty"`

	// The instance disks for this virtual server instance.
	Disks []InstanceDisk `json:"disks" validate:"required"`

	// The virtual server instance GPU configuration.
	Gpu *InstanceGpu `json:"gpu,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The image the virtual server instance was provisioned from.
	Image *ImageReference `json:"image,omitempty"`

	// The reasons for the current `lifecycle_state` (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []InstanceLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the virtual server instance.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The amount of memory, truncated to whole gibibytes.
	Memory *int64 `json:"memory" validate:"required"`

	// The metadata service configuration.
	MetadataService *InstanceMetadataService `json:"metadata_service" validate:"required"`

	// The name for this virtual server instance. The name is unique across all virtual server instances in the region.
	Name *string `json:"name" validate:"required"`

	// The network interfaces for this instance, including the primary network interface.
	NetworkInterfaces []NetworkInterfaceInstanceContextReference `json:"network_interfaces" validate:"required"`

	// The number of NUMA nodes this virtual server instance is provisioned on.
	//
	// This property will be absent if the instance's `status` is not `running`.
	NumaCount *int64 `json:"numa_count,omitempty"`

	// The placement restrictions for the virtual server instance.
	PlacementTarget InstancePlacementTargetIntf `json:"placement_target,omitempty"`

	// The primary network interface for this virtual server instance.
	PrimaryNetworkInterface *NetworkInterfaceInstanceContextReference `json:"primary_network_interface" validate:"required"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) for this virtual
	// server instance.
	Profile *InstanceProfileReference `json:"profile" validate:"required"`

	// The resource group for this instance.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// Indicates whether the state of the virtual server instance permits a start request.
	Startable *bool `json:"startable" validate:"required"`

	// The status of the virtual server instance.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the instance on which the unexpected
	// property value was encountered.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []InstanceStatusReason `json:"status_reasons" validate:"required"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance network interfaces.
	TotalNetworkBandwidth *int64 `json:"total_network_bandwidth" validate:"required"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth" validate:"required"`

	// The virtual server instance VCPU configuration.
	Vcpu *InstanceVcpu `json:"vcpu" validate:"required"`

	// The volume attachments for this virtual server instance, including the boot volume attachment.
	VolumeAttachments []VolumeAttachmentReferenceInstanceContext `json:"volume_attachments" validate:"required"`

	// The VPC this virtual server instance resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone this virtual server instance resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Instance.LifecycleState property.
// The lifecycle state of the virtual server instance.
const (
	InstanceLifecycleStateDeletingConst  = "deleting"
	InstanceLifecycleStateFailedConst    = "failed"
	InstanceLifecycleStatePendingConst   = "pending"
	InstanceLifecycleStateStableConst    = "stable"
	InstanceLifecycleStateSuspendedConst = "suspended"
	InstanceLifecycleStateUpdatingConst  = "updating"
	InstanceLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the Instance.ResourceType property.
// The resource type.
const (
	InstanceResourceTypeInstanceConst = "instance"
)

// Constants associated with the Instance.Status property.
// The status of the virtual server instance.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the instance on which the unexpected
// property value was encountered.
const (
	InstanceStatusDeletingConst   = "deleting"
	InstanceStatusFailedConst     = "failed"
	InstanceStatusPendingConst    = "pending"
	InstanceStatusRestartingConst = "restarting"
	InstanceStatusRunningConst    = "running"
	InstanceStatusStartingConst   = "starting"
	InstanceStatusStoppedConst    = "stopped"
	InstanceStatusStoppingConst   = "stopping"
)

// UnmarshalInstance unmarshals an instance of Instance from the specified map of raw messages.
func UnmarshalInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Instance)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bandwidth", &obj.Bandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentReferenceInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOffering)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dedicated_host", &obj.DedicatedHost, UnmarshalDedicatedHostReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalInstanceDisk)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu", &obj.Gpu, UnmarshalInstanceGpu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalInstanceLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataService)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfaceInstanceContextReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "numa_count", &obj.NumaCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfaceInstanceContextReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "startable", &obj.Startable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalInstanceStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_network_bandwidth", &obj.TotalNetworkBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu", &obj.Vcpu, UnmarshalInstanceVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentReferenceInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceAction : InstanceAction struct
type InstanceAction struct {
	// The date and time that the action was completed.
	// Deprecated: this field is deprecated and may be removed in a future release.
	CompletedAt *strfmt.DateTime `json:"completed_at,omitempty"`

	// The date and time that the action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start action.
	Force *bool `json:"force,omitempty"`

	// The URL for this instance action.
	// Deprecated: this field is deprecated and may be removed in a future release.
	Href *string `json:"href" validate:"required"`

	// The identifier for this instance action.
	// Deprecated: this field is deprecated and may be removed in a future release.
	ID *string `json:"id" validate:"required"`

	// The date and time that the action was started.
	// Deprecated: this field is deprecated and may be removed in a future release.
	StartedAt *strfmt.DateTime `json:"started_at,omitempty"`

	// The current status of this action.
	// Deprecated: this field is deprecated and may be removed in a future release.
	Status *string `json:"status" validate:"required"`

	// The type of action.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceAction.Status property.
// The current status of this action.
const (
	InstanceActionStatusCompletedConst = "completed"
	InstanceActionStatusFailedConst    = "failed"
	InstanceActionStatusPendingConst   = "pending"
	InstanceActionStatusRunningConst   = "running"
)

// Constants associated with the InstanceAction.Type property.
// The type of action.
const (
	InstanceActionTypeRebootConst = "reboot"
	InstanceActionTypeStartConst  = "start"
	InstanceActionTypeStopConst   = "stop"
)

// UnmarshalInstanceAction unmarshals an instance of InstanceAction from the specified map of raw messages.
func UnmarshalInstanceAction(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceAction)
	err = core.UnmarshalPrimitive(m, "completed_at", &obj.CompletedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "force", &obj.Force)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "started_at", &obj.StartedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceAvailabilityPolicy : InstanceAvailabilityPolicy struct
type InstanceAvailabilityPolicy struct {
	// The action to perform if the compute host experiences a failure.
	// - `restart`: Automatically restart the virtual server instance after host failure
	// - `stop`: Leave the virtual server instance stopped after host failure
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the instance on which the
	// unexpected property value was encountered.
	HostFailure *string `json:"host_failure" validate:"required"`
}

// Constants associated with the InstanceAvailabilityPolicy.HostFailure property.
// The action to perform if the compute host experiences a failure.
// - `restart`: Automatically restart the virtual server instance after host failure
// - `stop`: Leave the virtual server instance stopped after host failure
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the instance on which the
// unexpected property value was encountered.
const (
	InstanceAvailabilityPolicyHostFailureRestartConst = "restart"
	InstanceAvailabilityPolicyHostFailureStopConst    = "stop"
)

// UnmarshalInstanceAvailabilityPolicy unmarshals an instance of InstanceAvailabilityPolicy from the specified map of raw messages.
func UnmarshalInstanceAvailabilityPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceAvailabilityPolicy)
	err = core.UnmarshalPrimitive(m, "host_failure", &obj.HostFailure)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceAvailabilityPolicyPatch : InstanceAvailabilityPolicyPatch struct
type InstanceAvailabilityPolicyPatch struct {
	// The action to perform if the compute host experiences a failure.
	// - `restart`: Automatically restart the virtual server instance after host failure
	// - `stop`: Leave the virtual server instance stopped after host failure.
	HostFailure *string `json:"host_failure,omitempty"`
}

// Constants associated with the InstanceAvailabilityPolicyPatch.HostFailure property.
// The action to perform if the compute host experiences a failure.
// - `restart`: Automatically restart the virtual server instance after host failure
// - `stop`: Leave the virtual server instance stopped after host failure.
const (
	InstanceAvailabilityPolicyPatchHostFailureRestartConst = "restart"
	InstanceAvailabilityPolicyPatchHostFailureStopConst    = "stop"
)

// UnmarshalInstanceAvailabilityPolicyPatch unmarshals an instance of InstanceAvailabilityPolicyPatch from the specified map of raw messages.
func UnmarshalInstanceAvailabilityPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceAvailabilityPolicyPatch)
	err = core.UnmarshalPrimitive(m, "host_failure", &obj.HostFailure)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceAvailabilityPolicyPrototype : InstanceAvailabilityPolicyPrototype struct
type InstanceAvailabilityPolicyPrototype struct {
	// The action to perform if the compute host experiences a failure.
	// - `restart`: Automatically restart the virtual server instance after host failure
	// - `stop`: Leave the virtual server instance stopped after host failure.
	HostFailure *string `json:"host_failure,omitempty"`
}

// Constants associated with the InstanceAvailabilityPolicyPrototype.HostFailure property.
// The action to perform if the compute host experiences a failure.
// - `restart`: Automatically restart the virtual server instance after host failure
// - `stop`: Leave the virtual server instance stopped after host failure.
const (
	InstanceAvailabilityPolicyPrototypeHostFailureRestartConst = "restart"
	InstanceAvailabilityPolicyPrototypeHostFailureStopConst    = "stop"
)

// UnmarshalInstanceAvailabilityPolicyPrototype unmarshals an instance of InstanceAvailabilityPolicyPrototype from the specified map of raw messages.
func UnmarshalInstanceAvailabilityPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceAvailabilityPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "host_failure", &obj.HostFailure)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCatalogOffering : InstanceCatalogOffering struct
type InstanceCatalogOffering struct {
	// The catalog offering version this virtual server instance was provisioned from.
	//
	// The catalog offering version is not managed by the IBM VPC service, and may no longer
	// exist, or may refer to a different image CRN than the `image.crn` for this virtual
	// server instance. However, all images associated with a catalog offering version will
	// have the same checksum, and therefore will have the same data.
	Version *CatalogOfferingVersionReference `json:"version" validate:"required"`
}

// UnmarshalInstanceCatalogOffering unmarshals an instance of InstanceCatalogOffering from the specified map of raw messages.
func UnmarshalInstanceCatalogOffering(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCatalogOffering)
	err = core.UnmarshalModel(m, "version", &obj.Version, UnmarshalCatalogOfferingVersionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCatalogOfferingPrototype : The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering or offering version to use
// when provisioning this virtual server instance.
//
// If an offering is specified, the latest version of that offering will be used.
//
// The specified offering or offering version may be in a different account in the same
// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject to IAM policies.
// Models which "extend" this model:
// - InstanceCatalogOfferingPrototypeCatalogOfferingByOffering
// - InstanceCatalogOfferingPrototypeCatalogOfferingByVersion
type InstanceCatalogOfferingPrototype struct {
	// Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
	// offering by a unique property.
	Offering CatalogOfferingIdentityIntf `json:"offering,omitempty"`

	// Identifies a version of a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a
	// unique property.
	Version CatalogOfferingVersionIdentityIntf `json:"version,omitempty"`
}

func (*InstanceCatalogOfferingPrototype) isaInstanceCatalogOfferingPrototype() bool {
	return true
}

type InstanceCatalogOfferingPrototypeIntf interface {
	isaInstanceCatalogOfferingPrototype() bool
}

// UnmarshalInstanceCatalogOfferingPrototype unmarshals an instance of InstanceCatalogOfferingPrototype from the specified map of raw messages.
func UnmarshalInstanceCatalogOfferingPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCatalogOfferingPrototype)
	err = core.UnmarshalModel(m, "offering", &obj.Offering, UnmarshalCatalogOfferingIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "version", &obj.Version, UnmarshalCatalogOfferingVersionIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCollection : InstanceCollection struct
type InstanceCollection struct {
	// A link to the first page of resources.
	First *InstanceCollectionFirst `json:"first" validate:"required"`

	// Collection of virtual server instances.
	Instances []Instance `json:"instances" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceCollection unmarshals an instance of InstanceCollection from the specified map of raw messages.
func UnmarshalInstanceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instances", &obj.Instances, UnmarshalInstance)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *InstanceCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// InstanceCollectionFirst : A link to the first page of resources.
type InstanceCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceCollectionFirst unmarshals an instance of InstanceCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceCollectionNext unmarshals an instance of InstanceCollectionNext from the specified map of raw messages.
func UnmarshalInstanceCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceConsoleAccessToken : The instance console access token information.
type InstanceConsoleAccessToken struct {
	// A URL safe single-use token used to access the console WebSocket.
	AccessToken *string `json:"access_token" validate:"required"`

	// The instance console type for which this token may be used.
	ConsoleType *string `json:"console_type" validate:"required"`

	// The date and time that the access token was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The date and time that the access token will expire.
	ExpiresAt *strfmt.DateTime `json:"expires_at" validate:"required"`

	// Indicates whether to disconnect an existing serial console session as the serial console cannot be shared.  This has
	// no effect on VNC consoles.
	Force *bool `json:"force" validate:"required"`

	// The URL to access this instance console.
	Href *string `json:"href" validate:"required"`
}

// Constants associated with the InstanceConsoleAccessToken.ConsoleType property.
// The instance console type for which this token may be used.
const (
	InstanceConsoleAccessTokenConsoleTypeSerialConst = "serial"
	InstanceConsoleAccessTokenConsoleTypeVncConst    = "vnc"
)

// UnmarshalInstanceConsoleAccessToken unmarshals an instance of InstanceConsoleAccessToken from the specified map of raw messages.
func UnmarshalInstanceConsoleAccessToken(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceConsoleAccessToken)
	err = core.UnmarshalPrimitive(m, "access_token", &obj.AccessToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "console_type", &obj.ConsoleType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires_at", &obj.ExpiresAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "force", &obj.Force)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceDefaultTrustedProfilePrototype : InstanceDefaultTrustedProfilePrototype struct
type InstanceDefaultTrustedProfilePrototype struct {
	// If set to `true`, the system will create a link to the specified `target` trusted profile during instance creation.
	// Regardless of whether a link is created by the system or manually using the IAM Identity service, it will be
	// automatically deleted when the instance is deleted.
	AutoLink *bool `json:"auto_link,omitempty"`

	// The default IAM trusted profile to use for this virtual server instance.
	Target TrustedProfileIdentityIntf `json:"target" validate:"required"`
}

// NewInstanceDefaultTrustedProfilePrototype : Instantiate InstanceDefaultTrustedProfilePrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceDefaultTrustedProfilePrototype(target TrustedProfileIdentityIntf) (_model *InstanceDefaultTrustedProfilePrototype, err error) {
	_model = &InstanceDefaultTrustedProfilePrototype{
		Target: target,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalInstanceDefaultTrustedProfilePrototype unmarshals an instance of InstanceDefaultTrustedProfilePrototype from the specified map of raw messages.
func UnmarshalInstanceDefaultTrustedProfilePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceDefaultTrustedProfilePrototype)
	err = core.UnmarshalPrimitive(m, "auto_link", &obj.AutoLink)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalTrustedProfileIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceDisk : InstanceDisk struct
type InstanceDisk struct {
	// The date and time that the disk was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance disk.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance disk.
	ID *string `json:"id" validate:"required"`

	// The disk interface used for attaching the disk.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// The name for this instance disk. The name is unique across all disks on the instance.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The size of the disk in GB (gigabytes).
	Size *int64 `json:"size" validate:"required"`
}

// Constants associated with the InstanceDisk.InterfaceType property.
// The disk interface used for attaching the disk.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	InstanceDiskInterfaceTypeNvmeConst      = "nvme"
	InstanceDiskInterfaceTypeVirtioBlkConst = "virtio_blk"
)

// Constants associated with the InstanceDisk.ResourceType property.
// The resource type.
const (
	InstanceDiskResourceTypeInstanceDiskConst = "instance_disk"
)

// UnmarshalInstanceDisk unmarshals an instance of InstanceDisk from the specified map of raw messages.
func UnmarshalInstanceDisk(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceDisk)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceDiskCollection : InstanceDiskCollection struct
type InstanceDiskCollection struct {
	// Collection of the instance's disks.
	Disks []InstanceDisk `json:"disks" validate:"required"`
}

// UnmarshalInstanceDiskCollection unmarshals an instance of InstanceDiskCollection from the specified map of raw messages.
func UnmarshalInstanceDiskCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceDiskCollection)
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalInstanceDisk)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceDiskPatch : InstanceDiskPatch struct
type InstanceDiskPatch struct {
	// The name for this instance disk. The name must not be used by another disk on the instance.
	Name *string `json:"name,omitempty"`
}

// UnmarshalInstanceDiskPatch unmarshals an instance of InstanceDiskPatch from the specified map of raw messages.
func UnmarshalInstanceDiskPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceDiskPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceDiskPatch
func (instanceDiskPatch *InstanceDiskPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceDiskPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceDiskReference : InstanceDiskReference struct
type InstanceDiskReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceDiskReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance disk.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance disk.
	ID *string `json:"id" validate:"required"`

	// The name for this instance disk. The name is unique across all disks on the instance.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstanceDiskReference.ResourceType property.
// The resource type.
const (
	InstanceDiskReferenceResourceTypeInstanceDiskConst = "instance_disk"
)

// UnmarshalInstanceDiskReference unmarshals an instance of InstanceDiskReference from the specified map of raw messages.
func UnmarshalInstanceDiskReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceDiskReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceDiskReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceDiskReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceDiskReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceDiskReferenceDeleted unmarshals an instance of InstanceDiskReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceDiskReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceDiskReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGpu : The virtual server instance GPU configuration.
type InstanceGpu struct {
	// The number of GPUs assigned to the instance.
	Count *int64 `json:"count" validate:"required"`

	// The GPU manufacturer.
	Manufacturer *string `json:"manufacturer" validate:"required"`

	// The overall amount of GPU memory in GiB (gibibytes).
	Memory *int64 `json:"memory" validate:"required"`

	// The GPU model.
	Model *string `json:"model" validate:"required"`
}

// UnmarshalInstanceGpu unmarshals an instance of InstanceGpu from the specified map of raw messages.
func UnmarshalInstanceGpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGpu)
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manufacturer", &obj.Manufacturer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "model", &obj.Model)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroup : InstanceGroup struct
type InstanceGroup struct {
	// The port used for new load balancer pool members created by this instance group.
	//
	// This property will be present if and only if `load_balancer_pool` is present.
	ApplicationPort *int64 `json:"application_port,omitempty"`

	// The date and time that the instance group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance group.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group.
	ID *string `json:"id" validate:"required"`

	// The template used to create new instances for this group.
	InstanceTemplate *InstanceTemplateReference `json:"instance_template" validate:"required"`

	// If present, the load balancer pool this instance group manages. A pool member will
	// be created for each instance created by this group.
	LoadBalancerPool *LoadBalancerPoolReference `json:"load_balancer_pool,omitempty"`

	// The managers for the instance group.
	Managers []InstanceGroupManagerReference `json:"managers" validate:"required"`

	// The number of instances in the instance group.
	MembershipCount *int64 `json:"membership_count" validate:"required"`

	// The name for this instance group. The name is unique across all instance groups in the region.
	Name *string `json:"name" validate:"required"`

	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the instance group
	// - `deleting`: Group is being deleted
	// - `healthy`: Group has `membership_count` instances
	// - `scaling`: Instances in the group are being created or deleted to reach
	//              `membership_count`
	// - `unhealthy`: Group is unable to reach `membership_count` instances.
	Status *string `json:"status" validate:"required"`

	// The subnets to use when creating new instances.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The date and time that the instance group was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The VPC the instance group resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the InstanceGroup.Status property.
// The status of the instance group
//   - `deleting`: Group is being deleted
//   - `healthy`: Group has `membership_count` instances
//   - `scaling`: Instances in the group are being created or deleted to reach
//     `membership_count`
//   - `unhealthy`: Group is unable to reach `membership_count` instances.
const (
	InstanceGroupStatusDeletingConst  = "deleting"
	InstanceGroupStatusHealthyConst   = "healthy"
	InstanceGroupStatusScalingConst   = "scaling"
	InstanceGroupStatusUnhealthyConst = "unhealthy"
)

// UnmarshalInstanceGroup unmarshals an instance of InstanceGroup from the specified map of raw messages.
func UnmarshalInstanceGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroup)
	err = core.UnmarshalPrimitive(m, "application_port", &obj.ApplicationPort)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_template", &obj.InstanceTemplate, UnmarshalInstanceTemplateReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "load_balancer_pool", &obj.LoadBalancerPool, UnmarshalLoadBalancerPoolReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "managers", &obj.Managers, UnmarshalInstanceGroupManagerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "membership_count", &obj.MembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupCollection : InstanceGroupCollection struct
type InstanceGroupCollection struct {
	// A link to the first page of resources.
	First *InstanceGroupCollectionFirst `json:"first" validate:"required"`

	// Collection of instance groups.
	InstanceGroups []InstanceGroup `json:"instance_groups" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceGroupCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupCollection unmarshals an instance of InstanceGroupCollection from the specified map of raw messages.
func UnmarshalInstanceGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_groups", &obj.InstanceGroups, UnmarshalInstanceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *InstanceGroupCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// InstanceGroupCollectionFirst : A link to the first page of resources.
type InstanceGroupCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupCollectionFirst unmarshals an instance of InstanceGroupCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceGroupCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupCollectionNext unmarshals an instance of InstanceGroupCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManager : InstanceGroupManager struct
// Models which "extend" this model:
// - InstanceGroupManagerAutoScale
// - InstanceGroupManagerScheduled
type InstanceGroupManager struct {
	// The date and time that the instance group manager was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled" validate:"required"`

	// The name for this instance group manager. The name is unique across all managers for the instance group.
	Name *string `json:"name" validate:"required"`

	// The date and time that the instance group manager was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type,omitempty"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The policies of the instance group manager.
	Policies []InstanceGroupManagerPolicyReference `json:"policies,omitempty"`

	// The actions of the instance group manager.
	Actions []InstanceGroupManagerActionReference `json:"actions,omitempty"`
}

// Constants associated with the InstanceGroupManager.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerManagerTypeAutoscaleConst = "autoscale"
)

func (*InstanceGroupManager) isaInstanceGroupManager() bool {
	return true
}

type InstanceGroupManagerIntf interface {
	isaInstanceGroupManager() bool
}

// UnmarshalInstanceGroupManager unmarshals an instance of InstanceGroupManager from the specified map of raw messages.
func UnmarshalInstanceGroupManager(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManager)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalInstanceGroupManagerPolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "actions", &obj.Actions, UnmarshalInstanceGroupManagerActionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerAction : InstanceGroupManagerAction struct
// Models which "extend" this model:
// - InstanceGroupManagerActionScheduledAction
type InstanceGroupManagerAction struct {
	// Indicates whether this scheduled action will be automatically deleted after it has completed and
	// `auto_delete_timeout` hours have passed. At present, this is always
	// `true`, but may be modifiable in the future.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be automatically
	// deleted. If the value is `0`, the action will be deleted once it has finished. This value may be modifiable in the
	// future.
	AutoDeleteTimeout *int64 `json:"auto_delete_timeout" validate:"required"`

	// The date and time that the instance group manager action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager action.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager action.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager action. The name is unique across all actions for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the instance group action
	// - `active`: Action is ready to be run
	// - `completed`: Action was completed successfully
	// - `failed`: Action could not be completed successfully
	// - `incompatible`: Action parameters are not compatible with the group or manager
	// - `omitted`: Action was not applied because this action's manager was disabled.
	Status *string `json:"status" validate:"required"`

	// The date and time that the instance group manager action was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The type of action for the instance group.
	ActionType *string `json:"action_type,omitempty"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	// The date and time the scheduled action was last applied. If absent, the action has never been applied.
	LastAppliedAt *strfmt.DateTime `json:"last_applied_at,omitempty"`

	// The date and time the scheduled action will next run. If absent, the system is currently calculating the next run
	// time.
	NextRunAt *strfmt.DateTime `json:"next_run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroup `json:"group,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerIntf `json:"manager,omitempty"`
}

// Constants associated with the InstanceGroupManagerAction.ResourceType property.
// The resource type.
const (
	InstanceGroupManagerActionResourceTypeInstanceGroupManagerActionConst = "instance_group_manager_action"
)

// Constants associated with the InstanceGroupManagerAction.Status property.
// The status of the instance group action
// - `active`: Action is ready to be run
// - `completed`: Action was completed successfully
// - `failed`: Action could not be completed successfully
// - `incompatible`: Action parameters are not compatible with the group or manager
// - `omitted`: Action was not applied because this action's manager was disabled.
const (
	InstanceGroupManagerActionStatusActiveConst       = "active"
	InstanceGroupManagerActionStatusCompletedConst    = "completed"
	InstanceGroupManagerActionStatusFailedConst       = "failed"
	InstanceGroupManagerActionStatusIncompatibleConst = "incompatible"
	InstanceGroupManagerActionStatusOmittedConst      = "omitted"
)

// Constants associated with the InstanceGroupManagerAction.ActionType property.
// The type of action for the instance group.
const (
	InstanceGroupManagerActionActionTypeScheduledConst = "scheduled"
)

func (*InstanceGroupManagerAction) isaInstanceGroupManagerAction() bool {
	return true
}

type InstanceGroupManagerActionIntf interface {
	isaInstanceGroupManagerAction() bool
}

// UnmarshalInstanceGroupManagerAction unmarshals an instance of InstanceGroupManagerAction from the specified map of raw messages.
func UnmarshalInstanceGroupManagerAction(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerAction)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete_timeout", &obj.AutoDeleteTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "action_type", &obj.ActionType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "last_applied_at", &obj.LastAppliedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "next_run_at", &obj.NextRunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManager)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionGroupPatch : InstanceGroupManagerActionGroupPatch struct
type InstanceGroupManagerActionGroupPatch struct {
	// The desired number of instance group members at the scheduled time.
	MembershipCount *int64 `json:"membership_count,omitempty"`
}

// UnmarshalInstanceGroupManagerActionGroupPatch unmarshals an instance of InstanceGroupManagerActionGroupPatch from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionGroupPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionGroupPatch)
	err = core.UnmarshalPrimitive(m, "membership_count", &obj.MembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionManagerPatch : InstanceGroupManagerActionManagerPatch struct
type InstanceGroupManagerActionManagerPatch struct {
	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

// UnmarshalInstanceGroupManagerActionManagerPatch unmarshals an instance of InstanceGroupManagerActionManagerPatch from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionManagerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionManagerPatch)
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPatch : InstanceGroupManagerActionPatch struct
type InstanceGroupManagerActionPatch struct {
	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	Group *InstanceGroupManagerActionGroupPatch `json:"group,omitempty"`

	Manager *InstanceGroupManagerActionManagerPatch `json:"manager,omitempty"`

	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager.
	Name *string `json:"name,omitempty"`

	// The date and time the scheduled action will run.
	RunAt *strfmt.DateTime `json:"run_at,omitempty"`
}

// UnmarshalInstanceGroupManagerActionPatch unmarshals an instance of InstanceGroupManagerActionPatch from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPatch)
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerActionGroupPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerActionManagerPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "run_at", &obj.RunAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceGroupManagerActionPatch
func (instanceGroupManagerActionPatch *InstanceGroupManagerActionPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceGroupManagerActionPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceGroupManagerActionPrototype : InstanceGroupManagerActionPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerActionPrototypeScheduledActionPrototype
type InstanceGroupManagerActionPrototype struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The date and time the scheduled action will run.
	RunAt *strfmt.DateTime `json:"run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroupPrototype `json:"group,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerPrototypeIntf `json:"manager,omitempty"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`
}

func (*InstanceGroupManagerActionPrototype) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

type InstanceGroupManagerActionPrototypeIntf interface {
	isaInstanceGroupManagerActionPrototype() bool
}

// UnmarshalInstanceGroupManagerActionPrototype unmarshals an instance of InstanceGroupManagerActionPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "run_at", &obj.RunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroupPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManagerPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionReference : InstanceGroupManagerActionReference struct
type InstanceGroupManagerActionReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceGroupManagerActionReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance group manager action.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager action.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager action. The name is unique across all actions for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerActionReference.ResourceType property.
// The resource type.
const (
	InstanceGroupManagerActionReferenceResourceTypeInstanceGroupManagerActionConst = "instance_group_manager_action"
)

// UnmarshalInstanceGroupManagerActionReference unmarshals an instance of InstanceGroupManagerActionReference from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceGroupManagerActionReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceGroupManagerActionReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceGroupManagerActionReferenceDeleted unmarshals an instance of InstanceGroupManagerActionReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionsCollection : InstanceGroupManagerActionsCollection struct
type InstanceGroupManagerActionsCollection struct {
	// Collection of instance group manager actions.
	Actions []InstanceGroupManagerActionIntf `json:"actions" validate:"required"`

	// A link to the first page of resources.
	First *InstanceGroupManagerActionsCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceGroupManagerActionsCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupManagerActionsCollection unmarshals an instance of InstanceGroupManagerActionsCollection from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionsCollection)
	err = core.UnmarshalModel(m, "actions", &obj.Actions, UnmarshalInstanceGroupManagerAction)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupManagerActionsCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupManagerActionsCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *InstanceGroupManagerActionsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// InstanceGroupManagerActionsCollectionFirst : A link to the first page of resources.
type InstanceGroupManagerActionsCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerActionsCollectionFirst unmarshals an instance of InstanceGroupManagerActionsCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionsCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionsCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionsCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceGroupManagerActionsCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerActionsCollectionNext unmarshals an instance of InstanceGroupManagerActionsCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionsCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionsCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerCollection : InstanceGroupManagerCollection struct
type InstanceGroupManagerCollection struct {
	// A link to the first page of resources.
	First *InstanceGroupManagerCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of instance group managers.
	Managers []InstanceGroupManagerIntf `json:"managers" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceGroupManagerCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupManagerCollection unmarshals an instance of InstanceGroupManagerCollection from the specified map of raw messages.
func UnmarshalInstanceGroupManagerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupManagerCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "managers", &obj.Managers, UnmarshalInstanceGroupManager)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupManagerCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *InstanceGroupManagerCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// InstanceGroupManagerCollectionFirst : A link to the first page of resources.
type InstanceGroupManagerCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerCollectionFirst unmarshals an instance of InstanceGroupManagerCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupManagerCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceGroupManagerCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerCollectionNext unmarshals an instance of InstanceGroupManagerCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupManagerCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPatch : InstanceGroupManagerPatch struct
type InstanceGroupManagerPatch struct {
	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The name for this instance group manager. The name must not be used by another manager for the instance group.
	Name *string `json:"name,omitempty"`
}

// UnmarshalInstanceGroupManagerPatch unmarshals an instance of InstanceGroupManagerPatch from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPatch)
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceGroupManagerPatch
func (instanceGroupManagerPatch *InstanceGroupManagerPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceGroupManagerPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceGroupManagerPolicy : InstanceGroupManagerPolicy struct
// Models which "extend" this model:
// - InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy
type InstanceGroupManagerPolicy struct {
	// The date and time that the instance group manager policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager policy.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager policy. The name is unique across all policies for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The date and time that the instance group manager policy was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type,omitempty"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value,omitempty"`

	// The type of policy for the instance group.
	PolicyType *string `json:"policy_type,omitempty"`
}

// Constants associated with the InstanceGroupManagerPolicy.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicy.PolicyType property.
// The type of policy for the instance group.
const (
	InstanceGroupManagerPolicyPolicyTypeTargetConst = "target"
)

func (*InstanceGroupManagerPolicy) isaInstanceGroupManagerPolicy() bool {
	return true
}

type InstanceGroupManagerPolicyIntf interface {
	isaInstanceGroupManagerPolicy() bool
}

// UnmarshalInstanceGroupManagerPolicy unmarshals an instance of InstanceGroupManagerPolicy from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicy)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyCollection : InstanceGroupManagerPolicyCollection struct
type InstanceGroupManagerPolicyCollection struct {
	// A link to the first page of resources.
	First *InstanceGroupManagerPolicyCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceGroupManagerPolicyCollectionNext `json:"next,omitempty"`

	// Collection of instance group manager policies.
	Policies []InstanceGroupManagerPolicyIntf `json:"policies" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyCollection unmarshals an instance of InstanceGroupManagerPolicyCollection from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupManagerPolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupManagerPolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalInstanceGroupManagerPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *InstanceGroupManagerPolicyCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// InstanceGroupManagerPolicyCollectionFirst : A link to the first page of resources.
type InstanceGroupManagerPolicyCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyCollectionFirst unmarshals an instance of InstanceGroupManagerPolicyCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceGroupManagerPolicyCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyCollectionNext unmarshals an instance of InstanceGroupManagerPolicyCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyPatch : InstanceGroupManagerPolicyPatch struct
type InstanceGroupManagerPolicyPatch struct {
	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type,omitempty"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value,omitempty"`

	// The name for this instance group manager policy. The name must not be used by another policy for the instance group
	// manager.
	Name *string `json:"name,omitempty"`
}

// Constants associated with the InstanceGroupManagerPolicyPatch.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyPatchMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyPatchMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyPatchMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyPatchMetricTypeNetworkOutConst = "network_out"
)

// UnmarshalInstanceGroupManagerPolicyPatch unmarshals an instance of InstanceGroupManagerPolicyPatch from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyPatch)
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceGroupManagerPolicyPatch
func (instanceGroupManagerPolicyPatch *InstanceGroupManagerPolicyPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceGroupManagerPolicyPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceGroupManagerPolicyPrototype : InstanceGroupManagerPolicyPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype
type InstanceGroupManagerPolicyPrototype struct {
	// The name for this instance group manager policy. The name must not be used by another policy for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type,omitempty"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value,omitempty"`

	// The type of policy for the instance group.
	PolicyType *string `json:"policy_type,omitempty"`
}

// Constants associated with the InstanceGroupManagerPolicyPrototype.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyPrototypeMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyPrototypeMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyPrototypeMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyPrototypeMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicyPrototype.PolicyType property.
// The type of policy for the instance group.
const (
	InstanceGroupManagerPolicyPrototypePolicyTypeTargetConst = "target"
)

func (*InstanceGroupManagerPolicyPrototype) isaInstanceGroupManagerPolicyPrototype() bool {
	return true
}

type InstanceGroupManagerPolicyPrototypeIntf interface {
	isaInstanceGroupManagerPolicyPrototype() bool
}

// UnmarshalInstanceGroupManagerPolicyPrototype unmarshals an instance of InstanceGroupManagerPolicyPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyReference : InstanceGroupManagerPolicyReference struct
type InstanceGroupManagerPolicyReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceGroupManagerPolicyReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance group manager policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager policy.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager policy. The name is unique across all policies for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyReference unmarshals an instance of InstanceGroupManagerPolicyReference from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceGroupManagerPolicyReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceGroupManagerPolicyReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyReferenceDeleted unmarshals an instance of InstanceGroupManagerPolicyReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPrototype : InstanceGroupManagerPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype
// - InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype
type InstanceGroupManagerPrototype struct {
	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The name for this instance group manager. The name must not be used by another manager for the instance group. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type,omitempty"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

// Constants associated with the InstanceGroupManagerPrototype.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerPrototypeManagerTypeAutoscaleConst = "autoscale"
)

func (*InstanceGroupManagerPrototype) isaInstanceGroupManagerPrototype() bool {
	return true
}

type InstanceGroupManagerPrototypeIntf interface {
	isaInstanceGroupManagerPrototype() bool
}

// UnmarshalInstanceGroupManagerPrototype unmarshals an instance of InstanceGroupManagerPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPrototype)
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerReference : InstanceGroupManagerReference struct
type InstanceGroupManagerReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceGroupManagerReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager. The name is unique across all managers for the instance group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceGroupManagerReference unmarshals an instance of InstanceGroupManagerReference from the specified map of raw messages.
func UnmarshalInstanceGroupManagerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceGroupManagerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceGroupManagerReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceGroupManagerReferenceDeleted unmarshals an instance of InstanceGroupManagerReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceGroupManagerReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionGroup : InstanceGroupManagerScheduledActionGroup struct
type InstanceGroupManagerScheduledActionGroup struct {
	// The desired number of instance group members at the scheduled time.
	MembershipCount *int64 `json:"membership_count" validate:"required"`
}

// UnmarshalInstanceGroupManagerScheduledActionGroup unmarshals an instance of InstanceGroupManagerScheduledActionGroup from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionGroup)
	err = core.UnmarshalPrimitive(m, "membership_count", &obj.MembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionGroupPrototype : InstanceGroupManagerScheduledActionGroupPrototype struct
type InstanceGroupManagerScheduledActionGroupPrototype struct {
	// The desired number of instance group members at the scheduled time.
	MembershipCount *int64 `json:"membership_count" validate:"required"`
}

// NewInstanceGroupManagerScheduledActionGroupPrototype : Instantiate InstanceGroupManagerScheduledActionGroupPrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerScheduledActionGroupPrototype(membershipCount int64) (_model *InstanceGroupManagerScheduledActionGroupPrototype, err error) {
	_model = &InstanceGroupManagerScheduledActionGroupPrototype{
		MembershipCount: core.Int64Ptr(membershipCount),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalInstanceGroupManagerScheduledActionGroupPrototype unmarshals an instance of InstanceGroupManagerScheduledActionGroupPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionGroupPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionGroupPrototype)
	err = core.UnmarshalPrimitive(m, "membership_count", &obj.MembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionManager : InstanceGroupManagerScheduledActionManager struct
// Models which "extend" this model:
// - InstanceGroupManagerScheduledActionManagerAutoScale
type InstanceGroupManagerScheduledActionManager struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceGroupManagerReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id,omitempty"`

	// The name for this instance group manager. The name is unique across all managers for the instance group.
	Name *string `json:"name,omitempty"`

	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

func (*InstanceGroupManagerScheduledActionManager) isaInstanceGroupManagerScheduledActionManager() bool {
	return true
}

type InstanceGroupManagerScheduledActionManagerIntf interface {
	isaInstanceGroupManagerScheduledActionManager() bool
}

// UnmarshalInstanceGroupManagerScheduledActionManager unmarshals an instance of InstanceGroupManagerScheduledActionManager from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionManager(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionManager)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceGroupManagerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionManagerPrototype : InstanceGroupManagerScheduledActionManagerPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype
type InstanceGroupManagerScheduledActionManagerPrototype struct {
	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href,omitempty"`
}

func (*InstanceGroupManagerScheduledActionManagerPrototype) isaInstanceGroupManagerScheduledActionManagerPrototype() bool {
	return true
}

type InstanceGroupManagerScheduledActionManagerPrototypeIntf interface {
	isaInstanceGroupManagerScheduledActionManagerPrototype() bool
}

// UnmarshalInstanceGroupManagerScheduledActionManagerPrototype unmarshals an instance of InstanceGroupManagerScheduledActionManagerPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionManagerPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionManagerPrototype)
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembership : InstanceGroupMembership struct
type InstanceGroupMembership struct {
	// The date and time that the instance group manager policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If set to true, when deleting the membership the instance will also be deleted.
	DeleteInstanceOnMembershipDelete *bool `json:"delete_instance_on_membership_delete" validate:"required"`

	// The URL for this instance group membership.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group membership.
	ID *string `json:"id" validate:"required"`

	Instance *InstanceReference `json:"instance" validate:"required"`

	InstanceTemplate *InstanceTemplateReference `json:"instance_template" validate:"required"`

	// The name for this instance group membership. The name is unique across all memberships for the instance group.
	Name *string `json:"name" validate:"required"`

	PoolMember *LoadBalancerPoolMemberReference `json:"pool_member,omitempty"`

	// The status of the instance group membership
	// - `deleting`: Membership is deleting dependent resources
	// - `failed`: Membership was unable to maintain dependent resources
	// - `healthy`: Membership is active and serving in the group
	// - `pending`: Membership is waiting for dependent resources
	// - `unhealthy`: Membership has unhealthy dependent resources.
	Status *string `json:"status" validate:"required"`

	// The date and time that the instance group membership was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the InstanceGroupMembership.Status property.
// The status of the instance group membership
// - `deleting`: Membership is deleting dependent resources
// - `failed`: Membership was unable to maintain dependent resources
// - `healthy`: Membership is active and serving in the group
// - `pending`: Membership is waiting for dependent resources
// - `unhealthy`: Membership has unhealthy dependent resources.
const (
	InstanceGroupMembershipStatusDeletingConst  = "deleting"
	InstanceGroupMembershipStatusFailedConst    = "failed"
	InstanceGroupMembershipStatusHealthyConst   = "healthy"
	InstanceGroupMembershipStatusPendingConst   = "pending"
	InstanceGroupMembershipStatusUnhealthyConst = "unhealthy"
)

// UnmarshalInstanceGroupMembership unmarshals an instance of InstanceGroupMembership from the specified map of raw messages.
func UnmarshalInstanceGroupMembership(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembership)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delete_instance_on_membership_delete", &obj.DeleteInstanceOnMembershipDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_template", &obj.InstanceTemplate, UnmarshalInstanceTemplateReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pool_member", &obj.PoolMember, UnmarshalLoadBalancerPoolMemberReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembershipCollection : InstanceGroupMembershipCollection struct
type InstanceGroupMembershipCollection struct {
	// A link to the first page of resources.
	First *InstanceGroupMembershipCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of instance group memberships.
	Memberships []InstanceGroupMembership `json:"memberships" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceGroupMembershipCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupMembershipCollection unmarshals an instance of InstanceGroupMembershipCollection from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupMembershipCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memberships", &obj.Memberships, UnmarshalInstanceGroupMembership)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupMembershipCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *InstanceGroupMembershipCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// InstanceGroupMembershipCollectionFirst : A link to the first page of resources.
type InstanceGroupMembershipCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupMembershipCollectionFirst unmarshals an instance of InstanceGroupMembershipCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembershipCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceGroupMembershipCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupMembershipCollectionNext unmarshals an instance of InstanceGroupMembershipCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembershipPatch : InstanceGroupMembershipPatch struct
type InstanceGroupMembershipPatch struct {
	// The name for this instance group membership. The name must not be used by another membership for the instance group
	// manager.
	Name *string `json:"name,omitempty"`
}

// UnmarshalInstanceGroupMembershipPatch unmarshals an instance of InstanceGroupMembershipPatch from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceGroupMembershipPatch
func (instanceGroupMembershipPatch *InstanceGroupMembershipPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceGroupMembershipPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceGroupPatch : To add or update load balancer specification for an instance group the `membership_count` must first be set to 0.
type InstanceGroupPatch struct {
	// The port to use for new load balancer pool members created by this instance group.
	//
	// This property must be set if and only if `load_balancer_pool` has been set.
	ApplicationPort *int64 `json:"application_port,omitempty"`

	// Instance template to use when creating new instances.
	//
	// Instance groups are not compatible with instance templates that specify `true` for
	// `default_trusted_profile.auto_link`.
	InstanceTemplate InstanceTemplateIdentityIntf `json:"instance_template,omitempty"`

	// The load balancer associated with `load_balancer_pool`.
	// The load balancer must have `instance_groups_supported` set to `true`.
	//
	// This property must be set if and only if `load_balancer_pool` has been set.
	LoadBalancer LoadBalancerIdentityIntf `json:"load_balancer,omitempty"`

	// If specified, this instance group will manage the load balancer pool. A pool member
	// will be created for each instance created by this group.  The specified load
	// balancer pool must not be used by another instance group in the VPC.
	//
	// If set, `load_balancer` and `application_port` must also be set.
	LoadBalancerPool LoadBalancerPoolIdentityIntf `json:"load_balancer_pool,omitempty"`

	// The number of instances in the instance group.
	MembershipCount *int64 `json:"membership_count,omitempty"`

	// The name for this instance group. The name must not be used by another instance group in the region.
	Name *string `json:"name,omitempty"`

	// The subnets to use when creating new instances.
	Subnets []SubnetIdentityIntf `json:"subnets,omitempty"`
}

// UnmarshalInstanceGroupPatch unmarshals an instance of InstanceGroupPatch from the specified map of raw messages.
func UnmarshalInstanceGroupPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupPatch)
	err = core.UnmarshalPrimitive(m, "application_port", &obj.ApplicationPort)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_template", &obj.InstanceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "load_balancer", &obj.LoadBalancer, UnmarshalLoadBalancerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "load_balancer_pool", &obj.LoadBalancerPool, UnmarshalLoadBalancerPoolIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "membership_count", &obj.MembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceGroupPatch
func (instanceGroupPatch *InstanceGroupPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceGroupPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceGroupReference : InstanceGroupReference struct
type InstanceGroupReference struct {
	// The CRN for this instance group.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceGroupReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group. The name is unique across all instance groups in the region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceGroupReference unmarshals an instance of InstanceGroupReference from the specified map of raw messages.
func UnmarshalInstanceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceGroupReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceGroupReferenceDeleted unmarshals an instance of InstanceGroupReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceGroupReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceInitialization : InstanceInitialization struct
type InstanceInitialization struct {
	// The default trusted profile configuration specified at virtual server instance
	// creation. If absent, no default trusted profile was specified.
	DefaultTrustedProfile *InstanceInitializationDefaultTrustedProfile `json:"default_trusted_profile,omitempty"`

	// The public SSH keys used at instance initialization.
	Keys []KeyReference `json:"keys" validate:"required"`

	Password *InstanceInitializationPassword `json:"password,omitempty"`
}

// UnmarshalInstanceInitialization unmarshals an instance of InstanceInitialization from the specified map of raw messages.
func UnmarshalInstanceInitialization(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceInitialization)
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceInitializationDefaultTrustedProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalInstanceInitializationPassword)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceInitializationDefaultTrustedProfile : InstanceInitializationDefaultTrustedProfile struct
type InstanceInitializationDefaultTrustedProfile struct {
	// If set to `true`, the system created a link to the specified `target` trusted profile during instance creation.
	// Regardless of whether a link was created by the system or manually using the IAM Identity service, it will be
	// automatically deleted when the instance is deleted.
	AutoLink *bool `json:"auto_link" validate:"required"`

	// The default IAM trusted profile to use for this virtual server instance.
	Target *TrustedProfileReference `json:"target" validate:"required"`
}

// UnmarshalInstanceInitializationDefaultTrustedProfile unmarshals an instance of InstanceInitializationDefaultTrustedProfile from the specified map of raw messages.
func UnmarshalInstanceInitializationDefaultTrustedProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceInitializationDefaultTrustedProfile)
	err = core.UnmarshalPrimitive(m, "auto_link", &obj.AutoLink)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalTrustedProfileReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceInitializationPassword : InstanceInitializationPassword struct
type InstanceInitializationPassword struct {
	// The administrator password at initialization, encrypted using `encryption_key`, and returned base64-encoded.
	EncryptedPassword *[]byte `json:"encrypted_password" validate:"required"`

	// The public SSH key used to encrypt the administrator password.
	EncryptionKey *KeyIdentityByFingerprint `json:"encryption_key" validate:"required"`
}

// UnmarshalInstanceInitializationPassword unmarshals an instance of InstanceInitializationPassword from the specified map of raw messages.
func UnmarshalInstanceInitializationPassword(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceInitializationPassword)
	err = core.UnmarshalPrimitive(m, "encrypted_password", &obj.EncryptedPassword)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalKeyIdentityByFingerprint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceLifecycleReason : InstanceLifecycleReason struct
type InstanceLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the InstanceLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	InstanceLifecycleReasonCodeResourceSuspendedByProviderConst = "resource_suspended_by_provider"
)

// UnmarshalInstanceLifecycleReason unmarshals an instance of InstanceLifecycleReason from the specified map of raw messages.
func UnmarshalInstanceLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceMetadataService : The metadata service configuration.
type InstanceMetadataService struct {
	// Indicates whether the metadata service endpoint is available to the virtual server instance.
	Enabled *bool `json:"enabled" validate:"required"`

	// The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is
	// enabled.
	// - `http`: HTTP protocol (unencrypted)
	// - `https`: HTTP Secure protocol.
	Protocol *string `json:"protocol" validate:"required"`

	// The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the metadata
	// service is enabled.
	ResponseHopLimit *int64 `json:"response_hop_limit" validate:"required"`
}

// Constants associated with the InstanceMetadataService.Protocol property.
// The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is
// enabled.
// - `http`: HTTP protocol (unencrypted)
// - `https`: HTTP Secure protocol.
const (
	InstanceMetadataServiceProtocolHTTPConst  = "http"
	InstanceMetadataServiceProtocolHTTPSConst = "https"
)

// UnmarshalInstanceMetadataService unmarshals an instance of InstanceMetadataService from the specified map of raw messages.
func UnmarshalInstanceMetadataService(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceMetadataService)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "response_hop_limit", &obj.ResponseHopLimit)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceMetadataServicePatch : The metadata service configuration.
type InstanceMetadataServicePatch struct {
	// Indicates whether the metadata service endpoint will be available to the virtual server instance.
	Enabled *bool `json:"enabled,omitempty"`

	// The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is
	// enabled.
	// - `http`: HTTP protocol (unencrypted)
	// - `https`: HTTP Secure protocol.
	Protocol *string `json:"protocol,omitempty"`

	// The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the metadata
	// service is enabled.
	ResponseHopLimit *int64 `json:"response_hop_limit,omitempty"`
}

// Constants associated with the InstanceMetadataServicePatch.Protocol property.
// The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is
// enabled.
// - `http`: HTTP protocol (unencrypted)
// - `https`: HTTP Secure protocol.
const (
	InstanceMetadataServicePatchProtocolHTTPConst  = "http"
	InstanceMetadataServicePatchProtocolHTTPSConst = "https"
)

// UnmarshalInstanceMetadataServicePatch unmarshals an instance of InstanceMetadataServicePatch from the specified map of raw messages.
func UnmarshalInstanceMetadataServicePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceMetadataServicePatch)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "response_hop_limit", &obj.ResponseHopLimit)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceMetadataServicePrototype : The metadata service configuration.
type InstanceMetadataServicePrototype struct {
	// Indicates whether the metadata service endpoint will be available to the virtual server instance.
	Enabled *bool `json:"enabled,omitempty"`

	// The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is
	// enabled.
	// - `http`: HTTP protocol (unencrypted)
	// - `https`: HTTP Secure protocol.
	Protocol *string `json:"protocol,omitempty"`

	// The hop limit (IP time to live) for IP response packets from the metadata service. Applies only when the metadata
	// service is enabled.
	ResponseHopLimit *int64 `json:"response_hop_limit,omitempty"`
}

// Constants associated with the InstanceMetadataServicePrototype.Protocol property.
// The communication protocol to use for the metadata service endpoint. Applies only when the metadata service is
// enabled.
// - `http`: HTTP protocol (unencrypted)
// - `https`: HTTP Secure protocol.
const (
	InstanceMetadataServicePrototypeProtocolHTTPConst  = "http"
	InstanceMetadataServicePrototypeProtocolHTTPSConst = "https"
)

// UnmarshalInstanceMetadataServicePrototype unmarshals an instance of InstanceMetadataServicePrototype from the specified map of raw messages.
func UnmarshalInstanceMetadataServicePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceMetadataServicePrototype)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "response_hop_limit", &obj.ResponseHopLimit)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePatch : InstancePatch struct
type InstancePatch struct {
	// The availability policy for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPatch `json:"availability_policy,omitempty"`

	// The metadata service configuration.
	MetadataService *InstanceMetadataServicePatch `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. Changing the name will not affect the system hostname.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance. For the placement
	// restrictions to be changed, the instance `status` must be `stopping` or `stopped`.
	PlacementTarget InstancePlacementTargetPatchIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance. For the profile to be changed,
	// the instance `status` must be `stopping` or `stopped`. In addition, the requested
	// profile must:
	// - Have matching instance disk support. Any disks associated with the current profile
	//   will be deleted, and any disks associated with the requested profile will be
	//   created.
	// - Be compatible with any `placement_target` constraints. For example, if the
	//   instance is placed on a dedicated host, the requested profile `family` must be
	//   the same as the dedicated host `family`.
	// - Have the same `vcpu.architecture`.
	// - Support the number of network interfaces the instance currently has.
	Profile InstancePatchProfileIntf `json:"profile,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`
}

// UnmarshalInstancePatch unmarshals an instance of InstancePatch from the specified map of raw messages.
func UnmarshalInstancePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePatch)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstancePatchProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstancePatch
func (instancePatch *InstancePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instancePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstancePatchProfile : The profile to use for this virtual server instance. For the profile to be changed, the instance `status` must be
// `stopping` or `stopped`. In addition, the requested profile must:
//   - Have matching instance disk support. Any disks associated with the current profile
//     will be deleted, and any disks associated with the requested profile will be
//     created.
//   - Be compatible with any `placement_target` constraints. For example, if the
//     instance is placed on a dedicated host, the requested profile `family` must be
//     the same as the dedicated host `family`.
//   - Have the same `vcpu.architecture`.
//   - Support the number of network interfaces the instance currently has.
//
// Models which "extend" this model:
// - InstancePatchProfileInstanceProfileIdentityByName
// - InstancePatchProfileInstanceProfileIdentityByHref
type InstancePatchProfile struct {
	// The globally unique name for this virtual server instance profile.
	Name *string `json:"name,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href,omitempty"`
}

func (*InstancePatchProfile) isaInstancePatchProfile() bool {
	return true
}

type InstancePatchProfileIntf interface {
	isaInstancePatchProfile() bool
}

// UnmarshalInstancePatchProfile unmarshals an instance of InstancePatchProfile from the specified map of raw messages.
func UnmarshalInstancePatchProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePatchProfile)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTarget : InstancePlacementTarget struct
// Models which "extend" this model:
// - InstancePlacementTargetDedicatedHostGroupReference
// - InstancePlacementTargetDedicatedHostReference
// - InstancePlacementTargetPlacementGroupReference
type InstancePlacementTarget struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *DedicatedHostGroupReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The name for this dedicated host group. The name is unique across all dedicated host groups in the region.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the InstancePlacementTarget.ResourceType property.
// The resource type.
const (
	InstancePlacementTargetResourceTypeDedicatedHostGroupConst = "dedicated_host_group"
)

func (*InstancePlacementTarget) isaInstancePlacementTarget() bool {
	return true
}

type InstancePlacementTargetIntf interface {
	isaInstancePlacementTarget() bool
}

// UnmarshalInstancePlacementTarget unmarshals an instance of InstancePlacementTarget from the specified map of raw messages.
func UnmarshalInstancePlacementTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTarget)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalDedicatedHostGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatch : InstancePlacementTargetPatch struct
// Models which "extend" this model:
// - InstancePlacementTargetPatchDedicatedHostIdentity
// - InstancePlacementTargetPatchDedicatedHostGroupIdentity
type InstancePlacementTargetPatch struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPatch) isaInstancePlacementTargetPatch() bool {
	return true
}

type InstancePlacementTargetPatchIntf interface {
	isaInstancePlacementTargetPatch() bool
}

// UnmarshalInstancePlacementTargetPatch unmarshals an instance of InstancePlacementTargetPatch from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototype : InstancePlacementTargetPrototype struct
// Models which "extend" this model:
// - InstancePlacementTargetPrototypeDedicatedHostIdentity
// - InstancePlacementTargetPrototypeDedicatedHostGroupIdentity
// - InstancePlacementTargetPrototypePlacementGroupIdentity
type InstancePlacementTargetPrototype struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPrototype) isaInstancePlacementTargetPrototype() bool {
	return true
}

type InstancePlacementTargetPrototypeIntf interface {
	isaInstancePlacementTargetPrototype() bool
}

// UnmarshalInstancePlacementTargetPrototype unmarshals an instance of InstancePlacementTargetPrototype from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfile : InstanceProfile struct
type InstanceProfile struct {
	Bandwidth InstanceProfileBandwidthIntf `json:"bandwidth" validate:"required"`

	// Collection of the instance profile's disks.
	Disks []InstanceProfileDisk `json:"disks" validate:"required"`

	// The product family this virtual server instance profile belongs to.
	Family *string `json:"family" validate:"required"`

	GpuCount InstanceProfileGpuIntf `json:"gpu_count,omitempty"`

	GpuManufacturer *InstanceProfileGpuManufacturer `json:"gpu_manufacturer,omitempty"`

	GpuMemory InstanceProfileGpuMemoryIntf `json:"gpu_memory,omitempty"`

	GpuModel *InstanceProfileGpuModel `json:"gpu_model,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`

	Memory InstanceProfileMemoryIntf `json:"memory" validate:"required"`

	// The globally unique name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`

	NetworkInterfaceCount InstanceProfileNetworkInterfaceCountIntf `json:"network_interface_count" validate:"required"`

	NumaCount InstanceProfileNumaCountIntf `json:"numa_count,omitempty"`

	OsArchitecture *InstanceProfileOsArchitecture `json:"os_architecture" validate:"required"`

	PortSpeed InstanceProfilePortSpeedIntf `json:"port_speed" validate:"required"`

	// The status of the instance profile:
	//   - `previous`:  This instance profile is an older revision, but remains provisionable and
	//   usable.
	//   - `current`:  This profile is the latest revision.
	//
	// Note that revisions are indicated by the generation of an instance profile.  Refer to the
	// [profile naming conventions]
	// (https://cloud.ibm.com/docs/vpc?topic=vpc-profiles&interface=ui#profiles-naming-rule) for information on how
	// generations are defined within an instance profile.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the profile on which the
	// unexpected property value was encountered.
	Status *string `json:"status" validate:"required"`

	TotalVolumeBandwidth InstanceProfileVolumeBandwidthIntf `json:"total_volume_bandwidth" validate:"required"`

	VcpuArchitecture *InstanceProfileVcpuArchitecture `json:"vcpu_architecture" validate:"required"`

	VcpuCount InstanceProfileVcpuIntf `json:"vcpu_count" validate:"required"`

	VcpuManufacturer *InstanceProfileVcpuManufacturer `json:"vcpu_manufacturer" validate:"required"`
}

// Constants associated with the InstanceProfile.Status property.
// The status of the instance profile:
//   - `previous`:  This instance profile is an older revision, but remains provisionable and
//     usable.
//   - `current`:  This profile is the latest revision.
//
// Note that revisions are indicated by the generation of an instance profile.  Refer to the
// [profile naming conventions]
// (https://cloud.ibm.com/docs/vpc?topic=vpc-profiles&interface=ui#profiles-naming-rule) for information on how
// generations are defined within an instance profile.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the profile on which the
// unexpected property value was encountered.
const (
	InstanceProfileStatusCurrentConst  = "current"
	InstanceProfileStatusPreviousConst = "previous"
)

// UnmarshalInstanceProfile unmarshals an instance of InstanceProfile from the specified map of raw messages.
func UnmarshalInstanceProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfile)
	err = core.UnmarshalModel(m, "bandwidth", &obj.Bandwidth, UnmarshalInstanceProfileBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "disks", &obj.Disks, UnmarshalInstanceProfileDisk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_count", &obj.GpuCount, UnmarshalInstanceProfileGpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_manufacturer", &obj.GpuManufacturer, UnmarshalInstanceProfileGpuManufacturer)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_memory", &obj.GpuMemory, UnmarshalInstanceProfileGpuMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_model", &obj.GpuModel, UnmarshalInstanceProfileGpuModel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalInstanceProfileMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interface_count", &obj.NetworkInterfaceCount, UnmarshalInstanceProfileNetworkInterfaceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "numa_count", &obj.NumaCount, UnmarshalInstanceProfileNumaCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "os_architecture", &obj.OsArchitecture, UnmarshalInstanceProfileOsArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "port_speed", &obj.PortSpeed, UnmarshalInstanceProfilePortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth, UnmarshalInstanceProfileVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_architecture", &obj.VcpuArchitecture, UnmarshalInstanceProfileVcpuArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_count", &obj.VcpuCount, UnmarshalInstanceProfileVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_manufacturer", &obj.VcpuManufacturer, UnmarshalInstanceProfileVcpuManufacturer)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidth : InstanceProfileBandwidth struct
// Models which "extend" this model:
// - InstanceProfileBandwidthFixed
// - InstanceProfileBandwidthRange
// - InstanceProfileBandwidthEnum
// - InstanceProfileBandwidthDependent
type InstanceProfileBandwidth struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileBandwidth.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthTypeFixedConst = "fixed"
)

func (*InstanceProfileBandwidth) isaInstanceProfileBandwidth() bool {
	return true
}

type InstanceProfileBandwidthIntf interface {
	isaInstanceProfileBandwidth() bool
}

// UnmarshalInstanceProfileBandwidth unmarshals an instance of InstanceProfileBandwidth from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidth)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileCollection : InstanceProfileCollection struct
type InstanceProfileCollection struct {
	// Collection of virtual server instance profiles.
	Profiles []InstanceProfile `json:"profiles" validate:"required"`
}

// UnmarshalInstanceProfileCollection unmarshals an instance of InstanceProfileCollection from the specified map of raw messages.
func UnmarshalInstanceProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileCollection)
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalInstanceProfile)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDisk : Disks provided by this profile.
type InstanceProfileDisk struct {
	Quantity InstanceProfileDiskQuantityIntf `json:"quantity" validate:"required"`

	Size InstanceProfileDiskSizeIntf `json:"size" validate:"required"`

	SupportedInterfaceTypes *InstanceProfileDiskSupportedInterfaces `json:"supported_interface_types" validate:"required"`
}

// UnmarshalInstanceProfileDisk unmarshals an instance of InstanceProfileDisk from the specified map of raw messages.
func UnmarshalInstanceProfileDisk(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDisk)
	err = core.UnmarshalModel(m, "quantity", &obj.Quantity, UnmarshalInstanceProfileDiskQuantity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "size", &obj.Size, UnmarshalInstanceProfileDiskSize)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "supported_interface_types", &obj.SupportedInterfaceTypes, UnmarshalInstanceProfileDiskSupportedInterfaces)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskQuantity : InstanceProfileDiskQuantity struct
// Models which "extend" this model:
// - InstanceProfileDiskQuantityFixed
// - InstanceProfileDiskQuantityRange
// - InstanceProfileDiskQuantityEnum
// - InstanceProfileDiskQuantityDependent
type InstanceProfileDiskQuantity struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileDiskQuantity.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskQuantityTypeFixedConst = "fixed"
)

func (*InstanceProfileDiskQuantity) isaInstanceProfileDiskQuantity() bool {
	return true
}

type InstanceProfileDiskQuantityIntf interface {
	isaInstanceProfileDiskQuantity() bool
}

// UnmarshalInstanceProfileDiskQuantity unmarshals an instance of InstanceProfileDiskQuantity from the specified map of raw messages.
func UnmarshalInstanceProfileDiskQuantity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskQuantity)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskSize : InstanceProfileDiskSize struct
// Models which "extend" this model:
// - InstanceProfileDiskSizeFixed
// - InstanceProfileDiskSizeRange
// - InstanceProfileDiskSizeEnum
// - InstanceProfileDiskSizeDependent
type InstanceProfileDiskSize struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileDiskSize.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskSizeTypeFixedConst = "fixed"
)

func (*InstanceProfileDiskSize) isaInstanceProfileDiskSize() bool {
	return true
}

type InstanceProfileDiskSizeIntf interface {
	isaInstanceProfileDiskSize() bool
}

// UnmarshalInstanceProfileDiskSize unmarshals an instance of InstanceProfileDiskSize from the specified map of raw messages.
func UnmarshalInstanceProfileDiskSize(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskSize)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskSupportedInterfaces : InstanceProfileDiskSupportedInterfaces struct
type InstanceProfileDiskSupportedInterfaces struct {
	// The disk interface used for attaching the disk.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected property value was encountered.
	Default *string `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported disk interfaces used for attaching the disk.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileDiskSupportedInterfaces.Default property.
// The disk interface used for attaching the disk.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	InstanceProfileDiskSupportedInterfacesDefaultNvmeConst      = "nvme"
	InstanceProfileDiskSupportedInterfacesDefaultVirtioBlkConst = "virtio_blk"
)

// Constants associated with the InstanceProfileDiskSupportedInterfaces.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskSupportedInterfacesTypeEnumConst = "enum"
)

// Constants associated with the InstanceProfileDiskSupportedInterfaces.Values property.
// The disk interface used for attaching the disk.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
// unexpected property value was encountered.
const (
	InstanceProfileDiskSupportedInterfacesValuesNvmeConst      = "nvme"
	InstanceProfileDiskSupportedInterfacesValuesVirtioBlkConst = "virtio_blk"
)

// UnmarshalInstanceProfileDiskSupportedInterfaces unmarshals an instance of InstanceProfileDiskSupportedInterfaces from the specified map of raw messages.
func UnmarshalInstanceProfileDiskSupportedInterfaces(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskSupportedInterfaces)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpu : InstanceProfileGpu struct
// Models which "extend" this model:
// - InstanceProfileGpuFixed
// - InstanceProfileGpuRange
// - InstanceProfileGpuEnum
// - InstanceProfileGpuDependent
type InstanceProfileGpu struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileGpu.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuTypeFixedConst = "fixed"
)

func (*InstanceProfileGpu) isaInstanceProfileGpu() bool {
	return true
}

type InstanceProfileGpuIntf interface {
	isaInstanceProfileGpu() bool
}

// UnmarshalInstanceProfileGpu unmarshals an instance of InstanceProfileGpu from the specified map of raw messages.
func UnmarshalInstanceProfileGpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpu)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuManufacturer : InstanceProfileGpuManufacturer struct
type InstanceProfileGpuManufacturer struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The possible GPU manufacturer(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuManufacturer.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuManufacturerTypeEnumConst = "enum"
)

// UnmarshalInstanceProfileGpuManufacturer unmarshals an instance of InstanceProfileGpuManufacturer from the specified map of raw messages.
func UnmarshalInstanceProfileGpuManufacturer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuManufacturer)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemory : InstanceProfileGpuMemory struct
// Models which "extend" this model:
// - InstanceProfileGpuMemoryFixed
// - InstanceProfileGpuMemoryRange
// - InstanceProfileGpuMemoryEnum
// - InstanceProfileGpuMemoryDependent
type InstanceProfileGpuMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileGpuMemory.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryTypeFixedConst = "fixed"
)

func (*InstanceProfileGpuMemory) isaInstanceProfileGpuMemory() bool {
	return true
}

type InstanceProfileGpuMemoryIntf interface {
	isaInstanceProfileGpuMemory() bool
}

// UnmarshalInstanceProfileGpuMemory unmarshals an instance of InstanceProfileGpuMemory from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuModel : InstanceProfileGpuModel struct
type InstanceProfileGpuModel struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The possible GPU model(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuModel.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuModelTypeEnumConst = "enum"
)

// UnmarshalInstanceProfileGpuModel unmarshals an instance of InstanceProfileGpuModel from the specified map of raw messages.
func UnmarshalInstanceProfileGpuModel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuModel)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileIdentity : Identifies an instance profile by a unique property.
// Models which "extend" this model:
// - InstanceProfileIdentityByName
// - InstanceProfileIdentityByHref
type InstanceProfileIdentity struct {
	// The globally unique name for this virtual server instance profile.
	Name *string `json:"name,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href,omitempty"`
}

func (*InstanceProfileIdentity) isaInstanceProfileIdentity() bool {
	return true
}

type InstanceProfileIdentityIntf interface {
	isaInstanceProfileIdentity() bool
}

// UnmarshalInstanceProfileIdentity unmarshals an instance of InstanceProfileIdentity from the specified map of raw messages.
func UnmarshalInstanceProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemory : InstanceProfileMemory struct
// Models which "extend" this model:
// - InstanceProfileMemoryFixed
// - InstanceProfileMemoryRange
// - InstanceProfileMemoryEnum
// - InstanceProfileMemoryDependent
type InstanceProfileMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileMemory.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryTypeFixedConst = "fixed"
)

func (*InstanceProfileMemory) isaInstanceProfileMemory() bool {
	return true
}

type InstanceProfileMemoryIntf interface {
	isaInstanceProfileMemory() bool
}

// UnmarshalInstanceProfileMemory unmarshals an instance of InstanceProfileMemory from the specified map of raw messages.
func UnmarshalInstanceProfileMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileNumaCount : InstanceProfileNumaCount struct
// Models which "extend" this model:
// - InstanceProfileNumaCountFixed
// - InstanceProfileNumaCountDependent
type InstanceProfileNumaCount struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the InstanceProfileNumaCount.Type property.
// The type for this profile field.
const (
	InstanceProfileNumaCountTypeFixedConst = "fixed"
)

func (*InstanceProfileNumaCount) isaInstanceProfileNumaCount() bool {
	return true
}

type InstanceProfileNumaCountIntf interface {
	isaInstanceProfileNumaCount() bool
}

// UnmarshalInstanceProfileNumaCount unmarshals an instance of InstanceProfileNumaCount from the specified map of raw messages.
func UnmarshalInstanceProfileNumaCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileNumaCount)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileNetworkInterfaceCount : InstanceProfileNetworkInterfaceCount struct
// Models which "extend" this model:
// - InstanceProfileNetworkInterfaceCountRange
// - InstanceProfileNetworkInterfaceCountDependent
type InstanceProfileNetworkInterfaceCount struct {
	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The type for this profile field.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the InstanceProfileNetworkInterfaceCount.Type property.
// The type for this profile field.
const (
	InstanceProfileNetworkInterfaceCountTypeRangeConst = "range"
)

func (*InstanceProfileNetworkInterfaceCount) isaInstanceProfileNetworkInterfaceCount() bool {
	return true
}

type InstanceProfileNetworkInterfaceCountIntf interface {
	isaInstanceProfileNetworkInterfaceCount() bool
}

// UnmarshalInstanceProfileNetworkInterfaceCount unmarshals an instance of InstanceProfileNetworkInterfaceCount from the specified map of raw messages.
func UnmarshalInstanceProfileNetworkInterfaceCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileNetworkInterfaceCount)
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileOsArchitecture : InstanceProfileOsArchitecture struct
type InstanceProfileOsArchitecture struct {
	// The default OS architecture for an instance with this profile.
	Default *string `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported OS architecture(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileOsArchitecture.Type property.
// The type for this profile field.
const (
	InstanceProfileOsArchitectureTypeEnumConst = "enum"
)

// UnmarshalInstanceProfileOsArchitecture unmarshals an instance of InstanceProfileOsArchitecture from the specified map of raw messages.
func UnmarshalInstanceProfileOsArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileOsArchitecture)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfilePortSpeed : InstanceProfilePortSpeed struct
// Models which "extend" this model:
// - InstanceProfilePortSpeedFixed
// - InstanceProfilePortSpeedDependent
type InstanceProfilePortSpeed struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the InstanceProfilePortSpeed.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedTypeFixedConst = "fixed"
)

func (*InstanceProfilePortSpeed) isaInstanceProfilePortSpeed() bool {
	return true
}

type InstanceProfilePortSpeedIntf interface {
	isaInstanceProfilePortSpeed() bool
}

// UnmarshalInstanceProfilePortSpeed unmarshals an instance of InstanceProfilePortSpeed from the specified map of raw messages.
func UnmarshalInstanceProfilePortSpeed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfilePortSpeed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileReference : InstanceProfileReference struct
type InstanceProfileReference struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceProfileReference unmarshals an instance of InstanceProfileReference from the specified map of raw messages.
func UnmarshalInstanceProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpu : InstanceProfileVcpu struct
// Models which "extend" this model:
// - InstanceProfileVcpuFixed
// - InstanceProfileVcpuRange
// - InstanceProfileVcpuEnum
// - InstanceProfileVcpuDependent
type InstanceProfileVcpu struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileVcpu.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuTypeFixedConst = "fixed"
)

func (*InstanceProfileVcpu) isaInstanceProfileVcpu() bool {
	return true
}

type InstanceProfileVcpuIntf interface {
	isaInstanceProfileVcpu() bool
}

// UnmarshalInstanceProfileVcpu unmarshals an instance of InstanceProfileVcpu from the specified map of raw messages.
func UnmarshalInstanceProfileVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpu)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuArchitecture : InstanceProfileVcpuArchitecture struct
type InstanceProfileVcpuArchitecture struct {
	// The default VCPU architecture for an instance with this profile.
	Default *string `json:"default,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU architecture for an instance with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuArchitecture.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuArchitectureTypeFixedConst = "fixed"
)

// UnmarshalInstanceProfileVcpuArchitecture unmarshals an instance of InstanceProfileVcpuArchitecture from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuArchitecture)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuManufacturer : InstanceProfileVcpuManufacturer struct
type InstanceProfileVcpuManufacturer struct {
	// The default VCPU manufacturer for an instance with this profile.
	Default *string `json:"default,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU manufacturer for an instance with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuManufacturer.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuManufacturerTypeFixedConst = "fixed"
)

// UnmarshalInstanceProfileVcpuManufacturer unmarshals an instance of InstanceProfileVcpuManufacturer from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuManufacturer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuManufacturer)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVolumeBandwidth : InstanceProfileVolumeBandwidth struct
// Models which "extend" this model:
// - InstanceProfileVolumeBandwidthFixed
// - InstanceProfileVolumeBandwidthRange
// - InstanceProfileVolumeBandwidthEnum
// - InstanceProfileVolumeBandwidthDependent
type InstanceProfileVolumeBandwidth struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileVolumeBandwidth.Type property.
// The type for this profile field.
const (
	InstanceProfileVolumeBandwidthTypeFixedConst = "fixed"
)

func (*InstanceProfileVolumeBandwidth) isaInstanceProfileVolumeBandwidth() bool {
	return true
}

type InstanceProfileVolumeBandwidthIntf interface {
	isaInstanceProfileVolumeBandwidth() bool
}

// UnmarshalInstanceProfileVolumeBandwidth unmarshals an instance of InstanceProfileVolumeBandwidth from the specified map of raw messages.
func UnmarshalInstanceProfileVolumeBandwidth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVolumeBandwidth)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototype : InstancePrototype struct
// Models which "extend" this model:
// - InstancePrototypeInstanceByImage
// - InstancePrototypeInstanceByCatalogOffering
// - InstancePrototypeInstanceByVolume
// - InstancePrototypeInstanceBySourceSnapshot
// - InstancePrototypeInstanceBySourceTemplate
type InstancePrototype struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not
	// subsequently managed. Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
	// property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The metadata service configuration.
	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. If unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
	// virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change
	// in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network
	// interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
	// or offering version to use when provisioning this virtual server instance.
	//
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account in the same
	// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
	// to IAM policies.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering,omitempty"`

	// The template to create this virtual server instance from.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template,omitempty"`
}

func (*InstancePrototype) isaInstancePrototype() bool {
	return true
}

type InstancePrototypeIntf interface {
	isaInstancePrototype() bool
}

// UnmarshalInstancePrototype unmarshals an instance of InstancePrototype from the specified map of raw messages.
func UnmarshalInstancePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototype)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceReference : InstanceReference struct
type InstanceReference struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The name for this virtual server instance. The name is unique across all virtual server instances in the region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceReference unmarshals an instance of InstanceReference from the specified map of raw messages.
func UnmarshalInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceReferenceDeleted unmarshals an instance of InstanceReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceStatusReason : InstanceStatusReason struct
type InstanceStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the InstanceStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	InstanceStatusReasonCodeCannotStartConst               = "cannot_start"
	InstanceStatusReasonCodeCannotStartCapacityConst       = "cannot_start_capacity"
	InstanceStatusReasonCodeCannotStartComputeConst        = "cannot_start_compute"
	InstanceStatusReasonCodeCannotStartIPAddressConst      = "cannot_start_ip_address"
	InstanceStatusReasonCodeCannotStartNetworkConst        = "cannot_start_network"
	InstanceStatusReasonCodeCannotStartPlacementGroupConst = "cannot_start_placement_group"
	InstanceStatusReasonCodeCannotStartStorageConst        = "cannot_start_storage"
	InstanceStatusReasonCodeEncryptionKeyDeletedConst      = "encryption_key_deleted"
	InstanceStatusReasonCodeStoppedByHostFailureConst      = "stopped_by_host_failure"
	InstanceStatusReasonCodeStoppedForImageCreationConst   = "stopped_for_image_creation"
)

// UnmarshalInstanceStatusReason unmarshals an instance of InstanceStatusReason from the specified map of raw messages.
func UnmarshalInstanceStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplate : InstanceTemplate struct
// Models which "extend" this model:
// - InstanceTemplateInstanceByImageInstanceTemplateContext
// - InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext
// - InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext
type InstanceTemplate struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not
	// subsequently managed. Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
	// property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The metadata service configuration.
	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name is unique across all instance templates in the region.
	Name *string `json:"name" validate:"required"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
	// virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change
	// in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group for this instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network
	// interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
	// or offering version to use when provisioning this virtual server instance.
	//
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account in the same
	// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
	// to IAM policies.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering,omitempty"`
}

func (*InstanceTemplate) isaInstanceTemplate() bool {
	return true
}

type InstanceTemplateIntf interface {
	isaInstanceTemplate() bool
}

// UnmarshalInstanceTemplate unmarshals an instance of InstanceTemplate from the specified map of raw messages.
func UnmarshalInstanceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplate)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateCollection : InstanceTemplateCollection struct
type InstanceTemplateCollection struct {
	// A link to the first page of resources.
	First *InstanceTemplateCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *InstanceTemplateCollectionNext `json:"next,omitempty"`

	// Collection of instance templates.
	Templates []InstanceTemplateIntf `json:"templates" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceTemplateCollection unmarshals an instance of InstanceTemplateCollection from the specified map of raw messages.
func UnmarshalInstanceTemplateCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceTemplateCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceTemplateCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "templates", &obj.Templates, UnmarshalInstanceTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateCollectionFirst : A link to the first page of resources.
type InstanceTemplateCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceTemplateCollectionFirst unmarshals an instance of InstanceTemplateCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceTemplateCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type InstanceTemplateCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceTemplateCollectionNext unmarshals an instance of InstanceTemplateCollectionNext from the specified map of raw messages.
func UnmarshalInstanceTemplateCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentity : Identifies an instance template by a unique property.
// Models which "extend" this model:
// - InstanceTemplateIdentityByID
// - InstanceTemplateIdentityByHref
// - InstanceTemplateIdentityByCRN
type InstanceTemplateIdentity struct {
	// The unique identifier for this instance template.
	ID *string `json:"id,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href,omitempty"`

	// The CRN for this instance template.
	CRN *string `json:"crn,omitempty"`
}

func (*InstanceTemplateIdentity) isaInstanceTemplateIdentity() bool {
	return true
}

type InstanceTemplateIdentityIntf interface {
	isaInstanceTemplateIdentity() bool
}

// UnmarshalInstanceTemplateIdentity unmarshals an instance of InstanceTemplateIdentity from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePatch : InstanceTemplatePatch struct
type InstanceTemplatePatch struct {
	// The name for this instance template. The name must not be used by another instance template in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalInstanceTemplatePatch unmarshals an instance of InstanceTemplatePatch from the specified map of raw messages.
func UnmarshalInstanceTemplatePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the InstanceTemplatePatch
func (instanceTemplatePatch *InstanceTemplatePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(instanceTemplatePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// InstanceTemplatePrototype : InstanceTemplatePrototype struct
// Models which "extend" this model:
// - InstanceTemplatePrototypeInstanceTemplateByImage
// - InstanceTemplatePrototypeInstanceTemplateBySourceTemplate
// - InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot
// - InstanceTemplatePrototypeInstanceTemplateByCatalogOffering
type InstanceTemplatePrototype struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not
	// subsequently managed. Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization)
	// property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The metadata service configuration.
	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name must not be used by another instance template in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this
	// virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change
	// in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network
	// interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
	// offering version to use when provisioning this virtual server instance.
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account, subject to
	// IAM policies.
	//
	// If specified, `image` must not be specified, and `source_template` must not have
	// `image` specified.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering,omitempty"`

	// The template to create this virtual server instance from.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template,omitempty"`
}

func (*InstanceTemplatePrototype) isaInstanceTemplatePrototype() bool {
	return true
}

type InstanceTemplatePrototypeIntf interface {
	isaInstanceTemplatePrototype() bool
}

// UnmarshalInstanceTemplatePrototype unmarshals an instance of InstanceTemplatePrototype from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototype)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateReference : InstanceTemplateReference struct
type InstanceTemplateReference struct {
	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceTemplateReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The name for this instance template. The name is unique across all instance templates in the region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceTemplateReference unmarshals an instance of InstanceTemplateReference from the specified map of raw messages.
func UnmarshalInstanceTemplateReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceTemplateReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type InstanceTemplateReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalInstanceTemplateReferenceDeleted unmarshals an instance of InstanceTemplateReferenceDeleted from the specified map of raw messages.
func UnmarshalInstanceTemplateReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceVcpu : The virtual server instance VCPU configuration.
type InstanceVcpu struct {
	// The VCPU architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// The number of VCPUs assigned.
	Count *int64 `json:"count" validate:"required"`

	// The VCPU manufacturer.
	Manufacturer *string `json:"manufacturer" validate:"required"`
}

// UnmarshalInstanceVcpu unmarshals an instance of InstanceVcpu from the specified map of raw messages.
func UnmarshalInstanceVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceVcpu)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manufacturer", &obj.Manufacturer)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Key : Key struct
type Key struct {
	// The date and time that the key was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this key.
	CRN *string `json:"crn" validate:"required"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`

	// The URL for this key.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`

	// The length of this key (in bits).
	Length *int64 `json:"length" validate:"required"`

	// The name for this key. The name must not be used by another key in the region. If unspecified, the name will be a
	// hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The public SSH key, consisting of two space-separated fields: the algorithm name, and the base64-encoded key.
	PublicKey *string `json:"public_key" validate:"required"`

	// The resource group for this key.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The crypto-system used by this key.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the Key.Type property.
// The crypto-system used by this key.
const (
	KeyTypeEd25519Const = "ed25519"
	KeyTypeRsaConst     = "rsa"
)

// UnmarshalKey unmarshals an instance of Key from the specified map of raw messages.
func UnmarshalKey(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Key)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "length", &obj.Length)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyCollection : KeyCollection struct
type KeyCollection struct {
	// A link to the first page of resources.
	First *KeyCollectionFirst `json:"first" validate:"required"`

	// Collection of keys.
	Keys []Key `json:"keys" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *KeyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalKeyCollection unmarshals an instance of KeyCollection from the specified map of raw messages.
func UnmarshalKeyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalKeyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalKeyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *KeyCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// KeyCollectionFirst : A link to the first page of resources.
type KeyCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalKeyCollectionFirst unmarshals an instance of KeyCollectionFirst from the specified map of raw messages.
func UnmarshalKeyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type KeyCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalKeyCollectionNext unmarshals an instance of KeyCollectionNext from the specified map of raw messages.
func UnmarshalKeyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentity : Identifies a key by a unique property.
// Models which "extend" this model:
// - KeyIdentityByID
// - KeyIdentityByCRN
// - KeyIdentityByHref
// - KeyIdentityByFingerprint
type KeyIdentity struct {
	// The unique identifier for this key.
	ID *string `json:"id,omitempty"`

	// The CRN for this key.
	CRN *string `json:"crn,omitempty"`

	// The URL for this key.
	Href *string `json:"href,omitempty"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint,omitempty"`
}

func (*KeyIdentity) isaKeyIdentity() bool {
	return true
}

type KeyIdentityIntf interface {
	isaKeyIdentity() bool
}

// UnmarshalKeyIdentity unmarshals an instance of KeyIdentity from the specified map of raw messages.
func UnmarshalKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyPatch : KeyPatch struct
type KeyPatch struct {
	// The name for this key. The name must not be used by another key in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalKeyPatch unmarshals an instance of KeyPatch from the specified map of raw messages.
func UnmarshalKeyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the KeyPatch
func (keyPatch *KeyPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(keyPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// KeyReference : KeyReference struct
type KeyReference struct {
	// The CRN for this key.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *KeyReferenceDeleted `json:"deleted,omitempty"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`

	// The URL for this key.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`

	// The name for this key. The name is unique across all keys in the region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalKeyReference unmarshals an instance of KeyReference from the specified map of raw messages.
func UnmarshalKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalKeyReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type KeyReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalKeyReferenceDeleted unmarshals an instance of KeyReferenceDeleted from the specified map of raw messages.
func UnmarshalKeyReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LegacyCloudObjectStorageBucketIdentity : Identifies a Cloud Object Storage bucket by a unique property.
// Models which "extend" this model:
// - LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName
type LegacyCloudObjectStorageBucketIdentity struct {
	// The globally unique name of this Cloud Object Storage bucket.
	Name *string `json:"name,omitempty"`
}

func (*LegacyCloudObjectStorageBucketIdentity) isaLegacyCloudObjectStorageBucketIdentity() bool {
	return true
}

type LegacyCloudObjectStorageBucketIdentityIntf interface {
	isaLegacyCloudObjectStorageBucketIdentity() bool
}

// UnmarshalLegacyCloudObjectStorageBucketIdentity unmarshals an instance of LegacyCloudObjectStorageBucketIdentity from the specified map of raw messages.
func UnmarshalLegacyCloudObjectStorageBucketIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LegacyCloudObjectStorageBucketIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LegacyCloudObjectStorageBucketReference : LegacyCloudObjectStorageBucketReference struct
type LegacyCloudObjectStorageBucketReference struct {
	// The globally unique name of this Cloud Object Storage bucket.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLegacyCloudObjectStorageBucketReference unmarshals an instance of LegacyCloudObjectStorageBucketReference from the specified map of raw messages.
func UnmarshalLegacyCloudObjectStorageBucketReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LegacyCloudObjectStorageBucketReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListBackupPoliciesOptions : The ListBackupPolicies options.
type ListBackupPoliciesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources with an item in the `tags` property matching the exact specified tag.
	Tag *string `json:"tag,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBackupPoliciesOptions : Instantiate ListBackupPoliciesOptions
func (*VpcV1) NewListBackupPoliciesOptions() *ListBackupPoliciesOptions {
	return &ListBackupPoliciesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListBackupPoliciesOptions) SetStart(start string) *ListBackupPoliciesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListBackupPoliciesOptions) SetLimit(limit int64) *ListBackupPoliciesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListBackupPoliciesOptions) SetResourceGroupID(resourceGroupID string) *ListBackupPoliciesOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListBackupPoliciesOptions) SetName(name string) *ListBackupPoliciesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetTag : Allow user to set Tag
func (_options *ListBackupPoliciesOptions) SetTag(tag string) *ListBackupPoliciesOptions {
	_options.Tag = core.StringPtr(tag)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBackupPoliciesOptions) SetHeaders(param map[string]string) *ListBackupPoliciesOptions {
	options.Headers = param
	return options
}

// ListBackupPolicyJobsOptions : The ListBackupPolicyJobs options.
type ListBackupPolicyJobsOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// Filters the collection to backup policy jobs with a `status` property matching the specified value.
	Status *string `json:"status,omitempty"`

	// Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
	// identifier.
	BackupPolicyPlanID *string `json:"backup_policy_plan.id,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Filters the collection to backup policy jobs with a `source.id` property matching the specified identifier.
	SourceID *string `json:"source.id,omitempty"`

	// Filters the collection to backup policy jobs with an item in the `target_snapshots` property with an `id` property
	// matching the specified identifier.
	TargetSnapshotsID *string `json:"target_snapshots[].id,omitempty"`

	// Filters the collection to backup policy jobs with an item in the `target_snapshots` property with a `crn` property
	// matching the specified CRN.
	TargetSnapshotsCRN *string `json:"target_snapshots[].crn,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListBackupPolicyJobsOptions.Status property.
// Filters the collection to backup policy jobs with a `status` property matching the specified value.
const (
	ListBackupPolicyJobsOptionsStatusFailedConst    = "failed"
	ListBackupPolicyJobsOptionsStatusRunningConst   = "running"
	ListBackupPolicyJobsOptionsStatusSucceededConst = "succeeded"
)

// Constants associated with the ListBackupPolicyJobsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListBackupPolicyJobsOptionsSortCreatedAtConst = "created_at"
	ListBackupPolicyJobsOptionsSortNameConst      = "name"
)

// NewListBackupPolicyJobsOptions : Instantiate ListBackupPolicyJobsOptions
func (*VpcV1) NewListBackupPolicyJobsOptions(backupPolicyID string) *ListBackupPolicyJobsOptions {
	return &ListBackupPolicyJobsOptions{
		BackupPolicyID: core.StringPtr(backupPolicyID),
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *ListBackupPolicyJobsOptions) SetBackupPolicyID(backupPolicyID string) *ListBackupPolicyJobsOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListBackupPolicyJobsOptions) SetStatus(status string) *ListBackupPolicyJobsOptions {
	_options.Status = core.StringPtr(status)
	return _options
}

// SetBackupPolicyPlanID : Allow user to set BackupPolicyPlanID
func (_options *ListBackupPolicyJobsOptions) SetBackupPolicyPlanID(backupPolicyPlanID string) *ListBackupPolicyJobsOptions {
	_options.BackupPolicyPlanID = core.StringPtr(backupPolicyPlanID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListBackupPolicyJobsOptions) SetStart(start string) *ListBackupPolicyJobsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListBackupPolicyJobsOptions) SetLimit(limit int64) *ListBackupPolicyJobsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListBackupPolicyJobsOptions) SetSort(sort string) *ListBackupPolicyJobsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetSourceID : Allow user to set SourceID
func (_options *ListBackupPolicyJobsOptions) SetSourceID(sourceID string) *ListBackupPolicyJobsOptions {
	_options.SourceID = core.StringPtr(sourceID)
	return _options
}

// SetTargetSnapshotsID : Allow user to set TargetSnapshotsID
func (_options *ListBackupPolicyJobsOptions) SetTargetSnapshotsID(targetSnapshotsID string) *ListBackupPolicyJobsOptions {
	_options.TargetSnapshotsID = core.StringPtr(targetSnapshotsID)
	return _options
}

// SetTargetSnapshotsCRN : Allow user to set TargetSnapshotsCRN
func (_options *ListBackupPolicyJobsOptions) SetTargetSnapshotsCRN(targetSnapshotsCRN string) *ListBackupPolicyJobsOptions {
	_options.TargetSnapshotsCRN = core.StringPtr(targetSnapshotsCRN)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBackupPolicyJobsOptions) SetHeaders(param map[string]string) *ListBackupPolicyJobsOptions {
	options.Headers = param
	return options
}

// ListBackupPolicyPlansOptions : The ListBackupPolicyPlans options.
type ListBackupPolicyPlansOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBackupPolicyPlansOptions : Instantiate ListBackupPolicyPlansOptions
func (*VpcV1) NewListBackupPolicyPlansOptions(backupPolicyID string) *ListBackupPolicyPlansOptions {
	return &ListBackupPolicyPlansOptions{
		BackupPolicyID: core.StringPtr(backupPolicyID),
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *ListBackupPolicyPlansOptions) SetBackupPolicyID(backupPolicyID string) *ListBackupPolicyPlansOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListBackupPolicyPlansOptions) SetName(name string) *ListBackupPolicyPlansOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBackupPolicyPlansOptions) SetHeaders(param map[string]string) *ListBackupPolicyPlansOptions {
	options.Headers = param
	return options
}

// ListBareMetalServerDisksOptions : The ListBareMetalServerDisks options.
type ListBareMetalServerDisksOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBareMetalServerDisksOptions : Instantiate ListBareMetalServerDisksOptions
func (*VpcV1) NewListBareMetalServerDisksOptions(bareMetalServerID string) *ListBareMetalServerDisksOptions {
	return &ListBareMetalServerDisksOptions{
		BareMetalServerID: core.StringPtr(bareMetalServerID),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *ListBareMetalServerDisksOptions) SetBareMetalServerID(bareMetalServerID string) *ListBareMetalServerDisksOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBareMetalServerDisksOptions) SetHeaders(param map[string]string) *ListBareMetalServerDisksOptions {
	options.Headers = param
	return options
}

// ListBareMetalServerNetworkInterfaceFloatingIpsOptions : The ListBareMetalServerNetworkInterfaceFloatingIps options.
type ListBareMetalServerNetworkInterfaceFloatingIpsOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBareMetalServerNetworkInterfaceFloatingIpsOptions : Instantiate ListBareMetalServerNetworkInterfaceFloatingIpsOptions
func (*VpcV1) NewListBareMetalServerNetworkInterfaceFloatingIpsOptions(bareMetalServerID string, networkInterfaceID string) *ListBareMetalServerNetworkInterfaceFloatingIpsOptions {
	return &ListBareMetalServerNetworkInterfaceFloatingIpsOptions{
		BareMetalServerID:  core.StringPtr(bareMetalServerID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *ListBareMetalServerNetworkInterfaceFloatingIpsOptions) SetBareMetalServerID(bareMetalServerID string) *ListBareMetalServerNetworkInterfaceFloatingIpsOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *ListBareMetalServerNetworkInterfaceFloatingIpsOptions) SetNetworkInterfaceID(networkInterfaceID string) *ListBareMetalServerNetworkInterfaceFloatingIpsOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBareMetalServerNetworkInterfaceFloatingIpsOptions) SetHeaders(param map[string]string) *ListBareMetalServerNetworkInterfaceFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListBareMetalServerNetworkInterfaceIpsOptions : The ListBareMetalServerNetworkInterfaceIps options.
type ListBareMetalServerNetworkInterfaceIpsOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBareMetalServerNetworkInterfaceIpsOptions : Instantiate ListBareMetalServerNetworkInterfaceIpsOptions
func (*VpcV1) NewListBareMetalServerNetworkInterfaceIpsOptions(bareMetalServerID string, networkInterfaceID string) *ListBareMetalServerNetworkInterfaceIpsOptions {
	return &ListBareMetalServerNetworkInterfaceIpsOptions{
		BareMetalServerID:  core.StringPtr(bareMetalServerID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *ListBareMetalServerNetworkInterfaceIpsOptions) SetBareMetalServerID(bareMetalServerID string) *ListBareMetalServerNetworkInterfaceIpsOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *ListBareMetalServerNetworkInterfaceIpsOptions) SetNetworkInterfaceID(networkInterfaceID string) *ListBareMetalServerNetworkInterfaceIpsOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBareMetalServerNetworkInterfaceIpsOptions) SetHeaders(param map[string]string) *ListBareMetalServerNetworkInterfaceIpsOptions {
	options.Headers = param
	return options
}

// ListBareMetalServerNetworkInterfacesOptions : The ListBareMetalServerNetworkInterfaces options.
type ListBareMetalServerNetworkInterfacesOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBareMetalServerNetworkInterfacesOptions : Instantiate ListBareMetalServerNetworkInterfacesOptions
func (*VpcV1) NewListBareMetalServerNetworkInterfacesOptions(bareMetalServerID string) *ListBareMetalServerNetworkInterfacesOptions {
	return &ListBareMetalServerNetworkInterfacesOptions{
		BareMetalServerID: core.StringPtr(bareMetalServerID),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *ListBareMetalServerNetworkInterfacesOptions) SetBareMetalServerID(bareMetalServerID string) *ListBareMetalServerNetworkInterfacesOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListBareMetalServerNetworkInterfacesOptions) SetStart(start string) *ListBareMetalServerNetworkInterfacesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListBareMetalServerNetworkInterfacesOptions) SetLimit(limit int64) *ListBareMetalServerNetworkInterfacesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBareMetalServerNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListBareMetalServerNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListBareMetalServerProfilesOptions : The ListBareMetalServerProfiles options.
type ListBareMetalServerProfilesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBareMetalServerProfilesOptions : Instantiate ListBareMetalServerProfilesOptions
func (*VpcV1) NewListBareMetalServerProfilesOptions() *ListBareMetalServerProfilesOptions {
	return &ListBareMetalServerProfilesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListBareMetalServerProfilesOptions) SetStart(start string) *ListBareMetalServerProfilesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListBareMetalServerProfilesOptions) SetLimit(limit int64) *ListBareMetalServerProfilesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBareMetalServerProfilesOptions) SetHeaders(param map[string]string) *ListBareMetalServerProfilesOptions {
	options.Headers = param
	return options
}

// ListBareMetalServersOptions : The ListBareMetalServers options.
type ListBareMetalServersOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources with a `vpc.id` property matching the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBareMetalServersOptions : Instantiate ListBareMetalServersOptions
func (*VpcV1) NewListBareMetalServersOptions() *ListBareMetalServersOptions {
	return &ListBareMetalServersOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListBareMetalServersOptions) SetStart(start string) *ListBareMetalServersOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListBareMetalServersOptions) SetLimit(limit int64) *ListBareMetalServersOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListBareMetalServersOptions) SetResourceGroupID(resourceGroupID string) *ListBareMetalServersOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListBareMetalServersOptions) SetName(name string) *ListBareMetalServersOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetVPCID : Allow user to set VPCID
func (_options *ListBareMetalServersOptions) SetVPCID(vpcID string) *ListBareMetalServersOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListBareMetalServersOptions) SetVPCCRN(vpcCRN string) *ListBareMetalServersOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListBareMetalServersOptions) SetVPCName(vpcName string) *ListBareMetalServersOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBareMetalServersOptions) SetHeaders(param map[string]string) *ListBareMetalServersOptions {
	options.Headers = param
	return options
}

// ListDedicatedHostDisksOptions : The ListDedicatedHostDisks options.
type ListDedicatedHostDisksOptions struct {
	// The dedicated host identifier.
	DedicatedHostID *string `json:"dedicated_host_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostDisksOptions : Instantiate ListDedicatedHostDisksOptions
func (*VpcV1) NewListDedicatedHostDisksOptions(dedicatedHostID string) *ListDedicatedHostDisksOptions {
	return &ListDedicatedHostDisksOptions{
		DedicatedHostID: core.StringPtr(dedicatedHostID),
	}
}

// SetDedicatedHostID : Allow user to set DedicatedHostID
func (_options *ListDedicatedHostDisksOptions) SetDedicatedHostID(dedicatedHostID string) *ListDedicatedHostDisksOptions {
	_options.DedicatedHostID = core.StringPtr(dedicatedHostID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostDisksOptions) SetHeaders(param map[string]string) *ListDedicatedHostDisksOptions {
	options.Headers = param
	return options
}

// ListDedicatedHostGroupsOptions : The ListDedicatedHostGroups options.
type ListDedicatedHostGroupsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `zone.name` property matching the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostGroupsOptions : Instantiate ListDedicatedHostGroupsOptions
func (*VpcV1) NewListDedicatedHostGroupsOptions() *ListDedicatedHostGroupsOptions {
	return &ListDedicatedHostGroupsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListDedicatedHostGroupsOptions) SetStart(start string) *ListDedicatedHostGroupsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDedicatedHostGroupsOptions) SetLimit(limit int64) *ListDedicatedHostGroupsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListDedicatedHostGroupsOptions) SetResourceGroupID(resourceGroupID string) *ListDedicatedHostGroupsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *ListDedicatedHostGroupsOptions) SetZoneName(zoneName string) *ListDedicatedHostGroupsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListDedicatedHostGroupsOptions) SetName(name string) *ListDedicatedHostGroupsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostGroupsOptions) SetHeaders(param map[string]string) *ListDedicatedHostGroupsOptions {
	options.Headers = param
	return options
}

// ListDedicatedHostProfilesOptions : The ListDedicatedHostProfiles options.
type ListDedicatedHostProfilesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostProfilesOptions : Instantiate ListDedicatedHostProfilesOptions
func (*VpcV1) NewListDedicatedHostProfilesOptions() *ListDedicatedHostProfilesOptions {
	return &ListDedicatedHostProfilesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListDedicatedHostProfilesOptions) SetStart(start string) *ListDedicatedHostProfilesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDedicatedHostProfilesOptions) SetLimit(limit int64) *ListDedicatedHostProfilesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostProfilesOptions) SetHeaders(param map[string]string) *ListDedicatedHostProfilesOptions {
	options.Headers = param
	return options
}

// ListDedicatedHostsOptions : The ListDedicatedHosts options.
type ListDedicatedHostsOptions struct {
	// Filters the collection to dedicated hosts with a `group.id` property matching the specified identifier.
	DedicatedHostGroupID *string `json:"dedicated_host_group.id,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `zone.name` property matching the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostsOptions : Instantiate ListDedicatedHostsOptions
func (*VpcV1) NewListDedicatedHostsOptions() *ListDedicatedHostsOptions {
	return &ListDedicatedHostsOptions{}
}

// SetDedicatedHostGroupID : Allow user to set DedicatedHostGroupID
func (_options *ListDedicatedHostsOptions) SetDedicatedHostGroupID(dedicatedHostGroupID string) *ListDedicatedHostsOptions {
	_options.DedicatedHostGroupID = core.StringPtr(dedicatedHostGroupID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListDedicatedHostsOptions) SetStart(start string) *ListDedicatedHostsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDedicatedHostsOptions) SetLimit(limit int64) *ListDedicatedHostsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListDedicatedHostsOptions) SetResourceGroupID(resourceGroupID string) *ListDedicatedHostsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *ListDedicatedHostsOptions) SetZoneName(zoneName string) *ListDedicatedHostsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListDedicatedHostsOptions) SetName(name string) *ListDedicatedHostsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostsOptions) SetHeaders(param map[string]string) *ListDedicatedHostsOptions {
	options.Headers = param
	return options
}

// ListEndpointGatewayIpsOptions : The ListEndpointGatewayIps options.
type ListEndpointGatewayIpsOptions struct {
	// The endpoint gateway identifier.
	EndpointGatewayID *string `json:"endpoint_gateway_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListEndpointGatewayIpsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListEndpointGatewayIpsOptionsSortAddressConst   = "address"
	ListEndpointGatewayIpsOptionsSortCreatedAtConst = "created_at"
	ListEndpointGatewayIpsOptionsSortNameConst      = "name"
)

// NewListEndpointGatewayIpsOptions : Instantiate ListEndpointGatewayIpsOptions
func (*VpcV1) NewListEndpointGatewayIpsOptions(endpointGatewayID string) *ListEndpointGatewayIpsOptions {
	return &ListEndpointGatewayIpsOptions{
		EndpointGatewayID: core.StringPtr(endpointGatewayID),
	}
}

// SetEndpointGatewayID : Allow user to set EndpointGatewayID
func (_options *ListEndpointGatewayIpsOptions) SetEndpointGatewayID(endpointGatewayID string) *ListEndpointGatewayIpsOptions {
	_options.EndpointGatewayID = core.StringPtr(endpointGatewayID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListEndpointGatewayIpsOptions) SetStart(start string) *ListEndpointGatewayIpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListEndpointGatewayIpsOptions) SetLimit(limit int64) *ListEndpointGatewayIpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListEndpointGatewayIpsOptions) SetSort(sort string) *ListEndpointGatewayIpsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListEndpointGatewayIpsOptions) SetHeaders(param map[string]string) *ListEndpointGatewayIpsOptions {
	options.Headers = param
	return options
}

// ListEndpointGatewaysOptions : The ListEndpointGateways options.
type ListEndpointGatewaysOptions struct {
	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `vpc.id` property matching the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to endpoint gateways with an `allow_dns_resolution_binding` property matching the specified
	// value.
	AllowDnsResolutionBinding *bool `json:"allow_dns_resolution_binding,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListEndpointGatewaysOptions : Instantiate ListEndpointGatewaysOptions
func (*VpcV1) NewListEndpointGatewaysOptions() *ListEndpointGatewaysOptions {
	return &ListEndpointGatewaysOptions{}
}

// SetName : Allow user to set Name
func (_options *ListEndpointGatewaysOptions) SetName(name string) *ListEndpointGatewaysOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListEndpointGatewaysOptions) SetStart(start string) *ListEndpointGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListEndpointGatewaysOptions) SetLimit(limit int64) *ListEndpointGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListEndpointGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListEndpointGatewaysOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetVPCID : Allow user to set VPCID
func (_options *ListEndpointGatewaysOptions) SetVPCID(vpcID string) *ListEndpointGatewaysOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListEndpointGatewaysOptions) SetVPCCRN(vpcCRN string) *ListEndpointGatewaysOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListEndpointGatewaysOptions) SetVPCName(vpcName string) *ListEndpointGatewaysOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetAllowDnsResolutionBinding : Allow user to set AllowDnsResolutionBinding
func (_options *ListEndpointGatewaysOptions) SetAllowDnsResolutionBinding(allowDnsResolutionBinding bool) *ListEndpointGatewaysOptions {
	_options.AllowDnsResolutionBinding = core.BoolPtr(allowDnsResolutionBinding)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListEndpointGatewaysOptions) SetHeaders(param map[string]string) *ListEndpointGatewaysOptions {
	options.Headers = param
	return options
}

// ListFloatingIpsOptions : The ListFloatingIps options.
type ListFloatingIpsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListFloatingIpsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListFloatingIpsOptionsSortCreatedAtConst = "created_at"
	ListFloatingIpsOptionsSortNameConst      = "name"
)

// NewListFloatingIpsOptions : Instantiate ListFloatingIpsOptions
func (*VpcV1) NewListFloatingIpsOptions() *ListFloatingIpsOptions {
	return &ListFloatingIpsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListFloatingIpsOptions) SetStart(start string) *ListFloatingIpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListFloatingIpsOptions) SetLimit(limit int64) *ListFloatingIpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListFloatingIpsOptions) SetResourceGroupID(resourceGroupID string) *ListFloatingIpsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListFloatingIpsOptions) SetSort(sort string) *ListFloatingIpsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListFloatingIpsOptions) SetHeaders(param map[string]string) *ListFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListFlowLogCollectorsOptions : The ListFlowLogCollectors options.
type ListFlowLogCollectorsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources with a `vpc.id` property matching the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to resources with a `target.id` property matching the specified identifier.
	TargetID *string `json:"target.id,omitempty"`

	// Filters the collection to resources with a `target.resource_type` property matching the specified value.
	TargetResourceType *string `json:"target.resource_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListFlowLogCollectorsOptions : Instantiate ListFlowLogCollectorsOptions
func (*VpcV1) NewListFlowLogCollectorsOptions() *ListFlowLogCollectorsOptions {
	return &ListFlowLogCollectorsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListFlowLogCollectorsOptions) SetStart(start string) *ListFlowLogCollectorsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListFlowLogCollectorsOptions) SetLimit(limit int64) *ListFlowLogCollectorsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListFlowLogCollectorsOptions) SetResourceGroupID(resourceGroupID string) *ListFlowLogCollectorsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListFlowLogCollectorsOptions) SetName(name string) *ListFlowLogCollectorsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetVPCID : Allow user to set VPCID
func (_options *ListFlowLogCollectorsOptions) SetVPCID(vpcID string) *ListFlowLogCollectorsOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListFlowLogCollectorsOptions) SetVPCCRN(vpcCRN string) *ListFlowLogCollectorsOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListFlowLogCollectorsOptions) SetVPCName(vpcName string) *ListFlowLogCollectorsOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetTargetID : Allow user to set TargetID
func (_options *ListFlowLogCollectorsOptions) SetTargetID(targetID string) *ListFlowLogCollectorsOptions {
	_options.TargetID = core.StringPtr(targetID)
	return _options
}

// SetTargetResourceType : Allow user to set TargetResourceType
func (_options *ListFlowLogCollectorsOptions) SetTargetResourceType(targetResourceType string) *ListFlowLogCollectorsOptions {
	_options.TargetResourceType = core.StringPtr(targetResourceType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListFlowLogCollectorsOptions) SetHeaders(param map[string]string) *ListFlowLogCollectorsOptions {
	options.Headers = param
	return options
}

// ListIkePoliciesOptions : The ListIkePolicies options.
type ListIkePoliciesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIkePoliciesOptions : Instantiate ListIkePoliciesOptions
func (*VpcV1) NewListIkePoliciesOptions() *ListIkePoliciesOptions {
	return &ListIkePoliciesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListIkePoliciesOptions) SetStart(start string) *ListIkePoliciesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListIkePoliciesOptions) SetLimit(limit int64) *ListIkePoliciesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListIkePoliciesOptions) SetHeaders(param map[string]string) *ListIkePoliciesOptions {
	options.Headers = param
	return options
}

// ListIkePolicyConnectionsOptions : The ListIkePolicyConnections options.
type ListIkePolicyConnectionsOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIkePolicyConnectionsOptions : Instantiate ListIkePolicyConnectionsOptions
func (*VpcV1) NewListIkePolicyConnectionsOptions(id string) *ListIkePolicyConnectionsOptions {
	return &ListIkePolicyConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListIkePolicyConnectionsOptions) SetID(id string) *ListIkePolicyConnectionsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListIkePolicyConnectionsOptions) SetHeaders(param map[string]string) *ListIkePolicyConnectionsOptions {
	options.Headers = param
	return options
}

// ListImageExportJobsOptions : The ListImageExportJobs options.
type ListImageExportJobsOptions struct {
	// The image identifier.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListImageExportJobsOptions : Instantiate ListImageExportJobsOptions
func (*VpcV1) NewListImageExportJobsOptions(imageID string) *ListImageExportJobsOptions {
	return &ListImageExportJobsOptions{
		ImageID: core.StringPtr(imageID),
	}
}

// SetImageID : Allow user to set ImageID
func (_options *ListImageExportJobsOptions) SetImageID(imageID string) *ListImageExportJobsOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListImageExportJobsOptions) SetName(name string) *ListImageExportJobsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListImageExportJobsOptions) SetHeaders(param map[string]string) *ListImageExportJobsOptions {
	options.Headers = param
	return options
}

// ListImagesOptions : The ListImages options.
type ListImagesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to images with a `status` property matching one of the specified comma-separated values.
	Status []string `json:"status,omitempty"`

	// Filters the collection to images with a `visibility` property matching the specified value.
	Visibility *string `json:"visibility,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListImagesOptions.Status property.
const (
	ListImagesOptionsStatusAvailableConst  = "available"
	ListImagesOptionsStatusDeletingConst   = "deleting"
	ListImagesOptionsStatusDeprecatedConst = "deprecated"
	ListImagesOptionsStatusFailedConst     = "failed"
	ListImagesOptionsStatusObsoleteConst   = "obsolete"
	ListImagesOptionsStatusPendingConst    = "pending"
	ListImagesOptionsStatusUnusableConst   = "unusable"
)

// Constants associated with the ListImagesOptions.Visibility property.
// Filters the collection to images with a `visibility` property matching the specified value.
const (
	ListImagesOptionsVisibilityPrivateConst = "private"
	ListImagesOptionsVisibilityPublicConst  = "public"
)

// NewListImagesOptions : Instantiate ListImagesOptions
func (*VpcV1) NewListImagesOptions() *ListImagesOptions {
	return &ListImagesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListImagesOptions) SetStart(start string) *ListImagesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListImagesOptions) SetLimit(limit int64) *ListImagesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListImagesOptions) SetResourceGroupID(resourceGroupID string) *ListImagesOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListImagesOptions) SetName(name string) *ListImagesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListImagesOptions) SetStatus(status []string) *ListImagesOptions {
	_options.Status = status
	return _options
}

// SetVisibility : Allow user to set Visibility
func (_options *ListImagesOptions) SetVisibility(visibility string) *ListImagesOptions {
	_options.Visibility = core.StringPtr(visibility)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListImagesOptions) SetHeaders(param map[string]string) *ListImagesOptions {
	options.Headers = param
	return options
}

// ListInstanceDisksOptions : The ListInstanceDisks options.
type ListInstanceDisksOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceDisksOptions : Instantiate ListInstanceDisksOptions
func (*VpcV1) NewListInstanceDisksOptions(instanceID string) *ListInstanceDisksOptions {
	return &ListInstanceDisksOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListInstanceDisksOptions) SetInstanceID(instanceID string) *ListInstanceDisksOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceDisksOptions) SetHeaders(param map[string]string) *ListInstanceDisksOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupManagerActionsOptions : The ListInstanceGroupManagerActions options.
type ListInstanceGroupManagerActionsOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupManagerActionsOptions : Instantiate ListInstanceGroupManagerActionsOptions
func (*VpcV1) NewListInstanceGroupManagerActionsOptions(instanceGroupID string, instanceGroupManagerID string) *ListInstanceGroupManagerActionsOptions {
	return &ListInstanceGroupManagerActionsOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *ListInstanceGroupManagerActionsOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupManagerActionsOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *ListInstanceGroupManagerActionsOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *ListInstanceGroupManagerActionsOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListInstanceGroupManagerActionsOptions) SetStart(start string) *ListInstanceGroupManagerActionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstanceGroupManagerActionsOptions) SetLimit(limit int64) *ListInstanceGroupManagerActionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupManagerActionsOptions) SetHeaders(param map[string]string) *ListInstanceGroupManagerActionsOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupManagerPoliciesOptions : The ListInstanceGroupManagerPolicies options.
type ListInstanceGroupManagerPoliciesOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupManagerPoliciesOptions : Instantiate ListInstanceGroupManagerPoliciesOptions
func (*VpcV1) NewListInstanceGroupManagerPoliciesOptions(instanceGroupID string, instanceGroupManagerID string) *ListInstanceGroupManagerPoliciesOptions {
	return &ListInstanceGroupManagerPoliciesOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *ListInstanceGroupManagerPoliciesOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupManagerPoliciesOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *ListInstanceGroupManagerPoliciesOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *ListInstanceGroupManagerPoliciesOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListInstanceGroupManagerPoliciesOptions) SetStart(start string) *ListInstanceGroupManagerPoliciesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstanceGroupManagerPoliciesOptions) SetLimit(limit int64) *ListInstanceGroupManagerPoliciesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupManagerPoliciesOptions) SetHeaders(param map[string]string) *ListInstanceGroupManagerPoliciesOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupManagersOptions : The ListInstanceGroupManagers options.
type ListInstanceGroupManagersOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupManagersOptions : Instantiate ListInstanceGroupManagersOptions
func (*VpcV1) NewListInstanceGroupManagersOptions(instanceGroupID string) *ListInstanceGroupManagersOptions {
	return &ListInstanceGroupManagersOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *ListInstanceGroupManagersOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupManagersOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListInstanceGroupManagersOptions) SetStart(start string) *ListInstanceGroupManagersOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstanceGroupManagersOptions) SetLimit(limit int64) *ListInstanceGroupManagersOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupManagersOptions) SetHeaders(param map[string]string) *ListInstanceGroupManagersOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupMembershipsOptions : The ListInstanceGroupMemberships options.
type ListInstanceGroupMembershipsOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupMembershipsOptions : Instantiate ListInstanceGroupMembershipsOptions
func (*VpcV1) NewListInstanceGroupMembershipsOptions(instanceGroupID string) *ListInstanceGroupMembershipsOptions {
	return &ListInstanceGroupMembershipsOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *ListInstanceGroupMembershipsOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupMembershipsOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListInstanceGroupMembershipsOptions) SetStart(start string) *ListInstanceGroupMembershipsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstanceGroupMembershipsOptions) SetLimit(limit int64) *ListInstanceGroupMembershipsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupMembershipsOptions) SetHeaders(param map[string]string) *ListInstanceGroupMembershipsOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupsOptions : The ListInstanceGroups options.
type ListInstanceGroupsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupsOptions : Instantiate ListInstanceGroupsOptions
func (*VpcV1) NewListInstanceGroupsOptions() *ListInstanceGroupsOptions {
	return &ListInstanceGroupsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListInstanceGroupsOptions) SetStart(start string) *ListInstanceGroupsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstanceGroupsOptions) SetLimit(limit int64) *ListInstanceGroupsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupsOptions) SetHeaders(param map[string]string) *ListInstanceGroupsOptions {
	options.Headers = param
	return options
}

// ListInstanceNetworkInterfaceFloatingIpsOptions : The ListInstanceNetworkInterfaceFloatingIps options.
type ListInstanceNetworkInterfaceFloatingIpsOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceNetworkInterfaceFloatingIpsOptions : Instantiate ListInstanceNetworkInterfaceFloatingIpsOptions
func (*VpcV1) NewListInstanceNetworkInterfaceFloatingIpsOptions(instanceID string, networkInterfaceID string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	return &ListInstanceNetworkInterfaceFloatingIpsOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListInstanceNetworkInterfaceFloatingIpsOptions) SetInstanceID(instanceID string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *ListInstanceNetworkInterfaceFloatingIpsOptions) SetNetworkInterfaceID(networkInterfaceID string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceNetworkInterfaceFloatingIpsOptions) SetHeaders(param map[string]string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListInstanceNetworkInterfaceIpsOptions : The ListInstanceNetworkInterfaceIps options.
type ListInstanceNetworkInterfaceIpsOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceNetworkInterfaceIpsOptions : Instantiate ListInstanceNetworkInterfaceIpsOptions
func (*VpcV1) NewListInstanceNetworkInterfaceIpsOptions(instanceID string, networkInterfaceID string) *ListInstanceNetworkInterfaceIpsOptions {
	return &ListInstanceNetworkInterfaceIpsOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListInstanceNetworkInterfaceIpsOptions) SetInstanceID(instanceID string) *ListInstanceNetworkInterfaceIpsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *ListInstanceNetworkInterfaceIpsOptions) SetNetworkInterfaceID(networkInterfaceID string) *ListInstanceNetworkInterfaceIpsOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListInstanceNetworkInterfaceIpsOptions) SetStart(start string) *ListInstanceNetworkInterfaceIpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstanceNetworkInterfaceIpsOptions) SetLimit(limit int64) *ListInstanceNetworkInterfaceIpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceNetworkInterfaceIpsOptions) SetHeaders(param map[string]string) *ListInstanceNetworkInterfaceIpsOptions {
	options.Headers = param
	return options
}

// ListInstanceNetworkInterfacesOptions : The ListInstanceNetworkInterfaces options.
type ListInstanceNetworkInterfacesOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceNetworkInterfacesOptions : Instantiate ListInstanceNetworkInterfacesOptions
func (*VpcV1) NewListInstanceNetworkInterfacesOptions(instanceID string) *ListInstanceNetworkInterfacesOptions {
	return &ListInstanceNetworkInterfacesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListInstanceNetworkInterfacesOptions) SetInstanceID(instanceID string) *ListInstanceNetworkInterfacesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListInstanceNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListInstanceProfilesOptions : The ListInstanceProfiles options.
type ListInstanceProfilesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceProfilesOptions : Instantiate ListInstanceProfilesOptions
func (*VpcV1) NewListInstanceProfilesOptions() *ListInstanceProfilesOptions {
	return &ListInstanceProfilesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceProfilesOptions) SetHeaders(param map[string]string) *ListInstanceProfilesOptions {
	options.Headers = param
	return options
}

// ListInstanceTemplatesOptions : The ListInstanceTemplates options.
type ListInstanceTemplatesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceTemplatesOptions : Instantiate ListInstanceTemplatesOptions
func (*VpcV1) NewListInstanceTemplatesOptions() *ListInstanceTemplatesOptions {
	return &ListInstanceTemplatesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceTemplatesOptions) SetHeaders(param map[string]string) *ListInstanceTemplatesOptions {
	options.Headers = param
	return options
}

// ListInstanceVolumeAttachmentsOptions : The ListInstanceVolumeAttachments options.
type ListInstanceVolumeAttachmentsOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceVolumeAttachmentsOptions : Instantiate ListInstanceVolumeAttachmentsOptions
func (*VpcV1) NewListInstanceVolumeAttachmentsOptions(instanceID string) *ListInstanceVolumeAttachmentsOptions {
	return &ListInstanceVolumeAttachmentsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListInstanceVolumeAttachmentsOptions) SetInstanceID(instanceID string) *ListInstanceVolumeAttachmentsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceVolumeAttachmentsOptions) SetHeaders(param map[string]string) *ListInstanceVolumeAttachmentsOptions {
	options.Headers = param
	return options
}

// ListInstancesOptions : The ListInstances options.
type ListInstancesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources with a `vpc.id` property matching the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to instances with a `dedicated_host.id` property matching the specified identifier.
	DedicatedHostID *string `json:"dedicated_host.id,omitempty"`

	// Filters the collection to instances with a `dedicated_host.crn` property matching the specified CRN.
	DedicatedHostCRN *string `json:"dedicated_host.crn,omitempty"`

	// Filters the collection to instances with a `dedicated_host.name` property matching the exact specified name.
	DedicatedHostName *string `json:"dedicated_host.name,omitempty"`

	// Filters the collection to instances with a `placement_target.id` property matching the specified placement group
	// identifier.
	PlacementGroupID *string `json:"placement_group.id,omitempty"`

	// Filters the collection to instances with a `placement_target.crn` property matching the specified placement group
	// CRN.
	PlacementGroupCRN *string `json:"placement_group.crn,omitempty"`

	// Filters the collection to instances with a `placement_target.name` property matching the exact specified placement
	// group name.
	PlacementGroupName *string `json:"placement_group.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstancesOptions : Instantiate ListInstancesOptions
func (*VpcV1) NewListInstancesOptions() *ListInstancesOptions {
	return &ListInstancesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListInstancesOptions) SetStart(start string) *ListInstancesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListInstancesOptions) SetLimit(limit int64) *ListInstancesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListInstancesOptions) SetResourceGroupID(resourceGroupID string) *ListInstancesOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListInstancesOptions) SetName(name string) *ListInstancesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetVPCID : Allow user to set VPCID
func (_options *ListInstancesOptions) SetVPCID(vpcID string) *ListInstancesOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListInstancesOptions) SetVPCCRN(vpcCRN string) *ListInstancesOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListInstancesOptions) SetVPCName(vpcName string) *ListInstancesOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetDedicatedHostID : Allow user to set DedicatedHostID
func (_options *ListInstancesOptions) SetDedicatedHostID(dedicatedHostID string) *ListInstancesOptions {
	_options.DedicatedHostID = core.StringPtr(dedicatedHostID)
	return _options
}

// SetDedicatedHostCRN : Allow user to set DedicatedHostCRN
func (_options *ListInstancesOptions) SetDedicatedHostCRN(dedicatedHostCRN string) *ListInstancesOptions {
	_options.DedicatedHostCRN = core.StringPtr(dedicatedHostCRN)
	return _options
}

// SetDedicatedHostName : Allow user to set DedicatedHostName
func (_options *ListInstancesOptions) SetDedicatedHostName(dedicatedHostName string) *ListInstancesOptions {
	_options.DedicatedHostName = core.StringPtr(dedicatedHostName)
	return _options
}

// SetPlacementGroupID : Allow user to set PlacementGroupID
func (_options *ListInstancesOptions) SetPlacementGroupID(placementGroupID string) *ListInstancesOptions {
	_options.PlacementGroupID = core.StringPtr(placementGroupID)
	return _options
}

// SetPlacementGroupCRN : Allow user to set PlacementGroupCRN
func (_options *ListInstancesOptions) SetPlacementGroupCRN(placementGroupCRN string) *ListInstancesOptions {
	_options.PlacementGroupCRN = core.StringPtr(placementGroupCRN)
	return _options
}

// SetPlacementGroupName : Allow user to set PlacementGroupName
func (_options *ListInstancesOptions) SetPlacementGroupName(placementGroupName string) *ListInstancesOptions {
	_options.PlacementGroupName = core.StringPtr(placementGroupName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstancesOptions) SetHeaders(param map[string]string) *ListInstancesOptions {
	options.Headers = param
	return options
}

// ListIpsecPoliciesOptions : The ListIpsecPolicies options.
type ListIpsecPoliciesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIpsecPoliciesOptions : Instantiate ListIpsecPoliciesOptions
func (*VpcV1) NewListIpsecPoliciesOptions() *ListIpsecPoliciesOptions {
	return &ListIpsecPoliciesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListIpsecPoliciesOptions) SetStart(start string) *ListIpsecPoliciesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListIpsecPoliciesOptions) SetLimit(limit int64) *ListIpsecPoliciesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListIpsecPoliciesOptions) SetHeaders(param map[string]string) *ListIpsecPoliciesOptions {
	options.Headers = param
	return options
}

// ListIpsecPolicyConnectionsOptions : The ListIpsecPolicyConnections options.
type ListIpsecPolicyConnectionsOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIpsecPolicyConnectionsOptions : Instantiate ListIpsecPolicyConnectionsOptions
func (*VpcV1) NewListIpsecPolicyConnectionsOptions(id string) *ListIpsecPolicyConnectionsOptions {
	return &ListIpsecPolicyConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListIpsecPolicyConnectionsOptions) SetID(id string) *ListIpsecPolicyConnectionsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListIpsecPolicyConnectionsOptions) SetHeaders(param map[string]string) *ListIpsecPolicyConnectionsOptions {
	options.Headers = param
	return options
}

// ListKeysOptions : The ListKeys options.
type ListKeysOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListKeysOptions : Instantiate ListKeysOptions
func (*VpcV1) NewListKeysOptions() *ListKeysOptions {
	return &ListKeysOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListKeysOptions) SetStart(start string) *ListKeysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListKeysOptions) SetLimit(limit int64) *ListKeysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListKeysOptions) SetHeaders(param map[string]string) *ListKeysOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenerPoliciesOptions : The ListLoadBalancerListenerPolicies options.
type ListLoadBalancerListenerPoliciesOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenerPoliciesOptions : Instantiate ListLoadBalancerListenerPoliciesOptions
func (*VpcV1) NewListLoadBalancerListenerPoliciesOptions(loadBalancerID string, listenerID string) *ListLoadBalancerListenerPoliciesOptions {
	return &ListLoadBalancerListenerPoliciesOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *ListLoadBalancerListenerPoliciesOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenerPoliciesOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *ListLoadBalancerListenerPoliciesOptions) SetListenerID(listenerID string) *ListLoadBalancerListenerPoliciesOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenerPoliciesOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenerPoliciesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenerPolicyRulesOptions : The ListLoadBalancerListenerPolicyRules options.
type ListLoadBalancerListenerPolicyRulesOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenerPolicyRulesOptions : Instantiate ListLoadBalancerListenerPolicyRulesOptions
func (*VpcV1) NewListLoadBalancerListenerPolicyRulesOptions(loadBalancerID string, listenerID string, policyID string) *ListLoadBalancerListenerPolicyRulesOptions {
	return &ListLoadBalancerListenerPolicyRulesOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *ListLoadBalancerListenerPolicyRulesOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenerPolicyRulesOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *ListLoadBalancerListenerPolicyRulesOptions) SetListenerID(listenerID string) *ListLoadBalancerListenerPolicyRulesOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *ListLoadBalancerListenerPolicyRulesOptions) SetPolicyID(policyID string) *ListLoadBalancerListenerPolicyRulesOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenersOptions : The ListLoadBalancerListeners options.
type ListLoadBalancerListenersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenersOptions : Instantiate ListLoadBalancerListenersOptions
func (*VpcV1) NewListLoadBalancerListenersOptions(loadBalancerID string) *ListLoadBalancerListenersOptions {
	return &ListLoadBalancerListenersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *ListLoadBalancerListenersOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenersOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenersOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenersOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerPoolMembersOptions : The ListLoadBalancerPoolMembers options.
type ListLoadBalancerPoolMembersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerPoolMembersOptions : Instantiate ListLoadBalancerPoolMembersOptions
func (*VpcV1) NewListLoadBalancerPoolMembersOptions(loadBalancerID string, poolID string) *ListLoadBalancerPoolMembersOptions {
	return &ListLoadBalancerPoolMembersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *ListLoadBalancerPoolMembersOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerPoolMembersOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetPoolID : Allow user to set PoolID
func (_options *ListLoadBalancerPoolMembersOptions) SetPoolID(poolID string) *ListLoadBalancerPoolMembersOptions {
	_options.PoolID = core.StringPtr(poolID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerPoolMembersOptions) SetHeaders(param map[string]string) *ListLoadBalancerPoolMembersOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerPoolsOptions : The ListLoadBalancerPools options.
type ListLoadBalancerPoolsOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerPoolsOptions : Instantiate ListLoadBalancerPoolsOptions
func (*VpcV1) NewListLoadBalancerPoolsOptions(loadBalancerID string) *ListLoadBalancerPoolsOptions {
	return &ListLoadBalancerPoolsOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *ListLoadBalancerPoolsOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerPoolsOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerPoolsOptions) SetHeaders(param map[string]string) *ListLoadBalancerPoolsOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerProfilesOptions : The ListLoadBalancerProfiles options.
type ListLoadBalancerProfilesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerProfilesOptions : Instantiate ListLoadBalancerProfilesOptions
func (*VpcV1) NewListLoadBalancerProfilesOptions() *ListLoadBalancerProfilesOptions {
	return &ListLoadBalancerProfilesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListLoadBalancerProfilesOptions) SetStart(start string) *ListLoadBalancerProfilesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListLoadBalancerProfilesOptions) SetLimit(limit int64) *ListLoadBalancerProfilesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerProfilesOptions) SetHeaders(param map[string]string) *ListLoadBalancerProfilesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancersOptions : The ListLoadBalancers options.
type ListLoadBalancersOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancersOptions : Instantiate ListLoadBalancersOptions
func (*VpcV1) NewListLoadBalancersOptions() *ListLoadBalancersOptions {
	return &ListLoadBalancersOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListLoadBalancersOptions) SetStart(start string) *ListLoadBalancersOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListLoadBalancersOptions) SetLimit(limit int64) *ListLoadBalancersOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancersOptions) SetHeaders(param map[string]string) *ListLoadBalancersOptions {
	options.Headers = param
	return options
}

// ListNetworkACLRulesOptions : The ListNetworkACLRules options.
type ListNetworkACLRulesOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to rules with a `direction` property matching the specified value.
	Direction *string `json:"direction,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListNetworkACLRulesOptions.Direction property.
// Filters the collection to rules with a `direction` property matching the specified value.
const (
	ListNetworkACLRulesOptionsDirectionInboundConst  = "inbound"
	ListNetworkACLRulesOptionsDirectionOutboundConst = "outbound"
)

// NewListNetworkACLRulesOptions : Instantiate ListNetworkACLRulesOptions
func (*VpcV1) NewListNetworkACLRulesOptions(networkACLID string) *ListNetworkACLRulesOptions {
	return &ListNetworkACLRulesOptions{
		NetworkACLID: core.StringPtr(networkACLID),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (_options *ListNetworkACLRulesOptions) SetNetworkACLID(networkACLID string) *ListNetworkACLRulesOptions {
	_options.NetworkACLID = core.StringPtr(networkACLID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListNetworkACLRulesOptions) SetStart(start string) *ListNetworkACLRulesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListNetworkACLRulesOptions) SetLimit(limit int64) *ListNetworkACLRulesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetDirection : Allow user to set Direction
func (_options *ListNetworkACLRulesOptions) SetDirection(direction string) *ListNetworkACLRulesOptions {
	_options.Direction = core.StringPtr(direction)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkACLRulesOptions) SetHeaders(param map[string]string) *ListNetworkACLRulesOptions {
	options.Headers = param
	return options
}

// ListNetworkAclsOptions : The ListNetworkAcls options.
type ListNetworkAclsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNetworkAclsOptions : Instantiate ListNetworkAclsOptions
func (*VpcV1) NewListNetworkAclsOptions() *ListNetworkAclsOptions {
	return &ListNetworkAclsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListNetworkAclsOptions) SetStart(start string) *ListNetworkAclsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListNetworkAclsOptions) SetLimit(limit int64) *ListNetworkAclsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListNetworkAclsOptions) SetResourceGroupID(resourceGroupID string) *ListNetworkAclsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkAclsOptions) SetHeaders(param map[string]string) *ListNetworkAclsOptions {
	options.Headers = param
	return options
}

// ListOperatingSystemsOptions : The ListOperatingSystems options.
type ListOperatingSystemsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListOperatingSystemsOptions : Instantiate ListOperatingSystemsOptions
func (*VpcV1) NewListOperatingSystemsOptions() *ListOperatingSystemsOptions {
	return &ListOperatingSystemsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListOperatingSystemsOptions) SetStart(start string) *ListOperatingSystemsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListOperatingSystemsOptions) SetLimit(limit int64) *ListOperatingSystemsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListOperatingSystemsOptions) SetHeaders(param map[string]string) *ListOperatingSystemsOptions {
	options.Headers = param
	return options
}

// ListPlacementGroupsOptions : The ListPlacementGroups options.
type ListPlacementGroupsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListPlacementGroupsOptions : Instantiate ListPlacementGroupsOptions
func (*VpcV1) NewListPlacementGroupsOptions() *ListPlacementGroupsOptions {
	return &ListPlacementGroupsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListPlacementGroupsOptions) SetStart(start string) *ListPlacementGroupsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListPlacementGroupsOptions) SetLimit(limit int64) *ListPlacementGroupsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListPlacementGroupsOptions) SetHeaders(param map[string]string) *ListPlacementGroupsOptions {
	options.Headers = param
	return options
}

// ListPublicGatewaysOptions : The ListPublicGateways options.
type ListPublicGatewaysOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListPublicGatewaysOptions : Instantiate ListPublicGatewaysOptions
func (*VpcV1) NewListPublicGatewaysOptions() *ListPublicGatewaysOptions {
	return &ListPublicGatewaysOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListPublicGatewaysOptions) SetStart(start string) *ListPublicGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListPublicGatewaysOptions) SetLimit(limit int64) *ListPublicGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListPublicGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListPublicGatewaysOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListPublicGatewaysOptions) SetHeaders(param map[string]string) *ListPublicGatewaysOptions {
	options.Headers = param
	return options
}

// ListRegionZonesOptions : The ListRegionZones options.
type ListRegionZonesOptions struct {
	// The region name.
	RegionName *string `json:"region_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListRegionZonesOptions : Instantiate ListRegionZonesOptions
func (*VpcV1) NewListRegionZonesOptions(regionName string) *ListRegionZonesOptions {
	return &ListRegionZonesOptions{
		RegionName: core.StringPtr(regionName),
	}
}

// SetRegionName : Allow user to set RegionName
func (_options *ListRegionZonesOptions) SetRegionName(regionName string) *ListRegionZonesOptions {
	_options.RegionName = core.StringPtr(regionName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListRegionZonesOptions) SetHeaders(param map[string]string) *ListRegionZonesOptions {
	options.Headers = param
	return options
}

// ListRegionsOptions : The ListRegions options.
type ListRegionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListRegionsOptions : Instantiate ListRegionsOptions
func (*VpcV1) NewListRegionsOptions() *ListRegionsOptions {
	return &ListRegionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListRegionsOptions) SetHeaders(param map[string]string) *ListRegionsOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupRulesOptions : The ListSecurityGroupRules options.
type ListSecurityGroupRulesOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupRulesOptions : Instantiate ListSecurityGroupRulesOptions
func (*VpcV1) NewListSecurityGroupRulesOptions(securityGroupID string) *ListSecurityGroupRulesOptions {
	return &ListSecurityGroupRulesOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *ListSecurityGroupRulesOptions) SetSecurityGroupID(securityGroupID string) *ListSecurityGroupRulesOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupRulesOptions) SetHeaders(param map[string]string) *ListSecurityGroupRulesOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupTargetsOptions : The ListSecurityGroupTargets options.
type ListSecurityGroupTargetsOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupTargetsOptions : Instantiate ListSecurityGroupTargetsOptions
func (*VpcV1) NewListSecurityGroupTargetsOptions(securityGroupID string) *ListSecurityGroupTargetsOptions {
	return &ListSecurityGroupTargetsOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *ListSecurityGroupTargetsOptions) SetSecurityGroupID(securityGroupID string) *ListSecurityGroupTargetsOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListSecurityGroupTargetsOptions) SetStart(start string) *ListSecurityGroupTargetsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSecurityGroupTargetsOptions) SetLimit(limit int64) *ListSecurityGroupTargetsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupTargetsOptions) SetHeaders(param map[string]string) *ListSecurityGroupTargetsOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupsOptions : The ListSecurityGroups options.
type ListSecurityGroupsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `vpc.id` property matching the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupsOptions : Instantiate ListSecurityGroupsOptions
func (*VpcV1) NewListSecurityGroupsOptions() *ListSecurityGroupsOptions {
	return &ListSecurityGroupsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListSecurityGroupsOptions) SetStart(start string) *ListSecurityGroupsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSecurityGroupsOptions) SetLimit(limit int64) *ListSecurityGroupsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListSecurityGroupsOptions) SetResourceGroupID(resourceGroupID string) *ListSecurityGroupsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetVPCID : Allow user to set VPCID
func (_options *ListSecurityGroupsOptions) SetVPCID(vpcID string) *ListSecurityGroupsOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListSecurityGroupsOptions) SetVPCCRN(vpcCRN string) *ListSecurityGroupsOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListSecurityGroupsOptions) SetVPCName(vpcName string) *ListSecurityGroupsOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupsOptions) SetHeaders(param map[string]string) *ListSecurityGroupsOptions {
	options.Headers = param
	return options
}

// ListShareMountTargetsOptions : The ListShareMountTargets options.
type ListShareMountTargetsOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListShareMountTargetsOptions : Instantiate ListShareMountTargetsOptions
func (*VpcV1) NewListShareMountTargetsOptions(shareID string) *ListShareMountTargetsOptions {
	return &ListShareMountTargetsOptions{
		ShareID: core.StringPtr(shareID),
	}
}

// SetShareID : Allow user to set ShareID
func (_options *ListShareMountTargetsOptions) SetShareID(shareID string) *ListShareMountTargetsOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListShareMountTargetsOptions) SetName(name string) *ListShareMountTargetsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListShareMountTargetsOptions) SetStart(start string) *ListShareMountTargetsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListShareMountTargetsOptions) SetLimit(limit int64) *ListShareMountTargetsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListShareMountTargetsOptions) SetHeaders(param map[string]string) *ListShareMountTargetsOptions {
	options.Headers = param
	return options
}

// ListShareProfilesOptions : The ListShareProfiles options.
type ListShareProfilesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListShareProfilesOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListShareProfilesOptionsSortCreatedAtConst = "created_at"
	ListShareProfilesOptionsSortNameConst      = "name"
)

// NewListShareProfilesOptions : Instantiate ListShareProfilesOptions
func (*VpcV1) NewListShareProfilesOptions() *ListShareProfilesOptions {
	return &ListShareProfilesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListShareProfilesOptions) SetStart(start string) *ListShareProfilesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListShareProfilesOptions) SetLimit(limit int64) *ListShareProfilesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListShareProfilesOptions) SetSort(sort string) *ListShareProfilesOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListShareProfilesOptions) SetHeaders(param map[string]string) *ListShareProfilesOptions {
	options.Headers = param
	return options
}

// ListSharesOptions : The ListShares options.
type ListSharesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Filters the collection to file shares with a `replication_role` property matching the specified value.
	ReplicationRole *string `json:"replication_role,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListSharesOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListSharesOptionsSortCreatedAtConst = "created_at"
	ListSharesOptionsSortNameConst      = "name"
)

// Constants associated with the ListSharesOptions.ReplicationRole property.
// Filters the collection to file shares with a `replication_role` property matching the specified value.
const (
	ListSharesOptionsReplicationRoleNoneConst    = "none"
	ListSharesOptionsReplicationRoleReplicaConst = "replica"
	ListSharesOptionsReplicationRoleSourceConst  = "source"
)

// NewListSharesOptions : Instantiate ListSharesOptions
func (*VpcV1) NewListSharesOptions() *ListSharesOptions {
	return &ListSharesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListSharesOptions) SetStart(start string) *ListSharesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSharesOptions) SetLimit(limit int64) *ListSharesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListSharesOptions) SetResourceGroupID(resourceGroupID string) *ListSharesOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListSharesOptions) SetName(name string) *ListSharesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListSharesOptions) SetSort(sort string) *ListSharesOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetReplicationRole : Allow user to set ReplicationRole
func (_options *ListSharesOptions) SetReplicationRole(replicationRole string) *ListSharesOptions {
	_options.ReplicationRole = core.StringPtr(replicationRole)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSharesOptions) SetHeaders(param map[string]string) *ListSharesOptions {
	options.Headers = param
	return options
}

// ListSnapshotClonesOptions : The ListSnapshotClones options.
type ListSnapshotClonesOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSnapshotClonesOptions : Instantiate ListSnapshotClonesOptions
func (*VpcV1) NewListSnapshotClonesOptions(id string) *ListSnapshotClonesOptions {
	return &ListSnapshotClonesOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListSnapshotClonesOptions) SetID(id string) *ListSnapshotClonesOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSnapshotClonesOptions) SetHeaders(param map[string]string) *ListSnapshotClonesOptions {
	options.Headers = param
	return options
}

// ListSnapshotsOptions : The ListSnapshots options.
type ListSnapshotsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with an item in the `tags` property matching the exact specified tag.
	Tag *string `json:"tag,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources with a `source_volume.id` property matching the specified identifier.
	SourceVolumeID *string `json:"source_volume.id,omitempty"`

	// Filters the collection to resources with a `source_volume.crn` property matching the specified CRN.
	SourceVolumeCRN *string `json:"source_volume.crn,omitempty"`

	// Filters the collection to resources with a `source_image.id` property matching the specified identifier.
	//
	// This parameter also supports the values `null` and `not:null` which filter the collection to resources which have no
	// source image or any existent source image, respectively.
	SourceImageID *string `json:"source_image.id,omitempty"`

	// Filters the collection to resources with a `source_image.crn` property matching the specified CRN.
	//
	// This parameter also supports the values `null` and `not:null` which filter the collection to resources which have no
	// source image or any existent source image, respectively.
	SourceImageCRN *string `json:"source_image.crn,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Filters the collection to backup policy jobs with a `backup_policy_plan.id` property matching the specified
	// identifier.
	BackupPolicyPlanID *string `json:"backup_policy_plan.id,omitempty"`

	// Filters the collection to snapshots with an item in the `copies` property with an `id` property matching the
	// specified identifier.
	CopiesID *string `json:"copies[].id,omitempty"`

	// Filters the collection to snapshots with an item in the `copies` property with a `name` property matching the exact
	// specified name.
	CopiesName *string `json:"copies[].name,omitempty"`

	// Filters the collection to snapshots with an item in the `copies` property with an `id` property matching the
	// specified CRN.
	CopiesCRN *string `json:"copies[].crn,omitempty"`

	// Filters the collection to snapshots with an item in the `copies` property with a
	// `remote.region.name` property matching the exact specified name.
	CopiesRemoteRegionName *string `json:"copies[].remote.region.name,omitempty"`

	// Filters the collection to resources with a `source_snapshot.id` property matching the specified identifier.
	SourceSnapshotID *string `json:"source_snapshot.id,omitempty"`

	// Filters the collection to resources with a `source_snapshot.remote.region.name` property matching the exact
	// specified name.
	SourceSnapshotRemoteRegionName *string `json:"source_snapshot.remote.region.name,omitempty"`

	// Filters the collection to resources with a `source_volume.remote.region.name` property matching the exact specified
	// name.
	SourceVolumeRemoteRegionName *string `json:"source_volume.remote.region.name,omitempty"`

	// Filters the collection to resources with a `source_image.remote.region.name` property matching the exact specified
	// name.
	SourceImageRemoteRegionName *string `json:"source_image.remote.region.name,omitempty"`

	// Filters the collection to snapshots with an item in the `clones` property with a `zone.name` property matching the
	// exact specified name.
	ClonesZoneName *string `json:"clones[].zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListSnapshotsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListSnapshotsOptionsSortCreatedAtConst = "created_at"
	ListSnapshotsOptionsSortNameConst      = "name"
)

// NewListSnapshotsOptions : Instantiate ListSnapshotsOptions
func (*VpcV1) NewListSnapshotsOptions() *ListSnapshotsOptions {
	return &ListSnapshotsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListSnapshotsOptions) SetStart(start string) *ListSnapshotsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSnapshotsOptions) SetLimit(limit int64) *ListSnapshotsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetTag : Allow user to set Tag
func (_options *ListSnapshotsOptions) SetTag(tag string) *ListSnapshotsOptions {
	_options.Tag = core.StringPtr(tag)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListSnapshotsOptions) SetResourceGroupID(resourceGroupID string) *ListSnapshotsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListSnapshotsOptions) SetName(name string) *ListSnapshotsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSourceVolumeID : Allow user to set SourceVolumeID
func (_options *ListSnapshotsOptions) SetSourceVolumeID(sourceVolumeID string) *ListSnapshotsOptions {
	_options.SourceVolumeID = core.StringPtr(sourceVolumeID)
	return _options
}

// SetSourceVolumeCRN : Allow user to set SourceVolumeCRN
func (_options *ListSnapshotsOptions) SetSourceVolumeCRN(sourceVolumeCRN string) *ListSnapshotsOptions {
	_options.SourceVolumeCRN = core.StringPtr(sourceVolumeCRN)
	return _options
}

// SetSourceImageID : Allow user to set SourceImageID
func (_options *ListSnapshotsOptions) SetSourceImageID(sourceImageID string) *ListSnapshotsOptions {
	_options.SourceImageID = core.StringPtr(sourceImageID)
	return _options
}

// SetSourceImageCRN : Allow user to set SourceImageCRN
func (_options *ListSnapshotsOptions) SetSourceImageCRN(sourceImageCRN string) *ListSnapshotsOptions {
	_options.SourceImageCRN = core.StringPtr(sourceImageCRN)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListSnapshotsOptions) SetSort(sort string) *ListSnapshotsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetBackupPolicyPlanID : Allow user to set BackupPolicyPlanID
func (_options *ListSnapshotsOptions) SetBackupPolicyPlanID(backupPolicyPlanID string) *ListSnapshotsOptions {
	_options.BackupPolicyPlanID = core.StringPtr(backupPolicyPlanID)
	return _options
}

// SetCopiesID : Allow user to set CopiesID
func (_options *ListSnapshotsOptions) SetCopiesID(copiesID string) *ListSnapshotsOptions {
	_options.CopiesID = core.StringPtr(copiesID)
	return _options
}

// SetCopiesName : Allow user to set CopiesName
func (_options *ListSnapshotsOptions) SetCopiesName(copiesName string) *ListSnapshotsOptions {
	_options.CopiesName = core.StringPtr(copiesName)
	return _options
}

// SetCopiesCRN : Allow user to set CopiesCRN
func (_options *ListSnapshotsOptions) SetCopiesCRN(copiesCRN string) *ListSnapshotsOptions {
	_options.CopiesCRN = core.StringPtr(copiesCRN)
	return _options
}

// SetCopiesRemoteRegionName : Allow user to set CopiesRemoteRegionName
func (_options *ListSnapshotsOptions) SetCopiesRemoteRegionName(copiesRemoteRegionName string) *ListSnapshotsOptions {
	_options.CopiesRemoteRegionName = core.StringPtr(copiesRemoteRegionName)
	return _options
}

// SetSourceSnapshotID : Allow user to set SourceSnapshotID
func (_options *ListSnapshotsOptions) SetSourceSnapshotID(sourceSnapshotID string) *ListSnapshotsOptions {
	_options.SourceSnapshotID = core.StringPtr(sourceSnapshotID)
	return _options
}

// SetSourceSnapshotRemoteRegionName : Allow user to set SourceSnapshotRemoteRegionName
func (_options *ListSnapshotsOptions) SetSourceSnapshotRemoteRegionName(sourceSnapshotRemoteRegionName string) *ListSnapshotsOptions {
	_options.SourceSnapshotRemoteRegionName = core.StringPtr(sourceSnapshotRemoteRegionName)
	return _options
}

// SetSourceVolumeRemoteRegionName : Allow user to set SourceVolumeRemoteRegionName
func (_options *ListSnapshotsOptions) SetSourceVolumeRemoteRegionName(sourceVolumeRemoteRegionName string) *ListSnapshotsOptions {
	_options.SourceVolumeRemoteRegionName = core.StringPtr(sourceVolumeRemoteRegionName)
	return _options
}

// SetSourceImageRemoteRegionName : Allow user to set SourceImageRemoteRegionName
func (_options *ListSnapshotsOptions) SetSourceImageRemoteRegionName(sourceImageRemoteRegionName string) *ListSnapshotsOptions {
	_options.SourceImageRemoteRegionName = core.StringPtr(sourceImageRemoteRegionName)
	return _options
}

// SetClonesZoneName : Allow user to set ClonesZoneName
func (_options *ListSnapshotsOptions) SetClonesZoneName(clonesZoneName string) *ListSnapshotsOptions {
	_options.ClonesZoneName = core.StringPtr(clonesZoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSnapshotsOptions) SetHeaders(param map[string]string) *ListSnapshotsOptions {
	options.Headers = param
	return options
}

// ListSubnetReservedIpsOptions : The ListSubnetReservedIps options.
type ListSubnetReservedIpsOptions struct {
	// The subnet identifier.
	SubnetID *string `json:"subnet_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListSubnetReservedIpsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListSubnetReservedIpsOptionsSortAddressConst   = "address"
	ListSubnetReservedIpsOptionsSortCreatedAtConst = "created_at"
	ListSubnetReservedIpsOptionsSortNameConst      = "name"
)

// NewListSubnetReservedIpsOptions : Instantiate ListSubnetReservedIpsOptions
func (*VpcV1) NewListSubnetReservedIpsOptions(subnetID string) *ListSubnetReservedIpsOptions {
	return &ListSubnetReservedIpsOptions{
		SubnetID: core.StringPtr(subnetID),
	}
}

// SetSubnetID : Allow user to set SubnetID
func (_options *ListSubnetReservedIpsOptions) SetSubnetID(subnetID string) *ListSubnetReservedIpsOptions {
	_options.SubnetID = core.StringPtr(subnetID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListSubnetReservedIpsOptions) SetStart(start string) *ListSubnetReservedIpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubnetReservedIpsOptions) SetLimit(limit int64) *ListSubnetReservedIpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListSubnetReservedIpsOptions) SetSort(sort string) *ListSubnetReservedIpsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubnetReservedIpsOptions) SetHeaders(param map[string]string) *ListSubnetReservedIpsOptions {
	options.Headers = param
	return options
}

// ListSubnetsOptions : The ListSubnets options.
type ListSubnetsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with a `zone.name` property matching the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Filters the collection to resources with a `vpc.id` property matching the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to subnets with a `routing_table.id` property matching the specified identifier.
	RoutingTableID *string `json:"routing_table.id,omitempty"`

	// Filters the collection to subnets with a `routing_table.name` property matching the exact specified name.
	RoutingTableName *string `json:"routing_table.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubnetsOptions : Instantiate ListSubnetsOptions
func (*VpcV1) NewListSubnetsOptions() *ListSubnetsOptions {
	return &ListSubnetsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListSubnetsOptions) SetStart(start string) *ListSubnetsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubnetsOptions) SetLimit(limit int64) *ListSubnetsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListSubnetsOptions) SetResourceGroupID(resourceGroupID string) *ListSubnetsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *ListSubnetsOptions) SetZoneName(zoneName string) *ListSubnetsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetVPCID : Allow user to set VPCID
func (_options *ListSubnetsOptions) SetVPCID(vpcID string) *ListSubnetsOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListSubnetsOptions) SetVPCCRN(vpcCRN string) *ListSubnetsOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListSubnetsOptions) SetVPCName(vpcName string) *ListSubnetsOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (_options *ListSubnetsOptions) SetRoutingTableID(routingTableID string) *ListSubnetsOptions {
	_options.RoutingTableID = core.StringPtr(routingTableID)
	return _options
}

// SetRoutingTableName : Allow user to set RoutingTableName
func (_options *ListSubnetsOptions) SetRoutingTableName(routingTableName string) *ListSubnetsOptions {
	_options.RoutingTableName = core.StringPtr(routingTableName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubnetsOptions) SetHeaders(param map[string]string) *ListSubnetsOptions {
	options.Headers = param
	return options
}

// ListVirtualNetworkInterfacesOptions : The ListVirtualNetworkInterfaces options.
type ListVirtualNetworkInterfacesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVirtualNetworkInterfacesOptions : Instantiate ListVirtualNetworkInterfacesOptions
func (*VpcV1) NewListVirtualNetworkInterfacesOptions() *ListVirtualNetworkInterfacesOptions {
	return &ListVirtualNetworkInterfacesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListVirtualNetworkInterfacesOptions) SetStart(start string) *ListVirtualNetworkInterfacesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVirtualNetworkInterfacesOptions) SetLimit(limit int64) *ListVirtualNetworkInterfacesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListVirtualNetworkInterfacesOptions) SetResourceGroupID(resourceGroupID string) *ListVirtualNetworkInterfacesOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVirtualNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListVirtualNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListVolumeProfilesOptions : The ListVolumeProfiles options.
type ListVolumeProfilesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVolumeProfilesOptions : Instantiate ListVolumeProfilesOptions
func (*VpcV1) NewListVolumeProfilesOptions() *ListVolumeProfilesOptions {
	return &ListVolumeProfilesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListVolumeProfilesOptions) SetStart(start string) *ListVolumeProfilesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVolumeProfilesOptions) SetLimit(limit int64) *ListVolumeProfilesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumeProfilesOptions) SetHeaders(param map[string]string) *ListVolumeProfilesOptions {
	options.Headers = param
	return options
}

// ListVolumesOptions : The ListVolumes options.
type ListVolumesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to volumes with an `attachment_state` property matching the specified value.
	AttachmentState *string `json:"attachment_state,omitempty"`

	// Filters the collection to resources with an `encryption` property matching the specified value.
	Encryption *string `json:"encryption,omitempty"`

	// Filters the collection to resources with an `operating_system.family` property matching the specified operating
	// system family.
	//
	// This parameter also supports the values `null` and `not:null` which filter the collection to resources which have no
	// operating system or any operating system, respectively.
	OperatingSystemFamily *string `json:"operating_system.family,omitempty"`

	// Filters the collection to resources with an `operating_system.architecture` property matching the specified
	// operating system architecture.
	//
	// This parameter also supports the values `null` and `not:null` which filter the collection to resources which have no
	// operating system or any operating system, respectively.
	OperatingSystemArchitecture *string `json:"operating_system.architecture,omitempty"`

	// Filters the collection to resources with a `zone.name` property matching the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVolumesOptions.AttachmentState property.
// Filters the collection to volumes with an `attachment_state` property matching the specified value.
const (
	ListVolumesOptionsAttachmentStateAttachedConst   = "attached"
	ListVolumesOptionsAttachmentStateUnattachedConst = "unattached"
	ListVolumesOptionsAttachmentStateUnusableConst   = "unusable"
)

// Constants associated with the ListVolumesOptions.Encryption property.
// Filters the collection to resources with an `encryption` property matching the specified value.
const (
	ListVolumesOptionsEncryptionProviderManagedConst = "provider_managed"
	ListVolumesOptionsEncryptionUserManagedConst     = "user_managed"
)

// NewListVolumesOptions : Instantiate ListVolumesOptions
func (*VpcV1) NewListVolumesOptions() *ListVolumesOptions {
	return &ListVolumesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListVolumesOptions) SetStart(start string) *ListVolumesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVolumesOptions) SetLimit(limit int64) *ListVolumesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListVolumesOptions) SetName(name string) *ListVolumesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetAttachmentState : Allow user to set AttachmentState
func (_options *ListVolumesOptions) SetAttachmentState(attachmentState string) *ListVolumesOptions {
	_options.AttachmentState = core.StringPtr(attachmentState)
	return _options
}

// SetEncryption : Allow user to set Encryption
func (_options *ListVolumesOptions) SetEncryption(encryption string) *ListVolumesOptions {
	_options.Encryption = core.StringPtr(encryption)
	return _options
}

// SetOperatingSystemFamily : Allow user to set OperatingSystemFamily
func (_options *ListVolumesOptions) SetOperatingSystemFamily(operatingSystemFamily string) *ListVolumesOptions {
	_options.OperatingSystemFamily = core.StringPtr(operatingSystemFamily)
	return _options
}

// SetOperatingSystemArchitecture : Allow user to set OperatingSystemArchitecture
func (_options *ListVolumesOptions) SetOperatingSystemArchitecture(operatingSystemArchitecture string) *ListVolumesOptions {
	_options.OperatingSystemArchitecture = core.StringPtr(operatingSystemArchitecture)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *ListVolumesOptions) SetZoneName(zoneName string) *ListVolumesOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumesOptions) SetHeaders(param map[string]string) *ListVolumesOptions {
	options.Headers = param
	return options
}

// ListVPCAddressPrefixesOptions : The ListVPCAddressPrefixes options.
type ListVPCAddressPrefixesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCAddressPrefixesOptions : Instantiate ListVPCAddressPrefixesOptions
func (*VpcV1) NewListVPCAddressPrefixesOptions(vpcID string) *ListVPCAddressPrefixesOptions {
	return &ListVPCAddressPrefixesOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *ListVPCAddressPrefixesOptions) SetVPCID(vpcID string) *ListVPCAddressPrefixesOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPCAddressPrefixesOptions) SetStart(start string) *ListVPCAddressPrefixesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPCAddressPrefixesOptions) SetLimit(limit int64) *ListVPCAddressPrefixesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCAddressPrefixesOptions) SetHeaders(param map[string]string) *ListVPCAddressPrefixesOptions {
	options.Headers = param
	return options
}

// ListVPCDnsResolutionBindingsOptions : The ListVPCDnsResolutionBindings options.
type ListVPCDnsResolutionBindingsOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources with a `vpc.crn` property matching the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources with a `vpc.name` property matching the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to resources with a `vpc.remote.account.id` property matching the specified account
	// identifier.
	AccountID *string `json:"account.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPCDnsResolutionBindingsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListVPCDnsResolutionBindingsOptionsSortCreatedAtConst = "created_at"
	ListVPCDnsResolutionBindingsOptionsSortNameConst      = "name"
)

// NewListVPCDnsResolutionBindingsOptions : Instantiate ListVPCDnsResolutionBindingsOptions
func (*VpcV1) NewListVPCDnsResolutionBindingsOptions(vpcID string) *ListVPCDnsResolutionBindingsOptions {
	return &ListVPCDnsResolutionBindingsOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *ListVPCDnsResolutionBindingsOptions) SetVPCID(vpcID string) *ListVPCDnsResolutionBindingsOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListVPCDnsResolutionBindingsOptions) SetSort(sort string) *ListVPCDnsResolutionBindingsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPCDnsResolutionBindingsOptions) SetStart(start string) *ListVPCDnsResolutionBindingsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPCDnsResolutionBindingsOptions) SetLimit(limit int64) *ListVPCDnsResolutionBindingsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListVPCDnsResolutionBindingsOptions) SetName(name string) *ListVPCDnsResolutionBindingsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetVPCCRN : Allow user to set VPCCRN
func (_options *ListVPCDnsResolutionBindingsOptions) SetVPCCRN(vpcCRN string) *ListVPCDnsResolutionBindingsOptions {
	_options.VPCCRN = core.StringPtr(vpcCRN)
	return _options
}

// SetVPCName : Allow user to set VPCName
func (_options *ListVPCDnsResolutionBindingsOptions) SetVPCName(vpcName string) *ListVPCDnsResolutionBindingsOptions {
	_options.VPCName = core.StringPtr(vpcName)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *ListVPCDnsResolutionBindingsOptions) SetAccountID(accountID string) *ListVPCDnsResolutionBindingsOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCDnsResolutionBindingsOptions) SetHeaders(param map[string]string) *ListVPCDnsResolutionBindingsOptions {
	options.Headers = param
	return options
}

// ListVPCRoutesOptions : The ListVPCRoutes options.
type ListVPCRoutesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// Filters the collection to resources with a `zone.name` property matching the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCRoutesOptions : Instantiate ListVPCRoutesOptions
func (*VpcV1) NewListVPCRoutesOptions(vpcID string) *ListVPCRoutesOptions {
	return &ListVPCRoutesOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *ListVPCRoutesOptions) SetVPCID(vpcID string) *ListVPCRoutesOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *ListVPCRoutesOptions) SetZoneName(zoneName string) *ListVPCRoutesOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPCRoutesOptions) SetStart(start string) *ListVPCRoutesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPCRoutesOptions) SetLimit(limit int64) *ListVPCRoutesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCRoutesOptions) SetHeaders(param map[string]string) *ListVPCRoutesOptions {
	options.Headers = param
	return options
}

// ListVPCRoutingTableRoutesOptions : The ListVPCRoutingTableRoutes options.
type ListVPCRoutingTableRoutesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCRoutingTableRoutesOptions : Instantiate ListVPCRoutingTableRoutesOptions
func (*VpcV1) NewListVPCRoutingTableRoutesOptions(vpcID string, routingTableID string) *ListVPCRoutingTableRoutesOptions {
	return &ListVPCRoutingTableRoutesOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *ListVPCRoutingTableRoutesOptions) SetVPCID(vpcID string) *ListVPCRoutingTableRoutesOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (_options *ListVPCRoutingTableRoutesOptions) SetRoutingTableID(routingTableID string) *ListVPCRoutingTableRoutesOptions {
	_options.RoutingTableID = core.StringPtr(routingTableID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPCRoutingTableRoutesOptions) SetStart(start string) *ListVPCRoutingTableRoutesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPCRoutingTableRoutesOptions) SetLimit(limit int64) *ListVPCRoutingTableRoutesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCRoutingTableRoutesOptions) SetHeaders(param map[string]string) *ListVPCRoutingTableRoutesOptions {
	options.Headers = param
	return options
}

// ListVPCRoutingTablesOptions : The ListVPCRoutingTables options.
type ListVPCRoutingTablesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to routing tables with an `is_default` property matching the specified value.
	IsDefault *bool `json:"is_default,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCRoutingTablesOptions : Instantiate ListVPCRoutingTablesOptions
func (*VpcV1) NewListVPCRoutingTablesOptions(vpcID string) *ListVPCRoutingTablesOptions {
	return &ListVPCRoutingTablesOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *ListVPCRoutingTablesOptions) SetVPCID(vpcID string) *ListVPCRoutingTablesOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPCRoutingTablesOptions) SetStart(start string) *ListVPCRoutingTablesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPCRoutingTablesOptions) SetLimit(limit int64) *ListVPCRoutingTablesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetIsDefault : Allow user to set IsDefault
func (_options *ListVPCRoutingTablesOptions) SetIsDefault(isDefault bool) *ListVPCRoutingTablesOptions {
	_options.IsDefault = core.BoolPtr(isDefault)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCRoutingTablesOptions) SetHeaders(param map[string]string) *ListVPCRoutingTablesOptions {
	options.Headers = param
	return options
}

// ListVpcsOptions : The ListVpcs options.
type ListVpcsOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to VPCs with a `classic_access` property matching the specified value.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpcsOptions : Instantiate ListVpcsOptions
func (*VpcV1) NewListVpcsOptions() *ListVpcsOptions {
	return &ListVpcsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListVpcsOptions) SetStart(start string) *ListVpcsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVpcsOptions) SetLimit(limit int64) *ListVpcsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListVpcsOptions) SetResourceGroupID(resourceGroupID string) *ListVpcsOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetClassicAccess : Allow user to set ClassicAccess
func (_options *ListVpcsOptions) SetClassicAccess(classicAccess bool) *ListVpcsOptions {
	_options.ClassicAccess = core.BoolPtr(classicAccess)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpcsOptions) SetHeaders(param map[string]string) *ListVpcsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewayConnectionLocalCIDRsOptions : The ListVPNGatewayConnectionLocalCIDRs options.
type ListVPNGatewayConnectionLocalCIDRsOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPNGatewayConnectionLocalCIDRsOptions : Instantiate ListVPNGatewayConnectionLocalCIDRsOptions
func (*VpcV1) NewListVPNGatewayConnectionLocalCIDRsOptions(vpnGatewayID string, id string) *ListVPNGatewayConnectionLocalCIDRsOptions {
	return &ListVPNGatewayConnectionLocalCIDRsOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *ListVPNGatewayConnectionLocalCIDRsOptions) SetVPNGatewayID(vpnGatewayID string) *ListVPNGatewayConnectionLocalCIDRsOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListVPNGatewayConnectionLocalCIDRsOptions) SetID(id string) *ListVPNGatewayConnectionLocalCIDRsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewayConnectionLocalCIDRsOptions) SetHeaders(param map[string]string) *ListVPNGatewayConnectionLocalCIDRsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewayConnectionPeerCIDRsOptions : The ListVPNGatewayConnectionPeerCIDRs options.
type ListVPNGatewayConnectionPeerCIDRsOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPNGatewayConnectionPeerCIDRsOptions : Instantiate ListVPNGatewayConnectionPeerCIDRsOptions
func (*VpcV1) NewListVPNGatewayConnectionPeerCIDRsOptions(vpnGatewayID string, id string) *ListVPNGatewayConnectionPeerCIDRsOptions {
	return &ListVPNGatewayConnectionPeerCIDRsOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *ListVPNGatewayConnectionPeerCIDRsOptions) SetVPNGatewayID(vpnGatewayID string) *ListVPNGatewayConnectionPeerCIDRsOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListVPNGatewayConnectionPeerCIDRsOptions) SetID(id string) *ListVPNGatewayConnectionPeerCIDRsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewayConnectionPeerCIDRsOptions) SetHeaders(param map[string]string) *ListVPNGatewayConnectionPeerCIDRsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewayConnectionsOptions : The ListVPNGatewayConnections options.
type ListVPNGatewayConnectionsOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// Filters the collection to VPN gateway connections with a `status` property matching the specified value.
	Status *string `json:"status,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPNGatewayConnectionsOptions.Status property.
// Filters the collection to VPN gateway connections with a `status` property matching the specified value.
const (
	ListVPNGatewayConnectionsOptionsStatusDownConst = "down"
	ListVPNGatewayConnectionsOptionsStatusUpConst   = "up"
)

// NewListVPNGatewayConnectionsOptions : Instantiate ListVPNGatewayConnectionsOptions
func (*VpcV1) NewListVPNGatewayConnectionsOptions(vpnGatewayID string) *ListVPNGatewayConnectionsOptions {
	return &ListVPNGatewayConnectionsOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *ListVPNGatewayConnectionsOptions) SetVPNGatewayID(vpnGatewayID string) *ListVPNGatewayConnectionsOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListVPNGatewayConnectionsOptions) SetStatus(status string) *ListVPNGatewayConnectionsOptions {
	_options.Status = core.StringPtr(status)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewayConnectionsOptions) SetHeaders(param map[string]string) *ListVPNGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewaysOptions : The ListVPNGateways options.
type ListVPNGatewaysOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Filters the collection to VPN gateways with a `mode` property matching the specified value.
	Mode *string `json:"mode,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPNGatewaysOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListVPNGatewaysOptionsSortCreatedAtConst = "created_at"
	ListVPNGatewaysOptionsSortNameConst      = "name"
)

// Constants associated with the ListVPNGatewaysOptions.Mode property.
// Filters the collection to VPN gateways with a `mode` property matching the specified value.
const (
	ListVPNGatewaysOptionsModePolicyConst = "policy"
	ListVPNGatewaysOptionsModeRouteConst  = "route"
)

// NewListVPNGatewaysOptions : Instantiate ListVPNGatewaysOptions
func (*VpcV1) NewListVPNGatewaysOptions() *ListVPNGatewaysOptions {
	return &ListVPNGatewaysOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListVPNGatewaysOptions) SetStart(start string) *ListVPNGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPNGatewaysOptions) SetLimit(limit int64) *ListVPNGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListVPNGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListVPNGatewaysOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListVPNGatewaysOptions) SetSort(sort string) *ListVPNGatewaysOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetMode : Allow user to set Mode
func (_options *ListVPNGatewaysOptions) SetMode(mode string) *ListVPNGatewaysOptions {
	_options.Mode = core.StringPtr(mode)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewaysOptions) SetHeaders(param map[string]string) *ListVPNGatewaysOptions {
	options.Headers = param
	return options
}

// ListVPNServerClientsOptions : The ListVPNServerClients options.
type ListVPNServerClientsOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPNServerClientsOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order.
const (
	ListVPNServerClientsOptionsSortCreatedAtConst = "created_at"
)

// NewListVPNServerClientsOptions : Instantiate ListVPNServerClientsOptions
func (*VpcV1) NewListVPNServerClientsOptions(vpnServerID string) *ListVPNServerClientsOptions {
	return &ListVPNServerClientsOptions{
		VPNServerID: core.StringPtr(vpnServerID),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *ListVPNServerClientsOptions) SetVPNServerID(vpnServerID string) *ListVPNServerClientsOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPNServerClientsOptions) SetStart(start string) *ListVPNServerClientsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPNServerClientsOptions) SetLimit(limit int64) *ListVPNServerClientsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListVPNServerClientsOptions) SetSort(sort string) *ListVPNServerClientsOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNServerClientsOptions) SetHeaders(param map[string]string) *ListVPNServerClientsOptions {
	options.Headers = param
	return options
}

// ListVPNServerRoutesOptions : The ListVPNServerRoutes options.
type ListVPNServerRoutesOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPNServerRoutesOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListVPNServerRoutesOptionsSortCreatedAtConst = "created_at"
	ListVPNServerRoutesOptionsSortNameConst      = "name"
)

// NewListVPNServerRoutesOptions : Instantiate ListVPNServerRoutesOptions
func (*VpcV1) NewListVPNServerRoutesOptions(vpnServerID string) *ListVPNServerRoutesOptions {
	return &ListVPNServerRoutesOptions{
		VPNServerID: core.StringPtr(vpnServerID),
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *ListVPNServerRoutesOptions) SetVPNServerID(vpnServerID string) *ListVPNServerRoutesOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPNServerRoutesOptions) SetStart(start string) *ListVPNServerRoutesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPNServerRoutesOptions) SetLimit(limit int64) *ListVPNServerRoutesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListVPNServerRoutesOptions) SetSort(sort string) *ListVPNServerRoutesOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNServerRoutesOptions) SetHeaders(param map[string]string) *ListVPNServerRoutesOptions {
	options.Headers = param
	return options
}

// ListVPNServersOptions : The ListVPNServers options.
type ListVPNServersOptions struct {
	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
	// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
	// in descending order, and the value `name` sorts it by the `name` property in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPNServersOptions.Sort property.
// Sorts the returned collection by the specified property name in ascending order. A `-` may be prepended to the name
// to sort in descending order. For example, the value `-created_at` sorts the collection by the `created_at` property
// in descending order, and the value `name` sorts it by the `name` property in ascending order.
const (
	ListVPNServersOptionsSortCreatedAtConst = "created_at"
	ListVPNServersOptionsSortNameConst      = "name"
)

// NewListVPNServersOptions : Instantiate ListVPNServersOptions
func (*VpcV1) NewListVPNServersOptions() *ListVPNServersOptions {
	return &ListVPNServersOptions{}
}

// SetName : Allow user to set Name
func (_options *ListVPNServersOptions) SetName(name string) *ListVPNServersOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListVPNServersOptions) SetStart(start string) *ListVPNServersOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListVPNServersOptions) SetLimit(limit int64) *ListVPNServersOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListVPNServersOptions) SetResourceGroupID(resourceGroupID string) *ListVPNServersOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetSort : Allow user to set Sort
func (_options *ListVPNServersOptions) SetSort(sort string) *ListVPNServersOptions {
	_options.Sort = core.StringPtr(sort)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNServersOptions) SetHeaders(param map[string]string) *ListVPNServersOptions {
	options.Headers = param
	return options
}

// LoadBalancer : LoadBalancer struct
type LoadBalancer struct {
	// The date and time that this load balancer was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The load balancer's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The DNS configuration for this load balancer.
	//
	// If absent, DNS `A` records for this load balancer's `hostname` property will be added to
	// the public DNS zone `lb.appdomain.cloud`.
	Dns *LoadBalancerDns `json:"dns,omitempty"`

	// Fully qualified domain name assigned to this load balancer.
	Hostname *string `json:"hostname" validate:"required"`

	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this load balancer supports instance groups.
	InstanceGroupsSupported *bool `json:"instance_groups_supported" validate:"required"`

	// The type of this load balancer, public or private.
	IsPublic *bool `json:"is_public" validate:"required"`

	// The listeners of this load balancer.
	Listeners []LoadBalancerListenerReference `json:"listeners" validate:"required"`

	// The logging configuration for this load balancer.
	Logging *LoadBalancerLogging `json:"logging" validate:"required"`

	// The name for this load balancer. The name is unique across all load balancers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The operating status of this load balancer.
	OperatingStatus *string `json:"operating_status" validate:"required"`

	// The pools of this load balancer.
	Pools []LoadBalancerPoolReference `json:"pools" validate:"required"`

	// The private IP addresses assigned to this load balancer.
	PrivateIps []LoadBalancerPrivateIpsItem `json:"private_ips" validate:"required"`

	// The profile for this load balancer.
	Profile *LoadBalancerProfileReference `json:"profile" validate:"required"`

	// The provisioning status of this load balancer:
	//
	// - `active`: The load balancer is running.
	// - `create_pending`: The load balancer is being created.
	// - `delete_pending`: The load balancer is being deleted.
	// - `maintenance_pending`: The load balancer is unavailable due to an internal
	//                           error (contact IBM support).
	// - `migrate_pending`: The load balancer is migrating to the requested configuration.
	//                       Performance may be degraded.
	// - `update_pending`: The load balancer is being updated
	//     to the requested configuration.
	//
	//   The enumerated values for this property are expected to expand in the future. When
	//   processing this property, check for and log unknown values. Optionally halt
	//   processing and surface the error, or bypass the load balancer on which the
	//   unexpected property value was encountered.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The public IP addresses assigned to this load balancer.
	//
	// Applicable only for public load balancers.
	PublicIps []IP `json:"public_ips" validate:"required"`

	// The resource group for this load balancer.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// Indicates whether route mode is enabled for this load balancer.
	//
	// At present, public load balancers are not supported with route mode enabled.
	RouteMode *bool `json:"route_mode" validate:"required"`

	// The security groups targeting this load balancer.
	//
	// Applicable only for load balancers that support security groups.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// Indicates whether this load balancer supports security groups.
	SecurityGroupsSupported *bool `json:"security_groups_supported" validate:"required"`

	// The subnets this load balancer is provisioned in.  The load balancer's availability depends on the availability of
	// the zones that the subnets reside in.
	//
	// All subnets will be in the same VPC.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// Indicates whether this load balancer supports UDP.
	UDPSupported *bool `json:"udp_supported" validate:"required"`
}

// Constants associated with the LoadBalancer.OperatingStatus property.
// The operating status of this load balancer.
const (
	LoadBalancerOperatingStatusOfflineConst = "offline"
	LoadBalancerOperatingStatusOnlineConst  = "online"
)

// Constants associated with the LoadBalancer.ProvisioningStatus property.
// The provisioning status of this load balancer:
//
//   - `active`: The load balancer is running.
//
//   - `create_pending`: The load balancer is being created.
//
//   - `delete_pending`: The load balancer is being deleted.
//
//   - `maintenance_pending`: The load balancer is unavailable due to an internal
//     error (contact IBM support).
//
//   - `migrate_pending`: The load balancer is migrating to the requested configuration.
//     Performance may be degraded.
//
//   - `update_pending`: The load balancer is being updated
//     to the requested configuration.
//
//     The enumerated values for this property are expected to expand in the future. When
//     processing this property, check for and log unknown values. Optionally halt
//     processing and surface the error, or bypass the load balancer on which the
//     unexpected property value was encountered.
const (
	LoadBalancerProvisioningStatusActiveConst             = "active"
	LoadBalancerProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerProvisioningStatusFailedConst             = "failed"
	LoadBalancerProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerProvisioningStatusMigratePendingConst     = "migrate_pending"
	LoadBalancerProvisioningStatusUpdatePendingConst      = "update_pending"
)

// Constants associated with the LoadBalancer.ResourceType property.
// The resource type.
const (
	LoadBalancerResourceTypeLoadBalancerConst = "load_balancer"
)

// UnmarshalLoadBalancer unmarshals an instance of LoadBalancer from the specified map of raw messages.
func UnmarshalLoadBalancer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancer)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dns", &obj.Dns, UnmarshalLoadBalancerDns)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_groups_supported", &obj.InstanceGroupsSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_public", &obj.IsPublic)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listeners", &obj.Listeners, UnmarshalLoadBalancerListenerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "logging", &obj.Logging, UnmarshalLoadBalancerLogging)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operating_status", &obj.OperatingStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pools", &obj.Pools, UnmarshalLoadBalancerPoolReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "private_ips", &obj.PrivateIps, UnmarshalLoadBalancerPrivateIpsItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalLoadBalancerProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_ips", &obj.PublicIps, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_mode", &obj.RouteMode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "security_groups_supported", &obj.SecurityGroupsSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "udp_supported", &obj.UDPSupported)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerCollection : LoadBalancerCollection struct
type LoadBalancerCollection struct {
	// A link to the first page of resources.
	First *LoadBalancerCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of load balancers.
	LoadBalancers []LoadBalancer `json:"load_balancers" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *LoadBalancerCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalLoadBalancerCollection unmarshals an instance of LoadBalancerCollection from the specified map of raw messages.
func UnmarshalLoadBalancerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalLoadBalancerCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "load_balancers", &obj.LoadBalancers, UnmarshalLoadBalancer)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalLoadBalancerCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *LoadBalancerCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// LoadBalancerCollectionFirst : A link to the first page of resources.
type LoadBalancerCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalLoadBalancerCollectionFirst unmarshals an instance of LoadBalancerCollectionFirst from the specified map of raw messages.
func UnmarshalLoadBalancerCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type LoadBalancerCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalLoadBalancerCollectionNext unmarshals an instance of LoadBalancerCollectionNext from the specified map of raw messages.
func UnmarshalLoadBalancerCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerDns : The DNS configuration for this load balancer.
//
// If absent, DNS `A` records for this load balancer's `hostname` property will be added to the public DNS zone
// `lb.appdomain.cloud`.
type LoadBalancerDns struct {
	// The DNS instance associated with this load balancer.
	Instance *DnsInstanceReference `json:"instance" validate:"required"`

	// The DNS zone associated with this load balancer.
	Zone *DnsZoneReference `json:"zone" validate:"required"`
}

// UnmarshalLoadBalancerDns unmarshals an instance of LoadBalancerDns from the specified map of raw messages.
func UnmarshalLoadBalancerDns(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerDns)
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalDnsInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalDnsZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerDnsPatch : The DNS configuration for this load balancer.
//
// Specify `null` to remove the existing DNS configuration, which will remove all DNS `A` records for this load balancer
// that had been added to `zone`, and add equivalent `A` records to the public DNS zone `lb.appdomain.cloud`.
type LoadBalancerDnsPatch struct {
	// The DNS instance to associate with this load balancer.
	//
	// The specified instance may be in a different region or account, subject to IAM
	// policies.
	Instance DnsInstanceIdentityIntf `json:"instance,omitempty"`

	// The DNS zone to associate with this load balancer.
	//
	// The specified zone may be in a different region or account, subject to IAM policies.
	Zone DnsZoneIdentityIntf `json:"zone,omitempty"`
}

// UnmarshalLoadBalancerDnsPatch unmarshals an instance of LoadBalancerDnsPatch from the specified map of raw messages.
func UnmarshalLoadBalancerDnsPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerDnsPatch)
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalDnsInstanceIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalDnsZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerDnsPrototype : The DNS configuration for this load balancer.
//
// If unspecified, DNS `A` records for this load balancer's `hostname` property will be added to the public DNS zone
// `lb.appdomain.cloud`. Otherwise, those DNS `A` records will be added to the specified `zone`.
type LoadBalancerDnsPrototype struct {
	// The DNS instance to associate with this load balancer.
	//
	// The specified instance may be in a different region or account, subject to IAM
	// policies.
	Instance DnsInstanceIdentityIntf `json:"instance" validate:"required"`

	// The DNS zone to associate with this load balancer.
	//
	// The specified zone may be in a different region or account, subject to IAM policies.
	Zone DnsZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewLoadBalancerDnsPrototype : Instantiate LoadBalancerDnsPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerDnsPrototype(instance DnsInstanceIdentityIntf, zone DnsZoneIdentityIntf) (_model *LoadBalancerDnsPrototype, err error) {
	_model = &LoadBalancerDnsPrototype{
		Instance: instance,
		Zone:     zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerDnsPrototype unmarshals an instance of LoadBalancerDnsPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerDnsPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerDnsPrototype)
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalDnsInstanceIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalDnsZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentity : Identifies a load balancer by a unique property.
// Models which "extend" this model:
// - LoadBalancerIdentityByID
// - LoadBalancerIdentityByCRN
// - LoadBalancerIdentityByHref
type LoadBalancerIdentity struct {
	// The unique identifier for this load balancer.
	ID *string `json:"id,omitempty"`

	// The load balancer's CRN.
	CRN *string `json:"crn,omitempty"`

	// The load balancer's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerIdentity) isaLoadBalancerIdentity() bool {
	return true
}

type LoadBalancerIdentityIntf interface {
	isaLoadBalancerIdentity() bool
}

// UnmarshalLoadBalancerIdentity unmarshals an instance of LoadBalancerIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListener : LoadBalancerListener struct
type LoadBalancerListener struct {
	// If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load balancers in
	// the `application` family (otherwise always `false`). Additional restrictions:
	// - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
	//   match the `accept_proxy_protocol` value of the `https_redirect` listener.
	// - If this listener is the target of another listener's `https_redirect`, its
	//   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
	AcceptProxyProtocol *bool `json:"accept_proxy_protocol" validate:"required"`

	// The certificate instance used for SSL termination.
	//
	// If absent, this listener is not using a certificate instance.
	CertificateInstance *CertificateInstanceReference `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The date and time that this listener was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The default pool for this listener. If absent, this listener has no default pool.
	DefaultPool *LoadBalancerPoolReference `json:"default_pool,omitempty"`

	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`

	// If present, the target listener that requests are redirected to.
	HTTPSRedirect *LoadBalancerListenerHTTPSRedirect `json:"https_redirect,omitempty"`

	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`

	// The idle connection timeout of the listener in seconds. This property will be present for load balancers in the
	// `application` family.
	IdleConnectionTimeout *int64 `json:"idle_connection_timeout,omitempty"`

	// The policies for this listener.
	Policies []LoadBalancerListenerPolicyReference `json:"policies,omitempty"`

	// The listener port number, or the inclusive lower bound of the port range.
	Port *int64 `json:"port" validate:"required"`

	// The inclusive upper bound of the range of ports used by this listener.
	//
	// At present, only load balancers in the `network` family support more than one port per listener.
	PortMax *int64 `json:"port_max" validate:"required"`

	// The inclusive lower bound of the range of ports used by this listener.
	//
	// At present, only load balancers in the `network` family support more than one port per listener.
	PortMin *int64 `json:"port_min" validate:"required"`

	// The listener protocol.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the listener on which the
	// unexpected property value was encountered.
	Protocol *string `json:"protocol" validate:"required"`

	// The provisioning status of this listener
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the listener on which the
	// unexpected property value was encountered.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`
}

// Constants associated with the LoadBalancerListener.Protocol property.
// The listener protocol.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the listener on which the
// unexpected property value was encountered.
const (
	LoadBalancerListenerProtocolHTTPConst  = "http"
	LoadBalancerListenerProtocolHTTPSConst = "https"
	LoadBalancerListenerProtocolTCPConst   = "tcp"
	LoadBalancerListenerProtocolUDPConst   = "udp"
)

// Constants associated with the LoadBalancerListener.ProvisioningStatus property.
// The provisioning status of this listener
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the listener on which the
// unexpected property value was encountered.
const (
	LoadBalancerListenerProvisioningStatusActiveConst        = "active"
	LoadBalancerListenerProvisioningStatusCreatePendingConst = "create_pending"
	LoadBalancerListenerProvisioningStatusDeletePendingConst = "delete_pending"
	LoadBalancerListenerProvisioningStatusFailedConst        = "failed"
	LoadBalancerListenerProvisioningStatusUpdatePendingConst = "update_pending"
)

// UnmarshalLoadBalancerListener unmarshals an instance of LoadBalancerListener from the specified map of raw messages.
func UnmarshalLoadBalancerListener(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListener)
	err = core.UnmarshalPrimitive(m, "accept_proxy_protocol", &obj.AcceptProxyProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "certificate_instance", &obj.CertificateInstance, UnmarshalCertificateInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_limit", &obj.ConnectionLimit)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_pool", &obj.DefaultPool, UnmarshalLoadBalancerPoolReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "https_redirect", &obj.HTTPSRedirect, UnmarshalLoadBalancerListenerHTTPSRedirect)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "idle_connection_timeout", &obj.IdleConnectionTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalLoadBalancerListenerPolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerCollection : LoadBalancerListenerCollection struct
type LoadBalancerListenerCollection struct {
	// Collection of listeners.
	Listeners []LoadBalancerListener `json:"listeners" validate:"required"`
}

// UnmarshalLoadBalancerListenerCollection unmarshals an instance of LoadBalancerListenerCollection from the specified map of raw messages.
func UnmarshalLoadBalancerListenerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerCollection)
	err = core.UnmarshalModel(m, "listeners", &obj.Listeners, UnmarshalLoadBalancerListener)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerHTTPSRedirect : LoadBalancerListenerHTTPSRedirect struct
type LoadBalancerListenerHTTPSRedirect struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	Listener *LoadBalancerListenerReference `json:"listener" validate:"required"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

// UnmarshalLoadBalancerListenerHTTPSRedirect unmarshals an instance of LoadBalancerListenerHTTPSRedirect from the specified map of raw messages.
func UnmarshalLoadBalancerListenerHTTPSRedirect(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerHTTPSRedirect)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerHTTPSRedirectPatch : LoadBalancerListenerHTTPSRedirectPatch struct
type LoadBalancerListenerHTTPSRedirectPatch struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// Identifies a load balancer listener by a unique property.
	Listener LoadBalancerListenerIdentityIntf `json:"listener,omitempty"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

// UnmarshalLoadBalancerListenerHTTPSRedirectPatch unmarshals an instance of LoadBalancerListenerHTTPSRedirectPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerHTTPSRedirectPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerHTTPSRedirectPatch)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerHTTPSRedirectPrototype : LoadBalancerListenerHTTPSRedirectPrototype struct
type LoadBalancerListenerHTTPSRedirectPrototype struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	// Identifies a load balancer listener by a unique property.
	Listener LoadBalancerListenerIdentityIntf `json:"listener" validate:"required"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

// NewLoadBalancerListenerHTTPSRedirectPrototype : Instantiate LoadBalancerListenerHTTPSRedirectPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerHTTPSRedirectPrototype(httpStatusCode int64, listener LoadBalancerListenerIdentityIntf) (_model *LoadBalancerListenerHTTPSRedirectPrototype, err error) {
	_model = &LoadBalancerListenerHTTPSRedirectPrototype{
		HTTPStatusCode: core.Int64Ptr(httpStatusCode),
		Listener:       listener,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerHTTPSRedirectPrototype unmarshals an instance of LoadBalancerListenerHTTPSRedirectPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerHTTPSRedirectPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerHTTPSRedirectPrototype)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerIdentity : Identifies a load balancer listener by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerIdentityByID
// - LoadBalancerListenerIdentityByHref
type LoadBalancerListenerIdentity struct {
	// The unique identifier for this load balancer listener.
	ID *string `json:"id,omitempty"`

	// The listener's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerIdentity) isaLoadBalancerListenerIdentity() bool {
	return true
}

type LoadBalancerListenerIdentityIntf interface {
	isaLoadBalancerListenerIdentity() bool
}

// UnmarshalLoadBalancerListenerIdentity unmarshals an instance of LoadBalancerListenerIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerListenerIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPatch : LoadBalancerListenerPatch struct
type LoadBalancerListenerPatch struct {
	// If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load balancers in
	// the `application` family (otherwise always `false`). Additional restrictions:
	// - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
	//   match the `accept_proxy_protocol` value of the `https_redirect` listener.
	// - If this listener is the target of another listener's `https_redirect`, its
	//   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
	AcceptProxyProtocol *bool `json:"accept_proxy_protocol,omitempty"`

	// The certificate instance to use for SSL termination. The listener must have a
	// `protocol` of `https`.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool for this listener. The specified pool must:
	//
	// - Belong to this load balancer
	// - Have the same `protocol` as this listener, or have a compatible protocol.
	//   At present, the compatible protocols are `http` and `https`.
	// - Not already be the `default_pool` for another listener
	//
	// Specify `null` to remove an existing default pool.
	DefaultPool LoadBalancerPoolIdentityIntf `json:"default_pool,omitempty"`

	// The target listener that requests will be redirected to. This listener must have a
	// `protocol` of `http`, and the target listener must have a `protocol` of `https`.
	//
	// Specify `null` to remove any existing https redirect.
	HTTPSRedirect *LoadBalancerListenerHTTPSRedirectPatch `json:"https_redirect,omitempty"`

	// The idle connection timeout of the listener in seconds. Supported for load balancers in the `application` family.
	IdleConnectionTimeout *int64 `json:"idle_connection_timeout,omitempty"`

	// The listener port number, or the inclusive lower bound of the port range. Each listener in the load balancer must
	// have a unique `port` and `protocol` combination.
	//
	// Not supported for load balancers operating with route mode enabled.
	Port *int64 `json:"port,omitempty"`

	// The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
	//
	// At present, only load balancers operating with route mode enabled, and public load balancers in the `network` family
	// support different values for `port_min` and
	// `port_max`. When route mode is enabled, the value `65535` must be specified.
	//
	// The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
	// same protocol.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
	//
	// At present, only load balancers operating with route mode enabled, and public load balancers in the `network` family
	// support different values for `port_min` and
	// `port_max`. When route mode is enabled, the value `1` must be specified.
	//
	// The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
	// same protocol.
	PortMin *int64 `json:"port_min,omitempty"`

	// The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination.
	//
	// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
	// `application` family support `tcp`, `http` and
	// `https`.
	//
	// Additional restrictions:
	// - If `default_pool` is set, the protocol cannot be changed.
	// - If `https_redirect` is set, the protocol must be `http`.
	// - If another listener's `https_redirect` targets this listener, the protocol must be
	// `https`.
	Protocol *string `json:"protocol,omitempty"`
}

// Constants associated with the LoadBalancerListenerPatch.Protocol property.
// The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination.
//
// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
// `application` family support `tcp`, `http` and
// `https`.
//
// Additional restrictions:
// - If `default_pool` is set, the protocol cannot be changed.
// - If `https_redirect` is set, the protocol must be `http`.
// - If another listener's `https_redirect` targets this listener, the protocol must be
// `https`.
const (
	LoadBalancerListenerPatchProtocolHTTPConst  = "http"
	LoadBalancerListenerPatchProtocolHTTPSConst = "https"
	LoadBalancerListenerPatchProtocolTCPConst   = "tcp"
	LoadBalancerListenerPatchProtocolUDPConst   = "udp"
)

// UnmarshalLoadBalancerListenerPatch unmarshals an instance of LoadBalancerListenerPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPatch)
	err = core.UnmarshalPrimitive(m, "accept_proxy_protocol", &obj.AcceptProxyProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "certificate_instance", &obj.CertificateInstance, UnmarshalCertificateInstanceIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_limit", &obj.ConnectionLimit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_pool", &obj.DefaultPool, UnmarshalLoadBalancerPoolIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "https_redirect", &obj.HTTPSRedirect, UnmarshalLoadBalancerListenerHTTPSRedirectPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "idle_connection_timeout", &obj.IdleConnectionTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the LoadBalancerListenerPatch
func (loadBalancerListenerPatch *LoadBalancerListenerPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(loadBalancerListenerPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// LoadBalancerListenerPolicy : LoadBalancerListenerPolicy struct
type LoadBalancerListenerPolicy struct {
	// The policy action.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
	// unexpected property value was encountered.
	Action *string `json:"action" validate:"required"`

	// The date and time that this policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The listener policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The policy's unique identifier.
	ID *string `json:"id" validate:"required"`

	// The name for this load balancer listener policy. The name is unique across all policies for the load balancer
	// listener.
	Name *string `json:"name" validate:"required"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The provisioning status of this policy
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
	// unexpected property value was encountered.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The rules for this policy.
	Rules []LoadBalancerListenerPolicyRuleReference `json:"rules" validate:"required"`

	// - If `action` is `forward`, the response is a `LoadBalancerPoolReference`
	// - If `action` is `redirect`, the response is a `LoadBalancerListenerPolicyRedirectURL`
	// - If `action` is `https_redirect`, the response is a `LoadBalancerListenerHTTPSRedirect`.
	Target LoadBalancerListenerPolicyTargetIntf `json:"target,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicy.Action property.
// The policy action.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
// unexpected property value was encountered.
const (
	LoadBalancerListenerPolicyActionForwardConst       = "forward"
	LoadBalancerListenerPolicyActionHTTPSRedirectConst = "https_redirect"
	LoadBalancerListenerPolicyActionRedirectConst      = "redirect"
	LoadBalancerListenerPolicyActionRejectConst        = "reject"
)

// Constants associated with the LoadBalancerListenerPolicy.ProvisioningStatus property.
// The provisioning status of this policy
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
// unexpected property value was encountered.
const (
	LoadBalancerListenerPolicyProvisioningStatusActiveConst        = "active"
	LoadBalancerListenerPolicyProvisioningStatusCreatePendingConst = "create_pending"
	LoadBalancerListenerPolicyProvisioningStatusDeletePendingConst = "delete_pending"
	LoadBalancerListenerPolicyProvisioningStatusFailedConst        = "failed"
	LoadBalancerListenerPolicyProvisioningStatusUpdatePendingConst = "update_pending"
)

// UnmarshalLoadBalancerListenerPolicy unmarshals an instance of LoadBalancerListenerPolicy from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicy)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalLoadBalancerListenerPolicyRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerListenerPolicyTarget)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyCollection : LoadBalancerListenerPolicyCollection struct
type LoadBalancerListenerPolicyCollection struct {
	// Collection of policies.
	Policies []LoadBalancerListenerPolicy `json:"policies" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyCollection unmarshals an instance of LoadBalancerListenerPolicyCollection from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyCollection)
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalLoadBalancerListenerPolicy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPatch : LoadBalancerListenerPolicyPatch struct
type LoadBalancerListenerPolicyPatch struct {
	// The name for this policy. The name must not be used by another policy for the load balancer listener.
	Name *string `json:"name,omitempty"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority,omitempty"`

	// - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
	// - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
	// - If `action` is `https_redirect`, specify a
	//   `LoadBalancerListenerPolicyHTTPSRedirectPatch`.
	Target LoadBalancerListenerPolicyTargetPatchIntf `json:"target,omitempty"`
}

// UnmarshalLoadBalancerListenerPolicyPatch unmarshals an instance of LoadBalancerListenerPolicyPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerListenerPolicyTargetPatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the LoadBalancerListenerPolicyPatch
func (loadBalancerListenerPolicyPatch *LoadBalancerListenerPolicyPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(loadBalancerListenerPolicyPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// LoadBalancerListenerPolicyPrototype : LoadBalancerListenerPolicyPrototype struct
type LoadBalancerListenerPolicyPrototype struct {
	// The policy action.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
	// unexpected property value was encountered.
	Action *string `json:"action" validate:"required"`

	// The name for this policy. The name must not be used by another policy for the load balancer listener. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The rule prototype objects for this policy.
	Rules []LoadBalancerListenerPolicyRulePrototype `json:"rules,omitempty"`

	// - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
	// - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`.
	// - If `action` is `https_redirect`, specify a
	//   `LoadBalancerListenerPolicyHTTPSRedirectPrototype`.
	Target LoadBalancerListenerPolicyTargetPrototypeIntf `json:"target,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicyPrototype.Action property.
// The policy action.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the policy on which the
// unexpected property value was encountered.
const (
	LoadBalancerListenerPolicyPrototypeActionForwardConst       = "forward"
	LoadBalancerListenerPolicyPrototypeActionHTTPSRedirectConst = "https_redirect"
	LoadBalancerListenerPolicyPrototypeActionRedirectConst      = "redirect"
	LoadBalancerListenerPolicyPrototypeActionRejectConst        = "reject"
)

// NewLoadBalancerListenerPolicyPrototype : Instantiate LoadBalancerListenerPolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototype(action string, priority int64) (_model *LoadBalancerListenerPolicyPrototype, err error) {
	_model = &LoadBalancerListenerPolicyPrototype{
		Action:   core.StringPtr(action),
		Priority: core.Int64Ptr(priority),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototype unmarshals an instance of LoadBalancerListenerPolicyPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalLoadBalancerListenerPolicyRulePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerListenerPolicyTargetPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyReference : LoadBalancerListenerPolicyReference struct
type LoadBalancerListenerPolicyReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerListenerPolicyReferenceDeleted `json:"deleted,omitempty"`

	// The listener policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The policy's unique identifier.
	ID *string `json:"id" validate:"required"`

	Name interface{} `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyReference unmarshals an instance of LoadBalancerListenerPolicyReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerListenerPolicyReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type LoadBalancerListenerPolicyReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyReferenceDeleted unmarshals an instance of LoadBalancerListenerPolicyReferenceDeleted from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRule : LoadBalancerListenerPolicyRule struct
type LoadBalancerListenerPolicyRule struct {
	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The date and time that this rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The field. This is applicable to `header`, `query`, and `body` rule types.
	//
	// If the rule type is `header`, this property is required.
	//
	// If the rule type is `query`, this is optional. If specified and the rule condition is not
	// `matches_regex`, the value must be percent-encoded.
	//
	// If the rule type is `body`, this is optional.
	Field *string `json:"field,omitempty"`

	// The rule's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The rule's unique identifier.
	ID *string `json:"id" validate:"required"`

	// The provisioning status of this rule
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the rule on which the
	// unexpected property value was encountered.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The type of the rule.
	//
	// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	//
	// If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPolicyRule.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRuleConditionContainsConst     = "contains"
	LoadBalancerListenerPolicyRuleConditionEqualsConst       = "equals"
	LoadBalancerListenerPolicyRuleConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRule.ProvisioningStatus property.
// The provisioning status of this rule
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the rule on which the
// unexpected property value was encountered.
const (
	LoadBalancerListenerPolicyRuleProvisioningStatusActiveConst        = "active"
	LoadBalancerListenerPolicyRuleProvisioningStatusCreatePendingConst = "create_pending"
	LoadBalancerListenerPolicyRuleProvisioningStatusDeletePendingConst = "delete_pending"
	LoadBalancerListenerPolicyRuleProvisioningStatusFailedConst        = "failed"
	LoadBalancerListenerPolicyRuleProvisioningStatusUpdatePendingConst = "update_pending"
)

// Constants associated with the LoadBalancerListenerPolicyRule.Type property.
// The type of the rule.
//
// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
const (
	LoadBalancerListenerPolicyRuleTypeBodyConst     = "body"
	LoadBalancerListenerPolicyRuleTypeHeaderConst   = "header"
	LoadBalancerListenerPolicyRuleTypeHostnameConst = "hostname"
	LoadBalancerListenerPolicyRuleTypePathConst     = "path"
	LoadBalancerListenerPolicyRuleTypeQueryConst    = "query"
)

// UnmarshalLoadBalancerListenerPolicyRule unmarshals an instance of LoadBalancerListenerPolicyRule from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRule)
	err = core.UnmarshalPrimitive(m, "condition", &obj.Condition)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "field", &obj.Field)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRuleCollection : LoadBalancerListenerPolicyRuleCollection struct
type LoadBalancerListenerPolicyRuleCollection struct {
	// Collection of rules.
	Rules []LoadBalancerListenerPolicyRule `json:"rules" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleCollection unmarshals an instance of LoadBalancerListenerPolicyRuleCollection from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRuleCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRuleCollection)
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalLoadBalancerListenerPolicyRule)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRulePatch : LoadBalancerListenerPolicyRulePatch struct
type LoadBalancerListenerPolicyRulePatch struct {
	// The condition of the rule.
	Condition *string `json:"condition,omitempty"`

	// The field. This is applicable to `header`, `query`, and `body` rule types.
	//
	// If the rule type is `header`, this property is required.
	//
	// If the rule type is `query`, this is optional. If specified and the rule condition is not
	// `matches_regex`, the value must be percent-encoded.
	//
	// If the rule type is `body`, this is optional.
	Field *string `json:"field,omitempty"`

	// The type of the rule.
	//
	// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
	Type *string `json:"type,omitempty"`

	// Value to be matched for rule condition.
	//
	// If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
	Value *string `json:"value,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicyRulePatch.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRulePatchConditionContainsConst     = "contains"
	LoadBalancerListenerPolicyRulePatchConditionEqualsConst       = "equals"
	LoadBalancerListenerPolicyRulePatchConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRulePatch.Type property.
// The type of the rule.
//
// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
const (
	LoadBalancerListenerPolicyRulePatchTypeBodyConst     = "body"
	LoadBalancerListenerPolicyRulePatchTypeHeaderConst   = "header"
	LoadBalancerListenerPolicyRulePatchTypeHostnameConst = "hostname"
	LoadBalancerListenerPolicyRulePatchTypePathConst     = "path"
	LoadBalancerListenerPolicyRulePatchTypeQueryConst    = "query"
)

// UnmarshalLoadBalancerListenerPolicyRulePatch unmarshals an instance of LoadBalancerListenerPolicyRulePatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRulePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRulePatch)
	err = core.UnmarshalPrimitive(m, "condition", &obj.Condition)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "field", &obj.Field)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the LoadBalancerListenerPolicyRulePatch
func (loadBalancerListenerPolicyRulePatch *LoadBalancerListenerPolicyRulePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(loadBalancerListenerPolicyRulePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// LoadBalancerListenerPolicyRulePrototype : LoadBalancerListenerPolicyRulePrototype struct
type LoadBalancerListenerPolicyRulePrototype struct {
	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The field. This is applicable to `header`, `query`, and `body` rule types.
	//
	// If the rule type is `header`, this property is required.
	//
	// If the rule type is `query`, this is optional. If specified and the rule condition is not
	// `matches_regex`, the value must be percent-encoded.
	//
	// If the rule type is `body`, this is optional.
	Field *string `json:"field,omitempty"`

	// The type of the rule.
	//
	// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	//
	// If the rule type is `query` and the rule condition is not `matches_regex`, the value must be percent-encoded.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPolicyRulePrototype.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRulePrototypeConditionContainsConst     = "contains"
	LoadBalancerListenerPolicyRulePrototypeConditionEqualsConst       = "equals"
	LoadBalancerListenerPolicyRulePrototypeConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRulePrototype.Type property.
// The type of the rule.
//
// Body rules are applied to form-encoded request bodies using the `UTF-8` character set.
const (
	LoadBalancerListenerPolicyRulePrototypeTypeBodyConst     = "body"
	LoadBalancerListenerPolicyRulePrototypeTypeHeaderConst   = "header"
	LoadBalancerListenerPolicyRulePrototypeTypeHostnameConst = "hostname"
	LoadBalancerListenerPolicyRulePrototypeTypePathConst     = "path"
	LoadBalancerListenerPolicyRulePrototypeTypeQueryConst    = "query"
)

// NewLoadBalancerListenerPolicyRulePrototype : Instantiate LoadBalancerListenerPolicyRulePrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyRulePrototype(condition string, typeVar string, value string) (_model *LoadBalancerListenerPolicyRulePrototype, err error) {
	_model = &LoadBalancerListenerPolicyRulePrototype{
		Condition: core.StringPtr(condition),
		Type:      core.StringPtr(typeVar),
		Value:     core.StringPtr(value),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPolicyRulePrototype unmarshals an instance of LoadBalancerListenerPolicyRulePrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRulePrototype)
	err = core.UnmarshalPrimitive(m, "condition", &obj.Condition)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "field", &obj.Field)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRuleReference : LoadBalancerListenerPolicyRuleReference struct
type LoadBalancerListenerPolicyRuleReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerListenerPolicyRuleReferenceDeleted `json:"deleted,omitempty"`

	// The rule's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The rule's unique identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleReference unmarshals an instance of LoadBalancerListenerPolicyRuleReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRuleReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRuleReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerListenerPolicyRuleReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRuleReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type LoadBalancerListenerPolicyRuleReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleReferenceDeleted unmarshals an instance of LoadBalancerListenerPolicyRuleReferenceDeleted from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRuleReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRuleReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTarget : - If `action` is `forward`, the response is a `LoadBalancerPoolReference`
// - If `action` is `redirect`, the response is a `LoadBalancerListenerPolicyRedirectURL`
// - If `action` is `https_redirect`, the response is a `LoadBalancerListenerHTTPSRedirect`.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetLoadBalancerPoolReference
// - LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL
// - LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect
type LoadBalancerListenerPolicyTarget struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerPoolReferenceDeleted `json:"deleted,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The name for this load balancer pool. The name is unique across all pools for the load balancer.
	Name *string `json:"name,omitempty"`

	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`

	Listener *LoadBalancerListenerReference `json:"listener,omitempty"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

func (*LoadBalancerListenerPolicyTarget) isaLoadBalancerListenerPolicyTarget() bool {
	return true
}

type LoadBalancerListenerPolicyTargetIntf interface {
	isaLoadBalancerListenerPolicyTarget() bool
}

// UnmarshalLoadBalancerListenerPolicyTarget unmarshals an instance of LoadBalancerListenerPolicyTarget from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTarget)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerPoolReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPatch : - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
//   - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPatch`.
//   - If `action` is `https_redirect`, specify a
//     `LoadBalancerListenerPolicyHTTPSRedirectPatch`.
//
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity
// - LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch
// - LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch
type LoadBalancerListenerPolicyTargetPatch struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`

	// Identifies a load balancer listener by a unique property.
	Listener LoadBalancerListenerIdentityIntf `json:"listener,omitempty"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetPatch) isaLoadBalancerListenerPolicyTargetPatch() bool {
	return true
}

type LoadBalancerListenerPolicyTargetPatchIntf interface {
	isaLoadBalancerListenerPolicyTargetPatch() bool
}

// UnmarshalLoadBalancerListenerPolicyTargetPatch unmarshals an instance of LoadBalancerListenerPolicyTargetPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPrototype : - If `action` is `forward`, specify a `LoadBalancerPoolIdentity`.
//   - If `action` is `redirect`, specify a `LoadBalancerListenerPolicyRedirectURLPrototype`.
//   - If `action` is `https_redirect`, specify a
//     `LoadBalancerListenerPolicyHTTPSRedirectPrototype`.
//
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity
// - LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype
// - LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype
type LoadBalancerListenerPolicyTargetPrototype struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`

	// Identifies a load balancer listener by a unique property.
	Listener LoadBalancerListenerIdentityIntf `json:"listener,omitempty"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetPrototype) isaLoadBalancerListenerPolicyTargetPrototype() bool {
	return true
}

type LoadBalancerListenerPolicyTargetPrototypeIntf interface {
	isaLoadBalancerListenerPolicyTargetPrototype() bool
}

// UnmarshalLoadBalancerListenerPolicyTargetPrototype unmarshals an instance of LoadBalancerListenerPolicyTargetPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPrototypeLoadBalancerContext : LoadBalancerListenerPrototypeLoadBalancerContext struct
type LoadBalancerListenerPrototypeLoadBalancerContext struct {
	// If set to `true`, this listener will accept and forward PROXY protocol information. Supported by load balancers in
	// the `application` family (otherwise always `false`). Additional restrictions:
	// - If this listener has `https_redirect` specified, its `accept_proxy_protocol` value must
	//   match the `accept_proxy_protocol` value of the `https_redirect` listener.
	// - If this listener is the target of another listener's `https_redirect`, its
	//   `accept_proxy_protocol` value must match that listener's `accept_proxy_protocol` value.
	AcceptProxyProtocol *bool `json:"accept_proxy_protocol,omitempty"`

	// The certificate instance to use for SSL termination. The listener must have a
	// `protocol` of `https`.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool for this listener. If specified, the pool must:
	//   - Belong to this load balancer.
	//   - Have the same `protocol` as this listener, or have a compatible protocol.
	//     At present, the compatible protocols are `http` and `https`.
	//   - Not already be the `default_pool` for another listener.
	//
	// If unspecified, this listener will be created with no default pool, but one may be
	// subsequently set.
	DefaultPool *LoadBalancerPoolIdentityByName `json:"default_pool,omitempty"`

	// The target listener that requests will be redirected to. This listener must have a
	// `protocol` of `http`, and the target listener must have a `protocol` of `https`.
	HTTPSRedirect *LoadBalancerListenerHTTPSRedirectPrototype `json:"https_redirect,omitempty"`

	// The idle connection timeout of the listener in seconds. Supported for load balancers in the `application` family.
	IdleConnectionTimeout *int64 `json:"idle_connection_timeout,omitempty"`

	// The listener port number, or the inclusive lower bound of the port range. Each listener in the load balancer must
	// have a unique `port` and `protocol` combination.
	//
	// Not supported for load balancers operating with route mode enabled.
	Port *int64 `json:"port,omitempty"`

	// The inclusive upper bound of the range of ports used by this listener. Must not be less than `port_min`.
	//
	// At present, only load balancers operating with route mode enabled, and public load balancers in the `network` family
	// support different values for `port_min` and
	// `port_max`. When route mode is enabled, the value `65535` must be specified.
	//
	// The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
	// same protocol.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of the range of ports used by this listener. Must not be greater than `port_max`.
	//
	// At present, only load balancers operating with route mode enabled, and public load balancers in the `network` family
	// support different values for `port_min` and
	// `port_max`. When route mode is enabled, the value `1` must be specified.
	//
	// The specified port range must not overlap with port ranges used by other listeners for this load balancer using the
	// same protocol.
	PortMin *int64 `json:"port_min,omitempty"`

	// The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination.
	//
	// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
	// `application` family support `tcp`, `http` and
	// `https`.
	//
	// Additional restrictions:
	// - If `default_pool` is set, the pool's protocol must match, or be compatible with
	//   the listener's protocol. At present, the compatible protocols are `http` and
	//   `https`.
	// - If `https_redirect` is set, the protocol must be `http`.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPrototypeLoadBalancerContext.Protocol property.
// The listener protocol. Each listener in the load balancer must have a unique `port` and `protocol` combination.
//
// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
// `application` family support `tcp`, `http` and
// `https`.
//
// Additional restrictions:
//   - If `default_pool` is set, the pool's protocol must match, or be compatible with
//     the listener's protocol. At present, the compatible protocols are `http` and
//     `https`.
//   - If `https_redirect` is set, the protocol must be `http`.
const (
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolHTTPConst  = "http"
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolHTTPSConst = "https"
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolTCPConst   = "tcp"
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolUDPConst   = "udp"
)

// NewLoadBalancerListenerPrototypeLoadBalancerContext : Instantiate LoadBalancerListenerPrototypeLoadBalancerContext (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPrototypeLoadBalancerContext(protocol string) (_model *LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	_model = &LoadBalancerListenerPrototypeLoadBalancerContext{
		Protocol: core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext unmarshals an instance of LoadBalancerListenerPrototypeLoadBalancerContext from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPrototypeLoadBalancerContext)
	err = core.UnmarshalPrimitive(m, "accept_proxy_protocol", &obj.AcceptProxyProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "certificate_instance", &obj.CertificateInstance, UnmarshalCertificateInstanceIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_limit", &obj.ConnectionLimit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_pool", &obj.DefaultPool, UnmarshalLoadBalancerPoolIdentityByName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "https_redirect", &obj.HTTPSRedirect, UnmarshalLoadBalancerListenerHTTPSRedirectPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "idle_connection_timeout", &obj.IdleConnectionTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerReference : LoadBalancerListenerReference struct
type LoadBalancerListenerReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerListenerReferenceDeleted `json:"deleted,omitempty"`

	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerReference unmarshals an instance of LoadBalancerListenerReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerListenerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type LoadBalancerListenerReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalLoadBalancerListenerReferenceDeleted unmarshals an instance of LoadBalancerListenerReferenceDeleted from the specified map of raw messages.
func UnmarshalLoadBalancerListenerReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerLogging : LoadBalancerLogging struct
type LoadBalancerLogging struct {
	// The datapath logging configuration for this load balancer.
	Datapath *LoadBalancerLoggingDatapath `json:"datapath" validate:"required"`
}

// UnmarshalLoadBalancerLogging unmarshals an instance of LoadBalancerLogging from the specified map of raw messages.
func UnmarshalLoadBalancerLogging(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerLogging)
	err = core.UnmarshalModel(m, "datapath", &obj.Datapath, UnmarshalLoadBalancerLoggingDatapath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerLoggingDatapath : The datapath logging configuration for this load balancer.
type LoadBalancerLoggingDatapath struct {
	// Indicates whether datapath logging is active for this load balancer.
	Active *bool `json:"active" validate:"required"`
}

// UnmarshalLoadBalancerLoggingDatapath unmarshals an instance of LoadBalancerLoggingDatapath from the specified map of raw messages.
func UnmarshalLoadBalancerLoggingDatapath(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerLoggingDatapath)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerLoggingDatapathPatch : The datapath logging configuration for this load balancer.
type LoadBalancerLoggingDatapathPatch struct {
	// Indicates whether datapath logging will be active for this load balancer.
	Active *bool `json:"active,omitempty"`
}

// UnmarshalLoadBalancerLoggingDatapathPatch unmarshals an instance of LoadBalancerLoggingDatapathPatch from the specified map of raw messages.
func UnmarshalLoadBalancerLoggingDatapathPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerLoggingDatapathPatch)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerLoggingDatapathPrototype : The datapath logging configuration for this load balancer.
type LoadBalancerLoggingDatapathPrototype struct {
	// Indicates whether datapath logging will be active for this load balancer.
	Active *bool `json:"active,omitempty"`
}

// UnmarshalLoadBalancerLoggingDatapathPrototype unmarshals an instance of LoadBalancerLoggingDatapathPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerLoggingDatapathPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerLoggingDatapathPrototype)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerLoggingPatch : LoadBalancerLoggingPatch struct
type LoadBalancerLoggingPatch struct {
	// The datapath logging configuration for this load balancer.
	Datapath *LoadBalancerLoggingDatapathPatch `json:"datapath,omitempty"`
}

// UnmarshalLoadBalancerLoggingPatch unmarshals an instance of LoadBalancerLoggingPatch from the specified map of raw messages.
func UnmarshalLoadBalancerLoggingPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerLoggingPatch)
	err = core.UnmarshalModel(m, "datapath", &obj.Datapath, UnmarshalLoadBalancerLoggingDatapathPatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerLoggingPrototype : LoadBalancerLoggingPrototype struct
type LoadBalancerLoggingPrototype struct {
	// The datapath logging configuration for this load balancer.
	Datapath *LoadBalancerLoggingDatapathPrototype `json:"datapath,omitempty"`
}

// UnmarshalLoadBalancerLoggingPrototype unmarshals an instance of LoadBalancerLoggingPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerLoggingPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerLoggingPrototype)
	err = core.UnmarshalModel(m, "datapath", &obj.Datapath, UnmarshalLoadBalancerLoggingDatapathPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPatch : LoadBalancerPatch struct
type LoadBalancerPatch struct {
	// The DNS configuration for this load balancer.
	//
	// Specify `null` to remove the existing DNS configuration, which will remove all DNS `A`
	// records for this load balancer that had been added to `zone`, and add equivalent `A`
	// records to the public DNS zone `lb.appdomain.cloud`.
	Dns *LoadBalancerDnsPatch `json:"dns,omitempty"`

	// The logging configuration to use for this load balancer.
	//
	// To activate logging, the load balancer profile must support the specified logging type.
	Logging *LoadBalancerLoggingPatch `json:"logging,omitempty"`

	// The name for this load balancer. The name must not be used by another load balancer in the VPC.
	Name *string `json:"name,omitempty"`

	// The subnets to provision this load balancer in. The load balancer's availability will depend on the availability of
	// the zones that the subnets reside in.
	//
	// The specified subnets must be in the same VPC as the existing subnets, and will completely replace the existing
	// subnets.
	//
	// The load balancer must be in the `application` family.
	Subnets []SubnetIdentityIntf `json:"subnets,omitempty"`
}

// UnmarshalLoadBalancerPatch unmarshals an instance of LoadBalancerPatch from the specified map of raw messages.
func UnmarshalLoadBalancerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPatch)
	err = core.UnmarshalModel(m, "dns", &obj.Dns, UnmarshalLoadBalancerDnsPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "logging", &obj.Logging, UnmarshalLoadBalancerLoggingPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the LoadBalancerPatch
func (loadBalancerPatch *LoadBalancerPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(loadBalancerPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// LoadBalancerPool : LoadBalancerPool struct
type LoadBalancerPool struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The date and time that this pool was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitor `json:"health_monitor" validate:"required"`

	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The instance group that is managing this pool.
	InstanceGroup *InstanceGroupReference `json:"instance_group,omitempty"`

	// The backend server members of the pool.
	Members []LoadBalancerPoolMemberReference `json:"members,omitempty"`

	// The name for this load balancer pool. The name is unique across all pools for the load balancer.
	Name *string `json:"name" validate:"required"`

	// The protocol for this load balancer pool.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
	// unexpected property value was encountered.
	Protocol *string `json:"protocol" validate:"required"`

	// The provisioning status of this pool
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
	// unexpected property value was encountered.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The PROXY protocol setting for this pool:
	// - `v1`: Enabled with version 1 (human-readable header format)
	// - `v2`: Enabled with version 2 (binary header format)
	// - `disabled`: Disabled
	//
	// Supported by load balancers in the `application` family (otherwise always `disabled`).
	ProxyProtocol *string `json:"proxy_protocol" validate:"required"`

	// The session persistence of this pool.
	//
	// The enumerated values for this property are expected to expand in the future. When
	// processing this property, check for and log unknown values. Optionally halt
	// processing and surface the error, or bypass the pool on which the unexpected
	// property value was encountered.
	SessionPersistence *LoadBalancerPoolSessionPersistence `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPool.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPoolAlgorithmLeastConnectionsConst   = "least_connections"
	LoadBalancerPoolAlgorithmRoundRobinConst         = "round_robin"
	LoadBalancerPoolAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPool.Protocol property.
// The protocol for this load balancer pool.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
// unexpected property value was encountered.
const (
	LoadBalancerPoolProtocolHTTPConst  = "http"
	LoadBalancerPoolProtocolHTTPSConst = "https"
	LoadBalancerPoolProtocolTCPConst   = "tcp"
	LoadBalancerPoolProtocolUDPConst   = "udp"
)

// Constants associated with the LoadBalancerPool.ProvisioningStatus property.
// The provisioning status of this pool
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
// unexpected property value was encountered.
const (
	LoadBalancerPoolProvisioningStatusActiveConst        = "active"
	LoadBalancerPoolProvisioningStatusCreatePendingConst = "create_pending"
	LoadBalancerPoolProvisioningStatusDeletePendingConst = "delete_pending"
	LoadBalancerPoolProvisioningStatusFailedConst        = "failed"
	LoadBalancerPoolProvisioningStatusUpdatePendingConst = "update_pending"
)

// Constants associated with the LoadBalancerPool.ProxyProtocol property.
// The PROXY protocol setting for this pool:
// - `v1`: Enabled with version 1 (human-readable header format)
// - `v2`: Enabled with version 2 (binary header format)
// - `disabled`: Disabled
//
// Supported by load balancers in the `application` family (otherwise always `disabled`).
const (
	LoadBalancerPoolProxyProtocolDisabledConst = "disabled"
	LoadBalancerPoolProxyProtocolV1Const       = "v1"
	LoadBalancerPoolProxyProtocolV2Const       = "v2"
)

// UnmarshalLoadBalancerPool unmarshals an instance of LoadBalancerPool from the specified map of raw messages.
func UnmarshalLoadBalancerPool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPool)
	err = core.UnmarshalPrimitive(m, "algorithm", &obj.Algorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_monitor", &obj.HealthMonitor, UnmarshalLoadBalancerPoolHealthMonitor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_group", &obj.InstanceGroup, UnmarshalInstanceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalLoadBalancerPoolMemberReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "proxy_protocol", &obj.ProxyProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "session_persistence", &obj.SessionPersistence, UnmarshalLoadBalancerPoolSessionPersistence)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolCollection : LoadBalancerPoolCollection struct
type LoadBalancerPoolCollection struct {
	// Collection of pools.
	Pools []LoadBalancerPool `json:"pools" validate:"required"`
}

// UnmarshalLoadBalancerPoolCollection unmarshals an instance of LoadBalancerPoolCollection from the specified map of raw messages.
func UnmarshalLoadBalancerPoolCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolCollection)
	err = core.UnmarshalModel(m, "pools", &obj.Pools, UnmarshalLoadBalancerPool)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolHealthMonitor : LoadBalancerPoolHealthMonitor struct
type LoadBalancerPoolHealthMonitor struct {
	// The seconds to wait between health checks.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port.
	//
	// If present, this overrides the pool member port values.
	Port *int64 `json:"port,omitempty"`

	// The seconds to wait for a response to a health check.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The protocol type to use for health checks.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
	// the unexpected property value was encountered.
	Type *string `json:"type" validate:"required"`

	// The health check URL path. Applicable when `type` is `http` or `https`.
	//
	// Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
	URLPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitor.Type property.
// The protocol type to use for health checks.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
// the unexpected property value was encountered.
const (
	LoadBalancerPoolHealthMonitorTypeHTTPConst  = "http"
	LoadBalancerPoolHealthMonitorTypeHTTPSConst = "https"
	LoadBalancerPoolHealthMonitorTypeTCPConst   = "tcp"
)

// UnmarshalLoadBalancerPoolHealthMonitor unmarshals an instance of LoadBalancerPoolHealthMonitor from the specified map of raw messages.
func UnmarshalLoadBalancerPoolHealthMonitor(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolHealthMonitor)
	err = core.UnmarshalPrimitive(m, "delay", &obj.Delay)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_retries", &obj.MaxRetries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_path", &obj.URLPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolHealthMonitorPatch : LoadBalancerPoolHealthMonitorPatch struct
type LoadBalancerPoolHealthMonitorPatch struct {
	// The seconds to wait between health checks.  Must be greater than `timeout`.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port.
	//
	// If set, this overrides the pool member port values.
	//
	// Specify `null` to remove an existing health check port.
	Port *int64 `json:"port,omitempty"`

	// The seconds to wait for a response to a health check.  Must be less than `delay`.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The protocol type to use for health checks.
	Type *string `json:"type" validate:"required"`

	// The health check URL path. Applicable when `type` is `http` or `https`.
	//
	// Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
	URLPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitorPatch.Type property.
// The protocol type to use for health checks.
const (
	LoadBalancerPoolHealthMonitorPatchTypeHTTPConst  = "http"
	LoadBalancerPoolHealthMonitorPatchTypeHTTPSConst = "https"
	LoadBalancerPoolHealthMonitorPatchTypeTCPConst   = "tcp"
)

// NewLoadBalancerPoolHealthMonitorPatch : Instantiate LoadBalancerPoolHealthMonitorPatch (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolHealthMonitorPatch(delay int64, maxRetries int64, timeout int64, typeVar string) (_model *LoadBalancerPoolHealthMonitorPatch, err error) {
	_model = &LoadBalancerPoolHealthMonitorPatch{
		Delay:      core.Int64Ptr(delay),
		MaxRetries: core.Int64Ptr(maxRetries),
		Timeout:    core.Int64Ptr(timeout),
		Type:       core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPatch unmarshals an instance of LoadBalancerPoolHealthMonitorPatch from the specified map of raw messages.
func UnmarshalLoadBalancerPoolHealthMonitorPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolHealthMonitorPatch)
	err = core.UnmarshalPrimitive(m, "delay", &obj.Delay)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_retries", &obj.MaxRetries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_path", &obj.URLPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolHealthMonitorPrototype : LoadBalancerPoolHealthMonitorPrototype struct
type LoadBalancerPoolHealthMonitorPrototype struct {
	// The seconds to wait between health checks.  Must be greater than `timeout`.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port.
	//
	// If specified, this overrides the pool member port values.
	Port *int64 `json:"port,omitempty"`

	// The seconds to wait for a response to a health check.  Must be less than `delay`.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The protocol type to use for health checks.
	Type *string `json:"type" validate:"required"`

	// The health check URL path. Applicable when `type` is `http` or `https`.
	//
	// Must be in the format of an [origin-form request target](https://tools.ietf.org/html/rfc7230#section-5.3.1).
	URLPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitorPrototype.Type property.
// The protocol type to use for health checks.
const (
	LoadBalancerPoolHealthMonitorPrototypeTypeHTTPConst  = "http"
	LoadBalancerPoolHealthMonitorPrototypeTypeHTTPSConst = "https"
	LoadBalancerPoolHealthMonitorPrototypeTypeTCPConst   = "tcp"
)

// NewLoadBalancerPoolHealthMonitorPrototype : Instantiate LoadBalancerPoolHealthMonitorPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolHealthMonitorPrototype(delay int64, maxRetries int64, timeout int64, typeVar string) (_model *LoadBalancerPoolHealthMonitorPrototype, err error) {
	_model = &LoadBalancerPoolHealthMonitorPrototype{
		Delay:      core.Int64Ptr(delay),
		MaxRetries: core.Int64Ptr(maxRetries),
		Timeout:    core.Int64Ptr(timeout),
		Type:       core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPrototype unmarshals an instance of LoadBalancerPoolHealthMonitorPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolHealthMonitorPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolHealthMonitorPrototype)
	err = core.UnmarshalPrimitive(m, "delay", &obj.Delay)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_retries", &obj.MaxRetries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_path", &obj.URLPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerPoolIdentityByID
// - LoadBalancerPoolIdentityByHref
type LoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerPoolIdentity) isaLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerPoolIdentityIntf interface {
	isaLoadBalancerPoolIdentity() bool
}

// UnmarshalLoadBalancerPoolIdentity unmarshals an instance of LoadBalancerPoolIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentityByName : LoadBalancerPoolIdentityByName struct
type LoadBalancerPoolIdentityByName struct {
	// The name for this load balancer pool. The name is unique across all pools for the load balancer.
	Name *string `json:"name" validate:"required"`
}

// NewLoadBalancerPoolIdentityByName : Instantiate LoadBalancerPoolIdentityByName (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByName(name string) (_model *LoadBalancerPoolIdentityByName, err error) {
	_model = &LoadBalancerPoolIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolIdentityByName unmarshals an instance of LoadBalancerPoolIdentityByName from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMember : LoadBalancerPoolMember struct
type LoadBalancerPoolMember struct {
	// The date and time that this member was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Health of the server member in the pool.
	Health *string `json:"health" validate:"required"`

	// The member's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool member.
	ID *string `json:"id" validate:"required"`

	// The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on a
	// listener with a single port. (If the traffic is received on a listener with a port range, the member will receive
	// the traffic on the same port the listener received it on.)
	//
	// This port will also be used for health checks unless the `port` property of
	// `health_monitor` property is specified.
	Port *int64 `json:"port" validate:"required"`

	// The provisioning status of this member
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool member on which the
	// unexpected property value was encountered.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The pool member target. Load balancers in the `network` family support virtual server
	// instances. Load balancers in the `application` family support IP addresses. If the load
	// balancer has route mode enabled, the member must be in a zone the load balancer has a
	// subnet in.
	Target LoadBalancerPoolMemberTargetIntf `json:"target" validate:"required"`

	// Weight of the server member. Applicable only if the pool algorithm is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// Constants associated with the LoadBalancerPoolMember.Health property.
// Health of the server member in the pool.
const (
	LoadBalancerPoolMemberHealthFaultedConst = "faulted"
	LoadBalancerPoolMemberHealthOkConst      = "ok"
	LoadBalancerPoolMemberHealthUnknownConst = "unknown"
)

// Constants associated with the LoadBalancerPoolMember.ProvisioningStatus property.
// The provisioning status of this member
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool member on which the
// unexpected property value was encountered.
const (
	LoadBalancerPoolMemberProvisioningStatusActiveConst        = "active"
	LoadBalancerPoolMemberProvisioningStatusCreatePendingConst = "create_pending"
	LoadBalancerPoolMemberProvisioningStatusDeletePendingConst = "delete_pending"
	LoadBalancerPoolMemberProvisioningStatusFailedConst        = "failed"
	LoadBalancerPoolMemberProvisioningStatusUpdatePendingConst = "update_pending"
)

// UnmarshalLoadBalancerPoolMember unmarshals an instance of LoadBalancerPoolMember from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMember(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMember)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health", &obj.Health)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerPoolMemberTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "weight", &obj.Weight)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberCollection : LoadBalancerPoolMemberCollection struct
type LoadBalancerPoolMemberCollection struct {
	// Collection of members.
	Members []LoadBalancerPoolMember `json:"members" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberCollection unmarshals an instance of LoadBalancerPoolMemberCollection from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberCollection)
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalLoadBalancerPoolMember)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberPatch : LoadBalancerPoolMemberPatch struct
type LoadBalancerPoolMemberPatch struct {
	// The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on a
	// listener with a single port. (If the traffic is received on a listener with a port range, the member will receive
	// the traffic on the same port the listener received it on.)
	//
	// This port will also be used for health checks unless the `port` property of
	// `health_monitor` property is specified.
	//
	// The port must be unique across all members for all pools associated with this pool's listener.
	Port *int64 `json:"port,omitempty"`

	// The pool member target. Load balancers in the `network` family support virtual server
	// instances. Load balancers in the `application` family support IP addresses. If the load
	// balancer has route mode enabled, the member must be in a zone the load balancer has a
	// subnet in.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target,omitempty"`

	// Weight of the server member. Applicable only if the pool algorithm is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// UnmarshalLoadBalancerPoolMemberPatch unmarshals an instance of LoadBalancerPoolMemberPatch from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberPatch)
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerPoolMemberTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "weight", &obj.Weight)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the LoadBalancerPoolMemberPatch
func (loadBalancerPoolMemberPatch *LoadBalancerPoolMemberPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(loadBalancerPoolMemberPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// LoadBalancerPoolMemberPrototype : LoadBalancerPoolMemberPrototype struct
type LoadBalancerPoolMemberPrototype struct {
	// The port the member will receive load balancer traffic on. Applies only to load balancer traffic received on a
	// listener with a single port. (If the traffic is received on a listener with a port range, the member will receive
	// the traffic on the same port the listener received it on.)
	//
	// This port will also be used for health checks unless the `port` property of
	// `health_monitor` property is specified.
	//
	// The port must be unique across all members for all pools associated with this pool's listener.
	Port *int64 `json:"port" validate:"required"`

	// The pool member target. Load balancers in the `network` family support virtual server
	// instances. Load balancers in the `application` family support IP addresses. If the load
	// balancer has route mode enabled, the member must be in a zone the load balancer has a
	// subnet in.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target" validate:"required"`

	// Weight of the server member. Applicable only if the pool algorithm is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// NewLoadBalancerPoolMemberPrototype : Instantiate LoadBalancerPoolMemberPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberPrototype(port int64, target LoadBalancerPoolMemberTargetPrototypeIntf) (_model *LoadBalancerPoolMemberPrototype, err error) {
	_model = &LoadBalancerPoolMemberPrototype{
		Port:   core.Int64Ptr(port),
		Target: target,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolMemberPrototype unmarshals an instance of LoadBalancerPoolMemberPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberPrototype)
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerPoolMemberTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "weight", &obj.Weight)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberReference : LoadBalancerPoolMemberReference struct
type LoadBalancerPoolMemberReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerPoolMemberReferenceDeleted `json:"deleted,omitempty"`

	// The member's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool member.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberReference unmarshals an instance of LoadBalancerPoolMemberReference from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerPoolMemberReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type LoadBalancerPoolMemberReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberReferenceDeleted unmarshals an instance of LoadBalancerPoolMemberReferenceDeleted from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTarget : The pool member target. Load balancers in the `network` family support virtual server instances. Load balancers in
// the `application` family support IP addresses. If the load balancer has route mode enabled, the member must be in a
// zone the load balancer has a subnet in.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetInstanceReference
// - LoadBalancerPoolMemberTargetIP
type LoadBalancerPoolMemberTarget struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The name for this virtual server instance. The name is unique across all virtual server instances in the region.
	Name *string `json:"name,omitempty"`

	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*LoadBalancerPoolMemberTarget) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

type LoadBalancerPoolMemberTargetIntf interface {
	isaLoadBalancerPoolMemberTarget() bool
}

// UnmarshalLoadBalancerPoolMemberTarget unmarshals an instance of LoadBalancerPoolMemberTarget from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTarget)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototype : The pool member target. Load balancers in the `network` family support virtual server instances. Load balancers in
// the `application` family support IP addresses. If the load balancer has route mode enabled, the member must be in a
// zone the load balancer has a subnet in.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
// - LoadBalancerPoolMemberTargetPrototypeIP
type LoadBalancerPoolMemberTargetPrototype struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`

	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*LoadBalancerPoolMemberTargetPrototype) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

type LoadBalancerPoolMemberTargetPrototypeIntf interface {
	isaLoadBalancerPoolMemberTargetPrototype() bool
}

// UnmarshalLoadBalancerPoolMemberTargetPrototype unmarshals an instance of LoadBalancerPoolMemberTargetPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolPatch : LoadBalancerPoolPatch struct
type LoadBalancerPoolPatch struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm,omitempty"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPatch `json:"health_monitor,omitempty"`

	// The name for this load balancer pool. The name must not be used by another pool for the load balancer.
	Name *string `json:"name,omitempty"`

	// The protocol for this load balancer pool.
	//
	// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
	// `application` family support `tcp`, `http` and
	// `https`.
	//
	// If this pool is associated with a load balancer listener, the specified protocol must match, or be compatible with
	// the listener's protocol. At present, the compatible protocols are `http` and `https`.
	Protocol *string `json:"protocol,omitempty"`

	// The PROXY protocol setting for this pool:
	// - `v1`: Enabled with version 1 (human-readable header format)
	// - `v2`: Enabled with version 2 (binary header format)
	// - `disabled`: Disabled
	//
	// Supported by load balancers in the `application` family (otherwise always `disabled`).
	ProxyProtocol *string `json:"proxy_protocol,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePatch `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPoolPatch.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPoolPatchAlgorithmLeastConnectionsConst   = "least_connections"
	LoadBalancerPoolPatchAlgorithmRoundRobinConst         = "round_robin"
	LoadBalancerPoolPatchAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPoolPatch.Protocol property.
// The protocol for this load balancer pool.
//
// Load balancers in the `network` family support `tcp` and `udp` (if `udp_supported` is `true`). Load balancers in the
// `application` family support `tcp`, `http` and
// `https`.
//
// If this pool is associated with a load balancer listener, the specified protocol must match, or be compatible with
// the listener's protocol. At present, the compatible protocols are `http` and `https`.
const (
	LoadBalancerPoolPatchProtocolHTTPConst  = "http"
	LoadBalancerPoolPatchProtocolHTTPSConst = "https"
	LoadBalancerPoolPatchProtocolTCPConst   = "tcp"
	LoadBalancerPoolPatchProtocolUDPConst   = "udp"
)

// Constants associated with the LoadBalancerPoolPatch.ProxyProtocol property.
// The PROXY protocol setting for this pool:
// - `v1`: Enabled with version 1 (human-readable header format)
// - `v2`: Enabled with version 2 (binary header format)
// - `disabled`: Disabled
//
// Supported by load balancers in the `application` family (otherwise always `disabled`).
const (
	LoadBalancerPoolPatchProxyProtocolDisabledConst = "disabled"
	LoadBalancerPoolPatchProxyProtocolV1Const       = "v1"
	LoadBalancerPoolPatchProxyProtocolV2Const       = "v2"
)

// UnmarshalLoadBalancerPoolPatch unmarshals an instance of LoadBalancerPoolPatch from the specified map of raw messages.
func UnmarshalLoadBalancerPoolPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolPatch)
	err = core.UnmarshalPrimitive(m, "algorithm", &obj.Algorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_monitor", &obj.HealthMonitor, UnmarshalLoadBalancerPoolHealthMonitorPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "proxy_protocol", &obj.ProxyProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "session_persistence", &obj.SessionPersistence, UnmarshalLoadBalancerPoolSessionPersistencePatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the LoadBalancerPoolPatch
func (loadBalancerPoolPatch *LoadBalancerPoolPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(loadBalancerPoolPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// LoadBalancerPoolPrototype : LoadBalancerPoolPrototype struct
type LoadBalancerPoolPrototype struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPrototype `json:"health_monitor" validate:"required"`

	// The members for this load balancer pool. For load balancers in the `network` family, the same `port` and `target`
	// tuple cannot be shared by a pool member of any other load balancer in the same VPC.
	Members []LoadBalancerPoolMemberPrototype `json:"members,omitempty"`

	// The name for this load balancer pool. The name must not be used by another pool for the load balancer. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if
	// `udp_supported` is `true`). Load balancers in the
	// `application` family support `tcp`, `http`, and `https`.
	Protocol *string `json:"protocol" validate:"required"`

	// The PROXY protocol setting for this pool:
	// - `v1`: Enabled with version 1 (human-readable header format)
	// - `v2`: Enabled with version 2 (binary header format)
	// - `disabled`: Disabled
	//
	// Supported by load balancers in the `application` family (otherwise always `disabled`).
	ProxyProtocol *string `json:"proxy_protocol,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePrototype `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPoolPrototype.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPoolPrototypeAlgorithmLeastConnectionsConst   = "least_connections"
	LoadBalancerPoolPrototypeAlgorithmRoundRobinConst         = "round_robin"
	LoadBalancerPoolPrototypeAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPoolPrototype.Protocol property.
// The protocol used for this load balancer pool. Load balancers in the `network` family support `tcp` and `udp` (if
// `udp_supported` is `true`). Load balancers in the
// `application` family support `tcp`, `http`, and `https`.
const (
	LoadBalancerPoolPrototypeProtocolHTTPConst  = "http"
	LoadBalancerPoolPrototypeProtocolHTTPSConst = "https"
	LoadBalancerPoolPrototypeProtocolTCPConst   = "tcp"
	LoadBalancerPoolPrototypeProtocolUDPConst   = "udp"
)

// Constants associated with the LoadBalancerPoolPrototype.ProxyProtocol property.
// The PROXY protocol setting for this pool:
// - `v1`: Enabled with version 1 (human-readable header format)
// - `v2`: Enabled with version 2 (binary header format)
// - `disabled`: Disabled
//
// Supported by load balancers in the `application` family (otherwise always `disabled`).
const (
	LoadBalancerPoolPrototypeProxyProtocolDisabledConst = "disabled"
	LoadBalancerPoolPrototypeProxyProtocolV1Const       = "v1"
	LoadBalancerPoolPrototypeProxyProtocolV2Const       = "v2"
)

// NewLoadBalancerPoolPrototype : Instantiate LoadBalancerPoolPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolPrototype(algorithm string, healthMonitor *LoadBalancerPoolHealthMonitorPrototype, protocol string) (_model *LoadBalancerPoolPrototype, err error) {
	_model = &LoadBalancerPoolPrototype{
		Algorithm:     core.StringPtr(algorithm),
		HealthMonitor: healthMonitor,
		Protocol:      core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolPrototype unmarshals an instance of LoadBalancerPoolPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolPrototype)
	err = core.UnmarshalPrimitive(m, "algorithm", &obj.Algorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_monitor", &obj.HealthMonitor, UnmarshalLoadBalancerPoolHealthMonitorPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalLoadBalancerPoolMemberPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "proxy_protocol", &obj.ProxyProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "session_persistence", &obj.SessionPersistence, UnmarshalLoadBalancerPoolSessionPersistencePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolReference : LoadBalancerPoolReference struct
type LoadBalancerPoolReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerPoolReferenceDeleted `json:"deleted,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The name for this load balancer pool. The name is unique across all pools for the load balancer.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerPoolReference unmarshals an instance of LoadBalancerPoolReference from the specified map of raw messages.
func UnmarshalLoadBalancerPoolReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerPoolReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type LoadBalancerPoolReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalLoadBalancerPoolReferenceDeleted unmarshals an instance of LoadBalancerPoolReferenceDeleted from the specified map of raw messages.
func UnmarshalLoadBalancerPoolReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolSessionPersistence : LoadBalancerPoolSessionPersistence struct
type LoadBalancerPoolSessionPersistence struct {
	// The session persistence cookie name. Applicable only for type `app_cookie`. Names starting with `IBM` are not
	// allowed.
	CookieName *string `json:"cookie_name,omitempty"`

	// The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and `https`
	// protocols.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistence.Type property.
// The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and `https`
// protocols.
const (
	LoadBalancerPoolSessionPersistenceTypeAppCookieConst  = "app_cookie"
	LoadBalancerPoolSessionPersistenceTypeHTTPCookieConst = "http_cookie"
	LoadBalancerPoolSessionPersistenceTypeSourceIPConst   = "source_ip"
)

// UnmarshalLoadBalancerPoolSessionPersistence unmarshals an instance of LoadBalancerPoolSessionPersistence from the specified map of raw messages.
func UnmarshalLoadBalancerPoolSessionPersistence(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolSessionPersistence)
	err = core.UnmarshalPrimitive(m, "cookie_name", &obj.CookieName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolSessionPersistencePatch : The session persistence configuration. Specify `null` to remove any existing session persistence configuration.
type LoadBalancerPoolSessionPersistencePatch struct {
	// The session persistence cookie name. Applicable only for type `app_cookie`. Names starting with `IBM` are not
	// allowed.
	CookieName *string `json:"cookie_name,omitempty"`

	// The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and `https`
	// protocols.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the LoadBalancerPoolSessionPersistencePatch.Type property.
// The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and `https`
// protocols.
const (
	LoadBalancerPoolSessionPersistencePatchTypeAppCookieConst  = "app_cookie"
	LoadBalancerPoolSessionPersistencePatchTypeHTTPCookieConst = "http_cookie"
	LoadBalancerPoolSessionPersistencePatchTypeSourceIPConst   = "source_ip"
)

// UnmarshalLoadBalancerPoolSessionPersistencePatch unmarshals an instance of LoadBalancerPoolSessionPersistencePatch from the specified map of raw messages.
func UnmarshalLoadBalancerPoolSessionPersistencePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolSessionPersistencePatch)
	err = core.UnmarshalPrimitive(m, "cookie_name", &obj.CookieName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolSessionPersistencePrototype : LoadBalancerPoolSessionPersistencePrototype struct
type LoadBalancerPoolSessionPersistencePrototype struct {
	// The session persistence cookie name. Applicable only for type `app_cookie`. Names starting with `IBM` are not
	// allowed.
	CookieName *string `json:"cookie_name,omitempty"`

	// The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and `https`
	// protocols.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistencePrototype.Type property.
// The session persistence type. The `http_cookie` and `app_cookie` types are applicable only to the `http` and `https`
// protocols.
const (
	LoadBalancerPoolSessionPersistencePrototypeTypeAppCookieConst  = "app_cookie"
	LoadBalancerPoolSessionPersistencePrototypeTypeHTTPCookieConst = "http_cookie"
	LoadBalancerPoolSessionPersistencePrototypeTypeSourceIPConst   = "source_ip"
)

// NewLoadBalancerPoolSessionPersistencePrototype : Instantiate LoadBalancerPoolSessionPersistencePrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolSessionPersistencePrototype(typeVar string) (_model *LoadBalancerPoolSessionPersistencePrototype, err error) {
	_model = &LoadBalancerPoolSessionPersistencePrototype{
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePrototype unmarshals an instance of LoadBalancerPoolSessionPersistencePrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolSessionPersistencePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolSessionPersistencePrototype)
	err = core.UnmarshalPrimitive(m, "cookie_name", &obj.CookieName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPrivateIpsItem : LoadBalancerPrivateIpsItem struct
type LoadBalancerPrivateIpsItem struct {
	// The IP address.
	//
	// If the address has not yet been selected, the value will be `0.0.0.0`.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ReservedIPReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this reserved IP.
	ID *string `json:"id" validate:"required"`

	// The name for this reserved IP. The name is unique across all reserved IPs in a subnet.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the LoadBalancerPrivateIpsItem.ResourceType property.
// The resource type.
const (
	LoadBalancerPrivateIpsItemResourceTypeSubnetReservedIPConst = "subnet_reserved_ip"
)

// UnmarshalLoadBalancerPrivateIpsItem unmarshals an instance of LoadBalancerPrivateIpsItem from the specified map of raw messages.
func UnmarshalLoadBalancerPrivateIpsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPrivateIpsItem)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalReservedIPReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfile : LoadBalancerProfile struct
type LoadBalancerProfile struct {
	// The product family this load balancer profile belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this load balancer profile.
	Href *string `json:"href" validate:"required"`

	InstanceGroupsSupported LoadBalancerProfileInstanceGroupsSupportedIntf `json:"instance_groups_supported" validate:"required"`

	// Indicates which logging type(s) are supported for a load balancer with this profile.
	LoggingSupported *LoadBalancerProfileLoggingSupported `json:"logging_supported" validate:"required"`

	// The globally unique name for this load balancer profile.
	Name *string `json:"name" validate:"required"`

	RouteModeSupported LoadBalancerProfileRouteModeSupportedIntf `json:"route_mode_supported" validate:"required"`

	SecurityGroupsSupported LoadBalancerProfileSecurityGroupsSupportedIntf `json:"security_groups_supported" validate:"required"`

	UDPSupported LoadBalancerProfileUDPSupportedIntf `json:"udp_supported" validate:"required"`
}

// UnmarshalLoadBalancerProfile unmarshals an instance of LoadBalancerProfile from the specified map of raw messages.
func UnmarshalLoadBalancerProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfile)
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_groups_supported", &obj.InstanceGroupsSupported, UnmarshalLoadBalancerProfileInstanceGroupsSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "logging_supported", &obj.LoggingSupported, UnmarshalLoadBalancerProfileLoggingSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "route_mode_supported", &obj.RouteModeSupported, UnmarshalLoadBalancerProfileRouteModeSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups_supported", &obj.SecurityGroupsSupported, UnmarshalLoadBalancerProfileSecurityGroupsSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "udp_supported", &obj.UDPSupported, UnmarshalLoadBalancerProfileUDPSupported)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileCollection : LoadBalancerProfileCollection struct
type LoadBalancerProfileCollection struct {
	// A link to the first page of resources.
	First *LoadBalancerProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *LoadBalancerProfileCollectionNext `json:"next,omitempty"`

	// Collection of load balancer profiles.
	Profiles []LoadBalancerProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalLoadBalancerProfileCollection unmarshals an instance of LoadBalancerProfileCollection from the specified map of raw messages.
func UnmarshalLoadBalancerProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalLoadBalancerProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalLoadBalancerProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalLoadBalancerProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *LoadBalancerProfileCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// LoadBalancerProfileCollectionFirst : A link to the first page of resources.
type LoadBalancerProfileCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalLoadBalancerProfileCollectionFirst unmarshals an instance of LoadBalancerProfileCollectionFirst from the specified map of raw messages.
func UnmarshalLoadBalancerProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type LoadBalancerProfileCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalLoadBalancerProfileCollectionNext unmarshals an instance of LoadBalancerProfileCollectionNext from the specified map of raw messages.
func UnmarshalLoadBalancerProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileIdentity : Identifies a load balancer profile by a unique property.
// Models which "extend" this model:
// - LoadBalancerProfileIdentityByName
// - LoadBalancerProfileIdentityByHref
type LoadBalancerProfileIdentity struct {
	// The globally unique name for this load balancer profile.
	Name *string `json:"name,omitempty"`

	// The URL for this load balancer profile.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerProfileIdentity) isaLoadBalancerProfileIdentity() bool {
	return true
}

type LoadBalancerProfileIdentityIntf interface {
	isaLoadBalancerProfileIdentity() bool
}

// UnmarshalLoadBalancerProfileIdentity unmarshals an instance of LoadBalancerProfileIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileInstanceGroupsSupported : LoadBalancerProfileInstanceGroupsSupported struct
// Models which "extend" this model:
// - LoadBalancerProfileInstanceGroupsSupportedFixed
// - LoadBalancerProfileInstanceGroupsSupportedDependent
type LoadBalancerProfileInstanceGroupsSupported struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *bool `json:"value,omitempty"`
}

// Constants associated with the LoadBalancerProfileInstanceGroupsSupported.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileInstanceGroupsSupportedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileInstanceGroupsSupported) isaLoadBalancerProfileInstanceGroupsSupported() bool {
	return true
}

type LoadBalancerProfileInstanceGroupsSupportedIntf interface {
	isaLoadBalancerProfileInstanceGroupsSupported() bool
}

// UnmarshalLoadBalancerProfileInstanceGroupsSupported unmarshals an instance of LoadBalancerProfileInstanceGroupsSupported from the specified map of raw messages.
func UnmarshalLoadBalancerProfileInstanceGroupsSupported(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileInstanceGroupsSupported)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileLoggingSupported : Indicates which logging type(s) are supported for a load balancer with this profile.
type LoadBalancerProfileLoggingSupported struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported logging type(s) for a load balancer with this profile.
	Value []string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerProfileLoggingSupported.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileLoggingSupportedTypeFixedConst = "fixed"
)

// UnmarshalLoadBalancerProfileLoggingSupported unmarshals an instance of LoadBalancerProfileLoggingSupported from the specified map of raw messages.
func UnmarshalLoadBalancerProfileLoggingSupported(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileLoggingSupported)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileReference : LoadBalancerProfileReference struct
type LoadBalancerProfileReference struct {
	// The product family this load balancer profile belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this load balancer profile.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this load balancer profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerProfileReference unmarshals an instance of LoadBalancerProfileReference from the specified map of raw messages.
func UnmarshalLoadBalancerProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileReference)
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileRouteModeSupported : LoadBalancerProfileRouteModeSupported struct
// Models which "extend" this model:
// - LoadBalancerProfileRouteModeSupportedFixed
// - LoadBalancerProfileRouteModeSupportedDependent
type LoadBalancerProfileRouteModeSupported struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *bool `json:"value,omitempty"`
}

// Constants associated with the LoadBalancerProfileRouteModeSupported.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileRouteModeSupportedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileRouteModeSupported) isaLoadBalancerProfileRouteModeSupported() bool {
	return true
}

type LoadBalancerProfileRouteModeSupportedIntf interface {
	isaLoadBalancerProfileRouteModeSupported() bool
}

// UnmarshalLoadBalancerProfileRouteModeSupported unmarshals an instance of LoadBalancerProfileRouteModeSupported from the specified map of raw messages.
func UnmarshalLoadBalancerProfileRouteModeSupported(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileRouteModeSupported)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileSecurityGroupsSupported : LoadBalancerProfileSecurityGroupsSupported struct
// Models which "extend" this model:
// - LoadBalancerProfileSecurityGroupsSupportedFixed
// - LoadBalancerProfileSecurityGroupsSupportedDependent
type LoadBalancerProfileSecurityGroupsSupported struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *bool `json:"value,omitempty"`
}

// Constants associated with the LoadBalancerProfileSecurityGroupsSupported.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileSecurityGroupsSupportedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileSecurityGroupsSupported) isaLoadBalancerProfileSecurityGroupsSupported() bool {
	return true
}

type LoadBalancerProfileSecurityGroupsSupportedIntf interface {
	isaLoadBalancerProfileSecurityGroupsSupported() bool
}

// UnmarshalLoadBalancerProfileSecurityGroupsSupported unmarshals an instance of LoadBalancerProfileSecurityGroupsSupported from the specified map of raw messages.
func UnmarshalLoadBalancerProfileSecurityGroupsSupported(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileSecurityGroupsSupported)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileUDPSupported : LoadBalancerProfileUDPSupported struct
// Models which "extend" this model:
// - LoadBalancerProfileUDPSupportedFixed
// - LoadBalancerProfileUDPSupportedDependent
type LoadBalancerProfileUDPSupported struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *bool `json:"value,omitempty"`
}

// Constants associated with the LoadBalancerProfileUDPSupported.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileUDPSupportedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileUDPSupported) isaLoadBalancerProfileUDPSupported() bool {
	return true
}

type LoadBalancerProfileUDPSupportedIntf interface {
	isaLoadBalancerProfileUDPSupported() bool
}

// UnmarshalLoadBalancerProfileUDPSupported unmarshals an instance of LoadBalancerProfileUDPSupported from the specified map of raw messages.
func UnmarshalLoadBalancerProfileUDPSupported(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileUDPSupported)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type LoadBalancerReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalLoadBalancerReferenceDeleted unmarshals an instance of LoadBalancerReferenceDeleted from the specified map of raw messages.
func UnmarshalLoadBalancerReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerStatistics : LoadBalancerStatistics struct
type LoadBalancerStatistics struct {
	// Number of active connections of this load balancer.
	ActiveConnections *int64 `json:"active_connections" validate:"required"`

	// Current connection rate (connections per second) of this load balancer.
	ConnectionRate *float32 `json:"connection_rate" validate:"required"`

	// Total number of data processed (bytes) of this load balancer within current calendar month.
	DataProcessedThisMonth *int64 `json:"data_processed_this_month" validate:"required"`

	// Current throughput (Mbps) of this load balancer.
	Throughput *float32 `json:"throughput" validate:"required"`
}

// UnmarshalLoadBalancerStatistics unmarshals an instance of LoadBalancerStatistics from the specified map of raw messages.
func UnmarshalLoadBalancerStatistics(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerStatistics)
	err = core.UnmarshalPrimitive(m, "active_connections", &obj.ActiveConnections)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_rate", &obj.ConnectionRate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "data_processed_this_month", &obj.DataProcessedThisMonth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "throughput", &obj.Throughput)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACL : NetworkACL struct
type NetworkACL struct {
	// The date and time that the network ACL was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The name for this network ACL. The name is unique across all network ACLs for the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this network ACL.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The ordered rules for this network ACL. If no rules exist, all traffic will be denied.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The subnets to which this network ACL is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this network ACL resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalNetworkACL unmarshals an instance of NetworkACL from the specified map of raw messages.
func UnmarshalNetworkACL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACL)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRuleItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLCollection : NetworkACLCollection struct
type NetworkACLCollection struct {
	// A link to the first page of resources.
	First *NetworkACLCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of network ACLs.
	NetworkAcls []NetworkACL `json:"network_acls" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *NetworkACLCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalNetworkACLCollection unmarshals an instance of NetworkACLCollection from the specified map of raw messages.
func UnmarshalNetworkACLCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalNetworkACLCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acls", &obj.NetworkAcls, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNetworkACLCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *NetworkACLCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// NetworkACLCollectionFirst : A link to the first page of resources.
type NetworkACLCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLCollectionFirst unmarshals an instance of NetworkACLCollectionFirst from the specified map of raw messages.
func UnmarshalNetworkACLCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type NetworkACLCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLCollectionNext unmarshals an instance of NetworkACLCollectionNext from the specified map of raw messages.
func UnmarshalNetworkACLCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentity : Identifies a network ACL by a unique property.
// Models which "extend" this model:
// - NetworkACLIdentityByID
// - NetworkACLIdentityByCRN
// - NetworkACLIdentityByHref
type NetworkACLIdentity struct {
	// The unique identifier for this network ACL.
	ID *string `json:"id,omitempty"`

	// The CRN for this network ACL.
	CRN *string `json:"crn,omitempty"`

	// The URL for this network ACL.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLIdentity) isaNetworkACLIdentity() bool {
	return true
}

type NetworkACLIdentityIntf interface {
	isaNetworkACLIdentity() bool
}

// UnmarshalNetworkACLIdentity unmarshals an instance of NetworkACLIdentity from the specified map of raw messages.
func UnmarshalNetworkACLIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLPatch : NetworkACLPatch struct
type NetworkACLPatch struct {
	// The name for this network ACL. The name must not be used by another network ACL for the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalNetworkACLPatch unmarshals an instance of NetworkACLPatch from the specified map of raw messages.
func UnmarshalNetworkACLPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the NetworkACLPatch
func (networkACLPatch *NetworkACLPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(networkACLPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// NetworkACLPrototype : NetworkACLPrototype struct
// Models which "extend" this model:
// - NetworkACLPrototypeNetworkACLByRules
// - NetworkACLPrototypeNetworkACLBySourceNetworkACL
type NetworkACLPrototype struct {
	// The name for this network ACL. The name must not be used by another network ACL for the VPC. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The prototype objects for rules to create along with this network ACL. If unspecified, no rules will be created,
	// resulting in all traffic being denied.
	Rules []NetworkACLRulePrototypeNetworkACLContextIntf `json:"rules,omitempty"`

	// Network ACL to copy rules from.
	SourceNetworkACL NetworkACLIdentityIntf `json:"source_network_acl,omitempty"`
}

func (*NetworkACLPrototype) isaNetworkACLPrototype() bool {
	return true
}

type NetworkACLPrototypeIntf interface {
	isaNetworkACLPrototype() bool
}

// UnmarshalNetworkACLPrototype unmarshals an instance of NetworkACLPrototype from the specified map of raw messages.
func UnmarshalNetworkACLPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRulePrototypeNetworkACLContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_network_acl", &obj.SourceNetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLReference : NetworkACLReference struct
type NetworkACLReference struct {
	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkACLReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The name for this network ACL. The name is unique across all network ACLs for the VPC.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalNetworkACLReference unmarshals an instance of NetworkACLReference from the specified map of raw messages.
func UnmarshalNetworkACLReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkACLReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type NetworkACLReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalNetworkACLReferenceDeleted unmarshals an instance of NetworkACLReferenceDeleted from the specified map of raw messages.
func UnmarshalNetworkACLReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRule : NetworkACLRule struct
// Models which "extend" this model:
// - NetworkACLRuleNetworkACLRuleProtocolTcpudp
// - NetworkACLRuleNetworkACLRuleProtocolIcmp
// - NetworkACLRuleNetworkACLRuleProtocolAll
type NetworkACLRule struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to match.
	//
	// If absent, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to match.
	//
	// If absent, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRule.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleActionAllowConst = "allow"
	NetworkACLRuleActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRule.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleDirectionInboundConst  = "inbound"
	NetworkACLRuleDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRule.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRule.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolAllConst  = "all"
	NetworkACLRuleProtocolIcmpConst = "icmp"
	NetworkACLRuleProtocolTCPConst  = "tcp"
	NetworkACLRuleProtocolUDPConst  = "udp"
)

func (*NetworkACLRule) isaNetworkACLRule() bool {
	return true
}

type NetworkACLRuleIntf interface {
	isaNetworkACLRule() bool
}

// UnmarshalNetworkACLRule unmarshals an instance of NetworkACLRule from the specified map of raw messages.
func UnmarshalNetworkACLRule(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleNetworkACLRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleNetworkACLRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleNetworkACLRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleNetworkACLRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRuleBeforePatch : The rule to move this rule immediately before.
//
// Specify `null` to move this rule after all existing rules.
// Models which "extend" this model:
// - NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID
// - NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref
type NetworkACLRuleBeforePatch struct {
	// The unique identifier for this network ACL rule.
	ID *string `json:"id,omitempty"`

	// The URL for this network ACL rule.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLRuleBeforePatch) isaNetworkACLRuleBeforePatch() bool {
	return true
}

type NetworkACLRuleBeforePatchIntf interface {
	isaNetworkACLRuleBeforePatch() bool
}

// UnmarshalNetworkACLRuleBeforePatch unmarshals an instance of NetworkACLRuleBeforePatch from the specified map of raw messages.
func UnmarshalNetworkACLRuleBeforePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleBeforePatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleBeforePrototype : The rule to insert this rule immediately before.
//
// If unspecified, this rule will be inserted after all existing rules.
// Models which "extend" this model:
// - NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID
// - NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref
type NetworkACLRuleBeforePrototype struct {
	// The unique identifier for this network ACL rule.
	ID *string `json:"id,omitempty"`

	// The URL for this network ACL rule.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLRuleBeforePrototype) isaNetworkACLRuleBeforePrototype() bool {
	return true
}

type NetworkACLRuleBeforePrototypeIntf interface {
	isaNetworkACLRuleBeforePrototype() bool
}

// UnmarshalNetworkACLRuleBeforePrototype unmarshals an instance of NetworkACLRuleBeforePrototype from the specified map of raw messages.
func UnmarshalNetworkACLRuleBeforePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleBeforePrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleCollection : NetworkACLRuleCollection struct
type NetworkACLRuleCollection struct {
	// A link to the first page of resources.
	First *NetworkACLRuleCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *NetworkACLRuleCollectionNext `json:"next,omitempty"`

	// Ordered collection of network ACL rules.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalNetworkACLRuleCollection unmarshals an instance of NetworkACLRuleCollection from the specified map of raw messages.
func UnmarshalNetworkACLRuleCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalNetworkACLRuleCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNetworkACLRuleCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRuleItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *NetworkACLRuleCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// NetworkACLRuleCollectionFirst : A link to the first page of resources.
type NetworkACLRuleCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLRuleCollectionFirst unmarshals an instance of NetworkACLRuleCollectionFirst from the specified map of raw messages.
func UnmarshalNetworkACLRuleCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type NetworkACLRuleCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLRuleCollectionNext unmarshals an instance of NetworkACLRuleCollectionNext from the specified map of raw messages.
func UnmarshalNetworkACLRuleCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItem : NetworkACLRuleItem struct
// Models which "extend" this model:
// - NetworkACLRuleItemNetworkACLRuleProtocolTcpudp
// - NetworkACLRuleItemNetworkACLRuleProtocolIcmp
// - NetworkACLRuleItemNetworkACLRuleProtocolAll
type NetworkACLRuleItem struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. In a rule collection, this always
	// refers to the next item in the collection. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to match.
	//
	// If absent, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to match.
	//
	// If absent, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleItem.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleItemActionAllowConst = "allow"
	NetworkACLRuleItemActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItem.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleItemDirectionInboundConst  = "inbound"
	NetworkACLRuleItemDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItem.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleItem.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemProtocolAllConst  = "all"
	NetworkACLRuleItemProtocolIcmpConst = "icmp"
	NetworkACLRuleItemProtocolTCPConst  = "tcp"
	NetworkACLRuleItemProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleItem) isaNetworkACLRuleItem() bool {
	return true
}

type NetworkACLRuleItemIntf interface {
	isaNetworkACLRuleItem() bool
}

// UnmarshalNetworkACLRuleItem unmarshals an instance of NetworkACLRuleItem from the specified map of raw messages.
func UnmarshalNetworkACLRuleItem(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRulePatch : NetworkACLRulePatch struct
type NetworkACLRulePatch struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action,omitempty"`

	// The rule to move this rule immediately before.
	//
	// Specify `null` to move this rule after all existing rules.
	Before NetworkACLRuleBeforePatchIntf `json:"before,omitempty"`

	// The ICMP traffic code to match. If set, `type` must also be set.
	//
	// Specify `null` to remove an existing ICMP traffic code.
	Code *int64 `json:"code,omitempty"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The direction of traffic to match.
	Direction *string `json:"direction,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic type to match.
	//
	// Specify `null` to remove an existing ICMP traffic type value.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePatch.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePatchActionAllowConst = "allow"
	NetworkACLRulePatchActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePatch.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePatchDirectionInboundConst  = "inbound"
	NetworkACLRulePatchDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePatch.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePatchProtocolAllConst  = "all"
	NetworkACLRulePatchProtocolIcmpConst = "icmp"
	NetworkACLRulePatchProtocolTCPConst  = "tcp"
	NetworkACLRulePatchProtocolUDPConst  = "udp"
)

// UnmarshalNetworkACLRulePatch unmarshals an instance of NetworkACLRulePatch from the specified map of raw messages.
func UnmarshalNetworkACLRulePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePatch)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleBeforePatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the NetworkACLRulePatch
func (networkACLRulePatch *NetworkACLRulePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(networkACLRulePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// NetworkACLRulePrototype : NetworkACLRulePrototype struct
// Models which "extend" this model:
// - NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype
// - NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype
// - NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype
type NetworkACLRulePrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule to insert this rule immediately before.
	//
	// If unspecified, this rule will be inserted after all existing rules.
	Before NetworkACLRuleBeforePrototypeIntf `json:"before,omitempty"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to match.
	//
	// If specified, `type` must also be specified.  If unspecified, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to match.
	//
	// If unspecified, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeProtocolAllConst  = "all"
	NetworkACLRulePrototypeProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeProtocolUDPConst  = "udp"
)

func (*NetworkACLRulePrototype) isaNetworkACLRulePrototype() bool {
	return true
}

type NetworkACLRulePrototypeIntf interface {
	isaNetworkACLRulePrototype() bool
}

// UnmarshalNetworkACLRulePrototype unmarshals an instance of NetworkACLRulePrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRulePrototypeNetworkACLContext : NetworkACLRulePrototypeNetworkACLContext struct
// Models which "extend" this model:
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype
type NetworkACLRulePrototypeNetworkACLContext struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to match.
	//
	// If specified, `type` must also be specified.  If unspecified, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to match.
	//
	// If unspecified, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLContextActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLContextDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLContextProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLContextProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextProtocolUDPConst  = "udp"
)

func (*NetworkACLRulePrototypeNetworkACLContext) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

type NetworkACLRulePrototypeNetworkACLContextIntf interface {
	isaNetworkACLRulePrototypeNetworkACLContext() bool
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContext unmarshals an instance of NetworkACLRulePrototypeNetworkACLContext from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContext(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRuleReference : NetworkACLRuleReference struct
type NetworkACLRuleReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkACLRuleReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalNetworkACLRuleReference unmarshals an instance of NetworkACLRuleReference from the specified map of raw messages.
func UnmarshalNetworkACLRuleReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkACLRuleReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type NetworkACLRuleReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalNetworkACLRuleReferenceDeleted unmarshals an instance of NetworkACLRuleReferenceDeleted from the specified map of raw messages.
func UnmarshalNetworkACLRuleReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterface : NetworkInterface struct
type NetworkInterface struct {
	// Indicates whether source IP spoofing is allowed on this instance interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing" validate:"required"`

	// The date and time that the instance network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The floating IPs associated with this instance network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips" validate:"required"`

	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this instance network interface.
	Name *string `json:"name" validate:"required"`

	// The instance network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this instance network interface.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the instance network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The instance network interface type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the NetworkInterface.ResourceType property.
// The resource type.
const (
	NetworkInterfaceResourceTypeNetworkInterfaceConst = "network_interface"
)

// Constants associated with the NetworkInterface.Status property.
// The status of the instance network interface.
const (
	NetworkInterfaceStatusAvailableConst = "available"
	NetworkInterfaceStatusDeletingConst  = "deleting"
	NetworkInterfaceStatusFailedConst    = "failed"
	NetworkInterfaceStatusPendingConst   = "pending"
)

// Constants associated with the NetworkInterface.Type property.
// The instance network interface type.
const (
	NetworkInterfaceTypePrimaryConst   = "primary"
	NetworkInterfaceTypeSecondaryConst = "secondary"
)

// UnmarshalNetworkInterface unmarshals an instance of NetworkInterface from the specified map of raw messages.
func UnmarshalNetworkInterface(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterface)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_speed", &obj.PortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceBareMetalServerContextReference : NetworkInterfaceBareMetalServerContextReference struct
type NetworkInterfaceBareMetalServerContextReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceBareMetalServerContextReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the NetworkInterfaceBareMetalServerContextReference.ResourceType property.
// The resource type.
const (
	NetworkInterfaceBareMetalServerContextReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

// UnmarshalNetworkInterfaceBareMetalServerContextReference unmarshals an instance of NetworkInterfaceBareMetalServerContextReference from the specified map of raw messages.
func UnmarshalNetworkInterfaceBareMetalServerContextReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceBareMetalServerContextReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceBareMetalServerContextReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceBareMetalServerContextReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type NetworkInterfaceBareMetalServerContextReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalNetworkInterfaceBareMetalServerContextReferenceDeleted unmarshals an instance of NetworkInterfaceBareMetalServerContextReferenceDeleted from the specified map of raw messages.
func UnmarshalNetworkInterfaceBareMetalServerContextReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceBareMetalServerContextReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIPPrototype : NetworkInterfaceIPPrototype struct
// Models which "extend" this model:
// - NetworkInterfaceIPPrototypeReservedIPIdentity
// - NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext
type NetworkInterfaceIPPrototype struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href,omitempty"`

	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`
}

func (*NetworkInterfaceIPPrototype) isaNetworkInterfaceIPPrototype() bool {
	return true
}

type NetworkInterfaceIPPrototypeIntf interface {
	isaNetworkInterfaceIPPrototype() bool
}

// UnmarshalNetworkInterfaceIPPrototype unmarshals an instance of NetworkInterfaceIPPrototype from the specified map of raw messages.
func UnmarshalNetworkInterfaceIPPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIPPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceInstanceContextReference : NetworkInterfaceInstanceContextReference struct
type NetworkInterfaceInstanceContextReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceInstanceContextReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this instance network interface.
	Name *string `json:"name" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the NetworkInterfaceInstanceContextReference.ResourceType property.
// The resource type.
const (
	NetworkInterfaceInstanceContextReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

// UnmarshalNetworkInterfaceInstanceContextReference unmarshals an instance of NetworkInterfaceInstanceContextReference from the specified map of raw messages.
func UnmarshalNetworkInterfaceInstanceContextReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceInstanceContextReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceInstanceContextReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceInstanceContextReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type NetworkInterfaceInstanceContextReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalNetworkInterfaceInstanceContextReferenceDeleted unmarshals an instance of NetworkInterfaceInstanceContextReferenceDeleted from the specified map of raw messages.
func UnmarshalNetworkInterfaceInstanceContextReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceInstanceContextReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfacePatch : NetworkInterfacePatch struct
type NetworkInterfacePatch struct {
	// Indicates whether source IP spoofing is allowed on this instance interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// The name for the instance network interface. The name must not be used by another network interface on the virtual
	// server instance.
	Name *string `json:"name,omitempty"`
}

// UnmarshalNetworkInterfacePatch unmarshals an instance of NetworkInterfacePatch from the specified map of raw messages.
func UnmarshalNetworkInterfacePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfacePatch)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the NetworkInterfacePatch
func (networkInterfacePatch *NetworkInterfacePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(networkInterfacePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// NetworkInterfacePrototype : NetworkInterfacePrototype struct
type NetworkInterfacePrototype struct {
	// Indicates whether source IP spoofing is allowed on this instance interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// The name for the instance network interface. The name must not be used by another network interface on the virtual
	// server instance. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the instance network interface. This can be
	// specified using an existing reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must
	// be available on the instance network interface's subnet. Otherwise, an
	// available address on the subnet will be automatically selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this instance network interface. If unspecified, the VPC's default security group is
	// used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`
}

// NewNetworkInterfacePrototype : Instantiate NetworkInterfacePrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfacePrototype(subnet SubnetIdentityIntf) (_model *NetworkInterfacePrototype, err error) {
	_model = &NetworkInterfacePrototype{
		Subnet: subnet,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalNetworkInterfacePrototype unmarshals an instance of NetworkInterfacePrototype from the specified map of raw messages.
func UnmarshalNetworkInterfacePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfacePrototype)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalNetworkInterfaceIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type NetworkInterfaceReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalNetworkInterfaceReferenceDeleted unmarshals an instance of NetworkInterfaceReferenceDeleted from the specified map of raw messages.
func UnmarshalNetworkInterfaceReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceReferenceTargetContextDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type NetworkInterfaceReferenceTargetContextDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalNetworkInterfaceReferenceTargetContextDeleted unmarshals an instance of NetworkInterfaceReferenceTargetContextDeleted from the specified map of raw messages.
func UnmarshalNetworkInterfaceReferenceTargetContextDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceReferenceTargetContextDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceUnpaginatedCollection : NetworkInterfaceUnpaginatedCollection struct
type NetworkInterfaceUnpaginatedCollection struct {
	// Collection of instance network interfaces.
	NetworkInterfaces []NetworkInterface `json:"network_interfaces" validate:"required"`
}

// UnmarshalNetworkInterfaceUnpaginatedCollection unmarshals an instance of NetworkInterfaceUnpaginatedCollection from the specified map of raw messages.
func UnmarshalNetworkInterfaceUnpaginatedCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceUnpaginatedCollection)
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObsoleteImageOptions : The ObsoleteImage options.
type ObsoleteImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewObsoleteImageOptions : Instantiate ObsoleteImageOptions
func (*VpcV1) NewObsoleteImageOptions(id string) *ObsoleteImageOptions {
	return &ObsoleteImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ObsoleteImageOptions) SetID(id string) *ObsoleteImageOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ObsoleteImageOptions) SetHeaders(param map[string]string) *ObsoleteImageOptions {
	options.Headers = param
	return options
}

// OperatingSystem : OperatingSystem struct
type OperatingSystem struct {
	// The operating system architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// Images with this operating system can only be used on dedicated hosts or dedicated host groups.
	DedicatedHostOnly *bool `json:"dedicated_host_only" validate:"required"`

	// A unique, display-friendly name for the operating system.
	DisplayName *string `json:"display_name" validate:"required"`

	// The software family for this operating system.
	Family *string `json:"family" validate:"required"`

	// The URL for this operating system.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this operating system.
	Name *string `json:"name" validate:"required"`

	// The vendor of the operating system.
	Vendor *string `json:"vendor" validate:"required"`

	// The major release version of this operating system.
	Version *string `json:"version" validate:"required"`
}

// UnmarshalOperatingSystem unmarshals an instance of OperatingSystem from the specified map of raw messages.
func UnmarshalOperatingSystem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystem)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dedicated_host_only", &obj.DedicatedHostOnly)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vendor", &obj.Vendor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemCollection : OperatingSystemCollection struct
type OperatingSystemCollection struct {
	// A link to the first page of resources.
	First *OperatingSystemCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *OperatingSystemCollectionNext `json:"next,omitempty"`

	// Collection of operating systems.
	OperatingSystems []OperatingSystem `json:"operating_systems" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalOperatingSystemCollection unmarshals an instance of OperatingSystemCollection from the specified map of raw messages.
func UnmarshalOperatingSystemCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalOperatingSystemCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalOperatingSystemCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_systems", &obj.OperatingSystems, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *OperatingSystemCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// OperatingSystemCollectionFirst : A link to the first page of resources.
type OperatingSystemCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalOperatingSystemCollectionFirst unmarshals an instance of OperatingSystemCollectionFirst from the specified map of raw messages.
func UnmarshalOperatingSystemCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type OperatingSystemCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalOperatingSystemCollectionNext unmarshals an instance of OperatingSystemCollectionNext from the specified map of raw messages.
func UnmarshalOperatingSystemCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemIdentity : Identifies an operating system by a unique property.
// Models which "extend" this model:
// - OperatingSystemIdentityByName
// - OperatingSystemIdentityByHref
type OperatingSystemIdentity struct {
	// The globally unique name for this operating system.
	Name *string `json:"name,omitempty"`

	// The URL for this operating system.
	Href *string `json:"href,omitempty"`
}

func (*OperatingSystemIdentity) isaOperatingSystemIdentity() bool {
	return true
}

type OperatingSystemIdentityIntf interface {
	isaOperatingSystemIdentity() bool
}

// UnmarshalOperatingSystemIdentity unmarshals an instance of OperatingSystemIdentity from the specified map of raw messages.
func UnmarshalOperatingSystemIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PlacementGroup : PlacementGroup struct
type PlacementGroup struct {
	// The date and time that the placement group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this placement group.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this placement group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this placement group.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the placement group.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this placement group. The name is unique across all placement groups in the region.
	Name *string `json:"name" validate:"required"`

	// The resource group for this placement group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The strategy for this placement group
	// - `host_spread`: place on different compute hosts
	// - `power_spread`: place on compute hosts that use different power sources
	//
	// The enumerated values for this property may expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
	// unexpected strategy was encountered.
	Strategy *string `json:"strategy" validate:"required"`
}

// Constants associated with the PlacementGroup.LifecycleState property.
// The lifecycle state of the placement group.
const (
	PlacementGroupLifecycleStateDeletingConst  = "deleting"
	PlacementGroupLifecycleStateFailedConst    = "failed"
	PlacementGroupLifecycleStatePendingConst   = "pending"
	PlacementGroupLifecycleStateStableConst    = "stable"
	PlacementGroupLifecycleStateSuspendedConst = "suspended"
	PlacementGroupLifecycleStateUpdatingConst  = "updating"
	PlacementGroupLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the PlacementGroup.ResourceType property.
// The resource type.
const (
	PlacementGroupResourceTypePlacementGroupConst = "placement_group"
)

// Constants associated with the PlacementGroup.Strategy property.
// The strategy for this placement group
// - `host_spread`: place on different compute hosts
// - `power_spread`: place on compute hosts that use different power sources
//
// The enumerated values for this property may expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the placement group on which the
// unexpected strategy was encountered.
const (
	PlacementGroupStrategyHostSpreadConst  = "host_spread"
	PlacementGroupStrategyPowerSpreadConst = "power_spread"
)

// UnmarshalPlacementGroup unmarshals an instance of PlacementGroup from the specified map of raw messages.
func UnmarshalPlacementGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroup)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "strategy", &obj.Strategy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PlacementGroupCollection : PlacementGroupCollection struct
type PlacementGroupCollection struct {
	// A link to the first page of resources.
	First *PlacementGroupCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *PlacementGroupCollectionNext `json:"next,omitempty"`

	// Collection of placement groups.
	PlacementGroups []PlacementGroup `json:"placement_groups" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalPlacementGroupCollection unmarshals an instance of PlacementGroupCollection from the specified map of raw messages.
func UnmarshalPlacementGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPlacementGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPlacementGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_groups", &obj.PlacementGroups, UnmarshalPlacementGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *PlacementGroupCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// PlacementGroupCollectionFirst : A link to the first page of resources.
type PlacementGroupCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPlacementGroupCollectionFirst unmarshals an instance of PlacementGroupCollectionFirst from the specified map of raw messages.
func UnmarshalPlacementGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PlacementGroupCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type PlacementGroupCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPlacementGroupCollectionNext unmarshals an instance of PlacementGroupCollectionNext from the specified map of raw messages.
func UnmarshalPlacementGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PlacementGroupPatch : PlacementGroupPatch struct
type PlacementGroupPatch struct {
	// The name for this placement group. The name must not be used by another placement group in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalPlacementGroupPatch unmarshals an instance of PlacementGroupPatch from the specified map of raw messages.
func UnmarshalPlacementGroupPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroupPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the PlacementGroupPatch
func (placementGroupPatch *PlacementGroupPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(placementGroupPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// PlacementGroupReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type PlacementGroupReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalPlacementGroupReferenceDeleted unmarshals an instance of PlacementGroupReferenceDeleted from the specified map of raw messages.
func UnmarshalPlacementGroupReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroupReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGateway : PublicGateway struct
type PublicGateway struct {
	// The date and time that the public gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`

	// The floating IP bound to this public gateway.
	FloatingIP *PublicGatewayFloatingIP `json:"floating_ip" validate:"required"`

	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this public gateway. The name is unique across all public gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this public gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of this public gateway.
	Status *string `json:"status" validate:"required"`

	// The VPC this public gateway resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone this public gateway resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the PublicGateway.ResourceType property.
// The resource type.
const (
	PublicGatewayResourceTypePublicGatewayConst = "public_gateway"
)

// Constants associated with the PublicGateway.Status property.
// The status of this public gateway.
const (
	PublicGatewayStatusAvailableConst = "available"
	PublicGatewayStatusDeletingConst  = "deleting"
	PublicGatewayStatusFailedConst    = "failed"
	PublicGatewayStatusPendingConst   = "pending"
)

// UnmarshalPublicGateway unmarshals an instance of PublicGateway from the specified map of raw messages.
func UnmarshalPublicGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGateway)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ip", &obj.FloatingIP, UnmarshalPublicGatewayFloatingIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayCollection : PublicGatewayCollection struct
type PublicGatewayCollection struct {
	// A link to the first page of resources.
	First *PublicGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *PublicGatewayCollectionNext `json:"next,omitempty"`

	// Collection of public gateways.
	PublicGateways []PublicGateway `json:"public_gateways" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalPublicGatewayCollection unmarshals an instance of PublicGatewayCollection from the specified map of raw messages.
func UnmarshalPublicGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPublicGatewayCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPublicGatewayCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateways", &obj.PublicGateways, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *PublicGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// PublicGatewayCollectionFirst : A link to the first page of resources.
type PublicGatewayCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPublicGatewayCollectionFirst unmarshals an instance of PublicGatewayCollectionFirst from the specified map of raw messages.
func UnmarshalPublicGatewayCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type PublicGatewayCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPublicGatewayCollectionNext unmarshals an instance of PublicGatewayCollectionNext from the specified map of raw messages.
func UnmarshalPublicGatewayCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIP : The floating IP bound to this public gateway.
type PublicGatewayFloatingIP struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *FloatingIPReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The name for this floating IP. The name is unique across all floating IPs in the region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalPublicGatewayFloatingIP unmarshals an instance of PublicGatewayFloatingIP from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalFloatingIPReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototype : PublicGatewayFloatingIPPrototype struct
// Models which "extend" this model:
// - PublicGatewayFloatingIPPrototypeFloatingIPIdentity
// - PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext
type PublicGatewayFloatingIPPrototype struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id,omitempty"`

	// The CRN for this floating IP.
	CRN *string `json:"crn,omitempty"`

	// The URL for this floating IP.
	Href *string `json:"href,omitempty"`

	// The globally unique IP address.
	Address *string `json:"address,omitempty"`

	// The name for this floating IP. The name must not be used by another floating IP in the region. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

func (*PublicGatewayFloatingIPPrototype) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

type PublicGatewayFloatingIPPrototypeIntf interface {
	isaPublicGatewayFloatingIPPrototype() bool
}

// UnmarshalPublicGatewayFloatingIPPrototype unmarshals an instance of PublicGatewayFloatingIPPrototype from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentity : Identifies a public gateway by a unique property.
// Models which "extend" this model:
// - PublicGatewayIdentityPublicGatewayIdentityByID
// - PublicGatewayIdentityPublicGatewayIdentityByCRN
// - PublicGatewayIdentityPublicGatewayIdentityByHref
type PublicGatewayIdentity struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id,omitempty"`

	// The CRN for this public gateway.
	CRN *string `json:"crn,omitempty"`

	// The URL for this public gateway.
	Href *string `json:"href,omitempty"`
}

func (*PublicGatewayIdentity) isaPublicGatewayIdentity() bool {
	return true
}

type PublicGatewayIdentityIntf interface {
	isaPublicGatewayIdentity() bool
}

// UnmarshalPublicGatewayIdentity unmarshals an instance of PublicGatewayIdentity from the specified map of raw messages.
func UnmarshalPublicGatewayIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPatch : PublicGatewayPatch struct
type PublicGatewayPatch struct {
	// The name for this public gateway. The name must not be used by another public gateway in the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalPublicGatewayPatch unmarshals an instance of PublicGatewayPatch from the specified map of raw messages.
func UnmarshalPublicGatewayPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the PublicGatewayPatch
func (publicGatewayPatch *PublicGatewayPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(publicGatewayPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// PublicGatewayReference : PublicGatewayReference struct
type PublicGatewayReference struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *PublicGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this public gateway. The name is unique across all public gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the PublicGatewayReference.ResourceType property.
// The resource type.
const (
	PublicGatewayReferenceResourceTypePublicGatewayConst = "public_gateway"
)

// UnmarshalPublicGatewayReference unmarshals an instance of PublicGatewayReference from the specified map of raw messages.
func UnmarshalPublicGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalPublicGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type PublicGatewayReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalPublicGatewayReferenceDeleted unmarshals an instance of PublicGatewayReferenceDeleted from the specified map of raw messages.
func UnmarshalPublicGatewayReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Region : Region struct
type Region struct {
	// The API endpoint for this region.
	Endpoint *string `json:"endpoint" validate:"required"`

	// The URL for this region.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this region.
	Name *string `json:"name" validate:"required"`

	// The availability status of this region.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the Region.Status property.
// The availability status of this region.
const (
	RegionStatusAvailableConst   = "available"
	RegionStatusUnavailableConst = "unavailable"
)

// UnmarshalRegion unmarshals an instance of Region from the specified map of raw messages.
func UnmarshalRegion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Region)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionCollection : RegionCollection struct
type RegionCollection struct {
	// Collection of regions.
	Regions []Region `json:"regions" validate:"required"`
}

// UnmarshalRegionCollection unmarshals an instance of RegionCollection from the specified map of raw messages.
func UnmarshalRegionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionCollection)
	err = core.UnmarshalModel(m, "regions", &obj.Regions, UnmarshalRegion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionIdentity : Identifies a region by a unique property.
// Models which "extend" this model:
// - RegionIdentityByName
// - RegionIdentityByHref
type RegionIdentity struct {
	// The globally unique name for this region.
	Name *string `json:"name,omitempty"`

	// The URL for this region.
	Href *string `json:"href,omitempty"`
}

func (*RegionIdentity) isaRegionIdentity() bool {
	return true
}

type RegionIdentityIntf interface {
	isaRegionIdentity() bool
}

// UnmarshalRegionIdentity unmarshals an instance of RegionIdentity from the specified map of raw messages.
func UnmarshalRegionIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionReference : RegionReference struct
type RegionReference struct {
	// The URL for this region.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalRegionReference unmarshals an instance of RegionReference from the specified map of raw messages.
func UnmarshalRegionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoveBareMetalServerNetworkInterfaceFloatingIPOptions : The RemoveBareMetalServerNetworkInterfaceFloatingIP options.
type RemoveBareMetalServerNetworkInterfaceFloatingIPOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveBareMetalServerNetworkInterfaceFloatingIPOptions : Instantiate RemoveBareMetalServerNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewRemoveBareMetalServerNetworkInterfaceFloatingIPOptions(bareMetalServerID string, networkInterfaceID string, id string) *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions {
	return &RemoveBareMetalServerNetworkInterfaceFloatingIPOptions{
		BareMetalServerID:  core.StringPtr(bareMetalServerID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions) SetBareMetalServerID(bareMetalServerID string) *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions) SetID(id string) *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *RemoveBareMetalServerNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// RemoveEndpointGatewayIPOptions : The RemoveEndpointGatewayIP options.
type RemoveEndpointGatewayIPOptions struct {
	// The endpoint gateway identifier.
	EndpointGatewayID *string `json:"endpoint_gateway_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveEndpointGatewayIPOptions : Instantiate RemoveEndpointGatewayIPOptions
func (*VpcV1) NewRemoveEndpointGatewayIPOptions(endpointGatewayID string, id string) *RemoveEndpointGatewayIPOptions {
	return &RemoveEndpointGatewayIPOptions{
		EndpointGatewayID: core.StringPtr(endpointGatewayID),
		ID:                core.StringPtr(id),
	}
}

// SetEndpointGatewayID : Allow user to set EndpointGatewayID
func (_options *RemoveEndpointGatewayIPOptions) SetEndpointGatewayID(endpointGatewayID string) *RemoveEndpointGatewayIPOptions {
	_options.EndpointGatewayID = core.StringPtr(endpointGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *RemoveEndpointGatewayIPOptions) SetID(id string) *RemoveEndpointGatewayIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveEndpointGatewayIPOptions) SetHeaders(param map[string]string) *RemoveEndpointGatewayIPOptions {
	options.Headers = param
	return options
}

// RemoveInstanceNetworkInterfaceFloatingIPOptions : The RemoveInstanceNetworkInterfaceFloatingIP options.
type RemoveInstanceNetworkInterfaceFloatingIPOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required,ne="`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveInstanceNetworkInterfaceFloatingIPOptions : Instantiate RemoveInstanceNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewRemoveInstanceNetworkInterfaceFloatingIPOptions(instanceID string, networkInterfaceID string, id string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	return &RemoveInstanceNetworkInterfaceFloatingIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetInstanceID(instanceID string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (_options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	_options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetID(id string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// RemoveVPNGatewayConnectionLocalCIDROptions : The RemoveVPNGatewayConnectionLocalCIDR options.
type RemoveVPNGatewayConnectionLocalCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required,ne="`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveVPNGatewayConnectionLocalCIDROptions : Instantiate RemoveVPNGatewayConnectionLocalCIDROptions
func (*VpcV1) NewRemoveVPNGatewayConnectionLocalCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	return &RemoveVPNGatewayConnectionLocalCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *RemoveVPNGatewayConnectionLocalCIDROptions) SetVPNGatewayID(vpnGatewayID string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *RemoveVPNGatewayConnectionLocalCIDROptions) SetID(id string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (_options *RemoveVPNGatewayConnectionLocalCIDROptions) SetCIDRPrefix(cidrPrefix string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	_options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return _options
}

// SetPrefixLength : Allow user to set PrefixLength
func (_options *RemoveVPNGatewayConnectionLocalCIDROptions) SetPrefixLength(prefixLength string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	_options.PrefixLength = core.StringPtr(prefixLength)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveVPNGatewayConnectionLocalCIDROptions) SetHeaders(param map[string]string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	options.Headers = param
	return options
}

// RemoveVPNGatewayConnectionPeerCIDROptions : The RemoveVPNGatewayConnectionPeerCIDR options.
type RemoveVPNGatewayConnectionPeerCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required,ne="`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveVPNGatewayConnectionPeerCIDROptions : Instantiate RemoveVPNGatewayConnectionPeerCIDROptions
func (*VpcV1) NewRemoveVPNGatewayConnectionPeerCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	return &RemoveVPNGatewayConnectionPeerCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *RemoveVPNGatewayConnectionPeerCIDROptions) SetVPNGatewayID(vpnGatewayID string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *RemoveVPNGatewayConnectionPeerCIDROptions) SetID(id string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (_options *RemoveVPNGatewayConnectionPeerCIDROptions) SetCIDRPrefix(cidrPrefix string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	_options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return _options
}

// SetPrefixLength : Allow user to set PrefixLength
func (_options *RemoveVPNGatewayConnectionPeerCIDROptions) SetPrefixLength(prefixLength string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	_options.PrefixLength = core.StringPtr(prefixLength)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveVPNGatewayConnectionPeerCIDROptions) SetHeaders(param map[string]string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	options.Headers = param
	return options
}

// ReplaceLoadBalancerPoolMembersOptions : The ReplaceLoadBalancerPoolMembers options.
type ReplaceLoadBalancerPoolMembersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required,ne="`

	// The member prototype objects for this pool.
	Members []LoadBalancerPoolMemberPrototype `json:"members" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceLoadBalancerPoolMembersOptions : Instantiate ReplaceLoadBalancerPoolMembersOptions
func (*VpcV1) NewReplaceLoadBalancerPoolMembersOptions(loadBalancerID string, poolID string, members []LoadBalancerPoolMemberPrototype) *ReplaceLoadBalancerPoolMembersOptions {
	return &ReplaceLoadBalancerPoolMembersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		Members:        members,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *ReplaceLoadBalancerPoolMembersOptions) SetLoadBalancerID(loadBalancerID string) *ReplaceLoadBalancerPoolMembersOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetPoolID : Allow user to set PoolID
func (_options *ReplaceLoadBalancerPoolMembersOptions) SetPoolID(poolID string) *ReplaceLoadBalancerPoolMembersOptions {
	_options.PoolID = core.StringPtr(poolID)
	return _options
}

// SetMembers : Allow user to set Members
func (_options *ReplaceLoadBalancerPoolMembersOptions) SetMembers(members []LoadBalancerPoolMemberPrototype) *ReplaceLoadBalancerPoolMembersOptions {
	_options.Members = members
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceLoadBalancerPoolMembersOptions) SetHeaders(param map[string]string) *ReplaceLoadBalancerPoolMembersOptions {
	options.Headers = param
	return options
}

// ReplaceSubnetNetworkACLOptions : The ReplaceSubnetNetworkACL options.
type ReplaceSubnetNetworkACLOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The network ACL identity.
	NetworkACLIdentity NetworkACLIdentityIntf `json:"NetworkACLIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceSubnetNetworkACLOptions : Instantiate ReplaceSubnetNetworkACLOptions
func (*VpcV1) NewReplaceSubnetNetworkACLOptions(id string, networkACLIdentity NetworkACLIdentityIntf) *ReplaceSubnetNetworkACLOptions {
	return &ReplaceSubnetNetworkACLOptions{
		ID:                 core.StringPtr(id),
		NetworkACLIdentity: networkACLIdentity,
	}
}

// SetID : Allow user to set ID
func (_options *ReplaceSubnetNetworkACLOptions) SetID(id string) *ReplaceSubnetNetworkACLOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetNetworkACLIdentity : Allow user to set NetworkACLIdentity
func (_options *ReplaceSubnetNetworkACLOptions) SetNetworkACLIdentity(networkACLIdentity NetworkACLIdentityIntf) *ReplaceSubnetNetworkACLOptions {
	_options.NetworkACLIdentity = networkACLIdentity
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceSubnetNetworkACLOptions) SetHeaders(param map[string]string) *ReplaceSubnetNetworkACLOptions {
	options.Headers = param
	return options
}

// ReplaceSubnetRoutingTableOptions : The ReplaceSubnetRoutingTable options.
type ReplaceSubnetRoutingTableOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The routing table identity.
	RoutingTableIdentity RoutingTableIdentityIntf `json:"RoutingTableIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceSubnetRoutingTableOptions : Instantiate ReplaceSubnetRoutingTableOptions
func (*VpcV1) NewReplaceSubnetRoutingTableOptions(id string, routingTableIdentity RoutingTableIdentityIntf) *ReplaceSubnetRoutingTableOptions {
	return &ReplaceSubnetRoutingTableOptions{
		ID:                   core.StringPtr(id),
		RoutingTableIdentity: routingTableIdentity,
	}
}

// SetID : Allow user to set ID
func (_options *ReplaceSubnetRoutingTableOptions) SetID(id string) *ReplaceSubnetRoutingTableOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetRoutingTableIdentity : Allow user to set RoutingTableIdentity
func (_options *ReplaceSubnetRoutingTableOptions) SetRoutingTableIdentity(routingTableIdentity RoutingTableIdentityIntf) *ReplaceSubnetRoutingTableOptions {
	_options.RoutingTableIdentity = routingTableIdentity
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceSubnetRoutingTableOptions) SetHeaders(param map[string]string) *ReplaceSubnetRoutingTableOptions {
	options.Headers = param
	return options
}

// ReservedIP : ReservedIP struct
type ReservedIP struct {
	// The IP address.
	//
	// If the address has not yet been selected, the value will be `0.0.0.0`.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// The date and time that the reserved IP was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this reserved IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this reserved IP.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the reserved IP.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this reserved IP. The name is unique across all reserved IPs in a subnet.
	Name *string `json:"name" validate:"required"`

	// The owner of the reserved IP.
	Owner *string `json:"owner" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The target this reserved IP is bound to.
	//
	// If absent, this reserved IP is provider-owned or unbound.
	Target ReservedIPTargetIntf `json:"target,omitempty"`
}

// Constants associated with the ReservedIP.LifecycleState property.
// The lifecycle state of the reserved IP.
const (
	ReservedIPLifecycleStateDeletingConst  = "deleting"
	ReservedIPLifecycleStateFailedConst    = "failed"
	ReservedIPLifecycleStatePendingConst   = "pending"
	ReservedIPLifecycleStateStableConst    = "stable"
	ReservedIPLifecycleStateSuspendedConst = "suspended"
	ReservedIPLifecycleStateUpdatingConst  = "updating"
	ReservedIPLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the ReservedIP.Owner property.
// The owner of the reserved IP.
const (
	ReservedIPOwnerProviderConst = "provider"
	ReservedIPOwnerUserConst     = "user"
)

// Constants associated with the ReservedIP.ResourceType property.
// The resource type.
const (
	ReservedIPResourceTypeSubnetReservedIPConst = "subnet_reserved_ip"
)

// UnmarshalReservedIP unmarshals an instance of ReservedIP from the specified map of raw messages.
func UnmarshalReservedIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "owner", &obj.Owner)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalReservedIPTarget)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollection : ReservedIPCollection struct
type ReservedIPCollection struct {
	// A link to the first page of resources.
	First *ReservedIPCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ReservedIPCollectionNext `json:"next,omitempty"`

	// Collection of reserved IPs in this subnet.
	ReservedIps []ReservedIP `json:"reserved_ips" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalReservedIPCollection unmarshals an instance of ReservedIPCollection from the specified map of raw messages.
func UnmarshalReservedIPCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalReservedIPCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalReservedIPCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "reserved_ips", &obj.ReservedIps, UnmarshalReservedIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ReservedIPCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ReservedIPCollectionBareMetalServerNetworkInterfaceContext : ReservedIPCollectionBareMetalServerNetworkInterfaceContext struct
type ReservedIPCollectionBareMetalServerNetworkInterfaceContext struct {
	// A link to the first page of resources.
	First *ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst `json:"first" validate:"required"`

	// Collection of reserved IPs bound to a bare metal server network interface.
	Ips []ReservedIP `json:"ips" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContext unmarshals an instance of ReservedIPCollectionBareMetalServerNetworkInterfaceContext from the specified map of raw messages.
func UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionBareMetalServerNetworkInterfaceContext)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ips", &obj.Ips, UnmarshalReservedIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContextNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst : A link to the first page of resources.
type ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst unmarshals an instance of ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst from the specified map of raw messages.
func UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionBareMetalServerNetworkInterfaceContextFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext : A link to the next page of resources. This property is present for all pages except the last page.
type ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContextNext unmarshals an instance of ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext from the specified map of raw messages.
func UnmarshalReservedIPCollectionBareMetalServerNetworkInterfaceContextNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionBareMetalServerNetworkInterfaceContextNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionEndpointGatewayContext : ReservedIPCollectionEndpointGatewayContext struct
type ReservedIPCollectionEndpointGatewayContext struct {
	// A link to the first page of resources.
	First *ReservedIPCollectionEndpointGatewayContextFirst `json:"first" validate:"required"`

	// Collection of reserved IPs bound to an endpoint gateway.
	Ips []ReservedIP `json:"ips" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ReservedIPCollectionEndpointGatewayContextNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalReservedIPCollectionEndpointGatewayContext unmarshals an instance of ReservedIPCollectionEndpointGatewayContext from the specified map of raw messages.
func UnmarshalReservedIPCollectionEndpointGatewayContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionEndpointGatewayContext)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalReservedIPCollectionEndpointGatewayContextFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ips", &obj.Ips, UnmarshalReservedIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalReservedIPCollectionEndpointGatewayContextNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ReservedIPCollectionEndpointGatewayContext) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ReservedIPCollectionEndpointGatewayContextFirst : A link to the first page of resources.
type ReservedIPCollectionEndpointGatewayContextFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionEndpointGatewayContextFirst unmarshals an instance of ReservedIPCollectionEndpointGatewayContextFirst from the specified map of raw messages.
func UnmarshalReservedIPCollectionEndpointGatewayContextFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionEndpointGatewayContextFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionEndpointGatewayContextNext : A link to the next page of resources. This property is present for all pages except the last page.
type ReservedIPCollectionEndpointGatewayContextNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionEndpointGatewayContextNext unmarshals an instance of ReservedIPCollectionEndpointGatewayContextNext from the specified map of raw messages.
func UnmarshalReservedIPCollectionEndpointGatewayContextNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionEndpointGatewayContextNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionFirst : A link to the first page of resources.
type ReservedIPCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionFirst unmarshals an instance of ReservedIPCollectionFirst from the specified map of raw messages.
func UnmarshalReservedIPCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionInstanceNetworkInterfaceContext : ReservedIPCollectionInstanceNetworkInterfaceContext struct
type ReservedIPCollectionInstanceNetworkInterfaceContext struct {
	// A link to the first page of resources.
	First *ReservedIPCollectionInstanceNetworkInterfaceContextFirst `json:"first" validate:"required"`

	// Collection of reserved IPs bound to an instance network interface.
	Ips []ReservedIP `json:"ips" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ReservedIPCollectionInstanceNetworkInterfaceContextNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalReservedIPCollectionInstanceNetworkInterfaceContext unmarshals an instance of ReservedIPCollectionInstanceNetworkInterfaceContext from the specified map of raw messages.
func UnmarshalReservedIPCollectionInstanceNetworkInterfaceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionInstanceNetworkInterfaceContext)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalReservedIPCollectionInstanceNetworkInterfaceContextFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ips", &obj.Ips, UnmarshalReservedIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalReservedIPCollectionInstanceNetworkInterfaceContextNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ReservedIPCollectionInstanceNetworkInterfaceContext) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ReservedIPCollectionInstanceNetworkInterfaceContextFirst : A link to the first page of resources.
type ReservedIPCollectionInstanceNetworkInterfaceContextFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionInstanceNetworkInterfaceContextFirst unmarshals an instance of ReservedIPCollectionInstanceNetworkInterfaceContextFirst from the specified map of raw messages.
func UnmarshalReservedIPCollectionInstanceNetworkInterfaceContextFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionInstanceNetworkInterfaceContextFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionInstanceNetworkInterfaceContextNext : A link to the next page of resources. This property is present for all pages except the last page.
type ReservedIPCollectionInstanceNetworkInterfaceContextNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionInstanceNetworkInterfaceContextNext unmarshals an instance of ReservedIPCollectionInstanceNetworkInterfaceContextNext from the specified map of raw messages.
func UnmarshalReservedIPCollectionInstanceNetworkInterfaceContextNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionInstanceNetworkInterfaceContextNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type ReservedIPCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalReservedIPCollectionNext unmarshals an instance of ReservedIPCollectionNext from the specified map of raw messages.
func UnmarshalReservedIPCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPPatch : ReservedIPPatch struct
type ReservedIPPatch struct {
	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound. Must be `false` if the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed.
	Name *string `json:"name,omitempty"`
}

// UnmarshalReservedIPPatch unmarshals an instance of ReservedIPPatch from the specified map of raw messages.
func UnmarshalReservedIPPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPPatch)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the ReservedIPPatch
func (reservedIPPatch *ReservedIPPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(reservedIPPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// ReservedIPReference : ReservedIPReference struct
type ReservedIPReference struct {
	// The IP address.
	//
	// If the address has not yet been selected, the value will be `0.0.0.0`.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ReservedIPReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this reserved IP.
	ID *string `json:"id" validate:"required"`

	// The name for this reserved IP. The name is unique across all reserved IPs in a subnet.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPReference.ResourceType property.
// The resource type.
const (
	ReservedIPReferenceResourceTypeSubnetReservedIPConst = "subnet_reserved_ip"
)

// UnmarshalReservedIPReference unmarshals an instance of ReservedIPReference from the specified map of raw messages.
func UnmarshalReservedIPReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPReference)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalReservedIPReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type ReservedIPReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalReservedIPReferenceDeleted unmarshals an instance of ReservedIPReferenceDeleted from the specified map of raw messages.
func UnmarshalReservedIPReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTarget : The target this reserved IP is bound to.
//
// If absent, this reserved IP is provider-owned or unbound.
// Models which "extend" this model:
// - ReservedIPTargetEndpointGatewayReference
// - ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext
// - ReservedIPTargetNetworkInterfaceReferenceTargetContext
// - ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext
// - ReservedIPTargetLoadBalancerReference
// - ReservedIPTargetVPNGatewayReference
// - ReservedIPTargetVPNServerReference
// - ReservedIPTargetGenericResourceReference
type ReservedIPTarget struct {
	// The CRN for this endpoint gateway.
	CRN *string `json:"crn,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *EndpointGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this endpoint gateway.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this endpoint gateway.
	ID *string `json:"id,omitempty"`

	// The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the ReservedIPTarget.ResourceType property.
// The resource type.
const (
	ReservedIPTargetResourceTypeEndpointGatewayConst = "endpoint_gateway"
)

func (*ReservedIPTarget) isaReservedIPTarget() bool {
	return true
}

type ReservedIPTargetIntf interface {
	isaReservedIPTarget() bool
}

// UnmarshalReservedIPTarget unmarshals an instance of ReservedIPTarget from the specified map of raw messages.
func UnmarshalReservedIPTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTarget)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalEndpointGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetPrototype : The target to bind this reserved IP to.  The target must be in the same VPC.
//
// At present, only endpoint gateway targets are supported.  The endpoint gateway must not be already bound to a
// reserved IP in the subnet's zone.
//
// If unspecified, the reserved IP will be created unbound.
// Models which "extend" this model:
// - ReservedIPTargetPrototypeEndpointGatewayIdentity
type ReservedIPTargetPrototype struct {
	// The unique identifier for this endpoint gateway.
	ID *string `json:"id,omitempty"`

	// The CRN for this endpoint gateway.
	CRN *string `json:"crn,omitempty"`

	// The URL for this endpoint gateway.
	Href *string `json:"href,omitempty"`
}

func (*ReservedIPTargetPrototype) isaReservedIPTargetPrototype() bool {
	return true
}

type ReservedIPTargetPrototypeIntf interface {
	isaReservedIPTargetPrototype() bool
}

// UnmarshalReservedIPTargetPrototype unmarshals an instance of ReservedIPTargetPrototype from the specified map of raw messages.
func UnmarshalReservedIPTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceFilter : Identifies one or more resources according to the specified filter property.
type ResourceFilter struct {
	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// UnmarshalResourceFilter unmarshals an instance of ResourceFilter from the specified map of raw messages.
func UnmarshalResourceFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceFilter)
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
// Models which "extend" this model:
// - ResourceGroupIdentityByID
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id,omitempty"`
}

func (*ResourceGroupIdentity) isaResourceGroupIdentity() bool {
	return true
}

type ResourceGroupIdentityIntf interface {
	isaResourceGroupIdentity() bool
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : ResourceGroupReference struct
type ResourceGroupReference struct {
	// The URL for this resource group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`

	// The name for this resource group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RestartBareMetalServerOptions : The RestartBareMetalServer options.
type RestartBareMetalServerOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRestartBareMetalServerOptions : Instantiate RestartBareMetalServerOptions
func (*VpcV1) NewRestartBareMetalServerOptions(id string) *RestartBareMetalServerOptions {
	return &RestartBareMetalServerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *RestartBareMetalServerOptions) SetID(id string) *RestartBareMetalServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RestartBareMetalServerOptions) SetHeaders(param map[string]string) *RestartBareMetalServerOptions {
	options.Headers = param
	return options
}

// Route : Route struct
type Route struct {
	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to system-provided routes
	// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action" validate:"required"`

	// The date and time that the route was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If present, the resource that created the route. Routes with this property present cannot
	// be directly deleted. All routes with an `origin` of `service` will have this property set,
	// and future `origin` values may also have this property set.
	Creator RouteCreatorIntf `json:"creator,omitempty"`

	// The destination CIDR of the route.
	Destination *string `json:"destination" validate:"required"`

	// The URL for this route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this route.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the route.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this route. The name is unique across all routes in the routing table.
	Name *string `json:"name" validate:"required"`

	// If `action` is `deliver`, the next hop that packets will be delivered to.  For
	// other `action` values, its `address` will be `0.0.0.0`.
	NextHop RouteNextHopIntf `json:"next_hop" validate:"required"`

	// The origin of this route:
	// - `service`: route was directly created by a service
	// - `user`: route was directly created by a user
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
	// unexpected property value was encountered.
	Origin *string `json:"origin,omitempty"`

	// The priority of this route. Smaller values have higher priority.
	//
	// If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
	// priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
	// distributed between them.
	Priority *int64 `json:"priority" validate:"required"`

	// The zone the route applies to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Route.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to system-provided routes
// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	RouteActionDelegateConst    = "delegate"
	RouteActionDelegateVPCConst = "delegate_vpc"
	RouteActionDeliverConst     = "deliver"
	RouteActionDropConst        = "drop"
)

// Constants associated with the Route.LifecycleState property.
// The lifecycle state of the route.
const (
	RouteLifecycleStateDeletingConst  = "deleting"
	RouteLifecycleStateFailedConst    = "failed"
	RouteLifecycleStatePendingConst   = "pending"
	RouteLifecycleStateStableConst    = "stable"
	RouteLifecycleStateSuspendedConst = "suspended"
	RouteLifecycleStateUpdatingConst  = "updating"
	RouteLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the Route.Origin property.
// The origin of this route:
// - `service`: route was directly created by a service
// - `user`: route was directly created by a user
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
// unexpected property value was encountered.
const (
	RouteOriginServiceConst = "service"
	RouteOriginUserConst    = "user"
)

// UnmarshalRoute unmarshals an instance of Route from the specified map of raw messages.
func UnmarshalRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Route)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "creator", &obj.Creator, UnmarshalRouteCreator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next_hop", &obj.NextHop, UnmarshalRouteNextHop)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "origin", &obj.Origin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollection : RouteCollection struct
type RouteCollection struct {
	// A link to the first page of resources.
	First *RouteCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *RouteCollectionNext `json:"next,omitempty"`

	// Collection of routes.
	Routes []Route `json:"routes" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalRouteCollection unmarshals an instance of RouteCollection from the specified map of raw messages.
func UnmarshalRouteCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalRouteCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalRouteCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRoute)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *RouteCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// RouteCollectionFirst : A link to the first page of resources.
type RouteCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRouteCollectionFirst unmarshals an instance of RouteCollectionFirst from the specified map of raw messages.
func UnmarshalRouteCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type RouteCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRouteCollectionNext unmarshals an instance of RouteCollectionNext from the specified map of raw messages.
func UnmarshalRouteCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollectionVPCContext : RouteCollectionVPCContext struct
type RouteCollectionVPCContext struct {
	// A link to the first page of resources.
	First *RouteCollectionVPCContextFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *RouteCollectionVPCContextNext `json:"next,omitempty"`

	// Collection of routes.
	Routes []RouteCollectionVPCContextRoutesItem `json:"routes" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalRouteCollectionVPCContext unmarshals an instance of RouteCollectionVPCContext from the specified map of raw messages.
func UnmarshalRouteCollectionVPCContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionVPCContext)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalRouteCollectionVPCContextFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalRouteCollectionVPCContextNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteCollectionVPCContextRoutesItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *RouteCollectionVPCContext) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// RouteCollectionVPCContextFirst : A link to the first page of resources.
type RouteCollectionVPCContextFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRouteCollectionVPCContextFirst unmarshals an instance of RouteCollectionVPCContextFirst from the specified map of raw messages.
func UnmarshalRouteCollectionVPCContextFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionVPCContextFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollectionVPCContextNext : A link to the next page of resources. This property is present for all pages except the last page.
type RouteCollectionVPCContextNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRouteCollectionVPCContextNext unmarshals an instance of RouteCollectionVPCContextNext from the specified map of raw messages.
func UnmarshalRouteCollectionVPCContextNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionVPCContextNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollectionVPCContextRoutesItem : RouteCollectionVPCContextRoutesItem struct
type RouteCollectionVPCContextRoutesItem struct {
	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to system-provided routes
	// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action" validate:"required"`

	// The date and time that the route was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If present, the resource that created the route. Routes with this property present cannot
	// be directly deleted. All routes with an `origin` of `service` will have this property set,
	// and future `origin` values may also have this property set.
	Creator RouteCreatorIntf `json:"creator,omitempty"`

	// The destination CIDR of the route.
	Destination *string `json:"destination" validate:"required"`

	// The URL for this route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this route.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the route.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this route. The name is unique across all routes in the routing table.
	Name *string `json:"name" validate:"required"`

	// If `action` is `deliver`, the next hop that packets will be delivered to.  For
	// other `action` values, its `address` will be `0.0.0.0`.
	NextHop RouteNextHopIntf `json:"next_hop" validate:"required"`

	// The origin of this route:
	// - `service`: route was directly created by a service
	// - `user`: route was directly created by a user
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
	// unexpected property value was encountered.
	Origin *string `json:"origin,omitempty"`

	// The priority of this route. Smaller values have higher priority.
	//
	// If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
	// priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
	// distributed between them.
	Priority *int64 `json:"priority" validate:"required"`

	// The zone the route applies to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the RouteCollectionVPCContextRoutesItem.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to system-provided routes
// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	RouteCollectionVPCContextRoutesItemActionDelegateConst    = "delegate"
	RouteCollectionVPCContextRoutesItemActionDelegateVPCConst = "delegate_vpc"
	RouteCollectionVPCContextRoutesItemActionDeliverConst     = "deliver"
	RouteCollectionVPCContextRoutesItemActionDropConst        = "drop"
)

// Constants associated with the RouteCollectionVPCContextRoutesItem.LifecycleState property.
// The lifecycle state of the route.
const (
	RouteCollectionVPCContextRoutesItemLifecycleStateDeletingConst  = "deleting"
	RouteCollectionVPCContextRoutesItemLifecycleStateFailedConst    = "failed"
	RouteCollectionVPCContextRoutesItemLifecycleStatePendingConst   = "pending"
	RouteCollectionVPCContextRoutesItemLifecycleStateStableConst    = "stable"
	RouteCollectionVPCContextRoutesItemLifecycleStateSuspendedConst = "suspended"
	RouteCollectionVPCContextRoutesItemLifecycleStateUpdatingConst  = "updating"
	RouteCollectionVPCContextRoutesItemLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the RouteCollectionVPCContextRoutesItem.Origin property.
// The origin of this route:
// - `service`: route was directly created by a service
// - `user`: route was directly created by a user
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
// unexpected property value was encountered.
const (
	RouteCollectionVPCContextRoutesItemOriginServiceConst = "service"
	RouteCollectionVPCContextRoutesItemOriginUserConst    = "user"
)

// UnmarshalRouteCollectionVPCContextRoutesItem unmarshals an instance of RouteCollectionVPCContextRoutesItem from the specified map of raw messages.
func UnmarshalRouteCollectionVPCContextRoutesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionVPCContextRoutesItem)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "creator", &obj.Creator, UnmarshalRouteCreator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next_hop", &obj.NextHop, UnmarshalRouteNextHop)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "origin", &obj.Origin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCreator : If present, the resource that created the route. Routes with this property present cannot be directly deleted. All
// routes with an `origin` of `service` will have this property set, and future `origin` values may also have this
// property set.
// Models which "extend" this model:
// - RouteCreatorVPNGatewayReference
// - RouteCreatorVPNServerReference
type RouteCreator struct {
	// The VPN gateway's CRN.
	CRN *string `json:"crn,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id,omitempty"`

	// The name for this VPN gateway. The name is unique across all VPN gateways in the VPC.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the RouteCreator.ResourceType property.
// The resource type.
const (
	RouteCreatorResourceTypeVPNGatewayConst = "vpn_gateway"
)

func (*RouteCreator) isaRouteCreator() bool {
	return true
}

type RouteCreatorIntf interface {
	isaRouteCreator() bool
}

// UnmarshalRouteCreator unmarshals an instance of RouteCreator from the specified map of raw messages.
func UnmarshalRouteCreator(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCreator)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHop : RouteNextHop struct
// Models which "extend" this model:
// - RouteNextHopIP
// - RouteNextHopVPNGatewayConnectionReference
type RouteNextHop struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNGatewayConnectionReferenceDeleted `json:"deleted,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id,omitempty"`

	// The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the RouteNextHop.ResourceType property.
// The resource type.
const (
	RouteNextHopResourceTypeVPNGatewayConnectionConst = "vpn_gateway_connection"
)

func (*RouteNextHop) isaRouteNextHop() bool {
	return true
}

type RouteNextHopIntf interface {
	isaRouteNextHop() bool
}

// UnmarshalRouteNextHop unmarshals an instance of RouteNextHop from the specified map of raw messages.
func UnmarshalRouteNextHop(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHop)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNGatewayConnectionReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatch : If `action` is `deliver`, the next hop that packets will be delivered to. For other
// `action` values, specify `0.0.0.0` or remove it by specifying `null`.
//
// At most two routes per `zone` in a table can have the same `destination` and `priority`, and only when each route has
// an `action` of `deliver` and `next_hop` is an IP address.
// Models which "extend" this model:
// - RouteNextHopPatchRouteNextHopIP
// - RouteNextHopPatchVPNGatewayConnectionIdentity
type RouteNextHopPatch struct {
	// The sentinel IP address (`0.0.0.0`).
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*RouteNextHopPatch) isaRouteNextHopPatch() bool {
	return true
}

type RouteNextHopPatchIntf interface {
	isaRouteNextHopPatch() bool
}

// UnmarshalRouteNextHopPatch unmarshals an instance of RouteNextHopPatch from the specified map of raw messages.
func UnmarshalRouteNextHopPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatch)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePatch : RoutePatch struct
type RoutePatch struct {
	// The name for this route. The name must not be used by another route in the routing table. Names starting with `ibm-`
	// are reserved for system-provided routes, and are not allowed.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to. For other
	// `action` values, specify `0.0.0.0` or remove it by specifying `null`.
	//
	// At most two routes per `zone` in a table can have the same `destination` and `priority`,
	// and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
	NextHop RouteNextHopPatchIntf `json:"next_hop,omitempty"`

	// The priority of this route. Smaller values have higher priority.
	//
	// If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
	// priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
	// distributed between them.
	Priority *int64 `json:"priority,omitempty"`
}

// UnmarshalRoutePatch unmarshals an instance of RoutePatch from the specified map of raw messages.
func UnmarshalRoutePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next_hop", &obj.NextHop, UnmarshalRouteNextHopPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the RoutePatch
func (routePatch *RoutePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(routePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// RoutePrototype : RoutePrototype struct
type RoutePrototype struct {
	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to system-provided routes
	// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action,omitempty"`

	// The destination CIDR of the route. The host identifier in the CIDR must be zero.
	//
	// At most two routes per `zone` in a table can have the same `destination` and
	// `priority`, and only if both routes have an `action` of `deliver` and the `next_hop` is an IP address.
	Destination *string `json:"destination" validate:"required"`

	// The name for this route. The name must not be used by another route in the routing table. Names starting with `ibm-`
	// are reserved for system-provided routes, and are not allowed. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to. For other
	// `action` values, it must be omitted or specified as `0.0.0.0`.
	//
	// At most two routes per `zone` in a table can have the same `destination` and `priority`,
	// and only when each route has an `action` of `deliver` and `next_hop` is an IP address.
	NextHop RoutePrototypeNextHopIntf `json:"next_hop,omitempty"`

	// The priority of this route. Smaller values have higher priority.
	//
	// If a routing table contains multiple routes with the same `zone` and `destination`, the route with the highest
	// priority (smallest value) is selected. If two routes have the same `destination` and `priority`, traffic is
	// distributed between them.
	Priority *int64 `json:"priority,omitempty"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// Constants associated with the RoutePrototype.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to system-provided routes
// - `delegate_vpc`: delegate to system-provided routes, ignoring Internet-bound routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	RoutePrototypeActionDelegateConst    = "delegate"
	RoutePrototypeActionDelegateVPCConst = "delegate_vpc"
	RoutePrototypeActionDeliverConst     = "deliver"
	RoutePrototypeActionDropConst        = "drop"
)

// NewRoutePrototype : Instantiate RoutePrototype (Generic Model Constructor)
func (*VpcV1) NewRoutePrototype(destination string, zone ZoneIdentityIntf) (_model *RoutePrototype, err error) {
	_model = &RoutePrototype{
		Destination: core.StringPtr(destination),
		Zone:        zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalRoutePrototype unmarshals an instance of RoutePrototype from the specified map of raw messages.
func UnmarshalRoutePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next_hop", &obj.NextHop, UnmarshalRoutePrototypeNextHop)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHop : If `action` is `deliver`, the next hop that packets will be delivered to. For other
// `action` values, it must be omitted or specified as `0.0.0.0`.
//
// At most two routes per `zone` in a table can have the same `destination` and `priority`, and only when each route has
// an `action` of `deliver` and `next_hop` is an IP address.
// Models which "extend" this model:
// - RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP
// - RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity
type RoutePrototypeNextHop struct {
	// The sentinel IP address (`0.0.0.0`).
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*RoutePrototypeNextHop) isaRoutePrototypeNextHop() bool {
	return true
}

type RoutePrototypeNextHopIntf interface {
	isaRoutePrototypeNextHop() bool
}

// UnmarshalRoutePrototypeNextHop unmarshals an instance of RoutePrototypeNextHop from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHop(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHop)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReference : RouteReference struct
type RouteReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *RouteReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this route.
	ID *string `json:"id" validate:"required"`

	// The name for this route. The name is unique across all routes in the routing table.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalRouteReference unmarshals an instance of RouteReference from the specified map of raw messages.
func UnmarshalRouteReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalRouteReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type RouteReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalRouteReferenceDeleted unmarshals an instance of RouteReferenceDeleted from the specified map of raw messages.
func UnmarshalRouteReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTable : RoutingTable struct
type RoutingTable struct {
	// The filters specifying the resources that may create routes in this routing table.
	//
	// At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but filter
	// support is expected to expand in the future.
	AcceptRoutesFrom []ResourceFilter `json:"accept_routes_from" validate:"required"`

	// The date and time that this routing table was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default routing table for this VPC.
	IsDefault *bool `json:"is_default" validate:"required"`

	// The lifecycle state of the routing table.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this routing table. The name is unique across all routing tables for the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from
	// [Direct Link](https://cloud.ibm.com/docs/dl) to this VPC.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteDirectLinkIngress *bool `json:"route_direct_link_ingress" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from the internet.
	//
	// Incoming traffic will be routed according to the routing table with two exceptions:
	// - Traffic destined for IP addresses associated with public gateways will not be
	//   subject to routes in this routing table.
	// - Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is
	//   an IP address in a subnet in the route's `zone` that is able to accept traffic.
	//   Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	//   connection, the packet will be dropped.
	RouteInternetIngress *bool `json:"route_internet_ingress" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from from [Transit
	// Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteTransitGatewayIngress *bool `json:"route_transit_gateway_ingress" validate:"required"`

	// Indicates whether this routing table is used to route traffic that originates from subnets in other zones in this
	// VPC.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteVPCZoneIngress *bool `json:"route_vpc_zone_ingress" validate:"required"`

	// The routes for this routing table.
	Routes []RouteReference `json:"routes" validate:"required"`

	// The subnets to which this routing table is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`
}

// Constants associated with the RoutingTable.LifecycleState property.
// The lifecycle state of the routing table.
const (
	RoutingTableLifecycleStateDeletingConst  = "deleting"
	RoutingTableLifecycleStateFailedConst    = "failed"
	RoutingTableLifecycleStatePendingConst   = "pending"
	RoutingTableLifecycleStateStableConst    = "stable"
	RoutingTableLifecycleStateSuspendedConst = "suspended"
	RoutingTableLifecycleStateUpdatingConst  = "updating"
	RoutingTableLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the RoutingTable.ResourceType property.
// The resource type.
const (
	RoutingTableResourceTypeRoutingTableConst = "routing_table"
)

// UnmarshalRoutingTable unmarshals an instance of RoutingTable from the specified map of raw messages.
func UnmarshalRoutingTable(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTable)
	err = core.UnmarshalModel(m, "accept_routes_from", &obj.AcceptRoutesFrom, UnmarshalResourceFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_default", &obj.IsDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_direct_link_ingress", &obj.RouteDirectLinkIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_internet_ingress", &obj.RouteInternetIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_transit_gateway_ingress", &obj.RouteTransitGatewayIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_vpc_zone_ingress", &obj.RouteVPCZoneIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableCollection : RoutingTableCollection struct
type RoutingTableCollection struct {
	// A link to the first page of resources.
	First *RoutingTableCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *RoutingTableCollectionNext `json:"next,omitempty"`

	// Collection of routing tables.
	RoutingTables []RoutingTable `json:"routing_tables" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalRoutingTableCollection unmarshals an instance of RoutingTableCollection from the specified map of raw messages.
func UnmarshalRoutingTableCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalRoutingTableCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalRoutingTableCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_tables", &obj.RoutingTables, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *RoutingTableCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// RoutingTableCollectionFirst : A link to the first page of resources.
type RoutingTableCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRoutingTableCollectionFirst unmarshals an instance of RoutingTableCollectionFirst from the specified map of raw messages.
func UnmarshalRoutingTableCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type RoutingTableCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRoutingTableCollectionNext unmarshals an instance of RoutingTableCollectionNext from the specified map of raw messages.
func UnmarshalRoutingTableCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentity : Identifies a routing table by a unique property.
// Models which "extend" this model:
// - RoutingTableIdentityByID
// - RoutingTableIdentityByHref
type RoutingTableIdentity struct {
	// The unique identifier for this routing table.
	ID *string `json:"id,omitempty"`

	// The URL for this routing table.
	Href *string `json:"href,omitempty"`
}

func (*RoutingTableIdentity) isaRoutingTableIdentity() bool {
	return true
}

type RoutingTableIdentityIntf interface {
	isaRoutingTableIdentity() bool
}

// UnmarshalRoutingTableIdentity unmarshals an instance of RoutingTableIdentity from the specified map of raw messages.
func UnmarshalRoutingTableIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTablePatch : RoutingTablePatch struct
type RoutingTablePatch struct {
	// The filters specifying the resources that may create routes in this routing table
	// (replacing any existing filters). All routes created by resources that match a given filter will be removed when an
	// existing filter is removed. Therefore, if an empty array is specified, all filters will be removed, resulting in all
	// routes not directly created by the user being removed.
	//
	// At present, only the `resource_type` filter is permitted, and only the `vpn_server` value is supported, but filter
	// support is expected to expand in the future.
	AcceptRoutesFrom []ResourceFilter `json:"accept_routes_from,omitempty"`

	// The name for this routing table. The name must not be used by another routing table in the VPC.
	Name *string `json:"name,omitempty"`

	// Indicates whether this routing table is used to route traffic that originates from
	// [Direct Link](https://cloud.ibm.com/docs/dl/) to this VPC. Updating to `true` selects this routing table, provided
	// no other routing table in the VPC already has this property set to `true`, and no subnets are attached to this
	// routing table. Updating to
	// `false` deselects this routing table.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteDirectLinkIngress *bool `json:"route_direct_link_ingress,omitempty"`

	// Indicates whether this routing table is used to route traffic that originates from the internet.  Updating to `true`
	// selects this routing table, provided no other routing table in the VPC already has this property set to `true`.
	// Updating to `false` deselects this routing table.
	//
	// Incoming traffic will be routed according to the routing table with two exceptions:
	// -  Traffic destined for IP addresses associated with public gateways will not be subject
	//    to routes in this routing table.
	// -  Routes with an `action` of `deliver` are treated as `drop` unless the `next_hop` is an
	//    IP address in a subnet in the route's `zone` that is able to accept traffic.
	//    Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	//    connection, the packet will be dropped.
	RouteInternetIngress *bool `json:"route_internet_ingress,omitempty"`

	// Indicates whether this routing table is used to route traffic that originates from
	// [Transit Gateway](https://cloud.ibm.com/docs/transit-gateway) to this VPC. Updating to
	// `true` selects this routing table, provided no other routing table in the VPC already has this property set to
	// `true`, and no subnets are attached to this routing table. Updating to `false` deselects this routing table.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	//
	// If [Classic Access](https://cloud.ibm.com/docs/vpc?topic=vpc-setting-up-access-to-classic-infrastructure) is enabled
	// for this VPC, and this property is set to `true`, its incoming traffic will also be routed according to this routing
	// table.
	RouteTransitGatewayIngress *bool `json:"route_transit_gateway_ingress,omitempty"`

	// Indicates whether this routing table is used to route traffic that originates from subnets in other zones in this
	// VPC. Updating to `true` selects this routing table, provided no other routing table in the VPC already has this
	// property set to `true`, and no subnets are attached to this routing table. Updating to `false` deselects this
	// routing table.
	//
	// Incoming traffic will be routed according to the routing table with one exception: routes with an `action` of
	// `deliver` are treated as `drop` unless the `next_hop` is an IP address in a subnet in the route's `zone` that is
	// able to accept traffic. Therefore, if an incoming packet matches a route with a `next_hop` of a VPN gateway
	// connection, the packet will be dropped.
	RouteVPCZoneIngress *bool `json:"route_vpc_zone_ingress,omitempty"`
}

// UnmarshalRoutingTablePatch unmarshals an instance of RoutingTablePatch from the specified map of raw messages.
func UnmarshalRoutingTablePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTablePatch)
	err = core.UnmarshalModel(m, "accept_routes_from", &obj.AcceptRoutesFrom, UnmarshalResourceFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_direct_link_ingress", &obj.RouteDirectLinkIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_internet_ingress", &obj.RouteInternetIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_transit_gateway_ingress", &obj.RouteTransitGatewayIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_vpc_zone_ingress", &obj.RouteVPCZoneIngress)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the RoutingTablePatch
func (routingTablePatch *RoutingTablePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(routingTablePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// RoutingTableReference : RoutingTableReference struct
type RoutingTableReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *RoutingTableReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// The name for this routing table. The name is unique across all routing tables for the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the RoutingTableReference.ResourceType property.
// The resource type.
const (
	RoutingTableReferenceResourceTypeRoutingTableConst = "routing_table"
)

// UnmarshalRoutingTableReference unmarshals an instance of RoutingTableReference from the specified map of raw messages.
func UnmarshalRoutingTableReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalRoutingTableReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type RoutingTableReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalRoutingTableReferenceDeleted unmarshals an instance of RoutingTableReferenceDeleted from the specified map of raw messages.
func UnmarshalRoutingTableReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroup : SecurityGroup struct
type SecurityGroup struct {
	// The date and time that this security group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name for this security group. The name is unique across all security groups for the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this security group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The rules for this security group. If no rules exist, all traffic will be denied.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`

	// The targets for this security group.
	Targets []SecurityGroupTargetReferenceIntf `json:"targets" validate:"required"`

	// The VPC this security group resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalSecurityGroup unmarshals an instance of SecurityGroup from the specified map of raw messages.
func UnmarshalSecurityGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroup)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "targets", &obj.Targets, UnmarshalSecurityGroupTargetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupCollection : SecurityGroupCollection struct
type SecurityGroupCollection struct {
	// A link to the first page of resources.
	First *SecurityGroupCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *SecurityGroupCollectionNext `json:"next,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroup `json:"security_groups" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSecurityGroupCollection unmarshals an instance of SecurityGroupCollection from the specified map of raw messages.
func UnmarshalSecurityGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalSecurityGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalSecurityGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SecurityGroupCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// SecurityGroupCollectionFirst : A link to the first page of resources.
type SecurityGroupCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupCollectionFirst unmarshals an instance of SecurityGroupCollectionFirst from the specified map of raw messages.
func UnmarshalSecurityGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type SecurityGroupCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupCollectionNext unmarshals an instance of SecurityGroupCollectionNext from the specified map of raw messages.
func UnmarshalSecurityGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupIdentityByID
// - SecurityGroupIdentityByCRN
// - SecurityGroupIdentityByHref
type SecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupIdentity) isaSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupIdentityIntf interface {
	isaSecurityGroupIdentity() bool
}

// UnmarshalSecurityGroupIdentity unmarshals an instance of SecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupPatch : SecurityGroupPatch struct
type SecurityGroupPatch struct {
	// The name for this security group. The name must not be used by another security group for the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalSecurityGroupPatch unmarshals an instance of SecurityGroupPatch from the specified map of raw messages.
func UnmarshalSecurityGroupPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the SecurityGroupPatch
func (securityGroupPatch *SecurityGroupPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(securityGroupPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// SecurityGroupReference : SecurityGroupReference struct
type SecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SecurityGroupReferenceDeleted `json:"deleted,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name for this security group. The name is unique across all security groups for the VPC.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalSecurityGroupReference unmarshals an instance of SecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSecurityGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type SecurityGroupReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalSecurityGroupReferenceDeleted unmarshals an instance of SecurityGroupReferenceDeleted from the specified map of raw messages.
func UnmarshalSecurityGroupReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRule : SecurityGroupRule struct
// Models which "extend" this model:
// - SecurityGroupRuleSecurityGroupRuleProtocolAll
// - SecurityGroupRuleSecurityGroupRuleProtocolIcmp
// - SecurityGroupRuleSecurityGroupRuleProtocolTcpudp
type SecurityGroupRule struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The remote IP addresses or security groups from which this rule allows traffic (or to
	// which, for outbound rules). A CIDR block of `0.0.0.0/0` allows traffic from any source
	// (or to any destination, for outbound rules).
	Remote SecurityGroupRuleRemoteIntf `json:"remote" validate:"required"`

	// The ICMP traffic code to allow. If absent, all codes are allowed.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If absent, all types are allowed.
	Type *int64 `json:"type,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRule.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRuleDirectionInboundConst  = "inbound"
	SecurityGroupRuleDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRule.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRule.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolAllConst  = "all"
	SecurityGroupRuleProtocolIcmpConst = "icmp"
	SecurityGroupRuleProtocolTCPConst  = "tcp"
	SecurityGroupRuleProtocolUDPConst  = "udp"
)

func (*SecurityGroupRule) isaSecurityGroupRule() bool {
	return true
}

type SecurityGroupRuleIntf interface {
	isaSecurityGroupRule() bool
}

// UnmarshalSecurityGroupRule unmarshals an instance of SecurityGroupRule from the specified map of raw messages.
func UnmarshalSecurityGroupRule(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// SecurityGroupRuleCollection : Collection of rules in a security group.
type SecurityGroupRuleCollection struct {
	// Array of rules.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`
}

// UnmarshalSecurityGroupRuleCollection unmarshals an instance of SecurityGroupRuleCollection from the specified map of raw messages.
func UnmarshalSecurityGroupRuleCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleCollection)
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatch : SecurityGroupRulePatch struct
type SecurityGroupRulePatch struct {
	// The ICMP traffic code to allow. If set, `type` must also be set.
	//
	// Specify `null` to remove an existing ICMP traffic code.
	Code *int64 `json:"code,omitempty"`

	// The direction of traffic to enforce.
	Direction *string `json:"direction,omitempty"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of the protocol destination port range. If set, `port_min` must also be set, and must not
	// be larger.
	//
	// Specify `null` to remove an existing upper bound.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of the protocol destination port range. If set, `port_max` must also be set, and must not
	// be smaller.
	//
	// Specify `null` to remove an existing lower bound.
	PortMin *int64 `json:"port_min,omitempty"`

	// The remote IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
	// any destination, for outbound rules).
	Remote SecurityGroupRuleRemotePatchIntf `json:"remote,omitempty"`

	// The ICMP traffic type to allow.
	//
	// Specify `null` to remove an existing ICMP traffic type value.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRulePatch.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRulePatchDirectionInboundConst  = "inbound"
	SecurityGroupRulePatchDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePatch.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePatchIPVersionIpv4Const = "ipv4"
)

// UnmarshalSecurityGroupRulePatch unmarshals an instance of SecurityGroupRulePatch from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatch)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemotePatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the SecurityGroupRulePatch
func (securityGroupRulePatch *SecurityGroupRulePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(securityGroupRulePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// SecurityGroupRulePrototype : SecurityGroupRulePrototype struct
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp
type SecurityGroupRulePrototype struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The remote IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group within the VPC.
	//
	// If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
	// (or to any destination, for outbound rules).
	Remote SecurityGroupRuleRemotePrototypeIntf `json:"remote,omitempty"`

	// The ICMP traffic code to allow.
	//
	// If specified, `type` must also be specified.  If unspecified, all codes are allowed.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	//
	// If unspecified, all types are allowed.
	Type *int64 `json:"type,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	//
	// If specified, `port_min` must also be specified, and must not be larger. If unspecified,
	// `port_min` must also be unspecified, allowing traffic on all destination ports.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range
	//
	// If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also be
	// unspecified, allowing traffic on all destination ports.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototype.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRulePrototypeDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototype.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototype.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeProtocolAllConst  = "all"
	SecurityGroupRulePrototypeProtocolIcmpConst = "icmp"
	SecurityGroupRulePrototypeProtocolTCPConst  = "tcp"
	SecurityGroupRulePrototypeProtocolUDPConst  = "udp"
)

func (*SecurityGroupRulePrototype) isaSecurityGroupRulePrototype() bool {
	return true
}

type SecurityGroupRulePrototypeIntf interface {
	isaSecurityGroupRulePrototype() bool
}

// UnmarshalSecurityGroupRulePrototype unmarshals an instance of SecurityGroupRulePrototype from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// SecurityGroupRuleRemote : The remote IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). A
// CIDR block of `0.0.0.0/0` allows traffic from any source
// (or to any destination, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleRemoteIP
// - SecurityGroupRuleRemoteCIDR
// - SecurityGroupRuleRemoteSecurityGroupReference
type SecurityGroupRuleRemote struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SecurityGroupReferenceDeleted `json:"deleted,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The name for this security group. The name is unique across all security groups for the VPC.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRuleRemote) isaSecurityGroupRuleRemote() bool {
	return true
}

type SecurityGroupRuleRemoteIntf interface {
	isaSecurityGroupRuleRemote() bool
}

// UnmarshalSecurityGroupRuleRemote unmarshals an instance of SecurityGroupRuleRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSecurityGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatch : The remote IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules).
// Can be specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` will allow traffic
// from any source (or to any destination, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleRemotePatchIP
// - SecurityGroupRuleRemotePatchCIDR
// - SecurityGroupRuleRemotePatchSecurityGroupIdentity
type SecurityGroupRuleRemotePatch struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRuleRemotePatch) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

type SecurityGroupRuleRemotePatchIntf interface {
	isaSecurityGroupRuleRemotePatch() bool
}

// UnmarshalSecurityGroupRuleRemotePatch unmarshals an instance of SecurityGroupRuleRemotePatch from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatch)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototype : The remote IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules).
// Can be specified as an IP address, a CIDR block, or a security group within the VPC.
//
// If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
// (or to any destination, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleRemotePrototypeIP
// - SecurityGroupRuleRemotePrototypeCIDR
// - SecurityGroupRuleRemotePrototypeSecurityGroupIdentity
type SecurityGroupRuleRemotePrototype struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRuleRemotePrototype) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

type SecurityGroupRuleRemotePrototypeIntf interface {
	isaSecurityGroupRuleRemotePrototype() bool
}

// UnmarshalSecurityGroupRuleRemotePrototype unmarshals an instance of SecurityGroupRuleRemotePrototype from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototype)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetCollection : SecurityGroupTargetCollection struct
type SecurityGroupTargetCollection struct {
	// A link to the first page of resources.
	First *SecurityGroupTargetCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *SecurityGroupTargetCollectionNext `json:"next,omitempty"`

	// Collection of targets for this security group.
	Targets []SecurityGroupTargetReferenceIntf `json:"targets" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSecurityGroupTargetCollection unmarshals an instance of SecurityGroupTargetCollection from the specified map of raw messages.
func UnmarshalSecurityGroupTargetCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalSecurityGroupTargetCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalSecurityGroupTargetCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "targets", &obj.Targets, UnmarshalSecurityGroupTargetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SecurityGroupTargetCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// SecurityGroupTargetCollectionFirst : A link to the first page of resources.
type SecurityGroupTargetCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupTargetCollectionFirst unmarshals an instance of SecurityGroupTargetCollectionFirst from the specified map of raw messages.
func UnmarshalSecurityGroupTargetCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type SecurityGroupTargetCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupTargetCollectionNext unmarshals an instance of SecurityGroupTargetCollectionNext from the specified map of raw messages.
func UnmarshalSecurityGroupTargetCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReference : The resource types that can be security group targets are expected to expand in the future. When iterating over
// security group targets, do not assume that every target resource will be from a known set of resource types.
// Optionally halt processing and surface an error, or bypass resources of unrecognized types.
// Models which "extend" this model:
// - SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext
// - SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext
// - SecurityGroupTargetReferenceLoadBalancerReference
// - SecurityGroupTargetReferenceEndpointGatewayReference
// - SecurityGroupTargetReferenceVPNServerReference
// - SecurityGroupTargetReferenceVirtualNetworkInterfaceReference
type SecurityGroupTargetReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The name for this instance network interface.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`

	// The load balancer's CRN.
	CRN *string `json:"crn,omitempty"`

	// The primary IP for this virtual network interface.
	PrimaryIP *ReservedIPReference `json:"primary_ip,omitempty"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet,omitempty"`
}

// Constants associated with the SecurityGroupTargetReference.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*SecurityGroupTargetReference) isaSecurityGroupTargetReference() bool {
	return true
}

type SecurityGroupTargetReferenceIntf interface {
	isaSecurityGroupTargetReference() bool
}

// UnmarshalSecurityGroupTargetReference unmarshals an instance of SecurityGroupTargetReference from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SetSubnetPublicGatewayOptions : The SetSubnetPublicGateway options.
type SetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The public gateway identity.
	PublicGatewayIdentity PublicGatewayIdentityIntf `json:"PublicGatewayIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetSubnetPublicGatewayOptions : Instantiate SetSubnetPublicGatewayOptions
func (*VpcV1) NewSetSubnetPublicGatewayOptions(id string, publicGatewayIdentity PublicGatewayIdentityIntf) *SetSubnetPublicGatewayOptions {
	return &SetSubnetPublicGatewayOptions{
		ID:                    core.StringPtr(id),
		PublicGatewayIdentity: publicGatewayIdentity,
	}
}

// SetID : Allow user to set ID
func (_options *SetSubnetPublicGatewayOptions) SetID(id string) *SetSubnetPublicGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPublicGatewayIdentity : Allow user to set PublicGatewayIdentity
func (_options *SetSubnetPublicGatewayOptions) SetPublicGatewayIdentity(publicGatewayIdentity PublicGatewayIdentityIntf) *SetSubnetPublicGatewayOptions {
	_options.PublicGatewayIdentity = publicGatewayIdentity
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *SetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// Share : Share struct
type Share struct {
	// The access control mode for the share:
	//
	// - `security_group`: The security groups on the virtual network interface for a mount
	//   target control access to the mount target.
	// - `vpc`: All clients in the VPC for a mount target have access to the mount target.
	//
	// The enumerated access control mode values for this property may expand in the future. When processing this property,
	// check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which
	// the unexpected access control mode was encountered.
	AccessControlMode *string `json:"access_control_mode" validate:"required"`

	// The date and time that the file share is created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this file share.
	CRN *string `json:"crn" validate:"required"`

	// The type of encryption used for this file share.
	Encryption *string `json:"encryption" validate:"required"`

	// The key used to encrypt this file share.
	//
	// This property will be present if `encryption_type` is `user_managed`.
	EncryptionKey *EncryptionKeyReference `json:"encryption_key,omitempty"`

	// The URL for this file share.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this file share.
	ID *string `json:"id" validate:"required"`

	// The maximum input/output operations per second (IOPS) for the file share. In addition, each client accessing the
	// share will be restricted to 48,000 IOPS.
	//
	// The maximum IOPS for a share may increase in the future.
	Iops *int64 `json:"iops" validate:"required"`

	// The latest job associated with this file share.
	//
	// This property will be absent if no jobs have been created for this file share.
	LatestJob *ShareJob `json:"latest_job,omitempty"`

	// The lifecycle state of the file share.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The mount targets for the file share.
	MountTargets []ShareMountTargetReference `json:"mount_targets" validate:"required"`

	// The name for this share. The name is unique across all shares in the region.
	Name *string `json:"name" validate:"required"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) for
	// this file share.
	Profile *ShareProfileReference `json:"profile" validate:"required"`

	// The replica file share for this source file share.
	//
	// This property will be present when the `replication_role` is `source`.
	ReplicaShare *ShareReference `json:"replica_share,omitempty"`

	// The cron specification for the file share replication schedule.
	//
	// This property will be present when the `replication_role` is `replica`.
	ReplicationCronSpec *string `json:"replication_cron_spec,omitempty"`

	// The replication role of the file share.
	//
	// * `none`: This share is not participating in replication.
	// * `replica`: This share is a replication target.
	// * `source`: This share is a replication source.
	ReplicationRole *string `json:"replication_role" validate:"required"`

	// The replication status of the file share.
	//
	// * `active`: This share is actively participating in replication, and the replica's data is up-to-date with the
	// replication schedule.
	// * `failover_pending`: This share is performing a replication failover.
	// * `initializing`: This share is initializing replication.
	// * `none`: This share is not participating in replication.
	// * `split_pending`: This share is performing a replication split.
	ReplicationStatus *string `json:"replication_status" validate:"required"`

	// The reasons for the current replication status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	ReplicationStatusReasons []ShareReplicationStatusReason `json:"replication_status_reasons" validate:"required"`

	// The resource group for this file share.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The size of the file share rounded up to the next gigabyte.
	//
	// The maximum size for a share may increase in the future.
	Size *int64 `json:"size" validate:"required"`

	// The source file share for this replica file share.
	//
	// This property will be present when the `replication_role` is `replica`.
	SourceShare *ShareReference `json:"source_share,omitempty"`

	// Tags for this resource.
	UserTags []string `json:"user_tags" validate:"required"`

	// The zone this file share will reside in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Share.AccessControlMode property.
// The access control mode for the share:
//
//   - `security_group`: The security groups on the virtual network interface for a mount
//     target control access to the mount target.
//   - `vpc`: All clients in the VPC for a mount target have access to the mount target.
//
// The enumerated access control mode values for this property may expand in the future. When processing this property,
// check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which
// the unexpected access control mode was encountered.
const (
	ShareAccessControlModeSecurityGroupConst = "security_group"
	ShareAccessControlModeVPCConst           = "vpc"
)

// Constants associated with the Share.Encryption property.
// The type of encryption used for this file share.
const (
	ShareEncryptionProviderManagedConst = "provider_managed"
	ShareEncryptionUserManagedConst     = "user_managed"
)

// Constants associated with the Share.LifecycleState property.
// The lifecycle state of the file share.
const (
	ShareLifecycleStateDeletingConst  = "deleting"
	ShareLifecycleStateFailedConst    = "failed"
	ShareLifecycleStatePendingConst   = "pending"
	ShareLifecycleStateStableConst    = "stable"
	ShareLifecycleStateSuspendedConst = "suspended"
	ShareLifecycleStateUpdatingConst  = "updating"
	ShareLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the Share.ReplicationRole property.
// The replication role of the file share.
//
// * `none`: This share is not participating in replication.
// * `replica`: This share is a replication target.
// * `source`: This share is a replication source.
const (
	ShareReplicationRoleNoneConst    = "none"
	ShareReplicationRoleReplicaConst = "replica"
	ShareReplicationRoleSourceConst  = "source"
)

// Constants associated with the Share.ReplicationStatus property.
// The replication status of the file share.
//
// * `active`: This share is actively participating in replication, and the replica's data is up-to-date with the
// replication schedule.
// * `failover_pending`: This share is performing a replication failover.
// * `initializing`: This share is initializing replication.
// * `none`: This share is not participating in replication.
// * `split_pending`: This share is performing a replication split.
const (
	ShareReplicationStatusActiveConst          = "active"
	ShareReplicationStatusFailoverPendingConst = "failover_pending"
	ShareReplicationStatusInitializingConst    = "initializing"
	ShareReplicationStatusNoneConst            = "none"
	ShareReplicationStatusSplitPendingConst    = "split_pending"
)

// Constants associated with the Share.ResourceType property.
// The resource type.
const (
	ShareResourceTypeShareConst = "share"
)

// UnmarshalShare unmarshals an instance of Share from the specified map of raw messages.
func UnmarshalShare(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Share)
	err = core.UnmarshalPrimitive(m, "access_control_mode", &obj.AccessControlMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "latest_job", &obj.LatestJob, UnmarshalShareJob)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "mount_targets", &obj.MountTargets, UnmarshalShareMountTargetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalShareProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "replica_share", &obj.ReplicaShare, UnmarshalShareReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_cron_spec", &obj.ReplicationCronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_role", &obj.ReplicationRole)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_status", &obj.ReplicationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "replication_status_reasons", &obj.ReplicationStatusReasons, UnmarshalShareReplicationStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_share", &obj.SourceShare, UnmarshalShareReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareCollection : ShareCollection struct
type ShareCollection struct {
	// A link to the first page of resources.
	First *ShareCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ShareCollectionNext `json:"next,omitempty"`

	// Collection of file shares.
	Shares []Share `json:"shares" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalShareCollection unmarshals an instance of ShareCollection from the specified map of raw messages.
func UnmarshalShareCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalShareCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalShareCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "shares", &obj.Shares, UnmarshalShare)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ShareCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ShareCollectionFirst : A link to the first page of resources.
type ShareCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalShareCollectionFirst unmarshals an instance of ShareCollectionFirst from the specified map of raw messages.
func UnmarshalShareCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type ShareCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalShareCollectionNext unmarshals an instance of ShareCollectionNext from the specified map of raw messages.
func UnmarshalShareCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareIdentity : Identifies a file share by a unique property.
// Models which "extend" this model:
// - ShareIdentityByID
// - ShareIdentityByCRN
// - ShareIdentityByHref
type ShareIdentity struct {
	// The unique identifier for this file share.
	ID *string `json:"id,omitempty"`

	// The CRN for this file share.
	CRN *string `json:"crn,omitempty"`

	// The URL for this file share.
	Href *string `json:"href,omitempty"`
}

func (*ShareIdentity) isaShareIdentity() bool {
	return true
}

type ShareIdentityIntf interface {
	isaShareIdentity() bool
}

// UnmarshalShareIdentity unmarshals an instance of ShareIdentity from the specified map of raw messages.
func UnmarshalShareIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareInitialOwner : ShareInitialOwner struct
type ShareInitialOwner struct {
	// The initial group identifier for the file share.
	Gid *int64 `json:"gid,omitempty"`

	// The initial user identifier for the file share.
	Uid *int64 `json:"uid,omitempty"`
}

// UnmarshalShareInitialOwner unmarshals an instance of ShareInitialOwner from the specified map of raw messages.
func UnmarshalShareInitialOwner(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareInitialOwner)
	err = core.UnmarshalPrimitive(m, "gid", &obj.Gid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uid", &obj.Uid)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareJob : ShareJob struct
type ShareJob struct {
	// The status of the file share job.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the file share job on which the
	// unexpected property value was encountered.
	//
	// * `cancelled`: This job has been cancelled.
	// * `failed`: This job has failed.
	// * `queued`: This job is queued.
	// * `running`: This job is running.
	// * `succeeded`: This job completed successfully.
	Status *string `json:"status" validate:"required"`

	// The reasons for the file share job status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []ShareJobStatusReason `json:"status_reasons" validate:"required"`

	// The type of the file share job.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the file share job on which the
	// unexpected property value was encountered.
	//
	// * `replication_failover`: This is a share replication failover job.
	// * `replication_init`: This is a share replication is initialization job.
	// * `replication_split`: This is a share replication split job.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the ShareJob.Status property.
// The status of the file share job.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the file share job on which the
// unexpected property value was encountered.
//
// * `cancelled`: This job has been cancelled.
// * `failed`: This job has failed.
// * `queued`: This job is queued.
// * `running`: This job is running.
// * `succeeded`: This job completed successfully.
const (
	ShareJobStatusCancelledConst = "cancelled"
	ShareJobStatusFailedConst    = "failed"
	ShareJobStatusQueuedConst    = "queued"
	ShareJobStatusRunningConst   = "running"
	ShareJobStatusSucceededConst = "succeeded"
)

// Constants associated with the ShareJob.Type property.
// The type of the file share job.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the file share job on which the
// unexpected property value was encountered.
//
// * `replication_failover`: This is a share replication failover job.
// * `replication_init`: This is a share replication is initialization job.
// * `replication_split`: This is a share replication split job.
const (
	ShareJobTypeReplicationFailoverConst = "replication_failover"
	ShareJobTypeReplicationInitConst     = "replication_init"
	ShareJobTypeReplicationSplitConst    = "replication_split"
)

// UnmarshalShareJob unmarshals an instance of ShareJob from the specified map of raw messages.
func UnmarshalShareJob(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareJob)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalShareJobStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareJobStatusReason : ShareJobStatusReason struct
type ShareJobStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the ShareJobStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	ShareJobStatusReasonCodeCannotInitializeReplicationConst = "cannot_initialize_replication"
	ShareJobStatusReasonCodeCannotReachReplicaShareConst     = "cannot_reach_replica_share"
	ShareJobStatusReasonCodeCannotReachSourceShareConst      = "cannot_reach_source_share"
)

// UnmarshalShareJobStatusReason unmarshals an instance of ShareJobStatusReason from the specified map of raw messages.
func UnmarshalShareJobStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareJobStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTarget : ShareMountTarget struct
type ShareMountTarget struct {
	// The access control mode for the share:
	//
	// - `security_group`: The security groups on the virtual network interface for a mount
	//   target control access to the mount target.
	// - `vpc`: All clients in the VPC for a mount target have access to the mount target.
	//
	// The enumerated access control mode values for this property may expand in the future. When processing this property,
	// check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which
	// the unexpected access control mode was encountered.
	AccessControlMode *string `json:"access_control_mode" validate:"required"`

	// The date and time that the share mount target was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this share mount target.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this share mount target.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the mount target.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The mount path for the share.  The server component of the mount path may be either an IP address or a fully
	// qualified domain name.
	//
	// This property will be absent if the `lifecycle_state` of the mount target is
	// 'pending', `failed`, or `deleting`.
	//
	// If the share's `access_control_mode` is:
	//
	// - `security_group`: The IP address used in the mount path is the `primary_ip`
	//   address of the virtual network interface for this share mount target.
	// - `vpc`: The fully-qualified domain name used in the mount path is an address that
	//   resolves to the share mount target.
	MountPath *string `json:"mount_path,omitempty"`

	// The name for this share mount target. The name is unique across all mount targets for the file share.
	Name *string `json:"name" validate:"required"`

	// The primary IP address of the virtual network interface for the share mount target.
	//
	// Absent if `access_control_mode` is `vpc`.
	PrimaryIP *ReservedIPReference `json:"primary_ip,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The subnet of the virtual network interface for the share mount target.
	//
	// Absent if `access_control_mode` is `vpc`.
	Subnet *SubnetReference `json:"subnet,omitempty"`

	// The transit encryption mode for this share mount target:
	// - `none`: Not encrypted in transit
	// - `user_managed`: Encrypted in transit using an instance identity certificate
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the resource on which the unexpected
	// property value was encountered.
	TransitEncryption *string `json:"transit_encryption" validate:"required"`

	// The virtual network interface for this file share mount target.
	//
	// This property will be present when the `access_control_mode` is `security_group`.
	VirtualNetworkInterface *VirtualNetworkInterfaceReferenceAttachmentContext `json:"virtual_network_interface,omitempty"`

	// If `access_control_mode` is:
	//
	// - `security_group`: The VPC for the virtual network interface for this share mount
	//   target
	// - `vpc`: The VPC in which clients can mount the file share using this share
	//   mount target.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the ShareMountTarget.AccessControlMode property.
// The access control mode for the share:
//
//   - `security_group`: The security groups on the virtual network interface for a mount
//     target control access to the mount target.
//   - `vpc`: All clients in the VPC for a mount target have access to the mount target.
//
// The enumerated access control mode values for this property may expand in the future. When processing this property,
// check for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which
// the unexpected access control mode was encountered.
const (
	ShareMountTargetAccessControlModeSecurityGroupConst = "security_group"
	ShareMountTargetAccessControlModeVPCConst           = "vpc"
)

// Constants associated with the ShareMountTarget.LifecycleState property.
// The lifecycle state of the mount target.
const (
	ShareMountTargetLifecycleStateDeletingConst  = "deleting"
	ShareMountTargetLifecycleStateFailedConst    = "failed"
	ShareMountTargetLifecycleStatePendingConst   = "pending"
	ShareMountTargetLifecycleStateStableConst    = "stable"
	ShareMountTargetLifecycleStateSuspendedConst = "suspended"
	ShareMountTargetLifecycleStateUpdatingConst  = "updating"
	ShareMountTargetLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the ShareMountTarget.ResourceType property.
// The resource type.
const (
	ShareMountTargetResourceTypeShareMountTargetConst = "share_mount_target"
)

// Constants associated with the ShareMountTarget.TransitEncryption property.
// The transit encryption mode for this share mount target:
// - `none`: Not encrypted in transit
// - `user_managed`: Encrypted in transit using an instance identity certificate
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the resource on which the unexpected
// property value was encountered.
const (
	ShareMountTargetTransitEncryptionNoneConst        = "none"
	ShareMountTargetTransitEncryptionUserManagedConst = "user_managed"
)

// UnmarshalShareMountTarget unmarshals an instance of ShareMountTarget from the specified map of raw messages.
func UnmarshalShareMountTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTarget)
	err = core.UnmarshalPrimitive(m, "access_control_mode", &obj.AccessControlMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mount_path", &obj.MountPath)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_encryption", &obj.TransitEncryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtual_network_interface", &obj.VirtualNetworkInterface, UnmarshalVirtualNetworkInterfaceReferenceAttachmentContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetCollection : ShareMountTargetCollection struct
type ShareMountTargetCollection struct {
	// A link to the first page of resources.
	First *ShareMountTargetCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of share mount targets.
	MountTargets []ShareMountTarget `json:"mount_targets" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ShareMountTargetCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalShareMountTargetCollection unmarshals an instance of ShareMountTargetCollection from the specified map of raw messages.
func UnmarshalShareMountTargetCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalShareMountTargetCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "mount_targets", &obj.MountTargets, UnmarshalShareMountTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalShareMountTargetCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ShareMountTargetCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ShareMountTargetCollectionFirst : A link to the first page of resources.
type ShareMountTargetCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalShareMountTargetCollectionFirst unmarshals an instance of ShareMountTargetCollectionFirst from the specified map of raw messages.
func UnmarshalShareMountTargetCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type ShareMountTargetCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalShareMountTargetCollectionNext unmarshals an instance of ShareMountTargetCollectionNext from the specified map of raw messages.
func UnmarshalShareMountTargetCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetPatch : ShareMountTargetPatch struct
type ShareMountTargetPatch struct {
	// The name for this share mount target. The name must not be used by another mount target for the file share.
	Name *string `json:"name,omitempty"`
}

// UnmarshalShareMountTargetPatch unmarshals an instance of ShareMountTargetPatch from the specified map of raw messages.
func UnmarshalShareMountTargetPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the ShareMountTargetPatch
func (shareMountTargetPatch *ShareMountTargetPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(shareMountTargetPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// ShareMountTargetPrototype : ShareMountTargetPrototype struct
// Models which "extend" this model:
// - ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup
// - ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC
type ShareMountTargetPrototype struct {
	// The name for this share mount target. The name must not be used by another mount target for the file share.
	Name *string `json:"name,omitempty"`

	// The transit encryption mode to use for this share mount target:
	// - `none`: Not encrypted in transit.
	// - `user_managed`: Encrypted in transit using an instance identity certificate.  The
	//                   `access_control_mode` for the share must be `security_group`.
	TransitEncryption *string `json:"transit_encryption,omitempty"`

	VirtualNetworkInterface ShareMountTargetVirtualNetworkInterfacePrototypeIntf `json:"virtual_network_interface,omitempty"`

	// Identifies a VPC by a unique property.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`
}

// Constants associated with the ShareMountTargetPrototype.TransitEncryption property.
// The transit encryption mode to use for this share mount target:
//   - `none`: Not encrypted in transit.
//   - `user_managed`: Encrypted in transit using an instance identity certificate.  The
//     `access_control_mode` for the share must be `security_group`.
const (
	ShareMountTargetPrototypeTransitEncryptionNoneConst        = "none"
	ShareMountTargetPrototypeTransitEncryptionUserManagedConst = "user_managed"
)

func (*ShareMountTargetPrototype) isaShareMountTargetPrototype() bool {
	return true
}

type ShareMountTargetPrototypeIntf interface {
	isaShareMountTargetPrototype() bool
}

// UnmarshalShareMountTargetPrototype unmarshals an instance of ShareMountTargetPrototype from the specified map of raw messages.
func UnmarshalShareMountTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_encryption", &obj.TransitEncryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtual_network_interface", &obj.VirtualNetworkInterface, UnmarshalShareMountTargetVirtualNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetReference : ShareMountTargetReference struct
type ShareMountTargetReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ShareMountTargetReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this share mount target.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this share mount target.
	ID *string `json:"id" validate:"required"`

	// The name for this share mount target. The name is unique across all mount targets for the file share.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ShareMountTargetReference.ResourceType property.
// The resource type.
const (
	ShareMountTargetReferenceResourceTypeShareMountTargetConst = "share_mount_target"
)

// UnmarshalShareMountTargetReference unmarshals an instance of ShareMountTargetReference from the specified map of raw messages.
func UnmarshalShareMountTargetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalShareMountTargetReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type ShareMountTargetReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalShareMountTargetReferenceDeleted unmarshals an instance of ShareMountTargetReferenceDeleted from the specified map of raw messages.
func UnmarshalShareMountTargetReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetVirtualNetworkInterfacePrototype : ShareMountTargetVirtualNetworkInterfacePrototype struct
// Models which "extend" this model:
// - ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext
type ShareMountTargetVirtualNetworkInterfacePrototype struct {
	// The name for this virtual network interface. The name must not be used by another virtual network interface in the
	// VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with `ibm-` are
	// reserved for provider-owned resources, and are not allowed.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the virtual network interface. May be either a
	// reserved IP identity, or a reserved IP prototype object which will be used to create a
	// new reserved IP.
	//
	// If a reserved IP identity is provided, the specified reserved IP must be unbound.
	//
	// If a reserved IP prototype object with an address is provided, the address must be
	// available on the virtual network interface's subnet. If no address is specified,
	// an available address on the subnet will be automatically selected and reserved.
	PrimaryIP VirtualNetworkInterfacePrimaryIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The resource group to use for this virtual network interface. If unspecified, the
	// share's resource group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The security groups to use for this virtual network interface. If unspecified, the default security group of the VPC
	// for the subnet is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet. Required if `primary_ip` does not specify a reserved IP.
	Subnet SubnetIdentityIntf `json:"subnet,omitempty"`
}

func (*ShareMountTargetVirtualNetworkInterfacePrototype) isaShareMountTargetVirtualNetworkInterfacePrototype() bool {
	return true
}

type ShareMountTargetVirtualNetworkInterfacePrototypeIntf interface {
	isaShareMountTargetVirtualNetworkInterfacePrototype() bool
}

// UnmarshalShareMountTargetVirtualNetworkInterfacePrototype unmarshals an instance of ShareMountTargetVirtualNetworkInterfacePrototype from the specified map of raw messages.
func UnmarshalShareMountTargetVirtualNetworkInterfacePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetVirtualNetworkInterfacePrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalVirtualNetworkInterfacePrimaryIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharePatch : SharePatch struct
type SharePatch struct {
	// The access control mode for the share:
	//
	// - `security_group`: The security groups on the virtual network interface for a
	//   mount target control access to the mount target.
	// - `vpc`: All clients in the VPC for a mount target have access to the mount target.
	//
	// For this property to be changed, the share must have no mount targets and
	// `replication_role` must be `none`.
	AccessControlMode *string `json:"access_control_mode,omitempty"`

	// The maximum input/output operations per second (IOPS) for the file share. The value must be in the range supported
	// by the share's size.
	//
	// For this property to be changed, the share `lifecycle_state` must be `stable`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this share. The name must not be used by another share in the region.
	Name *string `json:"name,omitempty"`

	// The profile to use for this file share.
	//
	// The requested profile must be in the same `family`.
	Profile ShareProfileIdentityIntf `json:"profile,omitempty"`

	// The cron specification for the file share replication schedule.
	//
	// Replication of a share can be scheduled to occur at most once per hour.
	//
	// For this property to be changed, the share `replication_role` must be `replica`.
	ReplicationCronSpec *string `json:"replication_cron_spec,omitempty"`

	// The size of the file share rounded up to the next gigabyte. The value must not be less than the share's current
	// size, and must not exceed the maximum supported by the share's profile and IOPS.
	//
	// For this property to be changed, the share `lifecycle_state` must be `stable`.
	Size *int64 `json:"size,omitempty"`

	// Tags for this resource.
	UserTags []string `json:"user_tags,omitempty"`
}

// Constants associated with the SharePatch.AccessControlMode property.
// The access control mode for the share:
//
//   - `security_group`: The security groups on the virtual network interface for a
//     mount target control access to the mount target.
//   - `vpc`: All clients in the VPC for a mount target have access to the mount target.
//
// For this property to be changed, the share must have no mount targets and
// `replication_role` must be `none`.
const (
	SharePatchAccessControlModeSecurityGroupConst = "security_group"
	SharePatchAccessControlModeVPCConst           = "vpc"
)

// UnmarshalSharePatch unmarshals an instance of SharePatch from the specified map of raw messages.
func UnmarshalSharePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharePatch)
	err = core.UnmarshalPrimitive(m, "access_control_mode", &obj.AccessControlMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalShareProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_cron_spec", &obj.ReplicationCronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the SharePatch
func (sharePatch *SharePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(sharePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// ShareProfile : ShareProfile struct
type ShareProfile struct {
	// The permitted capacity range (in gigabytes) for a share with this profile.
	Capacity ShareProfileCapacityIntf `json:"capacity" validate:"required"`

	// The product family this share profile belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this share profile.
	Href *string `json:"href" validate:"required"`

	// The permitted IOPS range for a share with this profile.
	Iops ShareProfileIopsIntf `json:"iops" validate:"required"`

	// The globally unique name for this share profile.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ShareProfile.Family property.
// The product family this share profile belongs to.
const (
	ShareProfileFamilyDefinedPerformanceConst = "defined_performance"
)

// Constants associated with the ShareProfile.ResourceType property.
// The resource type.
const (
	ShareProfileResourceTypeShareProfileConst = "share_profile"
)

// UnmarshalShareProfile unmarshals an instance of ShareProfile from the specified map of raw messages.
func UnmarshalShareProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfile)
	err = core.UnmarshalModel(m, "capacity", &obj.Capacity, UnmarshalShareProfileCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "iops", &obj.Iops, UnmarshalShareProfileIops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCapacity : ShareProfileCapacity struct
// Models which "extend" this model:
// - ShareProfileCapacityFixed
// - ShareProfileCapacityRange
// - ShareProfileCapacityEnum
// - ShareProfileCapacityDependentRange
type ShareProfileCapacity struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the ShareProfileCapacity.Type property.
// The type for this profile field.
const (
	ShareProfileCapacityTypeFixedConst = "fixed"
)

func (*ShareProfileCapacity) isaShareProfileCapacity() bool {
	return true
}

type ShareProfileCapacityIntf interface {
	isaShareProfileCapacity() bool
}

// UnmarshalShareProfileCapacity unmarshals an instance of ShareProfileCapacity from the specified map of raw messages.
func UnmarshalShareProfileCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCapacity)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCollection : ShareProfileCollection struct
type ShareProfileCollection struct {
	// A link to the first page of resources.
	First *ShareProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *ShareProfileCollectionNext `json:"next,omitempty"`

	// Collection of share profiles.
	Profiles []ShareProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalShareProfileCollection unmarshals an instance of ShareProfileCollection from the specified map of raw messages.
func UnmarshalShareProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalShareProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalShareProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalShareProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ShareProfileCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// ShareProfileCollectionFirst : A link to the first page of resources.
type ShareProfileCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalShareProfileCollectionFirst unmarshals an instance of ShareProfileCollectionFirst from the specified map of raw messages.
func UnmarshalShareProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type ShareProfileCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalShareProfileCollectionNext unmarshals an instance of ShareProfileCollectionNext from the specified map of raw messages.
func UnmarshalShareProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIops : ShareProfileIops struct
// Models which "extend" this model:
// - ShareProfileIopsFixed
// - ShareProfileIopsRange
// - ShareProfileIopsEnum
// - ShareProfileIopsDependentRange
type ShareProfileIops struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the ShareProfileIops.Type property.
// The type for this profile field.
const (
	ShareProfileIopsTypeFixedConst = "fixed"
)

func (*ShareProfileIops) isaShareProfileIops() bool {
	return true
}

type ShareProfileIopsIntf interface {
	isaShareProfileIops() bool
}

// UnmarshalShareProfileIops unmarshals an instance of ShareProfileIops from the specified map of raw messages.
func UnmarshalShareProfileIops(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIops)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIdentity : Identifies a share profile by a unique property.
// Models which "extend" this model:
// - ShareProfileIdentityByName
// - ShareProfileIdentityByHref
type ShareProfileIdentity struct {
	// The globally unique name for this share profile.
	Name *string `json:"name,omitempty"`

	// The URL for this share profile.
	Href *string `json:"href,omitempty"`
}

func (*ShareProfileIdentity) isaShareProfileIdentity() bool {
	return true
}

type ShareProfileIdentityIntf interface {
	isaShareProfileIdentity() bool
}

// UnmarshalShareProfileIdentity unmarshals an instance of ShareProfileIdentity from the specified map of raw messages.
func UnmarshalShareProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileReference : ShareProfileReference struct
type ShareProfileReference struct {
	// The URL for this share profile.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this share profile.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ShareProfileReference.ResourceType property.
// The resource type.
const (
	ShareProfileReferenceResourceTypeShareProfileConst = "share_profile"
)

// UnmarshalShareProfileReference unmarshals an instance of ShareProfileReference from the specified map of raw messages.
func UnmarshalShareProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharePrototype : SharePrototype struct
// Models which "extend" this model:
// - SharePrototypeShareBySize
// - SharePrototypeShareBySourceShare
type SharePrototype struct {
	// The maximum input/output operations per second (IOPS) for the file share. The share must be in the
	// `defined_performance` profile family, and the value must be in the range supported by the share's specified size.
	//
	// In addition, each client accessing the share will be restricted to 48,000 IOPS.
	Iops *int64 `json:"iops,omitempty"`

	// The mount targets for the file share. Each mount target must be in a unique VPC.
	MountTargets []ShareMountTargetPrototypeIntf `json:"mount_targets,omitempty"`

	// The name for this share. The name must not be used by another share in the region. If unspecified, the name will be
	// a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
	// for this file share. The profile must support the share's specified IOPS and size.
	Profile ShareProfileIdentityIntf `json:"profile" validate:"required"`

	// Configuration for a replica file share to create and associate with this file share. If
	// unspecified, a replica may be subsequently added by creating a new file share with a
	// `source_share` referencing this file share.
	ReplicaShare *SharePrototypeShareContext `json:"replica_share,omitempty"`

	// Tags for this resource.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this file share will reside in.
	// For a replica share, this must be a different zone in the same region as the source share.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The access control mode for the share:
	//
	// - `security_group`: The security groups on the virtual network interface for a
	//   mount target control access to the mount target. Mount targets for this share
	//   require a virtual network interface.
	// - `vpc`: All clients in the VPC for a mount target have access to the mount target.
	//   Mount targets for this share require a VPC.
	AccessControlMode *string `json:"access_control_mode,omitempty"`

	// The root key to use to wrap the data encryption key for the share.
	//
	// If unspecified, the `encryption` type for the share will be `provider_managed`.
	//
	// The specified key may be in a different account, subject to IAM policies.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The owner assigned to the file share at creation. Subsequent changes to the owner
	// must be performed by a client that has mounted the file share.
	InitialOwner *ShareInitialOwner `json:"initial_owner,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The size of the file share rounded up to the next gigabyte.
	//
	// The maximum size for a share may increase in the future.
	Size *int64 `json:"size,omitempty"`

	// The cron specification for the file share replication schedule.
	//
	// Replication of a share can be scheduled to occur at most once per hour.
	ReplicationCronSpec *string `json:"replication_cron_spec,omitempty"`

	// The source file share for this replica file share. The specified file share must not
	// already have a replica, and must not be a replica.
	SourceShare ShareIdentityIntf `json:"source_share,omitempty"`
}

// Constants associated with the SharePrototype.AccessControlMode property.
// The access control mode for the share:
//
//   - `security_group`: The security groups on the virtual network interface for a
//     mount target control access to the mount target. Mount targets for this share
//     require a virtual network interface.
//   - `vpc`: All clients in the VPC for a mount target have access to the mount target.
//     Mount targets for this share require a VPC.
const (
	SharePrototypeAccessControlModeSecurityGroupConst = "security_group"
	SharePrototypeAccessControlModeVPCConst           = "vpc"
)

func (*SharePrototype) isaSharePrototype() bool {
	return true
}

type SharePrototypeIntf interface {
	isaSharePrototype() bool
}

// UnmarshalSharePrototype unmarshals an instance of SharePrototype from the specified map of raw messages.
func UnmarshalSharePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharePrototype)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "mount_targets", &obj.MountTargets, UnmarshalShareMountTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalShareProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "replica_share", &obj.ReplicaShare, UnmarshalSharePrototypeShareContext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "access_control_mode", &obj.AccessControlMode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "initial_owner", &obj.InitialOwner, UnmarshalShareInitialOwner)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_cron_spec", &obj.ReplicationCronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_share", &obj.SourceShare, UnmarshalShareIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharePrototypeShareContext : Configuration for a replica file share to create and associate with this file share. If unspecified, a replica may be
// subsequently added by creating a new file share with a
// `source_share` referencing this file share.
type SharePrototypeShareContext struct {
	// The maximum input/output operations per second (IOPS) for the file share. The share must be in the
	// `defined_performance` profile family, and the value must be in the range supported by the share's specified size.
	//
	// In addition, each client accessing the share will be restricted to 48,000 IOPS.
	Iops *int64 `json:"iops,omitempty"`

	// The mount targets for this replica file share. Each mount target must be in a unique VPC.
	//
	// A replica's mount targets must be mounted read-only.
	MountTargets []ShareMountTargetPrototypeIntf `json:"mount_targets,omitempty"`

	// The name for this share. The name must not be used by another share in the region. If unspecified, the name will be
	// a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use
	// for this file share. The profile must support the share's specified IOPS and size.
	Profile ShareProfileIdentityIntf `json:"profile" validate:"required"`

	// The cron specification for the file share replication schedule.
	//
	// Replication of a share can be scheduled to occur at most once per hour.
	ReplicationCronSpec *string `json:"replication_cron_spec" validate:"required"`

	// The resource group to use. If unspecified, the resource group from
	// the source share will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Tags for this resource.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this replica file share will reside in.
	//
	// Must be a different zone in the same region as the source share.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewSharePrototypeShareContext : Instantiate SharePrototypeShareContext (Generic Model Constructor)
func (*VpcV1) NewSharePrototypeShareContext(profile ShareProfileIdentityIntf, replicationCronSpec string, zone ZoneIdentityIntf) (_model *SharePrototypeShareContext, err error) {
	_model = &SharePrototypeShareContext{
		Profile:             profile,
		ReplicationCronSpec: core.StringPtr(replicationCronSpec),
		Zone:                zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalSharePrototypeShareContext unmarshals an instance of SharePrototypeShareContext from the specified map of raw messages.
func UnmarshalSharePrototypeShareContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharePrototypeShareContext)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "mount_targets", &obj.MountTargets, UnmarshalShareMountTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalShareProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_cron_spec", &obj.ReplicationCronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareReference : ShareReference struct
type ShareReference struct {
	// The CRN for this file share.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ShareReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this file share.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this file share.
	ID *string `json:"id" validate:"required"`

	// The name for this share. The name is unique across all shares in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ShareReference.ResourceType property.
// The resource type.
const (
	ShareReferenceResourceTypeShareConst = "share"
)

// UnmarshalShareReference unmarshals an instance of ShareReference from the specified map of raw messages.
func UnmarshalShareReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalShareReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type ShareReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalShareReferenceDeleted unmarshals an instance of ShareReferenceDeleted from the specified map of raw messages.
func UnmarshalShareReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareReplicationStatusReason : ShareReplicationStatusReason struct
type ShareReplicationStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the ShareReplicationStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	ShareReplicationStatusReasonCodeCannotInitializeReplicationConst = "cannot_initialize_replication"
	ShareReplicationStatusReasonCodeCannotReachReplicaShareConst     = "cannot_reach_replica_share"
	ShareReplicationStatusReasonCodeCannotReachSourceShareConst      = "cannot_reach_source_share"
)

// UnmarshalShareReplicationStatusReason unmarshals an instance of ShareReplicationStatusReason from the specified map of raw messages.
func UnmarshalShareReplicationStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareReplicationStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Snapshot : Snapshot struct
type Snapshot struct {
	// If present, the backup policy plan which created this snapshot.
	BackupPolicyPlan *BackupPolicyPlanReference `json:"backup_policy_plan,omitempty"`

	// Indicates if a boot volume attachment can be created with a volume created from this snapshot.
	Bootable *bool `json:"bootable" validate:"required"`

	// The date and time the data capture for this snapshot was completed.
	//
	// If absent, this snapshot's data has not yet been captured. Additionally, this property may be absent for snapshots
	// created before 1 January 2022.
	CapturedAt *strfmt.DateTime `json:"captured_at,omitempty"`

	// Clones for this snapshot.
	Clones []SnapshotClone `json:"clones" validate:"required"`

	// The copies of this snapshot.
	Copies []SnapshotCopiesItem `json:"copies" validate:"required"`

	// The date and time that this snapshot was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN of this snapshot.
	CRN *string `json:"crn" validate:"required"`

	// Indicates whether this snapshot can be deleted. This value will always be `true`.
	// Deprecated: this field is deprecated and may be removed in a future release.
	Deletable *bool `json:"deletable" validate:"required"`

	// The type of encryption used on the source volume.
	Encryption *string `json:"encryption" validate:"required"`

	// The root key used to wrap the data encryption key for the source volume.
	//
	// This property will be present for volumes with an `encryption` type of
	// `user_managed`.
	EncryptionKey *EncryptionKeyReference `json:"encryption_key,omitempty"`

	// The URL for this snapshot.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this snapshot.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of this snapshot.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The minimum capacity of a volume created from this snapshot. When a snapshot is created, this will be set to the
	// capacity of the `source_volume`.
	MinimumCapacity *int64 `json:"minimum_capacity" validate:"required"`

	// The name for this snapshot. The name is unique across all snapshots in the region.
	Name *string `json:"name" validate:"required"`

	// The operating system included in this snapshot.
	OperatingSystem *OperatingSystem `json:"operating_system,omitempty"`

	// The resource group for this snapshot.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The [service tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) prefixed with `is.snapshot:` associated with
	// this snapshot.
	ServiceTags []string `json:"service_tags" validate:"required"`

	// The size of this snapshot rounded up to the next gigabyte.
	Size *int64 `json:"size" validate:"required"`

	// If present, the image from which the data on this snapshot was most directly
	// provisioned.
	SourceImage *ImageReference `json:"source_image,omitempty"`

	// If present, the source snapshot this snapshot was created from.
	SourceSnapshot *SnapshotSourceSnapshot `json:"source_snapshot,omitempty"`

	// The source volume this snapshot was created from (may be
	// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
	SourceVolume *VolumeReference `json:"source_volume" validate:"required"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot.
	UserTags []string `json:"user_tags" validate:"required"`
}

// Constants associated with the Snapshot.Encryption property.
// The type of encryption used on the source volume.
const (
	SnapshotEncryptionProviderManagedConst = "provider_managed"
	SnapshotEncryptionUserManagedConst     = "user_managed"
)

// Constants associated with the Snapshot.LifecycleState property.
// The lifecycle state of this snapshot.
const (
	SnapshotLifecycleStateDeletingConst  = "deleting"
	SnapshotLifecycleStateFailedConst    = "failed"
	SnapshotLifecycleStatePendingConst   = "pending"
	SnapshotLifecycleStateStableConst    = "stable"
	SnapshotLifecycleStateSuspendedConst = "suspended"
	SnapshotLifecycleStateUpdatingConst  = "updating"
	SnapshotLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the Snapshot.ResourceType property.
// The resource type.
const (
	SnapshotResourceTypeSnapshotConst = "snapshot"
)

// UnmarshalSnapshot unmarshals an instance of Snapshot from the specified map of raw messages.
func UnmarshalSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Snapshot)
	err = core.UnmarshalModel(m, "backup_policy_plan", &obj.BackupPolicyPlan, UnmarshalBackupPolicyPlanReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bootable", &obj.Bootable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "captured_at", &obj.CapturedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clones", &obj.Clones, UnmarshalSnapshotClone)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "copies", &obj.Copies, UnmarshalSnapshotCopiesItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deletable", &obj.Deletable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minimum_capacity", &obj.MinimumCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_tags", &obj.ServiceTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_image", &obj.SourceImage, UnmarshalImageReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotSourceSnapshot)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_volume", &obj.SourceVolume, UnmarshalVolumeReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotClone : SnapshotClone struct
type SnapshotClone struct {
	// Indicates whether this snapshot clone is available for use.
	Available *bool `json:"available" validate:"required"`

	// The date and time that this snapshot clone was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The zone this snapshot clone resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalSnapshotClone unmarshals an instance of SnapshotClone from the specified map of raw messages.
func UnmarshalSnapshotClone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotClone)
	err = core.UnmarshalPrimitive(m, "available", &obj.Available)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotCloneCollection : SnapshotCloneCollection struct
type SnapshotCloneCollection struct {
	// Collection of snapshot clones.
	Clones []SnapshotClone `json:"clones" validate:"required"`
}

// UnmarshalSnapshotCloneCollection unmarshals an instance of SnapshotCloneCollection from the specified map of raw messages.
func UnmarshalSnapshotCloneCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotCloneCollection)
	err = core.UnmarshalModel(m, "clones", &obj.Clones, UnmarshalSnapshotClone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotClonePrototype : SnapshotClonePrototype struct
type SnapshotClonePrototype struct {
	// The zone this snapshot clone will reside in. Must be in the same region as the
	// snapshot.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewSnapshotClonePrototype : Instantiate SnapshotClonePrototype (Generic Model Constructor)
func (*VpcV1) NewSnapshotClonePrototype(zone ZoneIdentityIntf) (_model *SnapshotClonePrototype, err error) {
	_model = &SnapshotClonePrototype{
		Zone: zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalSnapshotClonePrototype unmarshals an instance of SnapshotClonePrototype from the specified map of raw messages.
func UnmarshalSnapshotClonePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotClonePrototype)
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotCollection : SnapshotCollection struct
type SnapshotCollection struct {
	// A link to the first page of resources.
	First *SnapshotCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *SnapshotCollectionNext `json:"next,omitempty"`

	// Collection of snapshots.
	Snapshots []Snapshot `json:"snapshots" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSnapshotCollection unmarshals an instance of SnapshotCollection from the specified map of raw messages.
func UnmarshalSnapshotCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalSnapshotCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalSnapshotCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "snapshots", &obj.Snapshots, UnmarshalSnapshot)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SnapshotCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// SnapshotCollectionFirst : A link to the first page of resources.
type SnapshotCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSnapshotCollectionFirst unmarshals an instance of SnapshotCollectionFirst from the specified map of raw messages.
func UnmarshalSnapshotCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type SnapshotCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSnapshotCollectionNext unmarshals an instance of SnapshotCollectionNext from the specified map of raw messages.
func UnmarshalSnapshotCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotCopiesItem : SnapshotCopiesItem struct
type SnapshotCopiesItem struct {
	// The CRN for the copied snapshot.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SnapshotReferenceDeleted `json:"deleted,omitempty"`

	// The URL for the copied snapshot.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for the copied snapshot.
	ID *string `json:"id" validate:"required"`

	// The name for the copied snapshot.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *SnapshotRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SnapshotCopiesItem.ResourceType property.
// The resource type.
const (
	SnapshotCopiesItemResourceTypeSnapshotConst = "snapshot"
)

// UnmarshalSnapshotCopiesItem unmarshals an instance of SnapshotCopiesItem from the specified map of raw messages.
func UnmarshalSnapshotCopiesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotCopiesItem)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSnapshotReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSnapshotRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotIdentity : Identifies a snapshot by a unique property.
// Models which "extend" this model:
// - SnapshotIdentityByID
// - SnapshotIdentityByCRN
// - SnapshotIdentityByHref
type SnapshotIdentity struct {
	// The unique identifier for this snapshot.
	ID *string `json:"id,omitempty"`

	// The CRN of this snapshot.
	CRN *string `json:"crn,omitempty"`

	// The URL for this snapshot.
	Href *string `json:"href,omitempty"`
}

func (*SnapshotIdentity) isaSnapshotIdentity() bool {
	return true
}

type SnapshotIdentityIntf interface {
	isaSnapshotIdentity() bool
}

// UnmarshalSnapshotIdentity unmarshals an instance of SnapshotIdentity from the specified map of raw messages.
func UnmarshalSnapshotIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotPatch : SnapshotPatch struct
type SnapshotPatch struct {
	// The name for this snapshot. The name must not be used by another snapshot in the region.
	Name *string `json:"name,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot.
	UserTags []string `json:"user_tags,omitempty"`
}

// UnmarshalSnapshotPatch unmarshals an instance of SnapshotPatch from the specified map of raw messages.
func UnmarshalSnapshotPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the SnapshotPatch
func (snapshotPatch *SnapshotPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(snapshotPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// SnapshotPrototype : SnapshotPrototype struct
// Models which "extend" this model:
// - SnapshotPrototypeSnapshotBySourceVolume
// - SnapshotPrototypeSnapshotBySourceSnapshot
type SnapshotPrototype struct {
	// Clones to create for this snapshot.
	Clones []SnapshotClonePrototype `json:"clones,omitempty"`

	// The name for this snapshot. The name must not be used by another snapshot in the region. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot.
	UserTags []string `json:"user_tags,omitempty"`

	// The volume to create this snapshot from.
	SourceVolume VolumeIdentityIntf `json:"source_volume,omitempty"`

	// The root key to use to wrap the data encryption key for this snapshot.
	//
	// A key must be specified if and only if the source snapshot has an `encryption` type of
	// `user_managed`. To maximize snapshot availability and sharing of snapshot data, specify
	// a key in the same region as the new snapshot, and use the same encryption key for all
	// snapshots using the same source volume.
	//
	// The specified key may be in a different account, subject to IAM policies.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The source snapshot (in another region) to create this snapshot from.
	// The specified snapshot must not already be the source of another snapshot in this
	// region.
	SourceSnapshot *SnapshotIdentityByCRN `json:"source_snapshot,omitempty"`
}

func (*SnapshotPrototype) isaSnapshotPrototype() bool {
	return true
}

type SnapshotPrototypeIntf interface {
	isaSnapshotPrototype() bool
}

// UnmarshalSnapshotPrototype unmarshals an instance of SnapshotPrototype from the specified map of raw messages.
func UnmarshalSnapshotPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotPrototype)
	err = core.UnmarshalModel(m, "clones", &obj.Clones, UnmarshalSnapshotClonePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_volume", &obj.SourceVolume, UnmarshalVolumeIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentityByCRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotReference : SnapshotReference struct
type SnapshotReference struct {
	// The CRN of this snapshot.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SnapshotReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this snapshot.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this snapshot.
	ID *string `json:"id" validate:"required"`

	// The name for this snapshot. The name is unique across all snapshots in the region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *SnapshotRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SnapshotReference.ResourceType property.
// The resource type.
const (
	SnapshotReferenceResourceTypeSnapshotConst = "snapshot"
)

// UnmarshalSnapshotReference unmarshals an instance of SnapshotReference from the specified map of raw messages.
func UnmarshalSnapshotReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSnapshotReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSnapshotRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type SnapshotReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalSnapshotReferenceDeleted unmarshals an instance of SnapshotReferenceDeleted from the specified map of raw messages.
func UnmarshalSnapshotReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotRemote : If present, this property indicates that the resource associated with this reference is remote and therefore may not
// be directly retrievable.
type SnapshotRemote struct {
	// If present, this property indicates that the referenced resource is remote to this
	// region, and identifies the native region.
	Region *RegionReference `json:"region,omitempty"`
}

// UnmarshalSnapshotRemote unmarshals an instance of SnapshotRemote from the specified map of raw messages.
func UnmarshalSnapshotRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotRemote)
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotSourceSnapshot : If present, the source snapshot this snapshot was created from.
type SnapshotSourceSnapshot struct {
	// The CRN of the source snapshot.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SnapshotReferenceDeleted `json:"deleted,omitempty"`

	// The URL for the source snapshot.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for the source snapshot.
	ID *string `json:"id" validate:"required"`

	// The name for the source snapshot. The name is unique across all snapshots in the source snapshot's native region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *SnapshotRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SnapshotSourceSnapshot.ResourceType property.
// The resource type.
const (
	SnapshotSourceSnapshotResourceTypeSnapshotConst = "snapshot"
)

// UnmarshalSnapshotSourceSnapshot unmarshals an instance of SnapshotSourceSnapshot from the specified map of raw messages.
func UnmarshalSnapshotSourceSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotSourceSnapshot)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSnapshotReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSnapshotRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StartBareMetalServerOptions : The StartBareMetalServer options.
type StartBareMetalServerOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewStartBareMetalServerOptions : Instantiate StartBareMetalServerOptions
func (*VpcV1) NewStartBareMetalServerOptions(id string) *StartBareMetalServerOptions {
	return &StartBareMetalServerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *StartBareMetalServerOptions) SetID(id string) *StartBareMetalServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *StartBareMetalServerOptions) SetHeaders(param map[string]string) *StartBareMetalServerOptions {
	options.Headers = param
	return options
}

// StopBareMetalServerOptions : The StopBareMetalServer options.
type StopBareMetalServerOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The type of stop operation:
	// - `soft`: signal running operating system to quiesce and shutdown cleanly
	// - `hard`: immediately stop the server.
	Type *string `json:"type" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the StopBareMetalServerOptions.Type property.
// The type of stop operation:
// - `soft`: signal running operating system to quiesce and shutdown cleanly
// - `hard`: immediately stop the server.
const (
	StopBareMetalServerOptionsTypeHardConst = "hard"
	StopBareMetalServerOptionsTypeSoftConst = "soft"
)

// NewStopBareMetalServerOptions : Instantiate StopBareMetalServerOptions
func (*VpcV1) NewStopBareMetalServerOptions(id string, typeVar string) *StopBareMetalServerOptions {
	return &StopBareMetalServerOptions{
		ID:   core.StringPtr(id),
		Type: core.StringPtr(typeVar),
	}
}

// SetID : Allow user to set ID
func (_options *StopBareMetalServerOptions) SetID(id string) *StopBareMetalServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *StopBareMetalServerOptions) SetType(typeVar string) *StopBareMetalServerOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *StopBareMetalServerOptions) SetHeaders(param map[string]string) *StopBareMetalServerOptions {
	options.Headers = param
	return options
}

// Subnet : Subnet struct
type Subnet struct {
	// The number of IPv4 addresses in this subnet that are not in-use, and have not been reserved by the user or the
	// provider.
	AvailableIpv4AddressCount *int64 `json:"available_ipv4_address_count" validate:"required"`

	// The date and time that the subnet was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The IP version(s) supported by this subnet.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The IPv4 range of the subnet, expressed in CIDR format.
	Ipv4CIDRBlock *string `json:"ipv4_cidr_block" validate:"required"`

	// The name for this subnet. The name is unique across all subnets in the VPC.
	Name *string `json:"name" validate:"required"`

	// The network ACL for this subnet.
	NetworkACL *NetworkACLReference `json:"network_acl" validate:"required"`

	// The public gateway to use for internet-bound traffic for this subnet.
	PublicGateway *PublicGatewayReference `json:"public_gateway,omitempty"`

	// The resource group for this subnet.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The routing table for this subnet.
	RoutingTable *RoutingTableReference `json:"routing_table" validate:"required"`

	// The status of the subnet.
	Status *string `json:"status" validate:"required"`

	// The total number of IPv4 addresses in this subnet.
	//
	// Note: This is calculated as 2<sup>(32 - prefix length)</sup>. For example, the prefix length `/24` gives:<br>
	// 2<sup>(32 - 24)</sup> = 2<sup>8</sup> = 256 addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count" validate:"required"`

	// The VPC this subnet resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone this subnet resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Subnet.IPVersion property.
// The IP version(s) supported by this subnet.
const (
	SubnetIPVersionIpv4Const = "ipv4"
)

// Constants associated with the Subnet.ResourceType property.
// The resource type.
const (
	SubnetResourceTypeSubnetConst = "subnet"
)

// Constants associated with the Subnet.Status property.
// The status of the subnet.
const (
	SubnetStatusAvailableConst = "available"
	SubnetStatusDeletingConst  = "deleting"
	SubnetStatusFailedConst    = "failed"
	SubnetStatusPendingConst   = "pending"
)

// UnmarshalSubnet unmarshals an instance of Subnet from the specified map of raw messages.
func UnmarshalSubnet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subnet)
	err = core.UnmarshalPrimitive(m, "available_ipv4_address_count", &obj.AvailableIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4_cidr_block", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_ipv4_address_count", &obj.TotalIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetCollection : SubnetCollection struct
type SubnetCollection struct {
	// A link to the first page of resources.
	First *SubnetCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *SubnetCollectionNext `json:"next,omitempty"`

	// Collection of subnets.
	Subnets []Subnet `json:"subnets" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSubnetCollection unmarshals an instance of SubnetCollection from the specified map of raw messages.
func UnmarshalSubnetCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalSubnetCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalSubnetCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SubnetCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// SubnetCollectionFirst : A link to the first page of resources.
type SubnetCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSubnetCollectionFirst unmarshals an instance of SubnetCollectionFirst from the specified map of raw messages.
func UnmarshalSubnetCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type SubnetCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSubnetCollectionNext unmarshals an instance of SubnetCollectionNext from the specified map of raw messages.
func UnmarshalSubnetCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentity : Identifies a subnet by a unique property.
// Models which "extend" this model:
// - SubnetIdentityByID
// - SubnetIdentityByCRN
// - SubnetIdentityByHref
type SubnetIdentity struct {
	// The unique identifier for this subnet.
	ID *string `json:"id,omitempty"`

	// The CRN for this subnet.
	CRN *string `json:"crn,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href,omitempty"`
}

func (*SubnetIdentity) isaSubnetIdentity() bool {
	return true
}

type SubnetIdentityIntf interface {
	isaSubnetIdentity() bool
}

// UnmarshalSubnetIdentity unmarshals an instance of SubnetIdentity from the specified map of raw messages.
func UnmarshalSubnetIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPatch : SubnetPatch struct
type SubnetPatch struct {
	// The name for this subnet. The name must not be used by another subnet in the VPC.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to use for internet-bound traffic for this subnet.
	PublicGateway SubnetPublicGatewayPatchIntf `json:"public_gateway,omitempty"`

	// The routing table to use for this subnet.  The routing table properties
	// `route_direct_link_ingress`, `route_internet_ingress`,
	// `route_transit_gateway_ingress`, and `route_vpc_zone_ingress` must be `false`.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`
}

// UnmarshalSubnetPatch unmarshals an instance of SubnetPatch from the specified map of raw messages.
func UnmarshalSubnetPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalSubnetPublicGatewayPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the SubnetPatch
func (subnetPatch *SubnetPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(subnetPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// SubnetPrototype : SubnetPrototype struct
// Models which "extend" this model:
// - SubnetPrototypeSubnetByTotalCount
// - SubnetPrototypeSubnetByCIDR
type SubnetPrototype struct {
	// The IP version(s) to support for this subnet.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this subnet. The name must not be used by another subnet in the VPC. If unspecified, the name will be a
	// hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to use for internet-bound traffic for this subnet. If
	// unspecified, the subnet will not be attached to a public gateway.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The routing table to use for this subnet. If unspecified, the default routing table
	// for the VPC is used. The routing table properties `route_direct_link_ingress`,
	// `route_internet_ingress`, `route_transit_gateway_ingress`, and
	// `route_vpc_zone_ingress` must be `false`.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// The VPC the subnet will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address prefix in the
	// specified zone, and that prefix must have a free CIDR range with at least this number of addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count,omitempty"`

	// The zone this subnet will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be between `/9`
	// (8,388,608 addresses) and `/29` (8 addresses). The IPv4 range of the subnet's CIDR must fall within an existing
	// address prefix in the VPC and must not overlap with any existing subnet. The subnet will be created in the zone of
	// the address prefix that contains the IPv4 CIDR. If zone is specified, it must match the zone of the address prefix
	// that contains the subnet's IPv4 CIDR.
	Ipv4CIDRBlock *string `json:"ipv4_cidr_block,omitempty"`
}

// Constants associated with the SubnetPrototype.IPVersion property.
// The IP version(s) to support for this subnet.
const (
	SubnetPrototypeIPVersionIpv4Const = "ipv4"
)

func (*SubnetPrototype) isaSubnetPrototype() bool {
	return true
}

type SubnetPrototypeIntf interface {
	isaSubnetPrototype() bool
}

// UnmarshalSubnetPrototype unmarshals an instance of SubnetPrototype from the specified map of raw messages.
func UnmarshalSubnetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPrototype)
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_ipv4_address_count", &obj.TotalIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4_cidr_block", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPublicGatewayPatch : The public gateway to use for internet-bound traffic for this subnet.
// Models which "extend" this model:
// - SubnetPublicGatewayPatchPublicGatewayIdentityByID
// - SubnetPublicGatewayPatchPublicGatewayIdentityByCRN
// - SubnetPublicGatewayPatchPublicGatewayIdentityByHref
type SubnetPublicGatewayPatch struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id,omitempty"`

	// The CRN for this public gateway.
	CRN *string `json:"crn,omitempty"`

	// The URL for this public gateway.
	Href *string `json:"href,omitempty"`
}

func (*SubnetPublicGatewayPatch) isaSubnetPublicGatewayPatch() bool {
	return true
}

type SubnetPublicGatewayPatchIntf interface {
	isaSubnetPublicGatewayPatch() bool
}

// UnmarshalSubnetPublicGatewayPatch unmarshals an instance of SubnetPublicGatewayPatch from the specified map of raw messages.
func UnmarshalSubnetPublicGatewayPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPublicGatewayPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetReference : SubnetReference struct
type SubnetReference struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SubnetReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The name for this subnet. The name is unique across all subnets in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SubnetReference.ResourceType property.
// The resource type.
const (
	SubnetReferenceResourceTypeSubnetConst = "subnet"
)

// UnmarshalSubnetReference unmarshals an instance of SubnetReference from the specified map of raw messages.
func UnmarshalSubnetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSubnetReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type SubnetReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalSubnetReferenceDeleted unmarshals an instance of SubnetReferenceDeleted from the specified map of raw messages.
func UnmarshalSubnetReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TrustedProfileIdentity : Identifies a trusted profile by a unique property.
// Models which "extend" this model:
// - TrustedProfileIdentityTrustedProfileByID
// - TrustedProfileIdentityTrustedProfileByCRN
type TrustedProfileIdentity struct {
	// The unique identifier for this trusted profile.
	ID *string `json:"id,omitempty"`

	// The CRN for this trusted profile.
	CRN *string `json:"crn,omitempty"`
}

func (*TrustedProfileIdentity) isaTrustedProfileIdentity() bool {
	return true
}

type TrustedProfileIdentityIntf interface {
	isaTrustedProfileIdentity() bool
}

// UnmarshalTrustedProfileIdentity unmarshals an instance of TrustedProfileIdentity from the specified map of raw messages.
func UnmarshalTrustedProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TrustedProfileIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TrustedProfileReference : TrustedProfileReference struct
type TrustedProfileReference struct {
	// The CRN for this trusted profile.
	CRN *string `json:"crn" validate:"required"`

	// The unique identifier for this trusted profile.
	ID *string `json:"id" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the TrustedProfileReference.ResourceType property.
// The resource type.
const (
	TrustedProfileReferenceResourceTypeTrustedProfileConst = "trusted_profile"
)

// UnmarshalTrustedProfileReference unmarshals an instance of TrustedProfileReference from the specified map of raw messages.
func UnmarshalTrustedProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TrustedProfileReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UnsetSubnetPublicGatewayOptions : The UnsetSubnetPublicGateway options.
type UnsetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUnsetSubnetPublicGatewayOptions : Instantiate UnsetSubnetPublicGatewayOptions
func (*VpcV1) NewUnsetSubnetPublicGatewayOptions(id string) *UnsetSubnetPublicGatewayOptions {
	return &UnsetSubnetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UnsetSubnetPublicGatewayOptions) SetID(id string) *UnsetSubnetPublicGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UnsetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *UnsetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// UpdateBackupPolicyOptions : The UpdateBackupPolicy options.
type UpdateBackupPolicyOptions struct {
	// The backup policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The backup policy patch.
	BackupPolicyPatch map[string]interface{} `json:"BackupPolicy_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateBackupPolicyOptions : Instantiate UpdateBackupPolicyOptions
func (*VpcV1) NewUpdateBackupPolicyOptions(id string, backupPolicyPatch map[string]interface{}) *UpdateBackupPolicyOptions {
	return &UpdateBackupPolicyOptions{
		ID:                core.StringPtr(id),
		BackupPolicyPatch: backupPolicyPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateBackupPolicyOptions) SetID(id string) *UpdateBackupPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetBackupPolicyPatch : Allow user to set BackupPolicyPatch
func (_options *UpdateBackupPolicyOptions) SetBackupPolicyPatch(backupPolicyPatch map[string]interface{}) *UpdateBackupPolicyOptions {
	_options.BackupPolicyPatch = backupPolicyPatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateBackupPolicyOptions) SetIfMatch(ifMatch string) *UpdateBackupPolicyOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateBackupPolicyOptions) SetHeaders(param map[string]string) *UpdateBackupPolicyOptions {
	options.Headers = param
	return options
}

// UpdateBackupPolicyPlanOptions : The UpdateBackupPolicyPlan options.
type UpdateBackupPolicyPlanOptions struct {
	// The backup policy identifier.
	BackupPolicyID *string `json:"backup_policy_id" validate:"required,ne="`

	// The backup policy plan identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The backup policy plan patch.
	BackupPolicyPlanPatch map[string]interface{} `json:"BackupPolicyPlan_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateBackupPolicyPlanOptions : Instantiate UpdateBackupPolicyPlanOptions
func (*VpcV1) NewUpdateBackupPolicyPlanOptions(backupPolicyID string, id string, backupPolicyPlanPatch map[string]interface{}) *UpdateBackupPolicyPlanOptions {
	return &UpdateBackupPolicyPlanOptions{
		BackupPolicyID:        core.StringPtr(backupPolicyID),
		ID:                    core.StringPtr(id),
		BackupPolicyPlanPatch: backupPolicyPlanPatch,
	}
}

// SetBackupPolicyID : Allow user to set BackupPolicyID
func (_options *UpdateBackupPolicyPlanOptions) SetBackupPolicyID(backupPolicyID string) *UpdateBackupPolicyPlanOptions {
	_options.BackupPolicyID = core.StringPtr(backupPolicyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateBackupPolicyPlanOptions) SetID(id string) *UpdateBackupPolicyPlanOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetBackupPolicyPlanPatch : Allow user to set BackupPolicyPlanPatch
func (_options *UpdateBackupPolicyPlanOptions) SetBackupPolicyPlanPatch(backupPolicyPlanPatch map[string]interface{}) *UpdateBackupPolicyPlanOptions {
	_options.BackupPolicyPlanPatch = backupPolicyPlanPatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateBackupPolicyPlanOptions) SetIfMatch(ifMatch string) *UpdateBackupPolicyPlanOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateBackupPolicyPlanOptions) SetHeaders(param map[string]string) *UpdateBackupPolicyPlanOptions {
	options.Headers = param
	return options
}

// UpdateBareMetalServerDiskOptions : The UpdateBareMetalServerDisk options.
type UpdateBareMetalServerDiskOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server disk identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The bare metal server disk patch.
	BareMetalServerDiskPatch map[string]interface{} `json:"BareMetalServerDisk_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateBareMetalServerDiskOptions : Instantiate UpdateBareMetalServerDiskOptions
func (*VpcV1) NewUpdateBareMetalServerDiskOptions(bareMetalServerID string, id string, bareMetalServerDiskPatch map[string]interface{}) *UpdateBareMetalServerDiskOptions {
	return &UpdateBareMetalServerDiskOptions{
		BareMetalServerID:        core.StringPtr(bareMetalServerID),
		ID:                       core.StringPtr(id),
		BareMetalServerDiskPatch: bareMetalServerDiskPatch,
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *UpdateBareMetalServerDiskOptions) SetBareMetalServerID(bareMetalServerID string) *UpdateBareMetalServerDiskOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateBareMetalServerDiskOptions) SetID(id string) *UpdateBareMetalServerDiskOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetBareMetalServerDiskPatch : Allow user to set BareMetalServerDiskPatch
func (_options *UpdateBareMetalServerDiskOptions) SetBareMetalServerDiskPatch(bareMetalServerDiskPatch map[string]interface{}) *UpdateBareMetalServerDiskOptions {
	_options.BareMetalServerDiskPatch = bareMetalServerDiskPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateBareMetalServerDiskOptions) SetHeaders(param map[string]string) *UpdateBareMetalServerDiskOptions {
	options.Headers = param
	return options
}

// UpdateBareMetalServerNetworkInterfaceOptions : The UpdateBareMetalServerNetworkInterface options.
type UpdateBareMetalServerNetworkInterfaceOptions struct {
	// The bare metal server identifier.
	BareMetalServerID *string `json:"bare_metal_server_id" validate:"required,ne="`

	// The bare metal server network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The bare metal server network interface patch.
	BareMetalServerNetworkInterfacePatch map[string]interface{} `json:"BareMetalServerNetworkInterface_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateBareMetalServerNetworkInterfaceOptions : Instantiate UpdateBareMetalServerNetworkInterfaceOptions
func (*VpcV1) NewUpdateBareMetalServerNetworkInterfaceOptions(bareMetalServerID string, id string, bareMetalServerNetworkInterfacePatch map[string]interface{}) *UpdateBareMetalServerNetworkInterfaceOptions {
	return &UpdateBareMetalServerNetworkInterfaceOptions{
		BareMetalServerID:                    core.StringPtr(bareMetalServerID),
		ID:                                   core.StringPtr(id),
		BareMetalServerNetworkInterfacePatch: bareMetalServerNetworkInterfacePatch,
	}
}

// SetBareMetalServerID : Allow user to set BareMetalServerID
func (_options *UpdateBareMetalServerNetworkInterfaceOptions) SetBareMetalServerID(bareMetalServerID string) *UpdateBareMetalServerNetworkInterfaceOptions {
	_options.BareMetalServerID = core.StringPtr(bareMetalServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateBareMetalServerNetworkInterfaceOptions) SetID(id string) *UpdateBareMetalServerNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetBareMetalServerNetworkInterfacePatch : Allow user to set BareMetalServerNetworkInterfacePatch
func (_options *UpdateBareMetalServerNetworkInterfaceOptions) SetBareMetalServerNetworkInterfacePatch(bareMetalServerNetworkInterfacePatch map[string]interface{}) *UpdateBareMetalServerNetworkInterfaceOptions {
	_options.BareMetalServerNetworkInterfacePatch = bareMetalServerNetworkInterfacePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateBareMetalServerNetworkInterfaceOptions) SetHeaders(param map[string]string) *UpdateBareMetalServerNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// UpdateBareMetalServerOptions : The UpdateBareMetalServer options.
type UpdateBareMetalServerOptions struct {
	// The bare metal server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The bare metal server patch.
	BareMetalServerPatch map[string]interface{} `json:"BareMetalServer_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateBareMetalServerOptions : Instantiate UpdateBareMetalServerOptions
func (*VpcV1) NewUpdateBareMetalServerOptions(id string, bareMetalServerPatch map[string]interface{}) *UpdateBareMetalServerOptions {
	return &UpdateBareMetalServerOptions{
		ID:                   core.StringPtr(id),
		BareMetalServerPatch: bareMetalServerPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateBareMetalServerOptions) SetID(id string) *UpdateBareMetalServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetBareMetalServerPatch : Allow user to set BareMetalServerPatch
func (_options *UpdateBareMetalServerOptions) SetBareMetalServerPatch(bareMetalServerPatch map[string]interface{}) *UpdateBareMetalServerOptions {
	_options.BareMetalServerPatch = bareMetalServerPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateBareMetalServerOptions) SetHeaders(param map[string]string) *UpdateBareMetalServerOptions {
	options.Headers = param
	return options
}

// UpdateDedicatedHostDiskOptions : The UpdateDedicatedHostDisk options.
type UpdateDedicatedHostDiskOptions struct {
	// The dedicated host identifier.
	DedicatedHostID *string `json:"dedicated_host_id" validate:"required,ne="`

	// The dedicated host disk identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The dedicated host disk patch.
	DedicatedHostDiskPatch map[string]interface{} `json:"DedicatedHostDisk_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDedicatedHostDiskOptions : Instantiate UpdateDedicatedHostDiskOptions
func (*VpcV1) NewUpdateDedicatedHostDiskOptions(dedicatedHostID string, id string, dedicatedHostDiskPatch map[string]interface{}) *UpdateDedicatedHostDiskOptions {
	return &UpdateDedicatedHostDiskOptions{
		DedicatedHostID:        core.StringPtr(dedicatedHostID),
		ID:                     core.StringPtr(id),
		DedicatedHostDiskPatch: dedicatedHostDiskPatch,
	}
}

// SetDedicatedHostID : Allow user to set DedicatedHostID
func (_options *UpdateDedicatedHostDiskOptions) SetDedicatedHostID(dedicatedHostID string) *UpdateDedicatedHostDiskOptions {
	_options.DedicatedHostID = core.StringPtr(dedicatedHostID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateDedicatedHostDiskOptions) SetID(id string) *UpdateDedicatedHostDiskOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDedicatedHostDiskPatch : Allow user to set DedicatedHostDiskPatch
func (_options *UpdateDedicatedHostDiskOptions) SetDedicatedHostDiskPatch(dedicatedHostDiskPatch map[string]interface{}) *UpdateDedicatedHostDiskOptions {
	_options.DedicatedHostDiskPatch = dedicatedHostDiskPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDedicatedHostDiskOptions) SetHeaders(param map[string]string) *UpdateDedicatedHostDiskOptions {
	options.Headers = param
	return options
}

// UpdateDedicatedHostGroupOptions : The UpdateDedicatedHostGroup options.
type UpdateDedicatedHostGroupOptions struct {
	// The dedicated host group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The dedicated host group patch.
	DedicatedHostGroupPatch map[string]interface{} `json:"DedicatedHostGroup_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDedicatedHostGroupOptions : Instantiate UpdateDedicatedHostGroupOptions
func (*VpcV1) NewUpdateDedicatedHostGroupOptions(id string, dedicatedHostGroupPatch map[string]interface{}) *UpdateDedicatedHostGroupOptions {
	return &UpdateDedicatedHostGroupOptions{
		ID:                      core.StringPtr(id),
		DedicatedHostGroupPatch: dedicatedHostGroupPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateDedicatedHostGroupOptions) SetID(id string) *UpdateDedicatedHostGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDedicatedHostGroupPatch : Allow user to set DedicatedHostGroupPatch
func (_options *UpdateDedicatedHostGroupOptions) SetDedicatedHostGroupPatch(dedicatedHostGroupPatch map[string]interface{}) *UpdateDedicatedHostGroupOptions {
	_options.DedicatedHostGroupPatch = dedicatedHostGroupPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDedicatedHostGroupOptions) SetHeaders(param map[string]string) *UpdateDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// UpdateDedicatedHostOptions : The UpdateDedicatedHost options.
type UpdateDedicatedHostOptions struct {
	// The dedicated host identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The dedicated host patch.
	DedicatedHostPatch map[string]interface{} `json:"DedicatedHost_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDedicatedHostOptions : Instantiate UpdateDedicatedHostOptions
func (*VpcV1) NewUpdateDedicatedHostOptions(id string, dedicatedHostPatch map[string]interface{}) *UpdateDedicatedHostOptions {
	return &UpdateDedicatedHostOptions{
		ID:                 core.StringPtr(id),
		DedicatedHostPatch: dedicatedHostPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateDedicatedHostOptions) SetID(id string) *UpdateDedicatedHostOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDedicatedHostPatch : Allow user to set DedicatedHostPatch
func (_options *UpdateDedicatedHostOptions) SetDedicatedHostPatch(dedicatedHostPatch map[string]interface{}) *UpdateDedicatedHostOptions {
	_options.DedicatedHostPatch = dedicatedHostPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDedicatedHostOptions) SetHeaders(param map[string]string) *UpdateDedicatedHostOptions {
	options.Headers = param
	return options
}

// UpdateEndpointGatewayOptions : The UpdateEndpointGateway options.
type UpdateEndpointGatewayOptions struct {
	// The endpoint gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The endpoint gateway patch.
	EndpointGatewayPatch map[string]interface{} `json:"EndpointGateway_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateEndpointGatewayOptions : Instantiate UpdateEndpointGatewayOptions
func (*VpcV1) NewUpdateEndpointGatewayOptions(id string, endpointGatewayPatch map[string]interface{}) *UpdateEndpointGatewayOptions {
	return &UpdateEndpointGatewayOptions{
		ID:                   core.StringPtr(id),
		EndpointGatewayPatch: endpointGatewayPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateEndpointGatewayOptions) SetID(id string) *UpdateEndpointGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetEndpointGatewayPatch : Allow user to set EndpointGatewayPatch
func (_options *UpdateEndpointGatewayOptions) SetEndpointGatewayPatch(endpointGatewayPatch map[string]interface{}) *UpdateEndpointGatewayOptions {
	_options.EndpointGatewayPatch = endpointGatewayPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateEndpointGatewayOptions) SetHeaders(param map[string]string) *UpdateEndpointGatewayOptions {
	options.Headers = param
	return options
}

// UpdateFloatingIPOptions : The UpdateFloatingIP options.
type UpdateFloatingIPOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The floating IP patch.
	FloatingIPPatch map[string]interface{} `json:"FloatingIP_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateFloatingIPOptions : Instantiate UpdateFloatingIPOptions
func (*VpcV1) NewUpdateFloatingIPOptions(id string, floatingIPPatch map[string]interface{}) *UpdateFloatingIPOptions {
	return &UpdateFloatingIPOptions{
		ID:              core.StringPtr(id),
		FloatingIPPatch: floatingIPPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateFloatingIPOptions) SetID(id string) *UpdateFloatingIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFloatingIPPatch : Allow user to set FloatingIPPatch
func (_options *UpdateFloatingIPOptions) SetFloatingIPPatch(floatingIPPatch map[string]interface{}) *UpdateFloatingIPOptions {
	_options.FloatingIPPatch = floatingIPPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFloatingIPOptions) SetHeaders(param map[string]string) *UpdateFloatingIPOptions {
	options.Headers = param
	return options
}

// UpdateFlowLogCollectorOptions : The UpdateFlowLogCollector options.
type UpdateFlowLogCollectorOptions struct {
	// The flow log collector identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The flow log collector patch.
	FlowLogCollectorPatch map[string]interface{} `json:"FlowLogCollector_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateFlowLogCollectorOptions : Instantiate UpdateFlowLogCollectorOptions
func (*VpcV1) NewUpdateFlowLogCollectorOptions(id string, flowLogCollectorPatch map[string]interface{}) *UpdateFlowLogCollectorOptions {
	return &UpdateFlowLogCollectorOptions{
		ID:                    core.StringPtr(id),
		FlowLogCollectorPatch: flowLogCollectorPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateFlowLogCollectorOptions) SetID(id string) *UpdateFlowLogCollectorOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFlowLogCollectorPatch : Allow user to set FlowLogCollectorPatch
func (_options *UpdateFlowLogCollectorOptions) SetFlowLogCollectorPatch(flowLogCollectorPatch map[string]interface{}) *UpdateFlowLogCollectorOptions {
	_options.FlowLogCollectorPatch = flowLogCollectorPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFlowLogCollectorOptions) SetHeaders(param map[string]string) *UpdateFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// UpdateIkePolicyOptions : The UpdateIkePolicy options.
type UpdateIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The IKE policy patch.
	IkePolicyPatch map[string]interface{} `json:"IkePolicy_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateIkePolicyOptions : Instantiate UpdateIkePolicyOptions
func (*VpcV1) NewUpdateIkePolicyOptions(id string, ikePolicyPatch map[string]interface{}) *UpdateIkePolicyOptions {
	return &UpdateIkePolicyOptions{
		ID:             core.StringPtr(id),
		IkePolicyPatch: ikePolicyPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateIkePolicyOptions) SetID(id string) *UpdateIkePolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIkePolicyPatch : Allow user to set IkePolicyPatch
func (_options *UpdateIkePolicyOptions) SetIkePolicyPatch(ikePolicyPatch map[string]interface{}) *UpdateIkePolicyOptions {
	_options.IkePolicyPatch = ikePolicyPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateIkePolicyOptions) SetHeaders(param map[string]string) *UpdateIkePolicyOptions {
	options.Headers = param
	return options
}

// UpdateImageExportJobOptions : The UpdateImageExportJob options.
type UpdateImageExportJobOptions struct {
	// The image identifier.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// The image export job identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The image export job patch.
	ImageExportJobPatch map[string]interface{} `json:"ImageExportJob_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateImageExportJobOptions : Instantiate UpdateImageExportJobOptions
func (*VpcV1) NewUpdateImageExportJobOptions(imageID string, id string, imageExportJobPatch map[string]interface{}) *UpdateImageExportJobOptions {
	return &UpdateImageExportJobOptions{
		ImageID:             core.StringPtr(imageID),
		ID:                  core.StringPtr(id),
		ImageExportJobPatch: imageExportJobPatch,
	}
}

// SetImageID : Allow user to set ImageID
func (_options *UpdateImageExportJobOptions) SetImageID(imageID string) *UpdateImageExportJobOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateImageExportJobOptions) SetID(id string) *UpdateImageExportJobOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetImageExportJobPatch : Allow user to set ImageExportJobPatch
func (_options *UpdateImageExportJobOptions) SetImageExportJobPatch(imageExportJobPatch map[string]interface{}) *UpdateImageExportJobOptions {
	_options.ImageExportJobPatch = imageExportJobPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateImageExportJobOptions) SetHeaders(param map[string]string) *UpdateImageExportJobOptions {
	options.Headers = param
	return options
}

// UpdateImageOptions : The UpdateImage options.
type UpdateImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The image patch.
	ImagePatch map[string]interface{} `json:"Image_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateImageOptions : Instantiate UpdateImageOptions
func (*VpcV1) NewUpdateImageOptions(id string, imagePatch map[string]interface{}) *UpdateImageOptions {
	return &UpdateImageOptions{
		ID:         core.StringPtr(id),
		ImagePatch: imagePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateImageOptions) SetID(id string) *UpdateImageOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetImagePatch : Allow user to set ImagePatch
func (_options *UpdateImageOptions) SetImagePatch(imagePatch map[string]interface{}) *UpdateImageOptions {
	_options.ImagePatch = imagePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateImageOptions) SetHeaders(param map[string]string) *UpdateImageOptions {
	options.Headers = param
	return options
}

// UpdateInstanceDiskOptions : The UpdateInstanceDisk options.
type UpdateInstanceDiskOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance disk identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance disk patch.
	InstanceDiskPatch map[string]interface{} `json:"InstanceDisk_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceDiskOptions : Instantiate UpdateInstanceDiskOptions
func (*VpcV1) NewUpdateInstanceDiskOptions(instanceID string, id string, instanceDiskPatch map[string]interface{}) *UpdateInstanceDiskOptions {
	return &UpdateInstanceDiskOptions{
		InstanceID:        core.StringPtr(instanceID),
		ID:                core.StringPtr(id),
		InstanceDiskPatch: instanceDiskPatch,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateInstanceDiskOptions) SetInstanceID(instanceID string) *UpdateInstanceDiskOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceDiskOptions) SetID(id string) *UpdateInstanceDiskOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceDiskPatch : Allow user to set InstanceDiskPatch
func (_options *UpdateInstanceDiskOptions) SetInstanceDiskPatch(instanceDiskPatch map[string]interface{}) *UpdateInstanceDiskOptions {
	_options.InstanceDiskPatch = instanceDiskPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceDiskOptions) SetHeaders(param map[string]string) *UpdateInstanceDiskOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupManagerActionOptions : The UpdateInstanceGroupManagerAction options.
type UpdateInstanceGroupManagerActionOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager action identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance group manager action patch.
	InstanceGroupManagerActionPatch map[string]interface{} `json:"InstanceGroupManagerAction_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupManagerActionOptions : Instantiate UpdateInstanceGroupManagerActionOptions
func (*VpcV1) NewUpdateInstanceGroupManagerActionOptions(instanceGroupID string, instanceGroupManagerID string, id string, instanceGroupManagerActionPatch map[string]interface{}) *UpdateInstanceGroupManagerActionOptions {
	return &UpdateInstanceGroupManagerActionOptions{
		InstanceGroupID:                 core.StringPtr(instanceGroupID),
		InstanceGroupManagerID:          core.StringPtr(instanceGroupManagerID),
		ID:                              core.StringPtr(id),
		InstanceGroupManagerActionPatch: instanceGroupManagerActionPatch,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *UpdateInstanceGroupManagerActionOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupManagerActionOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *UpdateInstanceGroupManagerActionOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *UpdateInstanceGroupManagerActionOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceGroupManagerActionOptions) SetID(id string) *UpdateInstanceGroupManagerActionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceGroupManagerActionPatch : Allow user to set InstanceGroupManagerActionPatch
func (_options *UpdateInstanceGroupManagerActionOptions) SetInstanceGroupManagerActionPatch(instanceGroupManagerActionPatch map[string]interface{}) *UpdateInstanceGroupManagerActionOptions {
	_options.InstanceGroupManagerActionPatch = instanceGroupManagerActionPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupManagerActionOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupManagerActionOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupManagerOptions : The UpdateInstanceGroupManager options.
type UpdateInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance group manager patch.
	InstanceGroupManagerPatch map[string]interface{} `json:"InstanceGroupManager_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupManagerOptions : Instantiate UpdateInstanceGroupManagerOptions
func (*VpcV1) NewUpdateInstanceGroupManagerOptions(instanceGroupID string, id string, instanceGroupManagerPatch map[string]interface{}) *UpdateInstanceGroupManagerOptions {
	return &UpdateInstanceGroupManagerOptions{
		InstanceGroupID:           core.StringPtr(instanceGroupID),
		ID:                        core.StringPtr(id),
		InstanceGroupManagerPatch: instanceGroupManagerPatch,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *UpdateInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupManagerOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceGroupManagerOptions) SetID(id string) *UpdateInstanceGroupManagerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceGroupManagerPatch : Allow user to set InstanceGroupManagerPatch
func (_options *UpdateInstanceGroupManagerOptions) SetInstanceGroupManagerPatch(instanceGroupManagerPatch map[string]interface{}) *UpdateInstanceGroupManagerOptions {
	_options.InstanceGroupManagerPatch = instanceGroupManagerPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupManagerOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupManagerPolicyOptions : The UpdateInstanceGroupManagerPolicy options.
type UpdateInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required,ne="`

	// The instance group manager policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance group manager policy patch.
	InstanceGroupManagerPolicyPatch map[string]interface{} `json:"InstanceGroupManagerPolicy_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupManagerPolicyOptions : Instantiate UpdateInstanceGroupManagerPolicyOptions
func (*VpcV1) NewUpdateInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, id string, instanceGroupManagerPolicyPatch map[string]interface{}) *UpdateInstanceGroupManagerPolicyOptions {
	return &UpdateInstanceGroupManagerPolicyOptions{
		InstanceGroupID:                 core.StringPtr(instanceGroupID),
		InstanceGroupManagerID:          core.StringPtr(instanceGroupManagerID),
		ID:                              core.StringPtr(id),
		InstanceGroupManagerPolicyPatch: instanceGroupManagerPolicyPatch,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *UpdateInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (_options *UpdateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *UpdateInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceGroupManagerPolicyOptions) SetID(id string) *UpdateInstanceGroupManagerPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceGroupManagerPolicyPatch : Allow user to set InstanceGroupManagerPolicyPatch
func (_options *UpdateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerPolicyPatch(instanceGroupManagerPolicyPatch map[string]interface{}) *UpdateInstanceGroupManagerPolicyOptions {
	_options.InstanceGroupManagerPolicyPatch = instanceGroupManagerPolicyPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupMembershipOptions : The UpdateInstanceGroupMembership options.
type UpdateInstanceGroupMembershipOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required,ne="`

	// The instance group membership identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance group membership patch.
	InstanceGroupMembershipPatch map[string]interface{} `json:"InstanceGroupMembership_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupMembershipOptions : Instantiate UpdateInstanceGroupMembershipOptions
func (*VpcV1) NewUpdateInstanceGroupMembershipOptions(instanceGroupID string, id string, instanceGroupMembershipPatch map[string]interface{}) *UpdateInstanceGroupMembershipOptions {
	return &UpdateInstanceGroupMembershipOptions{
		InstanceGroupID:              core.StringPtr(instanceGroupID),
		ID:                           core.StringPtr(id),
		InstanceGroupMembershipPatch: instanceGroupMembershipPatch,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (_options *UpdateInstanceGroupMembershipOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupMembershipOptions {
	_options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceGroupMembershipOptions) SetID(id string) *UpdateInstanceGroupMembershipOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceGroupMembershipPatch : Allow user to set InstanceGroupMembershipPatch
func (_options *UpdateInstanceGroupMembershipOptions) SetInstanceGroupMembershipPatch(instanceGroupMembershipPatch map[string]interface{}) *UpdateInstanceGroupMembershipOptions {
	_options.InstanceGroupMembershipPatch = instanceGroupMembershipPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupMembershipOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupMembershipOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupOptions : The UpdateInstanceGroup options.
type UpdateInstanceGroupOptions struct {
	// The instance group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance group patch.
	InstanceGroupPatch map[string]interface{} `json:"InstanceGroup_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupOptions : Instantiate UpdateInstanceGroupOptions
func (*VpcV1) NewUpdateInstanceGroupOptions(id string, instanceGroupPatch map[string]interface{}) *UpdateInstanceGroupOptions {
	return &UpdateInstanceGroupOptions{
		ID:                 core.StringPtr(id),
		InstanceGroupPatch: instanceGroupPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceGroupOptions) SetID(id string) *UpdateInstanceGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceGroupPatch : Allow user to set InstanceGroupPatch
func (_options *UpdateInstanceGroupOptions) SetInstanceGroupPatch(instanceGroupPatch map[string]interface{}) *UpdateInstanceGroupOptions {
	_options.InstanceGroupPatch = instanceGroupPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupOptions {
	options.Headers = param
	return options
}

// UpdateInstanceNetworkInterfaceOptions : The UpdateInstanceNetworkInterface options.
type UpdateInstanceNetworkInterfaceOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The instance network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance network interface patch.
	NetworkInterfacePatch map[string]interface{} `json:"NetworkInterface_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceNetworkInterfaceOptions : Instantiate UpdateInstanceNetworkInterfaceOptions
func (*VpcV1) NewUpdateInstanceNetworkInterfaceOptions(instanceID string, id string, networkInterfacePatch map[string]interface{}) *UpdateInstanceNetworkInterfaceOptions {
	return &UpdateInstanceNetworkInterfaceOptions{
		InstanceID:            core.StringPtr(instanceID),
		ID:                    core.StringPtr(id),
		NetworkInterfacePatch: networkInterfacePatch,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *UpdateInstanceNetworkInterfaceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceNetworkInterfaceOptions) SetID(id string) *UpdateInstanceNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetNetworkInterfacePatch : Allow user to set NetworkInterfacePatch
func (_options *UpdateInstanceNetworkInterfaceOptions) SetNetworkInterfacePatch(networkInterfacePatch map[string]interface{}) *UpdateInstanceNetworkInterfaceOptions {
	_options.NetworkInterfacePatch = networkInterfacePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *UpdateInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// UpdateInstanceOptions : The UpdateInstance options.
type UpdateInstanceOptions struct {
	// The virtual server instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance patch.
	InstancePatch map[string]interface{} `json:"Instance_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceOptions : Instantiate UpdateInstanceOptions
func (*VpcV1) NewUpdateInstanceOptions(id string, instancePatch map[string]interface{}) *UpdateInstanceOptions {
	return &UpdateInstanceOptions{
		ID:            core.StringPtr(id),
		InstancePatch: instancePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceOptions) SetID(id string) *UpdateInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstancePatch : Allow user to set InstancePatch
func (_options *UpdateInstanceOptions) SetInstancePatch(instancePatch map[string]interface{}) *UpdateInstanceOptions {
	_options.InstancePatch = instancePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceOptions) SetHeaders(param map[string]string) *UpdateInstanceOptions {
	options.Headers = param
	return options
}

// UpdateInstanceTemplateOptions : The UpdateInstanceTemplate options.
type UpdateInstanceTemplateOptions struct {
	// The instance template identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The instance template patch.
	InstanceTemplatePatch map[string]interface{} `json:"InstanceTemplate_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceTemplateOptions : Instantiate UpdateInstanceTemplateOptions
func (*VpcV1) NewUpdateInstanceTemplateOptions(id string, instanceTemplatePatch map[string]interface{}) *UpdateInstanceTemplateOptions {
	return &UpdateInstanceTemplateOptions{
		ID:                    core.StringPtr(id),
		InstanceTemplatePatch: instanceTemplatePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceTemplateOptions) SetID(id string) *UpdateInstanceTemplateOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInstanceTemplatePatch : Allow user to set InstanceTemplatePatch
func (_options *UpdateInstanceTemplateOptions) SetInstanceTemplatePatch(instanceTemplatePatch map[string]interface{}) *UpdateInstanceTemplateOptions {
	_options.InstanceTemplatePatch = instanceTemplatePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceTemplateOptions) SetHeaders(param map[string]string) *UpdateInstanceTemplateOptions {
	options.Headers = param
	return options
}

// UpdateInstanceVolumeAttachmentOptions : The UpdateInstanceVolumeAttachment options.
type UpdateInstanceVolumeAttachmentOptions struct {
	// The virtual server instance identifier.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The volume attachment patch.
	VolumeAttachmentPatch map[string]interface{} `json:"VolumeAttachment_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceVolumeAttachmentOptions : Instantiate UpdateInstanceVolumeAttachmentOptions
func (*VpcV1) NewUpdateInstanceVolumeAttachmentOptions(instanceID string, id string, volumeAttachmentPatch map[string]interface{}) *UpdateInstanceVolumeAttachmentOptions {
	return &UpdateInstanceVolumeAttachmentOptions{
		InstanceID:            core.StringPtr(instanceID),
		ID:                    core.StringPtr(id),
		VolumeAttachmentPatch: volumeAttachmentPatch,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *UpdateInstanceVolumeAttachmentOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateInstanceVolumeAttachmentOptions) SetID(id string) *UpdateInstanceVolumeAttachmentOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVolumeAttachmentPatch : Allow user to set VolumeAttachmentPatch
func (_options *UpdateInstanceVolumeAttachmentOptions) SetVolumeAttachmentPatch(volumeAttachmentPatch map[string]interface{}) *UpdateInstanceVolumeAttachmentOptions {
	_options.VolumeAttachmentPatch = volumeAttachmentPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *UpdateInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// UpdateIpsecPolicyOptions : The UpdateIpsecPolicy options.
type UpdateIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The IPsec policy patch.
	IPsecPolicyPatch map[string]interface{} `json:"IPsecPolicy_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateIpsecPolicyOptions : Instantiate UpdateIpsecPolicyOptions
func (*VpcV1) NewUpdateIpsecPolicyOptions(id string, iPsecPolicyPatch map[string]interface{}) *UpdateIpsecPolicyOptions {
	return &UpdateIpsecPolicyOptions{
		ID:               core.StringPtr(id),
		IPsecPolicyPatch: iPsecPolicyPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateIpsecPolicyOptions) SetID(id string) *UpdateIpsecPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIPsecPolicyPatch : Allow user to set IPsecPolicyPatch
func (_options *UpdateIpsecPolicyOptions) SetIPsecPolicyPatch(iPsecPolicyPatch map[string]interface{}) *UpdateIpsecPolicyOptions {
	_options.IPsecPolicyPatch = iPsecPolicyPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateIpsecPolicyOptions) SetHeaders(param map[string]string) *UpdateIpsecPolicyOptions {
	options.Headers = param
	return options
}

// UpdateKeyOptions : The UpdateKey options.
type UpdateKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The key patch.
	KeyPatch map[string]interface{} `json:"Key_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateKeyOptions : Instantiate UpdateKeyOptions
func (*VpcV1) NewUpdateKeyOptions(id string, keyPatch map[string]interface{}) *UpdateKeyOptions {
	return &UpdateKeyOptions{
		ID:       core.StringPtr(id),
		KeyPatch: keyPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateKeyOptions) SetID(id string) *UpdateKeyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetKeyPatch : Allow user to set KeyPatch
func (_options *UpdateKeyOptions) SetKeyPatch(keyPatch map[string]interface{}) *UpdateKeyOptions {
	_options.KeyPatch = keyPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateKeyOptions) SetHeaders(param map[string]string) *UpdateKeyOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerOptions : The UpdateLoadBalancerListener options.
type UpdateLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The load balancer listener patch.
	LoadBalancerListenerPatch map[string]interface{} `json:"LoadBalancerListener_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerListenerOptions : Instantiate UpdateLoadBalancerListenerOptions
func (*VpcV1) NewUpdateLoadBalancerListenerOptions(loadBalancerID string, id string, loadBalancerListenerPatch map[string]interface{}) *UpdateLoadBalancerListenerOptions {
	return &UpdateLoadBalancerListenerOptions{
		LoadBalancerID:            core.StringPtr(loadBalancerID),
		ID:                        core.StringPtr(id),
		LoadBalancerListenerPatch: loadBalancerListenerPatch,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *UpdateLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateLoadBalancerListenerOptions) SetID(id string) *UpdateLoadBalancerListenerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLoadBalancerListenerPatch : Allow user to set LoadBalancerListenerPatch
func (_options *UpdateLoadBalancerListenerOptions) SetLoadBalancerListenerPatch(loadBalancerListenerPatch map[string]interface{}) *UpdateLoadBalancerListenerOptions {
	_options.LoadBalancerListenerPatch = loadBalancerListenerPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerPolicyOptions : The UpdateLoadBalancerListenerPolicy options.
type UpdateLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The listener policy patch.
	LoadBalancerListenerPolicyPatch map[string]interface{} `json:"LoadBalancerListenerPolicy_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerListenerPolicyOptions : Instantiate UpdateLoadBalancerListenerPolicyOptions
func (*VpcV1) NewUpdateLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string, loadBalancerListenerPolicyPatch map[string]interface{}) *UpdateLoadBalancerListenerPolicyOptions {
	return &UpdateLoadBalancerListenerPolicyOptions{
		LoadBalancerID:                  core.StringPtr(loadBalancerID),
		ListenerID:                      core.StringPtr(listenerID),
		ID:                              core.StringPtr(id),
		LoadBalancerListenerPolicyPatch: loadBalancerListenerPolicyPatch,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *UpdateLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerPolicyOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *UpdateLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *UpdateLoadBalancerListenerPolicyOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateLoadBalancerListenerPolicyOptions) SetID(id string) *UpdateLoadBalancerListenerPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLoadBalancerListenerPolicyPatch : Allow user to set LoadBalancerListenerPolicyPatch
func (_options *UpdateLoadBalancerListenerPolicyOptions) SetLoadBalancerListenerPolicyPatch(loadBalancerListenerPolicyPatch map[string]interface{}) *UpdateLoadBalancerListenerPolicyOptions {
	_options.LoadBalancerListenerPolicyPatch = loadBalancerListenerPolicyPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerPolicyRuleOptions : The UpdateLoadBalancerListenerPolicyRule options.
type UpdateLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required,ne="`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The listener policy rule patch.
	LoadBalancerListenerPolicyRulePatch map[string]interface{} `json:"LoadBalancerListenerPolicyRule_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerListenerPolicyRuleOptions : Instantiate UpdateLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewUpdateLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string, loadBalancerListenerPolicyRulePatch map[string]interface{}) *UpdateLoadBalancerListenerPolicyRuleOptions {
	return &UpdateLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID:                      core.StringPtr(loadBalancerID),
		ListenerID:                          core.StringPtr(listenerID),
		PolicyID:                            core.StringPtr(policyID),
		ID:                                  core.StringPtr(id),
		LoadBalancerListenerPolicyRulePatch: loadBalancerListenerPolicyRulePatch,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *UpdateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetListenerID : Allow user to set ListenerID
func (_options *UpdateLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	_options.ListenerID = core.StringPtr(listenerID)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *UpdateLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateLoadBalancerListenerPolicyRuleOptions) SetID(id string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLoadBalancerListenerPolicyRulePatch : Allow user to set LoadBalancerListenerPolicyRulePatch
func (_options *UpdateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerListenerPolicyRulePatch(loadBalancerListenerPolicyRulePatch map[string]interface{}) *UpdateLoadBalancerListenerPolicyRuleOptions {
	_options.LoadBalancerListenerPolicyRulePatch = loadBalancerListenerPolicyRulePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerOptions : The UpdateLoadBalancer options.
type UpdateLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The load balancer patch.
	LoadBalancerPatch map[string]interface{} `json:"LoadBalancer_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerOptions : Instantiate UpdateLoadBalancerOptions
func (*VpcV1) NewUpdateLoadBalancerOptions(id string, loadBalancerPatch map[string]interface{}) *UpdateLoadBalancerOptions {
	return &UpdateLoadBalancerOptions{
		ID:                core.StringPtr(id),
		LoadBalancerPatch: loadBalancerPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateLoadBalancerOptions) SetID(id string) *UpdateLoadBalancerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLoadBalancerPatch : Allow user to set LoadBalancerPatch
func (_options *UpdateLoadBalancerOptions) SetLoadBalancerPatch(loadBalancerPatch map[string]interface{}) *UpdateLoadBalancerOptions {
	_options.LoadBalancerPatch = loadBalancerPatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateLoadBalancerOptions) SetIfMatch(ifMatch string) *UpdateLoadBalancerOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolMemberOptions : The UpdateLoadBalancerPoolMember options.
type UpdateLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required,ne="`

	// The member identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The load balancer pool member patch.
	LoadBalancerPoolMemberPatch map[string]interface{} `json:"LoadBalancerPoolMember_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerPoolMemberOptions : Instantiate UpdateLoadBalancerPoolMemberOptions
func (*VpcV1) NewUpdateLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string, loadBalancerPoolMemberPatch map[string]interface{}) *UpdateLoadBalancerPoolMemberOptions {
	return &UpdateLoadBalancerPoolMemberOptions{
		LoadBalancerID:              core.StringPtr(loadBalancerID),
		PoolID:                      core.StringPtr(poolID),
		ID:                          core.StringPtr(id),
		LoadBalancerPoolMemberPatch: loadBalancerPoolMemberPatch,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *UpdateLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolMemberOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetPoolID : Allow user to set PoolID
func (_options *UpdateLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *UpdateLoadBalancerPoolMemberOptions {
	_options.PoolID = core.StringPtr(poolID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateLoadBalancerPoolMemberOptions) SetID(id string) *UpdateLoadBalancerPoolMemberOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLoadBalancerPoolMemberPatch : Allow user to set LoadBalancerPoolMemberPatch
func (_options *UpdateLoadBalancerPoolMemberOptions) SetLoadBalancerPoolMemberPatch(loadBalancerPoolMemberPatch map[string]interface{}) *UpdateLoadBalancerPoolMemberOptions {
	_options.LoadBalancerPoolMemberPatch = loadBalancerPoolMemberPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolOptions : The UpdateLoadBalancerPool options.
type UpdateLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required,ne="`

	// The pool identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The load balancer pool patch.
	LoadBalancerPoolPatch map[string]interface{} `json:"LoadBalancerPool_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerPoolOptions : Instantiate UpdateLoadBalancerPoolOptions
func (*VpcV1) NewUpdateLoadBalancerPoolOptions(loadBalancerID string, id string, loadBalancerPoolPatch map[string]interface{}) *UpdateLoadBalancerPoolOptions {
	return &UpdateLoadBalancerPoolOptions{
		LoadBalancerID:        core.StringPtr(loadBalancerID),
		ID:                    core.StringPtr(id),
		LoadBalancerPoolPatch: loadBalancerPoolPatch,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (_options *UpdateLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolOptions {
	_options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateLoadBalancerPoolOptions) SetID(id string) *UpdateLoadBalancerPoolOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLoadBalancerPoolPatch : Allow user to set LoadBalancerPoolPatch
func (_options *UpdateLoadBalancerPoolOptions) SetLoadBalancerPoolPatch(loadBalancerPoolPatch map[string]interface{}) *UpdateLoadBalancerPoolOptions {
	_options.LoadBalancerPoolPatch = loadBalancerPoolPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// UpdateNetworkACLOptions : The UpdateNetworkACL options.
type UpdateNetworkACLOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The network ACL patch.
	NetworkACLPatch map[string]interface{} `json:"NetworkACL_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateNetworkACLOptions : Instantiate UpdateNetworkACLOptions
func (*VpcV1) NewUpdateNetworkACLOptions(id string, networkACLPatch map[string]interface{}) *UpdateNetworkACLOptions {
	return &UpdateNetworkACLOptions{
		ID:              core.StringPtr(id),
		NetworkACLPatch: networkACLPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateNetworkACLOptions) SetID(id string) *UpdateNetworkACLOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetNetworkACLPatch : Allow user to set NetworkACLPatch
func (_options *UpdateNetworkACLOptions) SetNetworkACLPatch(networkACLPatch map[string]interface{}) *UpdateNetworkACLOptions {
	_options.NetworkACLPatch = networkACLPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkACLOptions) SetHeaders(param map[string]string) *UpdateNetworkACLOptions {
	options.Headers = param
	return options
}

// UpdateNetworkACLRuleOptions : The UpdateNetworkACLRule options.
type UpdateNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The network ACL rule patch.
	NetworkACLRulePatch map[string]interface{} `json:"NetworkACLRule_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateNetworkACLRuleOptions : Instantiate UpdateNetworkACLRuleOptions
func (*VpcV1) NewUpdateNetworkACLRuleOptions(networkACLID string, id string, networkACLRulePatch map[string]interface{}) *UpdateNetworkACLRuleOptions {
	return &UpdateNetworkACLRuleOptions{
		NetworkACLID:        core.StringPtr(networkACLID),
		ID:                  core.StringPtr(id),
		NetworkACLRulePatch: networkACLRulePatch,
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (_options *UpdateNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *UpdateNetworkACLRuleOptions {
	_options.NetworkACLID = core.StringPtr(networkACLID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateNetworkACLRuleOptions) SetID(id string) *UpdateNetworkACLRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetNetworkACLRulePatch : Allow user to set NetworkACLRulePatch
func (_options *UpdateNetworkACLRuleOptions) SetNetworkACLRulePatch(networkACLRulePatch map[string]interface{}) *UpdateNetworkACLRuleOptions {
	_options.NetworkACLRulePatch = networkACLRulePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkACLRuleOptions) SetHeaders(param map[string]string) *UpdateNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// UpdatePlacementGroupOptions : The UpdatePlacementGroup options.
type UpdatePlacementGroupOptions struct {
	// The placement group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The placement group patch.
	PlacementGroupPatch map[string]interface{} `json:"PlacementGroup_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdatePlacementGroupOptions : Instantiate UpdatePlacementGroupOptions
func (*VpcV1) NewUpdatePlacementGroupOptions(id string, placementGroupPatch map[string]interface{}) *UpdatePlacementGroupOptions {
	return &UpdatePlacementGroupOptions{
		ID:                  core.StringPtr(id),
		PlacementGroupPatch: placementGroupPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdatePlacementGroupOptions) SetID(id string) *UpdatePlacementGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPlacementGroupPatch : Allow user to set PlacementGroupPatch
func (_options *UpdatePlacementGroupOptions) SetPlacementGroupPatch(placementGroupPatch map[string]interface{}) *UpdatePlacementGroupOptions {
	_options.PlacementGroupPatch = placementGroupPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdatePlacementGroupOptions) SetHeaders(param map[string]string) *UpdatePlacementGroupOptions {
	options.Headers = param
	return options
}

// UpdatePublicGatewayOptions : The UpdatePublicGateway options.
type UpdatePublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The public gateway patch.
	PublicGatewayPatch map[string]interface{} `json:"PublicGateway_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdatePublicGatewayOptions : Instantiate UpdatePublicGatewayOptions
func (*VpcV1) NewUpdatePublicGatewayOptions(id string, publicGatewayPatch map[string]interface{}) *UpdatePublicGatewayOptions {
	return &UpdatePublicGatewayOptions{
		ID:                 core.StringPtr(id),
		PublicGatewayPatch: publicGatewayPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdatePublicGatewayOptions) SetID(id string) *UpdatePublicGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPublicGatewayPatch : Allow user to set PublicGatewayPatch
func (_options *UpdatePublicGatewayOptions) SetPublicGatewayPatch(publicGatewayPatch map[string]interface{}) *UpdatePublicGatewayOptions {
	_options.PublicGatewayPatch = publicGatewayPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdatePublicGatewayOptions) SetHeaders(param map[string]string) *UpdatePublicGatewayOptions {
	options.Headers = param
	return options
}

// UpdateSecurityGroupOptions : The UpdateSecurityGroup options.
type UpdateSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The security group patch.
	SecurityGroupPatch map[string]interface{} `json:"SecurityGroup_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSecurityGroupOptions : Instantiate UpdateSecurityGroupOptions
func (*VpcV1) NewUpdateSecurityGroupOptions(id string, securityGroupPatch map[string]interface{}) *UpdateSecurityGroupOptions {
	return &UpdateSecurityGroupOptions{
		ID:                 core.StringPtr(id),
		SecurityGroupPatch: securityGroupPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateSecurityGroupOptions) SetID(id string) *UpdateSecurityGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetSecurityGroupPatch : Allow user to set SecurityGroupPatch
func (_options *UpdateSecurityGroupOptions) SetSecurityGroupPatch(securityGroupPatch map[string]interface{}) *UpdateSecurityGroupOptions {
	_options.SecurityGroupPatch = securityGroupPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecurityGroupOptions) SetHeaders(param map[string]string) *UpdateSecurityGroupOptions {
	options.Headers = param
	return options
}

// UpdateSecurityGroupRuleOptions : The UpdateSecurityGroupRule options.
type UpdateSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required,ne="`

	// The rule identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The security group rule patch.
	SecurityGroupRulePatch map[string]interface{} `json:"SecurityGroupRule_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSecurityGroupRuleOptions : Instantiate UpdateSecurityGroupRuleOptions
func (*VpcV1) NewUpdateSecurityGroupRuleOptions(securityGroupID string, id string, securityGroupRulePatch map[string]interface{}) *UpdateSecurityGroupRuleOptions {
	return &UpdateSecurityGroupRuleOptions{
		SecurityGroupID:        core.StringPtr(securityGroupID),
		ID:                     core.StringPtr(id),
		SecurityGroupRulePatch: securityGroupRulePatch,
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (_options *UpdateSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *UpdateSecurityGroupRuleOptions {
	_options.SecurityGroupID = core.StringPtr(securityGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSecurityGroupRuleOptions) SetID(id string) *UpdateSecurityGroupRuleOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetSecurityGroupRulePatch : Allow user to set SecurityGroupRulePatch
func (_options *UpdateSecurityGroupRuleOptions) SetSecurityGroupRulePatch(securityGroupRulePatch map[string]interface{}) *UpdateSecurityGroupRuleOptions {
	_options.SecurityGroupRulePatch = securityGroupRulePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecurityGroupRuleOptions) SetHeaders(param map[string]string) *UpdateSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// UpdateShareMountTargetOptions : The UpdateShareMountTarget options.
type UpdateShareMountTargetOptions struct {
	// The file share identifier.
	ShareID *string `json:"share_id" validate:"required,ne="`

	// The share mount target identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The share mount target patch.
	ShareMountTargetPatch map[string]interface{} `json:"ShareMountTarget_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateShareMountTargetOptions : Instantiate UpdateShareMountTargetOptions
func (*VpcV1) NewUpdateShareMountTargetOptions(shareID string, id string, shareMountTargetPatch map[string]interface{}) *UpdateShareMountTargetOptions {
	return &UpdateShareMountTargetOptions{
		ShareID:               core.StringPtr(shareID),
		ID:                    core.StringPtr(id),
		ShareMountTargetPatch: shareMountTargetPatch,
	}
}

// SetShareID : Allow user to set ShareID
func (_options *UpdateShareMountTargetOptions) SetShareID(shareID string) *UpdateShareMountTargetOptions {
	_options.ShareID = core.StringPtr(shareID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateShareMountTargetOptions) SetID(id string) *UpdateShareMountTargetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetShareMountTargetPatch : Allow user to set ShareMountTargetPatch
func (_options *UpdateShareMountTargetOptions) SetShareMountTargetPatch(shareMountTargetPatch map[string]interface{}) *UpdateShareMountTargetOptions {
	_options.ShareMountTargetPatch = shareMountTargetPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateShareMountTargetOptions) SetHeaders(param map[string]string) *UpdateShareMountTargetOptions {
	options.Headers = param
	return options
}

// UpdateShareOptions : The UpdateShare options.
type UpdateShareOptions struct {
	// The file share identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The file share patch.
	SharePatch map[string]interface{} `json:"Share_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateShareOptions : Instantiate UpdateShareOptions
func (*VpcV1) NewUpdateShareOptions(id string, sharePatch map[string]interface{}) *UpdateShareOptions {
	return &UpdateShareOptions{
		ID:         core.StringPtr(id),
		SharePatch: sharePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateShareOptions) SetID(id string) *UpdateShareOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetSharePatch : Allow user to set SharePatch
func (_options *UpdateShareOptions) SetSharePatch(sharePatch map[string]interface{}) *UpdateShareOptions {
	_options.SharePatch = sharePatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateShareOptions) SetIfMatch(ifMatch string) *UpdateShareOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateShareOptions) SetHeaders(param map[string]string) *UpdateShareOptions {
	options.Headers = param
	return options
}

// UpdateSnapshotOptions : The UpdateSnapshot options.
type UpdateSnapshotOptions struct {
	// The snapshot identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The snapshot patch.
	SnapshotPatch map[string]interface{} `json:"Snapshot_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSnapshotOptions : Instantiate UpdateSnapshotOptions
func (*VpcV1) NewUpdateSnapshotOptions(id string, snapshotPatch map[string]interface{}) *UpdateSnapshotOptions {
	return &UpdateSnapshotOptions{
		ID:            core.StringPtr(id),
		SnapshotPatch: snapshotPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateSnapshotOptions) SetID(id string) *UpdateSnapshotOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetSnapshotPatch : Allow user to set SnapshotPatch
func (_options *UpdateSnapshotOptions) SetSnapshotPatch(snapshotPatch map[string]interface{}) *UpdateSnapshotOptions {
	_options.SnapshotPatch = snapshotPatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateSnapshotOptions) SetIfMatch(ifMatch string) *UpdateSnapshotOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSnapshotOptions) SetHeaders(param map[string]string) *UpdateSnapshotOptions {
	options.Headers = param
	return options
}

// UpdateSubnetOptions : The UpdateSubnet options.
type UpdateSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The subnet patch.
	SubnetPatch map[string]interface{} `json:"Subnet_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubnetOptions : Instantiate UpdateSubnetOptions
func (*VpcV1) NewUpdateSubnetOptions(id string, subnetPatch map[string]interface{}) *UpdateSubnetOptions {
	return &UpdateSubnetOptions{
		ID:          core.StringPtr(id),
		SubnetPatch: subnetPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateSubnetOptions) SetID(id string) *UpdateSubnetOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetSubnetPatch : Allow user to set SubnetPatch
func (_options *UpdateSubnetOptions) SetSubnetPatch(subnetPatch map[string]interface{}) *UpdateSubnetOptions {
	_options.SubnetPatch = subnetPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubnetOptions) SetHeaders(param map[string]string) *UpdateSubnetOptions {
	options.Headers = param
	return options
}

// UpdateSubnetReservedIPOptions : The UpdateSubnetReservedIP options.
type UpdateSubnetReservedIPOptions struct {
	// The subnet identifier.
	SubnetID *string `json:"subnet_id" validate:"required,ne="`

	// The reserved IP identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The reserved IP patch.
	ReservedIPPatch map[string]interface{} `json:"ReservedIP_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubnetReservedIPOptions : Instantiate UpdateSubnetReservedIPOptions
func (*VpcV1) NewUpdateSubnetReservedIPOptions(subnetID string, id string, reservedIPPatch map[string]interface{}) *UpdateSubnetReservedIPOptions {
	return &UpdateSubnetReservedIPOptions{
		SubnetID:        core.StringPtr(subnetID),
		ID:              core.StringPtr(id),
		ReservedIPPatch: reservedIPPatch,
	}
}

// SetSubnetID : Allow user to set SubnetID
func (_options *UpdateSubnetReservedIPOptions) SetSubnetID(subnetID string) *UpdateSubnetReservedIPOptions {
	_options.SubnetID = core.StringPtr(subnetID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSubnetReservedIPOptions) SetID(id string) *UpdateSubnetReservedIPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetReservedIPPatch : Allow user to set ReservedIPPatch
func (_options *UpdateSubnetReservedIPOptions) SetReservedIPPatch(reservedIPPatch map[string]interface{}) *UpdateSubnetReservedIPOptions {
	_options.ReservedIPPatch = reservedIPPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubnetReservedIPOptions) SetHeaders(param map[string]string) *UpdateSubnetReservedIPOptions {
	options.Headers = param
	return options
}

// UpdateVirtualNetworkInterfaceOptions : The UpdateVirtualNetworkInterface options.
type UpdateVirtualNetworkInterfaceOptions struct {
	// The virtual network interface identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The virtual network interface patch.
	VirtualNetworkInterfacePatch map[string]interface{} `json:"VirtualNetworkInterface_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVirtualNetworkInterfaceOptions : Instantiate UpdateVirtualNetworkInterfaceOptions
func (*VpcV1) NewUpdateVirtualNetworkInterfaceOptions(id string, virtualNetworkInterfacePatch map[string]interface{}) *UpdateVirtualNetworkInterfaceOptions {
	return &UpdateVirtualNetworkInterfaceOptions{
		ID:                           core.StringPtr(id),
		VirtualNetworkInterfacePatch: virtualNetworkInterfacePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateVirtualNetworkInterfaceOptions) SetID(id string) *UpdateVirtualNetworkInterfaceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVirtualNetworkInterfacePatch : Allow user to set VirtualNetworkInterfacePatch
func (_options *UpdateVirtualNetworkInterfaceOptions) SetVirtualNetworkInterfacePatch(virtualNetworkInterfacePatch map[string]interface{}) *UpdateVirtualNetworkInterfaceOptions {
	_options.VirtualNetworkInterfacePatch = virtualNetworkInterfacePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVirtualNetworkInterfaceOptions) SetHeaders(param map[string]string) *UpdateVirtualNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// UpdateVolumeOptions : The UpdateVolume options.
type UpdateVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The volume patch.
	VolumePatch map[string]interface{} `json:"Volume_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVolumeOptions : Instantiate UpdateVolumeOptions
func (*VpcV1) NewUpdateVolumeOptions(id string, volumePatch map[string]interface{}) *UpdateVolumeOptions {
	return &UpdateVolumeOptions{
		ID:          core.StringPtr(id),
		VolumePatch: volumePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateVolumeOptions) SetID(id string) *UpdateVolumeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVolumePatch : Allow user to set VolumePatch
func (_options *UpdateVolumeOptions) SetVolumePatch(volumePatch map[string]interface{}) *UpdateVolumeOptions {
	_options.VolumePatch = volumePatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateVolumeOptions) SetIfMatch(ifMatch string) *UpdateVolumeOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVolumeOptions) SetHeaders(param map[string]string) *UpdateVolumeOptions {
	options.Headers = param
	return options
}

// UpdateVPCAddressPrefixOptions : The UpdateVPCAddressPrefix options.
type UpdateVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The prefix identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The prefix patch.
	AddressPrefixPatch map[string]interface{} `json:"AddressPrefix_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCAddressPrefixOptions : Instantiate UpdateVPCAddressPrefixOptions
func (*VpcV1) NewUpdateVPCAddressPrefixOptions(vpcID string, id string, addressPrefixPatch map[string]interface{}) *UpdateVPCAddressPrefixOptions {
	return &UpdateVPCAddressPrefixOptions{
		VPCID:              core.StringPtr(vpcID),
		ID:                 core.StringPtr(id),
		AddressPrefixPatch: addressPrefixPatch,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *UpdateVPCAddressPrefixOptions) SetVPCID(vpcID string) *UpdateVPCAddressPrefixOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPCAddressPrefixOptions) SetID(id string) *UpdateVPCAddressPrefixOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAddressPrefixPatch : Allow user to set AddressPrefixPatch
func (_options *UpdateVPCAddressPrefixOptions) SetAddressPrefixPatch(addressPrefixPatch map[string]interface{}) *UpdateVPCAddressPrefixOptions {
	_options.AddressPrefixPatch = addressPrefixPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCAddressPrefixOptions) SetHeaders(param map[string]string) *UpdateVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// UpdateVPCDnsResolutionBindingOptions : The UpdateVPCDnsResolutionBinding options.
type UpdateVPCDnsResolutionBindingOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The DNS resolution binding identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The DNS resolution binding patch.
	VpcdnsResolutionBindingPatch map[string]interface{} `json:"VpcdnsResolutionBinding_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCDnsResolutionBindingOptions : Instantiate UpdateVPCDnsResolutionBindingOptions
func (*VpcV1) NewUpdateVPCDnsResolutionBindingOptions(vpcID string, id string, vpcdnsResolutionBindingPatch map[string]interface{}) *UpdateVPCDnsResolutionBindingOptions {
	return &UpdateVPCDnsResolutionBindingOptions{
		VPCID:                        core.StringPtr(vpcID),
		ID:                           core.StringPtr(id),
		VpcdnsResolutionBindingPatch: vpcdnsResolutionBindingPatch,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *UpdateVPCDnsResolutionBindingOptions) SetVPCID(vpcID string) *UpdateVPCDnsResolutionBindingOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPCDnsResolutionBindingOptions) SetID(id string) *UpdateVPCDnsResolutionBindingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVpcdnsResolutionBindingPatch : Allow user to set VpcdnsResolutionBindingPatch
func (_options *UpdateVPCDnsResolutionBindingOptions) SetVpcdnsResolutionBindingPatch(vpcdnsResolutionBindingPatch map[string]interface{}) *UpdateVPCDnsResolutionBindingOptions {
	_options.VpcdnsResolutionBindingPatch = vpcdnsResolutionBindingPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCDnsResolutionBindingOptions) SetHeaders(param map[string]string) *UpdateVPCDnsResolutionBindingOptions {
	options.Headers = param
	return options
}

// UpdateVPCOptions : The UpdateVPC options.
type UpdateVPCOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The VPC patch.
	VPCPatch map[string]interface{} `json:"VPC_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCOptions : Instantiate UpdateVPCOptions
func (*VpcV1) NewUpdateVPCOptions(id string, vpcPatch map[string]interface{}) *UpdateVPCOptions {
	return &UpdateVPCOptions{
		ID:       core.StringPtr(id),
		VPCPatch: vpcPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateVPCOptions) SetID(id string) *UpdateVPCOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVPCPatch : Allow user to set VPCPatch
func (_options *UpdateVPCOptions) SetVPCPatch(vpcPatch map[string]interface{}) *UpdateVPCOptions {
	_options.VPCPatch = vpcPatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateVPCOptions) SetIfMatch(ifMatch string) *UpdateVPCOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCOptions) SetHeaders(param map[string]string) *UpdateVPCOptions {
	options.Headers = param
	return options
}

// UpdateVPCRouteOptions : The UpdateVPCRoute options.
type UpdateVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The route patch.
	RoutePatch map[string]interface{} `json:"Route_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCRouteOptions : Instantiate UpdateVPCRouteOptions
func (*VpcV1) NewUpdateVPCRouteOptions(vpcID string, id string, routePatch map[string]interface{}) *UpdateVPCRouteOptions {
	return &UpdateVPCRouteOptions{
		VPCID:      core.StringPtr(vpcID),
		ID:         core.StringPtr(id),
		RoutePatch: routePatch,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *UpdateVPCRouteOptions) SetVPCID(vpcID string) *UpdateVPCRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPCRouteOptions) SetID(id string) *UpdateVPCRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetRoutePatch : Allow user to set RoutePatch
func (_options *UpdateVPCRouteOptions) SetRoutePatch(routePatch map[string]interface{}) *UpdateVPCRouteOptions {
	_options.RoutePatch = routePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCRouteOptions) SetHeaders(param map[string]string) *UpdateVPCRouteOptions {
	options.Headers = param
	return options
}

// UpdateVPCRoutingTableOptions : The UpdateVPCRoutingTable options.
type UpdateVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The routing table patch.
	RoutingTablePatch map[string]interface{} `json:"RoutingTable_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCRoutingTableOptions : Instantiate UpdateVPCRoutingTableOptions
func (*VpcV1) NewUpdateVPCRoutingTableOptions(vpcID string, id string, routingTablePatch map[string]interface{}) *UpdateVPCRoutingTableOptions {
	return &UpdateVPCRoutingTableOptions{
		VPCID:             core.StringPtr(vpcID),
		ID:                core.StringPtr(id),
		RoutingTablePatch: routingTablePatch,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *UpdateVPCRoutingTableOptions) SetVPCID(vpcID string) *UpdateVPCRoutingTableOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPCRoutingTableOptions) SetID(id string) *UpdateVPCRoutingTableOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetRoutingTablePatch : Allow user to set RoutingTablePatch
func (_options *UpdateVPCRoutingTableOptions) SetRoutingTablePatch(routingTablePatch map[string]interface{}) *UpdateVPCRoutingTableOptions {
	_options.RoutingTablePatch = routingTablePatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateVPCRoutingTableOptions) SetIfMatch(ifMatch string) *UpdateVPCRoutingTableOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCRoutingTableOptions) SetHeaders(param map[string]string) *UpdateVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// UpdateVPCRoutingTableRouteOptions : The UpdateVPCRoutingTableRoute options.
type UpdateVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required,ne="`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required,ne="`

	// The VPC routing table route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The VPC route patch.
	RoutePatch map[string]interface{} `json:"Route_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCRoutingTableRouteOptions : Instantiate UpdateVPCRoutingTableRouteOptions
func (*VpcV1) NewUpdateVPCRoutingTableRouteOptions(vpcID string, routingTableID string, id string, routePatch map[string]interface{}) *UpdateVPCRoutingTableRouteOptions {
	return &UpdateVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		ID:             core.StringPtr(id),
		RoutePatch:     routePatch,
	}
}

// SetVPCID : Allow user to set VPCID
func (_options *UpdateVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *UpdateVPCRoutingTableRouteOptions {
	_options.VPCID = core.StringPtr(vpcID)
	return _options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (_options *UpdateVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *UpdateVPCRoutingTableRouteOptions {
	_options.RoutingTableID = core.StringPtr(routingTableID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPCRoutingTableRouteOptions) SetID(id string) *UpdateVPCRoutingTableRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetRoutePatch : Allow user to set RoutePatch
func (_options *UpdateVPCRoutingTableRouteOptions) SetRoutePatch(routePatch map[string]interface{}) *UpdateVPCRoutingTableRouteOptions {
	_options.RoutePatch = routePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *UpdateVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// UpdateVPNGatewayConnectionOptions : The UpdateVPNGatewayConnection options.
type UpdateVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required,ne="`

	// The VPN gateway connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The VPN gateway connection patch.
	VPNGatewayConnectionPatch map[string]interface{} `json:"VPNGatewayConnection_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPNGatewayConnectionOptions : Instantiate UpdateVPNGatewayConnectionOptions
func (*VpcV1) NewUpdateVPNGatewayConnectionOptions(vpnGatewayID string, id string, vpnGatewayConnectionPatch map[string]interface{}) *UpdateVPNGatewayConnectionOptions {
	return &UpdateVPNGatewayConnectionOptions{
		VPNGatewayID:              core.StringPtr(vpnGatewayID),
		ID:                        core.StringPtr(id),
		VPNGatewayConnectionPatch: vpnGatewayConnectionPatch,
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (_options *UpdateVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *UpdateVPNGatewayConnectionOptions {
	_options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPNGatewayConnectionOptions) SetID(id string) *UpdateVPNGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVPNGatewayConnectionPatch : Allow user to set VPNGatewayConnectionPatch
func (_options *UpdateVPNGatewayConnectionOptions) SetVPNGatewayConnectionPatch(vpnGatewayConnectionPatch map[string]interface{}) *UpdateVPNGatewayConnectionOptions {
	_options.VPNGatewayConnectionPatch = vpnGatewayConnectionPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *UpdateVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// UpdateVPNGatewayOptions : The UpdateVPNGateway options.
type UpdateVPNGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The VPN gateway patch.
	VPNGatewayPatch map[string]interface{} `json:"VPNGateway_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPNGatewayOptions : Instantiate UpdateVPNGatewayOptions
func (*VpcV1) NewUpdateVPNGatewayOptions(id string, vpnGatewayPatch map[string]interface{}) *UpdateVPNGatewayOptions {
	return &UpdateVPNGatewayOptions{
		ID:              core.StringPtr(id),
		VPNGatewayPatch: vpnGatewayPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateVPNGatewayOptions) SetID(id string) *UpdateVPNGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVPNGatewayPatch : Allow user to set VPNGatewayPatch
func (_options *UpdateVPNGatewayOptions) SetVPNGatewayPatch(vpnGatewayPatch map[string]interface{}) *UpdateVPNGatewayOptions {
	_options.VPNGatewayPatch = vpnGatewayPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPNGatewayOptions) SetHeaders(param map[string]string) *UpdateVPNGatewayOptions {
	options.Headers = param
	return options
}

// UpdateVPNServerOptions : The UpdateVPNServer options.
type UpdateVPNServerOptions struct {
	// The VPN server identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The VPN server patch.
	VPNServerPatch map[string]interface{} `json:"VPNServer_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPNServerOptions : Instantiate UpdateVPNServerOptions
func (*VpcV1) NewUpdateVPNServerOptions(id string, vpnServerPatch map[string]interface{}) *UpdateVPNServerOptions {
	return &UpdateVPNServerOptions{
		ID:             core.StringPtr(id),
		VPNServerPatch: vpnServerPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateVPNServerOptions) SetID(id string) *UpdateVPNServerOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVPNServerPatch : Allow user to set VPNServerPatch
func (_options *UpdateVPNServerOptions) SetVPNServerPatch(vpnServerPatch map[string]interface{}) *UpdateVPNServerOptions {
	_options.VPNServerPatch = vpnServerPatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateVPNServerOptions) SetIfMatch(ifMatch string) *UpdateVPNServerOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPNServerOptions) SetHeaders(param map[string]string) *UpdateVPNServerOptions {
	options.Headers = param
	return options
}

// UpdateVPNServerRouteOptions : The UpdateVPNServerRoute options.
type UpdateVPNServerRouteOptions struct {
	// The VPN server identifier.
	VPNServerID *string `json:"vpn_server_id" validate:"required,ne="`

	// The VPN route identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The VPN route patch.
	VPNServerRoutePatch map[string]interface{} `json:"VPNServerRoute_patch" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPNServerRouteOptions : Instantiate UpdateVPNServerRouteOptions
func (*VpcV1) NewUpdateVPNServerRouteOptions(vpnServerID string, id string, vpnServerRoutePatch map[string]interface{}) *UpdateVPNServerRouteOptions {
	return &UpdateVPNServerRouteOptions{
		VPNServerID:         core.StringPtr(vpnServerID),
		ID:                  core.StringPtr(id),
		VPNServerRoutePatch: vpnServerRoutePatch,
	}
}

// SetVPNServerID : Allow user to set VPNServerID
func (_options *UpdateVPNServerRouteOptions) SetVPNServerID(vpnServerID string) *UpdateVPNServerRouteOptions {
	_options.VPNServerID = core.StringPtr(vpnServerID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVPNServerRouteOptions) SetID(id string) *UpdateVPNServerRouteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetVPNServerRoutePatch : Allow user to set VPNServerRoutePatch
func (_options *UpdateVPNServerRouteOptions) SetVPNServerRoutePatch(vpnServerRoutePatch map[string]interface{}) *UpdateVPNServerRouteOptions {
	_options.VPNServerRoutePatch = vpnServerRoutePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPNServerRouteOptions) SetHeaders(param map[string]string) *UpdateVPNServerRouteOptions {
	options.Headers = param
	return options
}

// Vcpu : The VCPU configuration.
type Vcpu struct {
	// The VCPU architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// The number of VCPUs assigned.
	Count *int64 `json:"count" validate:"required"`

	// The VCPU manufacturer.
	Manufacturer *string `json:"manufacturer" validate:"required"`
}

// UnmarshalVcpu unmarshals an instance of Vcpu from the specified map of raw messages.
func UnmarshalVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Vcpu)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manufacturer", &obj.Manufacturer)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPC : VPC struct
type VPC struct {
	// Indicates whether this VPC is connected to Classic Infrastructure. If true, this VPC's resources have private
	// network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be connected
	// in this way. This value is set at creation and subsequently immutable.
	ClassicAccess *bool `json:"classic_access" validate:"required"`

	// The date and time that the VPC was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// The CSE ([Cloud Service Endpoint](https://cloud.ibm.com/docs/resources?topic=resources-service-endpoints)) source IP
	// addresses for the VPC. The VPC will have one CSE source IP address per zone.
	CseSourceIps []VpccseSourceIP `json:"cse_source_ips,omitempty"`

	// The default network ACL to use for subnets created in this VPC.
	DefaultNetworkACL *NetworkACLReference `json:"default_network_acl" validate:"required"`

	// The default routing table to use for subnets created in this VPC.
	DefaultRoutingTable *RoutingTableReference `json:"default_routing_table" validate:"required"`

	// The default security group for this VPC. Resources created in this VPC that allow
	// a security group to be optionally specified will use this security group by
	// default.
	DefaultSecurityGroup *SecurityGroupReference `json:"default_security_group" validate:"required"`

	// The DNS configuration for this VPC.
	Dns *Vpcdns `json:"dns" validate:"required"`

	// The reasons for the current `health_state` (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPCHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The name for this VPC. The name is unique across all VPCs in the region.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPC.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of this VPC.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VPC.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPCHealthStateDegradedConst     = "degraded"
	VPCHealthStateFaultedConst      = "faulted"
	VPCHealthStateInapplicableConst = "inapplicable"
	VPCHealthStateOkConst           = "ok"
)

// Constants associated with the VPC.ResourceType property.
// The resource type.
const (
	VPCResourceTypeVPCConst = "vpc"
)

// Constants associated with the VPC.Status property.
// The status of this VPC.
const (
	VPCStatusAvailableConst = "available"
	VPCStatusDeletingConst  = "deleting"
	VPCStatusFailedConst    = "failed"
	VPCStatusPendingConst   = "pending"
)

// UnmarshalVPC unmarshals an instance of VPC from the specified map of raw messages.
func UnmarshalVPC(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPC)
	err = core.UnmarshalPrimitive(m, "classic_access", &obj.ClassicAccess)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cse_source_ips", &obj.CseSourceIps, UnmarshalVpccseSourceIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_network_acl", &obj.DefaultNetworkACL, UnmarshalNetworkACLReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_routing_table", &obj.DefaultRoutingTable, UnmarshalRoutingTableReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_security_group", &obj.DefaultSecurityGroup, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dns", &obj.Dns, UnmarshalVpcdns)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPCHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpccseSourceIP : VpccseSourceIP struct
type VpccseSourceIP struct {
	// The cloud service endpoint source IP address for this zone.
	IP *IP `json:"ip" validate:"required"`

	// The zone this cloud service endpoint source IP resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalVpccseSourceIP unmarshals an instance of VpccseSourceIP from the specified map of raw messages.
func UnmarshalVpccseSourceIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpccseSourceIP)
	err = core.UnmarshalModel(m, "ip", &obj.IP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCollection : VPCCollection struct
type VPCCollection struct {
	// A link to the first page of resources.
	First *VPCCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VPCCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPCs.
	Vpcs []VPC `json:"vpcs" validate:"required"`
}

// UnmarshalVPCCollection unmarshals an instance of VPCCollection from the specified map of raw messages.
func UnmarshalVPCCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPCCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPCCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpcs", &obj.Vpcs, UnmarshalVPC)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VPCCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VPCCollectionFirst : A link to the first page of resources.
type VPCCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPCCollectionFirst unmarshals an instance of VPCCollectionFirst from the specified map of raw messages.
func UnmarshalVPCCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VPCCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPCCollectionNext unmarshals an instance of VPCCollectionNext from the specified map of raw messages.
func UnmarshalVPCCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Vpcdns : The DNS configuration for this VPC.
type Vpcdns struct {
	// Indicates whether this VPC is enabled as a DNS name resolution hub.
	EnableHub *bool `json:"enable_hub" validate:"required"`

	// The number of DNS resolution bindings for this VPC.
	ResolutionBindingCount *int64 `json:"resolution_binding_count" validate:"required"`

	// The DNS resolver configuration for the VPC.
	Resolver VpcdnsResolverIntf `json:"resolver" validate:"required"`
}

// UnmarshalVpcdns unmarshals an instance of Vpcdns from the specified map of raw messages.
func UnmarshalVpcdns(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Vpcdns)
	err = core.UnmarshalPrimitive(m, "enable_hub", &obj.EnableHub)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resolution_binding_count", &obj.ResolutionBindingCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resolver", &obj.Resolver, UnmarshalVpcdnsResolver)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsPatch : The DNS configuration for this VPC.
type VpcdnsPatch struct {
	// Indicates whether this VPC is enabled as a DNS name resolution hub.
	//
	// Updating the value to `true` requires `allow_dns_resolution_binding` to be `true` for all endpoint gateways residing
	// in this VPC.
	//
	// Changing the value requires `dns.resolution_binding_count` to be zero.
	EnableHub *bool `json:"enable_hub,omitempty"`

	Resolver *VpcdnsResolverPatch `json:"resolver,omitempty"`
}

// UnmarshalVpcdnsPatch unmarshals an instance of VpcdnsPatch from the specified map of raw messages.
func UnmarshalVpcdnsPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsPatch)
	err = core.UnmarshalPrimitive(m, "enable_hub", &obj.EnableHub)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resolver", &obj.Resolver, UnmarshalVpcdnsResolverPatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsPrototype : The DNS configuration for this VPC.
//
// If unspecified, the system will assign DNS servers capable of resolving hosts and endpoint gateways within this VPC,
// and hosts on the internet.
type VpcdnsPrototype struct {
	// Indicates whether this VPC is enabled as a DNS name resolution hub.
	EnableHub *bool `json:"enable_hub,omitempty"`

	Resolver VpcdnsResolverPrototypeIntf `json:"resolver,omitempty"`
}

// UnmarshalVpcdnsPrototype unmarshals an instance of VpcdnsPrototype from the specified map of raw messages.
func UnmarshalVpcdnsPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsPrototype)
	err = core.UnmarshalPrimitive(m, "enable_hub", &obj.EnableHub)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resolver", &obj.Resolver, UnmarshalVpcdnsResolverPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolutionBinding : VpcdnsResolutionBinding struct
type VpcdnsResolutionBinding struct {
	// The date and time that the DNS resolution binding was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The endpoint gateways that have `allow_dns_resolution_binding` set to `true` and reside in the VPC that has
	// `dns.enable_hub` set to `false`.
	//
	// The endpoint gateways may be remote and therefore may not be directly retrievable.
	EndpointGateways []EndpointGatewayReferenceRemote `json:"endpoint_gateways" validate:"required"`

	// The URL for this DNS resolution binding.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this DNS resolution binding.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the DNS resolution binding.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this DNS resolution binding. The name is unique across all DNS resolution bindings for the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The VPC bound to for DNS resolution.
	//
	// The VPC may be remote and therefore may not be directly retrievable.
	VPC *VPCReferenceRemote `json:"vpc" validate:"required"`
}

// Constants associated with the VpcdnsResolutionBinding.LifecycleState property.
// The lifecycle state of the DNS resolution binding.
const (
	VpcdnsResolutionBindingLifecycleStateDeletingConst  = "deleting"
	VpcdnsResolutionBindingLifecycleStateFailedConst    = "failed"
	VpcdnsResolutionBindingLifecycleStatePendingConst   = "pending"
	VpcdnsResolutionBindingLifecycleStateStableConst    = "stable"
	VpcdnsResolutionBindingLifecycleStateSuspendedConst = "suspended"
	VpcdnsResolutionBindingLifecycleStateUpdatingConst  = "updating"
	VpcdnsResolutionBindingLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VpcdnsResolutionBinding.ResourceType property.
// The resource type.
const (
	VpcdnsResolutionBindingResourceTypeVPCDnsResolutionBindingConst = "vpc_dns_resolution_binding"
)

// UnmarshalVpcdnsResolutionBinding unmarshals an instance of VpcdnsResolutionBinding from the specified map of raw messages.
func UnmarshalVpcdnsResolutionBinding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolutionBinding)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "endpoint_gateways", &obj.EndpointGateways, UnmarshalEndpointGatewayReferenceRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReferenceRemote)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolutionBindingCollection : VpcdnsResolutionBindingCollection struct
type VpcdnsResolutionBindingCollection struct {
	// Collection of DNS resolution bindings for this VPC.
	DnsResolutionBindings []VpcdnsResolutionBinding `json:"dns_resolution_bindings" validate:"required"`

	// A link to the first page of resources.
	First *VpcdnsResolutionBindingCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VpcdnsResolutionBindingCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalVpcdnsResolutionBindingCollection unmarshals an instance of VpcdnsResolutionBindingCollection from the specified map of raw messages.
func UnmarshalVpcdnsResolutionBindingCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolutionBindingCollection)
	err = core.UnmarshalModel(m, "dns_resolution_bindings", &obj.DnsResolutionBindings, UnmarshalVpcdnsResolutionBinding)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVpcdnsResolutionBindingCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVpcdnsResolutionBindingCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VpcdnsResolutionBindingCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VpcdnsResolutionBindingPatch : VpcdnsResolutionBindingPatch struct
type VpcdnsResolutionBindingPatch struct {
	// The name for this DNS resolution binding. The name must not be used by another DNS resolution binding for the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVpcdnsResolutionBindingPatch unmarshals an instance of VpcdnsResolutionBindingPatch from the specified map of raw messages.
func UnmarshalVpcdnsResolutionBindingPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolutionBindingPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VpcdnsResolutionBindingPatch
func (vpcdnsResolutionBindingPatch *VpcdnsResolutionBindingPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpcdnsResolutionBindingPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VpcdnsResolver : VpcdnsResolver struct
// Models which "extend" this model:
// - VpcdnsResolverTypeDelegated
// - VpcdnsResolverTypeManual
// - VpcdnsResolverTypeSystem
type VpcdnsResolver struct {
	// The DNS servers for this VPC. The servers are populated:
	//
	// - by the system when `dns.resolver.type` is `system`
	// - using the DNS servers in `dns.resolver.vpc` when `dns.resolver.type` is `delegated`
	// - using `dns.resolver.manual_servers` when the `dns.resolver.type` is `manual`.
	Servers []DnsServer `json:"servers" validate:"required"`

	// The type of the DNS resolver used for the VPC.
	//
	// - `delegated`: DNS server addresses are provided by the DNS resolver of the VPC
	//                specified in `dns.resolver.vpc`.
	// - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
	// - `system`: DNS server addresses are provided by the system.
	Type *string `json:"type" validate:"required"`

	// The VPC whose DNS resolver provides the DNS server addresses for this VPC.
	//
	// The VPC may be remote and therefore may not be directly retrievable.
	VPC *VPCReferenceDnsResolverContext `json:"vpc,omitempty"`

	// The manually specified DNS servers for this VPC.
	ManualServers []DnsServer `json:"manual_servers,omitempty"`

	// The configuration of the system DNS resolver for this VPC.
	//
	// - `custom_resolver`: A custom DNS resolver is configured for this VPC.
	//
	// - `private_resolver`: A private DNS resolver is configured for this VPC. Applicable when
	//   the VPC has either or both of the following:
	//
	//     - at least one endpoint gateway residing in it
	//     - a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it
	//
	// - `default`: The provider default DNS resolvers are configured for this VPC.
	//
	//   This system DNS resolver configuration is used when the VPC has:
	//
	//   - no custom DNS resolver configured for it, and
	//   - no endpoint gateways residing in it, and
	//   - no [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it.
	Configuration *string `json:"configuration,omitempty"`
}

// Constants associated with the VpcdnsResolver.Type property.
// The type of the DNS resolver used for the VPC.
//
//   - `delegated`: DNS server addresses are provided by the DNS resolver of the VPC
//     specified in `dns.resolver.vpc`.
//   - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
//   - `system`: DNS server addresses are provided by the system.
const (
	VpcdnsResolverTypeDelegatedConst = "delegated"
	VpcdnsResolverTypeManualConst    = "manual"
	VpcdnsResolverTypeSystemConst    = "system"
)

// Constants associated with the VpcdnsResolver.Configuration property.
// The configuration of the system DNS resolver for this VPC.
//
// - `custom_resolver`: A custom DNS resolver is configured for this VPC.
//
//   - `private_resolver`: A private DNS resolver is configured for this VPC. Applicable when
//     the VPC has either or both of the following:
//
//   - at least one endpoint gateway residing in it
//
//   - a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it
//
// - `default`: The provider default DNS resolvers are configured for this VPC.
//
//	This system DNS resolver configuration is used when the VPC has:
//
//	- no custom DNS resolver configured for it, and
//	- no endpoint gateways residing in it, and
//	- no [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it.
const (
	VpcdnsResolverConfigurationCustomResolverConst  = "custom_resolver"
	VpcdnsResolverConfigurationDefaultConst         = "default"
	VpcdnsResolverConfigurationPrivateResolverConst = "private_resolver"
)

func (*VpcdnsResolver) isaVpcdnsResolver() bool {
	return true
}

type VpcdnsResolverIntf interface {
	isaVpcdnsResolver() bool
}

// UnmarshalVpcdnsResolver unmarshals an instance of VpcdnsResolver from the specified map of raw messages.
func UnmarshalVpcdnsResolver(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolver)
	err = core.UnmarshalModel(m, "servers", &obj.Servers, UnmarshalDnsServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReferenceDnsResolverContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manual_servers", &obj.ManualServers, UnmarshalDnsServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "configuration", &obj.Configuration)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverPatch : VpcdnsResolverPatch struct
type VpcdnsResolverPatch struct {
	// The DNS servers to use for this VPC, replacing any existing servers. All the DNS servers must either:
	//
	// - have a unique `zone_affinity`, or
	// - not have a `zone_affinity`.
	//
	// `dns.resolver.manual_servers` must be set if and only if `dns.resolver.type` is `manual`.
	ManualServers []DnsServerPrototype `json:"manual_servers,omitempty"`

	// The type of the DNS resolver to use.
	//
	// - `delegated`: DNS server addresses will be provided by the resolver for the VPC
	//                specified in `dns.resolver.vpc`. Requires `dns.enable_hub` to be
	//                `false`.
	// - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
	// - `system`: DNS server addresses will be provided by the system and depend on the
	//             configuration.
	//
	// Updating from `manual` requires `dns.resolver.manual_servers` to be specified as
	// `null`.
	//
	// Updating to `manual` requires `dns.resolver.manual_servers` to be specified and not empty.
	//
	// Updating from `delegated` requires `dns.resolver.vpc` to be specified as `null`.
	Type *string `json:"type,omitempty"`

	// The VPC to provide DNS server addresses for this VPC.  The specified VPC must be configured
	// with a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) custom resolver and must be in
	// one of this VPC's DNS resolution bindings.
	//
	// Specify `null` to remove an existing VPC.
	//
	// This property must be set if and only if `dns.resolver.type` is `delegated`.
	VPC VpcdnsResolverVPCPatchIntf `json:"vpc,omitempty"`
}

// Constants associated with the VpcdnsResolverPatch.Type property.
// The type of the DNS resolver to use.
//
//   - `delegated`: DNS server addresses will be provided by the resolver for the VPC
//     specified in `dns.resolver.vpc`. Requires `dns.enable_hub` to be
//     `false`.
//   - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
//   - `system`: DNS server addresses will be provided by the system and depend on the
//     configuration.
//
// Updating from `manual` requires `dns.resolver.manual_servers` to be specified as
// `null`.
//
// Updating to `manual` requires `dns.resolver.manual_servers` to be specified and not empty.
//
// Updating from `delegated` requires `dns.resolver.vpc` to be specified as `null`.
const (
	VpcdnsResolverPatchTypeDelegatedConst = "delegated"
	VpcdnsResolverPatchTypeManualConst    = "manual"
	VpcdnsResolverPatchTypeSystemConst    = "system"
)

// UnmarshalVpcdnsResolverPatch unmarshals an instance of VpcdnsResolverPatch from the specified map of raw messages.
func UnmarshalVpcdnsResolverPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverPatch)
	err = core.UnmarshalModel(m, "manual_servers", &obj.ManualServers, UnmarshalDnsServerPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVpcdnsResolverVPCPatch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverPrototype : VpcdnsResolverPrototype struct
// Models which "extend" this model:
// - VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype
// - VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype
type VpcdnsResolverPrototype struct {
	// The type of the DNS resolver to use.
	//
	// - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
	// - `system`: DNS server addresses will be provided by the system and depend on the
	//             configuration.
	Type *string `json:"type,omitempty"`

	// The DNS servers to use for this VPC. All the DNS servers must either:
	//
	// - have a unique `zone_affinity`, or
	// - not have a `zone_affinity`.
	ManualServers []DnsServerPrototype `json:"manual_servers,omitempty"`
}

// Constants associated with the VpcdnsResolverPrototype.Type property.
// The type of the DNS resolver to use.
//
//   - `manual`: DNS server addresses are specified in `dns.resolver.manual_servers`.
//   - `system`: DNS server addresses will be provided by the system and depend on the
//     configuration.
const (
	VpcdnsResolverPrototypeTypeManualConst = "manual"
	VpcdnsResolverPrototypeTypeSystemConst = "system"
)

func (*VpcdnsResolverPrototype) isaVpcdnsResolverPrototype() bool {
	return true
}

type VpcdnsResolverPrototypeIntf interface {
	isaVpcdnsResolverPrototype() bool
}

// UnmarshalVpcdnsResolverPrototype unmarshals an instance of VpcdnsResolverPrototype from the specified map of raw messages.
func UnmarshalVpcdnsResolverPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverPrototype)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manual_servers", &obj.ManualServers, UnmarshalDnsServerPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverVPCPatch : The VPC to provide DNS server addresses for this VPC.  The specified VPC must be configured with a [DNS
// Services](https://cloud.ibm.com/docs/dns-svcs) custom resolver and must be in one of this VPC's DNS resolution
// bindings.
//
// Specify `null` to remove an existing VPC.
//
// This property must be set if and only if `dns.resolver.type` is `delegated`.
// Models which "extend" this model:
// - VpcdnsResolverVPCPatchVPCIdentityByID
// - VpcdnsResolverVPCPatchVPCIdentityByCRN
// - VpcdnsResolverVPCPatchVPCIdentityByHref
type VpcdnsResolverVPCPatch struct {
	// The unique identifier for this VPC.
	ID *string `json:"id,omitempty"`

	// The CRN for this VPC.
	CRN *string `json:"crn,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href,omitempty"`
}

func (*VpcdnsResolverVPCPatch) isaVpcdnsResolverVPCPatch() bool {
	return true
}

type VpcdnsResolverVPCPatchIntf interface {
	isaVpcdnsResolverVPCPatch() bool
}

// UnmarshalVpcdnsResolverVPCPatch unmarshals an instance of VpcdnsResolverVPCPatch from the specified map of raw messages.
func UnmarshalVpcdnsResolverVPCPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverVPCPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCHealthReason : VPCHealthReason struct
type VPCHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPCHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	VPCHealthReasonCodeInternalErrorConst = "internal_error"
)

// UnmarshalVPCHealthReason unmarshals an instance of VPCHealthReason from the specified map of raw messages.
func UnmarshalVPCHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentity : Identifies a VPC by a unique property.
// Models which "extend" this model:
// - VPCIdentityByID
// - VPCIdentityByCRN
// - VPCIdentityByHref
type VPCIdentity struct {
	// The unique identifier for this VPC.
	ID *string `json:"id,omitempty"`

	// The CRN for this VPC.
	CRN *string `json:"crn,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href,omitempty"`
}

func (*VPCIdentity) isaVPCIdentity() bool {
	return true
}

type VPCIdentityIntf interface {
	isaVPCIdentity() bool
}

// UnmarshalVPCIdentity unmarshals an instance of VPCIdentity from the specified map of raw messages.
func UnmarshalVPCIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCPatch : VPCPatch struct
type VPCPatch struct {
	// The DNS configuration for this VPC.
	Dns *VpcdnsPatch `json:"dns,omitempty"`

	// The name for this VPC. The name must not be used by another VPC in the region.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVPCPatch unmarshals an instance of VPCPatch from the specified map of raw messages.
func UnmarshalVPCPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCPatch)
	err = core.UnmarshalModel(m, "dns", &obj.Dns, UnmarshalVpcdnsPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VPCPatch
func (vpcPatch *VPCPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpcPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VPCReference : VPCReference struct
type VPCReference struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPCReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The name for this VPC. The name is unique across all VPCs in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPCReference.ResourceType property.
// The resource type.
const (
	VPCReferenceResourceTypeVPCConst = "vpc"
)

// UnmarshalVPCReference unmarshals an instance of VPCReference from the specified map of raw messages.
func UnmarshalVPCReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPCReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCReferenceDnsResolverContext : A VPC whose DNS resolver is delegated to provide DNS servers for this VPC.
//
// The VPC may be remote and therefore may not be directly retrievable.
type VPCReferenceDnsResolverContext struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPCReferenceDnsResolverContextDeleted `json:"deleted,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The name for this VPC. The name is unique across all VPCs in the region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *VPCRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPCReferenceDnsResolverContext.ResourceType property.
// The resource type.
const (
	VPCReferenceDnsResolverContextResourceTypeVPCConst = "vpc"
)

// UnmarshalVPCReferenceDnsResolverContext unmarshals an instance of VPCReferenceDnsResolverContext from the specified map of raw messages.
func UnmarshalVPCReferenceDnsResolverContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReferenceDnsResolverContext)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPCReferenceDnsResolverContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalVPCRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VPCReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVPCReferenceDeleted unmarshals an instance of VPCReferenceDeleted from the specified map of raw messages.
func UnmarshalVPCReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCReferenceDnsResolverContextDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VPCReferenceDnsResolverContextDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVPCReferenceDnsResolverContextDeleted unmarshals an instance of VPCReferenceDnsResolverContextDeleted from the specified map of raw messages.
func UnmarshalVPCReferenceDnsResolverContextDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReferenceDnsResolverContextDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCReferenceRemote : VPCReferenceRemote struct
type VPCReferenceRemote struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The name for this VPC. The name is unique across all VPCs in the region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *VPCRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPCReferenceRemote.ResourceType property.
// The resource type.
const (
	VPCReferenceRemoteResourceTypeVPCConst = "vpc"
)

// UnmarshalVPCReferenceRemote unmarshals an instance of VPCReferenceRemote from the specified map of raw messages.
func UnmarshalVPCReferenceRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReferenceRemote)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalVPCRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCRemote : If present, this property indicates that the resource associated with this reference is remote and therefore may not
// be directly retrievable.
type VPCRemote struct {
	// If present, this property indicates that the referenced resource is remote to this
	// account, and identifies the owning account.
	Account *AccountReference `json:"account,omitempty"`

	// If present, this property indicates that the referenced resource is remote to this
	// region, and identifies the native region.
	Region *RegionReference `json:"region,omitempty"`
}

// UnmarshalVPCRemote unmarshals an instance of VPCRemote from the specified map of raw messages.
func UnmarshalVPCRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCRemote)
	err = core.UnmarshalModel(m, "account", &obj.Account, UnmarshalAccountReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGateway : VPNGateway struct
// Models which "extend" this model:
// - VPNGatewayRouteMode
// - VPNGatewayPolicyMode
type VPNGateway struct {
	// Connections for this VPN gateway.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this VPN gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The VPN gateway's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The reasons for the current VPN gateway health_state (if any):
	// - `cannot_create_vpc_route`: VPN cannot create route (check for conflict)
	// - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
	//   subnet)
	// - `internal_error`: Internal error (contact IBM support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPNGatewayHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current VPN gateway lifecycle_state (if any):
	// - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
	//   support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []VPNGatewayLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the VPN gateway.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// Collection of VPN gateway members.
	Members []VPNGatewayMember `json:"members" validate:"required"`

	// The name for this VPN gateway. The name is unique across all VPN gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPN gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The VPC this VPN gateway resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// Route mode VPN gateway.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the VPNGateway.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPNGatewayHealthStateDegradedConst     = "degraded"
	VPNGatewayHealthStateFaultedConst      = "faulted"
	VPNGatewayHealthStateInapplicableConst = "inapplicable"
	VPNGatewayHealthStateOkConst           = "ok"
)

// Constants associated with the VPNGateway.LifecycleState property.
// The lifecycle state of the VPN gateway.
const (
	VPNGatewayLifecycleStateDeletingConst  = "deleting"
	VPNGatewayLifecycleStateFailedConst    = "failed"
	VPNGatewayLifecycleStatePendingConst   = "pending"
	VPNGatewayLifecycleStateStableConst    = "stable"
	VPNGatewayLifecycleStateSuspendedConst = "suspended"
	VPNGatewayLifecycleStateUpdatingConst  = "updating"
	VPNGatewayLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VPNGateway.ResourceType property.
// The resource type.
const (
	VPNGatewayResourceTypeVPNGatewayConst = "vpn_gateway"
)

// Constants associated with the VPNGateway.Mode property.
// Route mode VPN gateway.
const (
	VPNGatewayModeRouteConst = "route"
)

func (*VPNGateway) isaVPNGateway() bool {
	return true
}

type VPNGatewayIntf interface {
	isaVPNGateway() bool
}

// UnmarshalVPNGateway unmarshals an instance of VPNGateway from the specified map of raw messages.
func UnmarshalVPNGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGateway)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPNGatewayHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalVPNGatewayLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalVPNGatewayMember)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayCollection : VPNGatewayCollection struct
type VPNGatewayCollection struct {
	// A link to the first page of resources.
	First *VPNGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VPNGatewayCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPN gateways.
	VPNGateways []VPNGatewayIntf `json:"vpn_gateways" validate:"required"`
}

// UnmarshalVPNGatewayCollection unmarshals an instance of VPNGatewayCollection from the specified map of raw messages.
func UnmarshalVPNGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPNGatewayCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPNGatewayCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpn_gateways", &obj.VPNGateways, UnmarshalVPNGateway)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VPNGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VPNGatewayCollectionFirst : A link to the first page of resources.
type VPNGatewayCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNGatewayCollectionFirst unmarshals an instance of VPNGatewayCollectionFirst from the specified map of raw messages.
func UnmarshalVPNGatewayCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VPNGatewayCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNGatewayCollectionNext unmarshals an instance of VPNGatewayCollectionNext from the specified map of raw messages.
func UnmarshalVPNGatewayCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnection : VPNGatewayConnection struct
// Models which "extend" this model:
// - VPNGatewayConnectionStaticRouteMode
// - VPNGatewayConnectionPolicyMode
type VPNGatewayConnection struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up" validate:"required"`

	// The authentication mode. Only `psk` is currently supported.
	AuthenticationMode *string `json:"authentication_mode" validate:"required"`

	// The date and time that this VPN gateway connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDpd `json:"dead_peer_detection" validate:"required"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`

	// The IKE policy. If absent, [auto-negotiation is
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
	IkePolicy *IkePolicyReference `json:"ike_policy,omitempty"`

	// The IPsec policy. If absent, [auto-negotiation is
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
	IpsecPolicy *IPsecPolicyReference `json:"ipsec_policy,omitempty"`

	// The mode of the VPN gateway.
	Mode *string `json:"mode" validate:"required"`

	// The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The pre-shared key.
	Psk *string `json:"psk" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of a VPN gateway connection.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current VPN gateway connection status (if any):
	// - `cannot_authenticate_connection`: Failed to authenticate a connection because of
	//   mismatched IKE ID and PSK (check IKE ID and PSK in peer VPN configuration)
	// - `internal_error`: Internal error (contact IBM support)
	// - `ike_policy_mismatch`: None of the proposed IKE crypto suites was acceptable (check
	//    the IKE policies on both sides of the VPN)
	// - `ike_v1_id_local_remote_cidr_mismatch`: Invalid IKE ID or mismatched local CIDRs and
	//   remote CIDRs in IKE V1 (check the IKE ID or the local CIDRs and remote CIDRs in IKE
	//   V1 configuration)
	// - `ike_v2_local_remote_cidr_mismatch`: Mismatched local CIDRs and remote CIDRs in IKE
	//   V2 (check the local CIDRs and remote CIDRs in IKE V2 configuration)
	// - `ipsec_policy_mismatch`: None of the proposed IPsec crypto suites was acceptable
	//   (check the IPsec policies on both sides of the VPN)
	// - `peer_not_responding`: No response from peer (check network ACL configuration, peer
	//   availability, and on-premise firewall configuration)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []VPNGatewayConnectionStatusReason `json:"status_reasons" validate:"required"`

	// Routing protocols are disabled for this VPN gateway connection.
	RoutingProtocol *string `json:"routing_protocol,omitempty"`

	// The VPN tunnel configuration for this VPN gateway connection (in static route mode).
	Tunnels []VPNGatewayConnectionStaticRouteModeTunnel `json:"tunnels,omitempty"`

	// The local CIDRs for this resource.
	LocalCIDRs []string `json:"local_cidrs,omitempty"`

	// The peer CIDRs for this resource.
	PeerCIDRs []string `json:"peer_cidrs,omitempty"`
}

// Constants associated with the VPNGatewayConnection.AuthenticationMode property.
// The authentication mode. Only `psk` is currently supported.
const (
	VPNGatewayConnectionAuthenticationModePskConst = "psk"
)

// Constants associated with the VPNGatewayConnection.Mode property.
// The mode of the VPN gateway.
const (
	VPNGatewayConnectionModePolicyConst = "policy"
	VPNGatewayConnectionModeRouteConst  = "route"
)

// Constants associated with the VPNGatewayConnection.ResourceType property.
// The resource type.
const (
	VPNGatewayConnectionResourceTypeVPNGatewayConnectionConst = "vpn_gateway_connection"
)

// Constants associated with the VPNGatewayConnection.Status property.
// The status of a VPN gateway connection.
const (
	VPNGatewayConnectionStatusDownConst = "down"
	VPNGatewayConnectionStatusUpConst   = "up"
)

// Constants associated with the VPNGatewayConnection.RoutingProtocol property.
// Routing protocols are disabled for this VPN gateway connection.
const (
	VPNGatewayConnectionRoutingProtocolNoneConst = "none"
)

func (*VPNGatewayConnection) isaVPNGatewayConnection() bool {
	return true
}

type VPNGatewayConnectionIntf interface {
	isaVPNGatewayConnection() bool
}

// UnmarshalVPNGatewayConnection unmarshals an instance of VPNGatewayConnection from the specified map of raw messages.
func UnmarshalVPNGatewayConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnection)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authentication_mode", &obj.AuthenticationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalIkePolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalIPsecPolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalVPNGatewayConnectionStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_protocol", &obj.RoutingProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalVPNGatewayConnectionStaticRouteModeTunnel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCIDRs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCIDRs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionCollection : Collection of VPN gateway connections in a VPN gateway.
type VPNGatewayConnectionCollection struct {
	// Array of VPN gateway connections.
	Connections []VPNGatewayConnectionIntf `json:"connections" validate:"required"`
}

// UnmarshalVPNGatewayConnectionCollection unmarshals an instance of VPNGatewayConnectionCollection from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionDpd : The Dead Peer Detection settings.
type VPNGatewayConnectionDpd struct {
	// Dead Peer Detection actions.
	Action *string `json:"action" validate:"required"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval" validate:"required"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionDpd.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDpdActionClearConst   = "clear"
	VPNGatewayConnectionDpdActionHoldConst    = "hold"
	VPNGatewayConnectionDpdActionNoneConst    = "none"
	VPNGatewayConnectionDpdActionRestartConst = "restart"
)

// UnmarshalVPNGatewayConnectionDpd unmarshals an instance of VPNGatewayConnectionDpd from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionDpd(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionDpd)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionDpdPatch : The Dead Peer Detection settings.
type VPNGatewayConnectionDpdPatch struct {
	// Dead Peer Detection actions.
	Action *string `json:"action,omitempty"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval,omitempty"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout,omitempty"`
}

// Constants associated with the VPNGatewayConnectionDpdPatch.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDpdPatchActionClearConst   = "clear"
	VPNGatewayConnectionDpdPatchActionHoldConst    = "hold"
	VPNGatewayConnectionDpdPatchActionNoneConst    = "none"
	VPNGatewayConnectionDpdPatchActionRestartConst = "restart"
)

// UnmarshalVPNGatewayConnectionDpdPatch unmarshals an instance of VPNGatewayConnectionDpdPatch from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionDpdPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionDpdPatch)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionDpdPrototype : The Dead Peer Detection settings.
type VPNGatewayConnectionDpdPrototype struct {
	// Dead Peer Detection actions.
	Action *string `json:"action,omitempty"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval,omitempty"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout,omitempty"`
}

// Constants associated with the VPNGatewayConnectionDpdPrototype.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDpdPrototypeActionClearConst   = "clear"
	VPNGatewayConnectionDpdPrototypeActionHoldConst    = "hold"
	VPNGatewayConnectionDpdPrototypeActionNoneConst    = "none"
	VPNGatewayConnectionDpdPrototypeActionRestartConst = "restart"
)

// UnmarshalVPNGatewayConnectionDpdPrototype unmarshals an instance of VPNGatewayConnectionDpdPrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionDpdPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionDpdPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIkePolicyPatch : The IKE policy to use. Specify `null` to remove any existing policy, [resulting in
// auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
// Models which "extend" this model:
// - VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID
// - VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref
type VPNGatewayConnectionIkePolicyPatch struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id,omitempty"`

	// The IKE policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*VPNGatewayConnectionIkePolicyPatch) isaVPNGatewayConnectionIkePolicyPatch() bool {
	return true
}

type VPNGatewayConnectionIkePolicyPatchIntf interface {
	isaVPNGatewayConnectionIkePolicyPatch() bool
}

// UnmarshalVPNGatewayConnectionIkePolicyPatch unmarshals an instance of VPNGatewayConnectionIkePolicyPatch from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIkePolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIkePolicyPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIkePolicyPrototype : The IKE policy to use. If unspecified, [auto-negotiation will be
// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
// Models which "extend" this model:
// - VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID
// - VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref
type VPNGatewayConnectionIkePolicyPrototype struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id,omitempty"`

	// The IKE policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*VPNGatewayConnectionIkePolicyPrototype) isaVPNGatewayConnectionIkePolicyPrototype() bool {
	return true
}

type VPNGatewayConnectionIkePolicyPrototypeIntf interface {
	isaVPNGatewayConnectionIkePolicyPrototype() bool
}

// UnmarshalVPNGatewayConnectionIkePolicyPrototype unmarshals an instance of VPNGatewayConnectionIkePolicyPrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIkePolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIkePolicyPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIPsecPolicyPatch : The IPsec policy to use. Specify `null` to remove any existing policy, [resulting in
// auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
// Models which "extend" this model:
// - VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID
// - VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref
type VPNGatewayConnectionIPsecPolicyPatch struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id,omitempty"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*VPNGatewayConnectionIPsecPolicyPatch) isaVPNGatewayConnectionIPsecPolicyPatch() bool {
	return true
}

type VPNGatewayConnectionIPsecPolicyPatchIntf interface {
	isaVPNGatewayConnectionIPsecPolicyPatch() bool
}

// UnmarshalVPNGatewayConnectionIPsecPolicyPatch unmarshals an instance of VPNGatewayConnectionIPsecPolicyPatch from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIPsecPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIPsecPolicyPatch)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIPsecPolicyPrototype : The IPsec policy to use. If unspecified, [auto-negotiation will be
// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
// Models which "extend" this model:
// - VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID
// - VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref
type VPNGatewayConnectionIPsecPolicyPrototype struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id,omitempty"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*VPNGatewayConnectionIPsecPolicyPrototype) isaVPNGatewayConnectionIPsecPolicyPrototype() bool {
	return true
}

type VPNGatewayConnectionIPsecPolicyPrototypeIntf interface {
	isaVPNGatewayConnectionIPsecPolicyPrototype() bool
}

// UnmarshalVPNGatewayConnectionIPsecPolicyPrototype unmarshals an instance of VPNGatewayConnectionIPsecPolicyPrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIPsecPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIPsecPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionLocalCIDRs : VPNGatewayConnectionLocalCIDRs struct
type VPNGatewayConnectionLocalCIDRs struct {
	// The local CIDRs for this resource.
	LocalCIDRs []string `json:"local_cidrs,omitempty"`
}

// UnmarshalVPNGatewayConnectionLocalCIDRs unmarshals an instance of VPNGatewayConnectionLocalCIDRs from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionLocalCIDRs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionLocalCIDRs)
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCIDRs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionPatch : VPNGatewayConnectionPatch struct
// Models which "extend" this model:
// - VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch
type VPNGatewayConnectionPatch struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDpdPatch `json:"dead_peer_detection,omitempty"`

	// The IKE policy to use. Specify `null` to remove any existing policy, [resulting in
	// auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
	IkePolicy VPNGatewayConnectionIkePolicyPatchIntf `json:"ike_policy,omitempty"`

	// The IPsec policy to use. Specify `null` to remove any existing policy, [resulting in
	// auto-negotiation](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
	IpsecPolicy VPNGatewayConnectionIPsecPolicyPatchIntf `json:"ipsec_policy,omitempty"`

	// The name for this VPN gateway connection. The name must not be used by another connection for the VPN gateway.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address,omitempty"`

	// The pre-shared key.
	Psk *string `json:"psk,omitempty"`

	// Routing protocols are disabled for this VPN gateway connection.
	RoutingProtocol *string `json:"routing_protocol,omitempty"`
}

// Constants associated with the VPNGatewayConnectionPatch.RoutingProtocol property.
// Routing protocols are disabled for this VPN gateway connection.
const (
	VPNGatewayConnectionPatchRoutingProtocolNoneConst = "none"
)

func (*VPNGatewayConnectionPatch) isaVPNGatewayConnectionPatch() bool {
	return true
}

type VPNGatewayConnectionPatchIntf interface {
	isaVPNGatewayConnectionPatch() bool
}

// UnmarshalVPNGatewayConnectionPatch unmarshals an instance of VPNGatewayConnectionPatch from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPatch)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpdPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalVPNGatewayConnectionIkePolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalVPNGatewayConnectionIPsecPolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_protocol", &obj.RoutingProtocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VPNGatewayConnectionPatch
func (vpnGatewayConnectionPatch *VPNGatewayConnectionPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpnGatewayConnectionPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VPNGatewayConnectionPeerCIDRs : VPNGatewayConnectionPeerCIDRs struct
type VPNGatewayConnectionPeerCIDRs struct {
	// The peer CIDRs for this resource.
	PeerCIDRs []string `json:"peer_cidrs,omitempty"`
}

// UnmarshalVPNGatewayConnectionPeerCIDRs unmarshals an instance of VPNGatewayConnectionPeerCIDRs from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPeerCIDRs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPeerCIDRs)
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCIDRs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionPrototype : VPNGatewayConnectionPrototype struct
// Models which "extend" this model:
// - VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype
// - VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype
type VPNGatewayConnectionPrototype struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDpdPrototype `json:"dead_peer_detection,omitempty"`

	// The IKE policy to use. If unspecified, [auto-negotiation will be
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
	IkePolicy VPNGatewayConnectionIkePolicyPrototypeIntf `json:"ike_policy,omitempty"`

	// The IPsec policy to use. If unspecified, [auto-negotiation will be
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
	IpsecPolicy VPNGatewayConnectionIPsecPolicyPrototypeIntf `json:"ipsec_policy,omitempty"`

	// The name for this VPN gateway connection. The name must not be used by another connection for the VPN gateway. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The pre-shared key.
	Psk *string `json:"psk" validate:"required"`

	// Routing protocols are disabled for this VPN gateway connection.
	RoutingProtocol *string `json:"routing_protocol,omitempty"`

	// The local CIDRs for this resource.
	LocalCIDRs []string `json:"local_cidrs,omitempty"`

	// The peer CIDRs for this resource.
	PeerCIDRs []string `json:"peer_cidrs,omitempty"`
}

// Constants associated with the VPNGatewayConnectionPrototype.RoutingProtocol property.
// Routing protocols are disabled for this VPN gateway connection.
const (
	VPNGatewayConnectionPrototypeRoutingProtocolNoneConst = "none"
)

func (*VPNGatewayConnectionPrototype) isaVPNGatewayConnectionPrototype() bool {
	return true
}

type VPNGatewayConnectionPrototypeIntf interface {
	isaVPNGatewayConnectionPrototype() bool
}

// UnmarshalVPNGatewayConnectionPrototype unmarshals an instance of VPNGatewayConnectionPrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPrototype)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpdPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalVPNGatewayConnectionIkePolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalVPNGatewayConnectionIPsecPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_protocol", &obj.RoutingProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCIDRs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCIDRs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionReference : VPNGatewayConnectionReference struct
type VPNGatewayConnectionReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNGatewayConnectionReferenceDeleted `json:"deleted,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionReference.ResourceType property.
// The resource type.
const (
	VPNGatewayConnectionReferenceResourceTypeVPNGatewayConnectionConst = "vpn_gateway_connection"
)

// UnmarshalVPNGatewayConnectionReference unmarshals an instance of VPNGatewayConnectionReference from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNGatewayConnectionReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VPNGatewayConnectionReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVPNGatewayConnectionReferenceDeleted unmarshals an instance of VPNGatewayConnectionReferenceDeleted from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionStaticRouteModeTunnel : VPNGatewayConnectionStaticRouteModeTunnel struct
type VPNGatewayConnectionStaticRouteModeTunnel struct {
	// The IP address of the VPN gateway member in which the tunnel resides.
	PublicIP *IP `json:"public_ip" validate:"required"`

	// The status of the VPN Tunnel.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current VPN gateway connection tunnels status (if any):
	// - `cannot_authenticate_connection`: Failed to authenticate a connection because of
	//   mismatched IKE ID and PSK (check IKE ID and PSK in peer VPN configuration)
	// - `internal_error`: Internal error (contact IBM support)
	// - `ike_policy_mismatch`: None of the proposed IKE crypto suites was acceptable (check
	//    the IKE policies on both sides of the VPN)
	// - `ike_v1_id_local_remote_cidr_mismatch`: Invalid IKE ID or mismatched local CIDRs and
	//   remote CIDRs in IKE V1 (check the IKE ID or the local CIDRs and remote CIDRs in IKE
	//   V1 configuration)
	// - `ike_v2_local_remote_cidr_mismatch`: Mismatched local CIDRs and remote CIDRs in IKE
	//   V2 (check the local CIDRs and remote CIDRs in IKE V2 configuration)
	// - `ipsec_policy_mismatch`: None of the proposed IPsec crypto suites was acceptable
	//   (check the IPsec policies on both sides of the VPN)
	// - `peer_not_responding`: No response from peer (check network ACL configuration, peer
	//   availability, and on-premise firewall configuration)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []VPNGatewayConnectionTunnelStatusReason `json:"status_reasons" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionStaticRouteModeTunnel.Status property.
// The status of the VPN Tunnel.
const (
	VPNGatewayConnectionStaticRouteModeTunnelStatusDownConst = "down"
	VPNGatewayConnectionStaticRouteModeTunnelStatusUpConst   = "up"
)

// UnmarshalVPNGatewayConnectionStaticRouteModeTunnel unmarshals an instance of VPNGatewayConnectionStaticRouteModeTunnel from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionStaticRouteModeTunnel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionStaticRouteModeTunnel)
	err = core.UnmarshalModel(m, "public_ip", &obj.PublicIP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalVPNGatewayConnectionTunnelStatusReason)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionStatusReason : VPNGatewayConnectionStatusReason struct
type VPNGatewayConnectionStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this VPN gateway connection's status.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNGatewayConnectionStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	VPNGatewayConnectionStatusReasonCodeCannotAuthenticateConnectionConst   = "cannot_authenticate_connection"
	VPNGatewayConnectionStatusReasonCodeIkePolicyMismatchConst              = "ike_policy_mismatch"
	VPNGatewayConnectionStatusReasonCodeIkeV1IDLocalRemoteCIDRMismatchConst = "ike_v1_id_local_remote_cidr_mismatch"
	VPNGatewayConnectionStatusReasonCodeIkeV2LocalRemoteCIDRMismatchConst   = "ike_v2_local_remote_cidr_mismatch"
	VPNGatewayConnectionStatusReasonCodeInternalErrorConst                  = "internal_error"
	VPNGatewayConnectionStatusReasonCodeIpsecPolicyMismatchConst            = "ipsec_policy_mismatch"
	VPNGatewayConnectionStatusReasonCodePeerNotRespondingConst              = "peer_not_responding"
)

// UnmarshalVPNGatewayConnectionStatusReason unmarshals an instance of VPNGatewayConnectionStatusReason from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionTunnelStatusReason : VPNGatewayConnectionTunnelStatusReason struct
type VPNGatewayConnectionTunnelStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this VPN gateway connection tunnel's status.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNGatewayConnectionTunnelStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	VPNGatewayConnectionTunnelStatusReasonCodeCannotAuthenticateConnectionConst   = "cannot_authenticate_connection"
	VPNGatewayConnectionTunnelStatusReasonCodeIkePolicyMismatchConst              = "ike_policy_mismatch"
	VPNGatewayConnectionTunnelStatusReasonCodeIkeV1IDLocalRemoteCIDRMismatchConst = "ike_v1_id_local_remote_cidr_mismatch"
	VPNGatewayConnectionTunnelStatusReasonCodeIkeV2LocalRemoteCIDRMismatchConst   = "ike_v2_local_remote_cidr_mismatch"
	VPNGatewayConnectionTunnelStatusReasonCodeInternalErrorConst                  = "internal_error"
	VPNGatewayConnectionTunnelStatusReasonCodeIpsecPolicyMismatchConst            = "ipsec_policy_mismatch"
	VPNGatewayConnectionTunnelStatusReasonCodePeerNotRespondingConst              = "peer_not_responding"
)

// UnmarshalVPNGatewayConnectionTunnelStatusReason unmarshals an instance of VPNGatewayConnectionTunnelStatusReason from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionTunnelStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionTunnelStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayHealthReason : VPNGatewayHealthReason struct
type VPNGatewayHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNGatewayHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	VPNGatewayHealthReasonCodeCannotCreateVPCRouteConst   = "cannot_create_vpc_route"
	VPNGatewayHealthReasonCodeCannotReserveIPAddressConst = "cannot_reserve_ip_address"
	VPNGatewayHealthReasonCodeInternalErrorConst          = "internal_error"
)

// UnmarshalVPNGatewayHealthReason unmarshals an instance of VPNGatewayHealthReason from the specified map of raw messages.
func UnmarshalVPNGatewayHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayLifecycleReason : VPNGatewayLifecycleReason struct
type VPNGatewayLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNGatewayLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	VPNGatewayLifecycleReasonCodeResourceSuspendedByProviderConst = "resource_suspended_by_provider"
)

// UnmarshalVPNGatewayLifecycleReason unmarshals an instance of VPNGatewayLifecycleReason from the specified map of raw messages.
func UnmarshalVPNGatewayLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayMember : VPNGatewayMember struct
type VPNGatewayMember struct {
	// The reasons for the current VPN gateway member health_state (if any):
	// - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
	//   subnet)
	// - `internal_error`: Internal error (contact IBM support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPNGatewayMemberHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The reasons for the current VPN gateway member lifecycle_state (if any):
	// - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
	//   support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []VPNGatewayMemberLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the VPN gateway member.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The reserved IP address assigned to the VPN gateway member.
	//
	// This property will be present only when the VPN gateway status is `available`.
	PrivateIP *ReservedIPReference `json:"private_ip" validate:"required"`

	// The public IP address assigned to the VPN gateway member.
	PublicIP *IP `json:"public_ip" validate:"required"`

	// The high availability role assigned to the VPN gateway member.
	Role *string `json:"role" validate:"required"`
}

// Constants associated with the VPNGatewayMember.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPNGatewayMemberHealthStateDegradedConst     = "degraded"
	VPNGatewayMemberHealthStateFaultedConst      = "faulted"
	VPNGatewayMemberHealthStateInapplicableConst = "inapplicable"
	VPNGatewayMemberHealthStateOkConst           = "ok"
)

// Constants associated with the VPNGatewayMember.LifecycleState property.
// The lifecycle state of the VPN gateway member.
const (
	VPNGatewayMemberLifecycleStateDeletingConst  = "deleting"
	VPNGatewayMemberLifecycleStateFailedConst    = "failed"
	VPNGatewayMemberLifecycleStatePendingConst   = "pending"
	VPNGatewayMemberLifecycleStateStableConst    = "stable"
	VPNGatewayMemberLifecycleStateSuspendedConst = "suspended"
	VPNGatewayMemberLifecycleStateUpdatingConst  = "updating"
	VPNGatewayMemberLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VPNGatewayMember.Role property.
// The high availability role assigned to the VPN gateway member.
const (
	VPNGatewayMemberRoleActiveConst  = "active"
	VPNGatewayMemberRoleStandbyConst = "standby"
)

// UnmarshalVPNGatewayMember unmarshals an instance of VPNGatewayMember from the specified map of raw messages.
func UnmarshalVPNGatewayMember(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayMember)
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPNGatewayMemberHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalVPNGatewayMemberLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "private_ip", &obj.PrivateIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_ip", &obj.PublicIP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "role", &obj.Role)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayMemberHealthReason : VPNGatewayMemberHealthReason struct
type VPNGatewayMemberHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNGatewayMemberHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	VPNGatewayMemberHealthReasonCodeCannotReserveIPAddressConst = "cannot_reserve_ip_address"
	VPNGatewayMemberHealthReasonCodeInternalErrorConst          = "internal_error"
)

// UnmarshalVPNGatewayMemberHealthReason unmarshals an instance of VPNGatewayMemberHealthReason from the specified map of raw messages.
func UnmarshalVPNGatewayMemberHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayMemberHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayMemberLifecycleReason : VPNGatewayMemberLifecycleReason struct
type VPNGatewayMemberLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNGatewayMemberLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	VPNGatewayMemberLifecycleReasonCodeResourceSuspendedByProviderConst = "resource_suspended_by_provider"
)

// UnmarshalVPNGatewayMemberLifecycleReason unmarshals an instance of VPNGatewayMemberLifecycleReason from the specified map of raw messages.
func UnmarshalVPNGatewayMemberLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayMemberLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayPatch : VPNGatewayPatch struct
type VPNGatewayPatch struct {
	// The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVPNGatewayPatch unmarshals an instance of VPNGatewayPatch from the specified map of raw messages.
func UnmarshalVPNGatewayPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VPNGatewayPatch
func (vpnGatewayPatch *VPNGatewayPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpnGatewayPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VPNGatewayPrototype : VPNGatewayPrototype struct
// Models which "extend" this model:
// - VPNGatewayPrototypeVPNGatewayRouteModePrototype
// - VPNGatewayPrototypeVPNGatewayPolicyModePrototype
type VPNGatewayPrototype struct {
	// The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Identifies a subnet by a unique property.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Route mode VPN gateway.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the VPNGatewayPrototype.Mode property.
// Route mode VPN gateway.
const (
	VPNGatewayPrototypeModeRouteConst = "route"
)

func (*VPNGatewayPrototype) isaVPNGatewayPrototype() bool {
	return true
}

type VPNGatewayPrototypeIntf interface {
	isaVPNGatewayPrototype() bool
}

// UnmarshalVPNGatewayPrototype unmarshals an instance of VPNGatewayPrototype from the specified map of raw messages.
func UnmarshalVPNGatewayPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VPNGatewayReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVPNGatewayReferenceDeleted unmarshals an instance of VPNGatewayReferenceDeleted from the specified map of raw messages.
func UnmarshalVPNGatewayReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServer : VPNServer struct
type VPNServer struct {
	// The certificate instance for this VPN server.
	Certificate *CertificateInstanceReference `json:"certificate" validate:"required"`

	// The methods used to authenticate VPN clients to this VPN server. VPN clients must authenticate against all specified
	// methods.
	ClientAuthentication []VPNServerAuthenticationIntf `json:"client_authentication" validate:"required"`

	// Indicates whether disconnected VPN clients will be automatically deleted after
	// `client_auto_delete_timeout` hours have passed. At present, this is always `true`, but may be modifiable in the
	// future.
	ClientAutoDelete *bool `json:"client_auto_delete" validate:"required"`

	// If `client_auto_delete` is `true`, the hours after which disconnected VPN clients will be automatically deleted. If
	// the value is `0`, disconnected VPN clients will be deleted immediately. This value may be modifiable in the future.
	ClientAutoDeleteTimeout *int64 `json:"client_auto_delete_timeout" validate:"required"`

	// The DNS server addresses that will be provided to VPN clients that are connected to this VPN server.
	ClientDnsServerIps []IP `json:"client_dns_server_ips" validate:"required"`

	// The seconds a VPN client can be idle before this VPN server will disconnect it.  If `0`, the server will not
	// disconnect idle clients.
	ClientIdleTimeout *int64 `json:"client_idle_timeout" validate:"required"`

	// The VPN client IPv4 address pool, expressed in CIDR format.
	ClientIPPool *string `json:"client_ip_pool" validate:"required"`

	// The date and time that the VPN server was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this VPN server.
	CRN *string `json:"crn" validate:"required"`

	// Indicates whether the split tunneling is enabled on this VPN server.
	EnableSplitTunneling *bool `json:"enable_split_tunneling" validate:"required"`

	// The reasons for the current VPN server health_state (if any):
	// - `cannot_access_client_certificate`: VPN server's client certificate is inaccessible
	//   (verify certificate exists and that IAM policies grant `VPN server for VPC` access to
	//   `Secrets Manager`)
	// - `cannot_access_server_certificate`: VPN server's server certificate is inaccessible
	//   (verify certificate exists and that IAM policies grant `VPN server for VPC` access to
	//   `Secrets Manager`)
	// - `cannot_create_vpc_route`: VPN cannot create route (check for conflict)
	// - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
	//   subnet)
	// - `internal_error`: Internal error (contact IBM support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPNServerHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// Fully qualified domain name assigned to this VPN server.
	Hostname *string `json:"hostname" validate:"required"`

	// The URL for this VPN server.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN server.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current VPN server lifecycle_state (if any):
	// - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
	//   support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []VPNServerLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the VPN server.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this VPN server. The name is unique across all VPN servers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The port number used by this VPN server.
	Port *int64 `json:"port" validate:"required"`

	// The reserved IPs bound to this VPN server.
	PrivateIps []ReservedIPReference `json:"private_ips" validate:"required"`

	// The transport protocol used by this VPN server.
	Protocol *string `json:"protocol" validate:"required"`

	// The resource group for this VPN server.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this VPN server.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The subnets this VPN server is provisioned in.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this VPN server resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the VPNServer.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPNServerHealthStateDegradedConst     = "degraded"
	VPNServerHealthStateFaultedConst      = "faulted"
	VPNServerHealthStateInapplicableConst = "inapplicable"
	VPNServerHealthStateOkConst           = "ok"
)

// Constants associated with the VPNServer.LifecycleState property.
// The lifecycle state of the VPN server.
const (
	VPNServerLifecycleStateDeletingConst  = "deleting"
	VPNServerLifecycleStateFailedConst    = "failed"
	VPNServerLifecycleStatePendingConst   = "pending"
	VPNServerLifecycleStateStableConst    = "stable"
	VPNServerLifecycleStateSuspendedConst = "suspended"
	VPNServerLifecycleStateUpdatingConst  = "updating"
	VPNServerLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VPNServer.Protocol property.
// The transport protocol used by this VPN server.
const (
	VPNServerProtocolTCPConst = "tcp"
	VPNServerProtocolUDPConst = "udp"
)

// Constants associated with the VPNServer.ResourceType property.
// The resource type.
const (
	VPNServerResourceTypeVPNServerConst = "vpn_server"
)

// UnmarshalVPNServer unmarshals an instance of VPNServer from the specified map of raw messages.
func UnmarshalVPNServer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServer)
	err = core.UnmarshalModel(m, "certificate", &obj.Certificate, UnmarshalCertificateInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_authentication", &obj.ClientAuthentication, UnmarshalVPNServerAuthentication)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_auto_delete", &obj.ClientAutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_auto_delete_timeout", &obj.ClientAutoDeleteTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_dns_server_ips", &obj.ClientDnsServerIps, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_idle_timeout", &obj.ClientIdleTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_ip_pool", &obj.ClientIPPool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_split_tunneling", &obj.EnableSplitTunneling)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPNServerHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalVPNServerLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "private_ips", &obj.PrivateIps, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthentication : An authentication method for this VPN server.
// Models which "extend" this model:
// - VPNServerAuthenticationByUsername
// - VPNServerAuthenticationByCertificate
type VPNServerAuthentication struct {
	// The type of authentication.
	Method *string `json:"method" validate:"required"`

	// The type of identity provider to be used by VPN client.
	IdentityProvider VPNServerAuthenticationByUsernameIDProviderIntf `json:"identity_provider,omitempty"`

	// The certificate instance used for the VPN client certificate authority (CA).
	ClientCa *CertificateInstanceReference `json:"client_ca,omitempty"`

	// The certificate revocation list contents, encoded in PEM format.
	Crl *string `json:"crl,omitempty"`
}

// Constants associated with the VPNServerAuthentication.Method property.
// The type of authentication.
const (
	VPNServerAuthenticationMethodCertificateConst = "certificate"
	VPNServerAuthenticationMethodUsernameConst    = "username"
)

func (*VPNServerAuthentication) isaVPNServerAuthentication() bool {
	return true
}

type VPNServerAuthenticationIntf interface {
	isaVPNServerAuthentication() bool
}

// UnmarshalVPNServerAuthentication unmarshals an instance of VPNServerAuthentication from the specified map of raw messages.
func UnmarshalVPNServerAuthentication(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthentication)
	err = core.UnmarshalPrimitive(m, "method", &obj.Method)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "identity_provider", &obj.IdentityProvider, UnmarshalVPNServerAuthenticationByUsernameIDProvider)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_ca", &obj.ClientCa, UnmarshalCertificateInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crl", &obj.Crl)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationByUsernameIDProvider : The type of identity provider to be used by VPN client.
// Models which "extend" this model:
// - VPNServerAuthenticationByUsernameIDProviderByIam
type VPNServerAuthenticationByUsernameIDProvider struct {
	// The type of identity provider to be used by the VPN client.
	// - `iam`: IBM identity and access management
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
	// unexpected property value was encountered.
	ProviderType *string `json:"provider_type,omitempty"`
}

// Constants associated with the VPNServerAuthenticationByUsernameIDProvider.ProviderType property.
// The type of identity provider to be used by the VPN client.
// - `iam`: IBM identity and access management
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
// unexpected property value was encountered.
const (
	VPNServerAuthenticationByUsernameIDProviderProviderTypeIamConst = "iam"
)

func (*VPNServerAuthenticationByUsernameIDProvider) isaVPNServerAuthenticationByUsernameIDProvider() bool {
	return true
}

type VPNServerAuthenticationByUsernameIDProviderIntf interface {
	isaVPNServerAuthenticationByUsernameIDProvider() bool
}

// UnmarshalVPNServerAuthenticationByUsernameIDProvider unmarshals an instance of VPNServerAuthenticationByUsernameIDProvider from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationByUsernameIDProvider(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthenticationByUsernameIDProvider)
	err = core.UnmarshalPrimitive(m, "provider_type", &obj.ProviderType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationPrototype : An authentication method for this VPN server.
// Models which "extend" this model:
// - VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype
// - VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype
type VPNServerAuthenticationPrototype struct {
	// The type of authentication.
	Method *string `json:"method" validate:"required"`

	// The type of identity provider to be used by VPN client.
	IdentityProvider VPNServerAuthenticationByUsernameIDProviderIntf `json:"identity_provider,omitempty"`

	// The certificate instance to use for the VPN client certificate authority (CA).
	ClientCa CertificateInstanceIdentityIntf `json:"client_ca,omitempty"`

	// The certificate revocation list contents, encoded in PEM format.
	Crl *string `json:"crl,omitempty"`
}

// Constants associated with the VPNServerAuthenticationPrototype.Method property.
// The type of authentication.
const (
	VPNServerAuthenticationPrototypeMethodCertificateConst = "certificate"
	VPNServerAuthenticationPrototypeMethodUsernameConst    = "username"
)

func (*VPNServerAuthenticationPrototype) isaVPNServerAuthenticationPrototype() bool {
	return true
}

type VPNServerAuthenticationPrototypeIntf interface {
	isaVPNServerAuthenticationPrototype() bool
}

// UnmarshalVPNServerAuthenticationPrototype unmarshals an instance of VPNServerAuthenticationPrototype from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "method", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'method': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'method' not found in JSON object")
		return
	}
	if discValue == "certificate" {
		err = core.UnmarshalModel(m, "", result, UnmarshalVPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype)
	} else if discValue == "username" {
		err = core.UnmarshalModel(m, "", result, UnmarshalVPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'method': %s", discValue)
	}
	return
}

// VPNServerClient : VPNServerClient struct
type VPNServerClient struct {
	// The IP address assigned to this VPN client from `client_ip_pool`.
	ClientIP *IP `json:"client_ip" validate:"required"`

	// The common name of client certificate that the VPN client provided when connecting to the server.
	//
	// This property will be present only when the `certificate` client authentication method is enabled on the VPN server.
	CommonName *string `json:"common_name,omitempty"`

	// The date and time that the VPN client was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The date and time that the VPN client was disconnected.
	//
	// This property will be present only when the client `status` is `disconnected`.
	DisconnectedAt *strfmt.DateTime `json:"disconnected_at,omitempty"`

	// The URL for this VPN client.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN client.
	ID *string `json:"id" validate:"required"`

	// The remote IP address of this VPN client.
	RemoteIP *IP `json:"remote_ip" validate:"required"`

	// The remote port of this VPN client.
	RemotePort *int64 `json:"remote_port" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the VPN client:
	// - `connected`: the VPN client is `connected` to this VPN server.
	// - `disconnected`: the VPN client is `disconnected` from this VPN server.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN client on which the
	// unexpected property value was encountered.
	Status *string `json:"status" validate:"required"`

	// The username that this VPN client provided when connecting to the VPN server.
	//
	// This property will be present only when the `username` client authentication method is enabled on the VPN server.
	Username *string `json:"username,omitempty"`
}

// Constants associated with the VPNServerClient.ResourceType property.
// The resource type.
const (
	VPNServerClientResourceTypeVPNServerClientConst = "vpn_server_client"
)

// Constants associated with the VPNServerClient.Status property.
// The status of the VPN client:
// - `connected`: the VPN client is `connected` to this VPN server.
// - `disconnected`: the VPN client is `disconnected` from this VPN server.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN client on which the
// unexpected property value was encountered.
const (
	VPNServerClientStatusConnectedConst    = "connected"
	VPNServerClientStatusDisconnectedConst = "disconnected"
)

// UnmarshalVPNServerClient unmarshals an instance of VPNServerClient from the specified map of raw messages.
func UnmarshalVPNServerClient(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerClient)
	err = core.UnmarshalModel(m, "client_ip", &obj.ClientIP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "common_name", &obj.CommonName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disconnected_at", &obj.DisconnectedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote_ip", &obj.RemoteIP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_port", &obj.RemotePort)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerClientCollection : VPNServerClientCollection struct
type VPNServerClientCollection struct {
	// Collection of VPN clients.
	Clients []VPNServerClient `json:"clients" validate:"required"`

	// A link to the first page of resources.
	First *VPNServerClientCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VPNServerClientCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalVPNServerClientCollection unmarshals an instance of VPNServerClientCollection from the specified map of raw messages.
func UnmarshalVPNServerClientCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerClientCollection)
	err = core.UnmarshalModel(m, "clients", &obj.Clients, UnmarshalVPNServerClient)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPNServerClientCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPNServerClientCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VPNServerClientCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VPNServerClientCollectionFirst : A link to the first page of resources.
type VPNServerClientCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNServerClientCollectionFirst unmarshals an instance of VPNServerClientCollectionFirst from the specified map of raw messages.
func UnmarshalVPNServerClientCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerClientCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerClientCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VPNServerClientCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNServerClientCollectionNext unmarshals an instance of VPNServerClientCollectionNext from the specified map of raw messages.
func UnmarshalVPNServerClientCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerClientCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerCollection : VPNServerCollection struct
type VPNServerCollection struct {
	// A link to the first page of resources.
	First *VPNServerCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VPNServerCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPN servers.
	VPNServers []VPNServer `json:"vpn_servers" validate:"required"`
}

// UnmarshalVPNServerCollection unmarshals an instance of VPNServerCollection from the specified map of raw messages.
func UnmarshalVPNServerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPNServerCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPNServerCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpn_servers", &obj.VPNServers, UnmarshalVPNServer)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VPNServerCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VPNServerCollectionFirst : A link to the first page of resources.
type VPNServerCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNServerCollectionFirst unmarshals an instance of VPNServerCollectionFirst from the specified map of raw messages.
func UnmarshalVPNServerCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VPNServerCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNServerCollectionNext unmarshals an instance of VPNServerCollectionNext from the specified map of raw messages.
func UnmarshalVPNServerCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerHealthReason : VPNServerHealthReason struct
type VPNServerHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNServerHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	VPNServerHealthReasonCodeCannotAccessClientCertificateConst = "cannot_access_client_certificate"
	VPNServerHealthReasonCodeCannotAccessServerCertificateConst = "cannot_access_server_certificate"
	VPNServerHealthReasonCodeCannotCreateVPCRouteConst          = "cannot_create_vpc_route"
	VPNServerHealthReasonCodeCannotReserveIPAddressConst        = "cannot_reserve_ip_address"
	VPNServerHealthReasonCodeInternalErrorConst                 = "internal_error"
)

// UnmarshalVPNServerHealthReason unmarshals an instance of VPNServerHealthReason from the specified map of raw messages.
func UnmarshalVPNServerHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerLifecycleReason : VPNServerLifecycleReason struct
type VPNServerLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNServerLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	VPNServerLifecycleReasonCodeResourceSuspendedByProviderConst = "resource_suspended_by_provider"
)

// UnmarshalVPNServerLifecycleReason unmarshals an instance of VPNServerLifecycleReason from the specified map of raw messages.
func UnmarshalVPNServerLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerPatch : VPNServerPatch struct
type VPNServerPatch struct {
	// The certificate instance for this VPN server.
	Certificate CertificateInstanceIdentityIntf `json:"certificate,omitempty"`

	// The authentication methods to use to authenticate VPN client on this VPN server
	// (replacing any existing methods).
	ClientAuthentication []VPNServerAuthenticationPrototypeIntf `json:"client_authentication,omitempty"`

	// The DNS server addresses that will be provided to VPN clients connected to this VPN server (replacing any existing
	// addresses).
	ClientDnsServerIps []IP `json:"client_dns_server_ips,omitempty"`

	// The seconds a VPN client can be idle before this VPN server will disconnect it.  If `0`, the server will not
	// disconnect idle clients.
	ClientIdleTimeout *int64 `json:"client_idle_timeout,omitempty"`

	// The VPN client IPv4 address pool, expressed in CIDR format. The request must not overlap with any existing address
	// prefixes in the VPC or any of the following reserved address ranges:
	//   - `127.0.0.0/8` (IPv4 loopback addresses)
	//   - `161.26.0.0/16` (IBM services)
	//   - `166.8.0.0/14` (Cloud Service Endpoints)
	//   - `169.254.0.0/16` (IPv4 link-local addresses)
	//   - `224.0.0.0/4` (IPv4 multicast addresses)
	//
	// The prefix length of the client IP address pool's CIDR must be between
	// `/9` (8,388,608 addresses) and `/22` (1024 addresses). A CIDR block that contains twice the number of IP addresses
	// that are required to enable the maximum number of concurrent connections is recommended.
	ClientIPPool *string `json:"client_ip_pool,omitempty"`

	// Indicates whether the split tunneling is enabled on this VPN server.
	EnableSplitTunneling *bool `json:"enable_split_tunneling,omitempty"`

	// The name for this VPN server. The name must not be used by another VPN server in the VPC.
	Name *string `json:"name,omitempty"`

	// The port number used by this VPN server.
	Port *int64 `json:"port,omitempty"`

	// The transport protocol used by this VPN server.
	Protocol *string `json:"protocol,omitempty"`

	// The subnets to provision this VPN server in (replacing the existing subnets).
	Subnets []SubnetIdentityIntf `json:"subnets,omitempty"`
}

// Constants associated with the VPNServerPatch.Protocol property.
// The transport protocol used by this VPN server.
const (
	VPNServerPatchProtocolTCPConst = "tcp"
	VPNServerPatchProtocolUDPConst = "udp"
)

// UnmarshalVPNServerPatch unmarshals an instance of VPNServerPatch from the specified map of raw messages.
func UnmarshalVPNServerPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerPatch)
	err = core.UnmarshalModel(m, "certificate", &obj.Certificate, UnmarshalCertificateInstanceIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_authentication", &obj.ClientAuthentication, UnmarshalVPNServerAuthenticationPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_dns_server_ips", &obj.ClientDnsServerIps, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_idle_timeout", &obj.ClientIdleTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_ip_pool", &obj.ClientIPPool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_split_tunneling", &obj.EnableSplitTunneling)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VPNServerPatch
func (vpnServerPatch *VPNServerPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpnServerPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VPNServerReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VPNServerReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVPNServerReferenceDeleted unmarshals an instance of VPNServerReferenceDeleted from the specified map of raw messages.
func UnmarshalVPNServerReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerRoute : VPNServerRoute struct
type VPNServerRoute struct {
	// The action to perform with a packet matching the VPN route:
	// - `translate`: translate the source IP address to one of the private IP addresses of the VPN server.
	// - `deliver`: deliver the packet into the VPC.
	// - `drop`: drop the packet
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on which the
	// unexpected property value was encountered.
	Action *string `json:"action" validate:"required"`

	// The date and time that the VPN route was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination for this VPN route in the VPN server. If an incoming packet does not match any destination, it will
	// be dropped.
	Destination *string `json:"destination" validate:"required"`

	// The reasons for the current VPN server route health_state (if any):
	// - `internal_error`: Internal error (contact IBM support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPNServerRouteHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this VPN route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN route.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current VPN server route lifecycle_state (if any):
	// - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
	//   support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []VPNServerRouteLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the VPN route.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this VPN route. The name is unique across all routes for a VPN server.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPNServerRoute.Action property.
// The action to perform with a packet matching the VPN route:
// - `translate`: translate the source IP address to one of the private IP addresses of the VPN server.
// - `deliver`: deliver the packet into the VPC.
// - `drop`: drop the packet
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the VPN route on which the
// unexpected property value was encountered.
const (
	VPNServerRouteActionDeliverConst   = "deliver"
	VPNServerRouteActionDropConst      = "drop"
	VPNServerRouteActionTranslateConst = "translate"
)

// Constants associated with the VPNServerRoute.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPNServerRouteHealthStateDegradedConst     = "degraded"
	VPNServerRouteHealthStateFaultedConst      = "faulted"
	VPNServerRouteHealthStateInapplicableConst = "inapplicable"
	VPNServerRouteHealthStateOkConst           = "ok"
)

// Constants associated with the VPNServerRoute.LifecycleState property.
// The lifecycle state of the VPN route.
const (
	VPNServerRouteLifecycleStateDeletingConst  = "deleting"
	VPNServerRouteLifecycleStateFailedConst    = "failed"
	VPNServerRouteLifecycleStatePendingConst   = "pending"
	VPNServerRouteLifecycleStateStableConst    = "stable"
	VPNServerRouteLifecycleStateSuspendedConst = "suspended"
	VPNServerRouteLifecycleStateUpdatingConst  = "updating"
	VPNServerRouteLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VPNServerRoute.ResourceType property.
// The resource type.
const (
	VPNServerRouteResourceTypeVPNServerRouteConst = "vpn_server_route"
)

// UnmarshalVPNServerRoute unmarshals an instance of VPNServerRoute from the specified map of raw messages.
func UnmarshalVPNServerRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRoute)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPNServerRouteHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalVPNServerRouteLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerRouteCollection : VPNServerRouteCollection struct
type VPNServerRouteCollection struct {
	// A link to the first page of resources.
	First *VPNServerRouteCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VPNServerRouteCollectionNext `json:"next,omitempty"`

	// Collection of VPN routes.
	Routes []VPNServerRoute `json:"routes" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalVPNServerRouteCollection unmarshals an instance of VPNServerRouteCollection from the specified map of raw messages.
func UnmarshalVPNServerRouteCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRouteCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPNServerRouteCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPNServerRouteCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalVPNServerRoute)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VPNServerRouteCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VPNServerRouteCollectionFirst : A link to the first page of resources.
type VPNServerRouteCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNServerRouteCollectionFirst unmarshals an instance of VPNServerRouteCollectionFirst from the specified map of raw messages.
func UnmarshalVPNServerRouteCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRouteCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerRouteCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VPNServerRouteCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNServerRouteCollectionNext unmarshals an instance of VPNServerRouteCollectionNext from the specified map of raw messages.
func UnmarshalVPNServerRouteCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRouteCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerRouteHealthReason : VPNServerRouteHealthReason struct
type VPNServerRouteHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNServerRouteHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	VPNServerRouteHealthReasonCodeInternalErrorConst = "internal_error"
)

// UnmarshalVPNServerRouteHealthReason unmarshals an instance of VPNServerRouteHealthReason from the specified map of raw messages.
func UnmarshalVPNServerRouteHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRouteHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerRouteLifecycleReason : VPNServerRouteLifecycleReason struct
type VPNServerRouteLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VPNServerRouteLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	VPNServerRouteLifecycleReasonCodeResourceSuspendedByProviderConst = "resource_suspended_by_provider"
)

// UnmarshalVPNServerRouteLifecycleReason unmarshals an instance of VPNServerRouteLifecycleReason from the specified map of raw messages.
func UnmarshalVPNServerRouteLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRouteLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerRoutePatch : VPNServerRoutePatch struct
type VPNServerRoutePatch struct {
	// The name for this VPN server route. The name must not be used by another route for the VPN server.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVPNServerRoutePatch unmarshals an instance of VPNServerRoutePatch from the specified map of raw messages.
func UnmarshalVPNServerRoutePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerRoutePatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VPNServerRoutePatch
func (vpnServerRoutePatch *VPNServerRoutePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpnServerRoutePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VirtualNetworkInterface : VirtualNetworkInterface struct
type VirtualNetworkInterface struct {
	// Indicates whether this virtual network interface will be automatically deleted when
	// `target` is deleted.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// The date and time that the virtual network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this virtual network interface.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this virtual network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual network interface.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the virtual network interface.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this virtual network interface. The name is unique across all virtual network interfaces in the VPC.
	Name *string `json:"name" validate:"required"`

	// The reserved IP for this virtual network interface.
	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource group for this virtual network interface.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups for this virtual network interface.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The target of this virtual network interface.
	//
	// If absent, this virtual network interface is not attached to a target.
	Target VirtualNetworkInterfaceTargetIntf `json:"target,omitempty"`

	// The VPC this virtual network interface resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone this virtual network interface resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the VirtualNetworkInterface.LifecycleState property.
// The lifecycle state of the virtual network interface.
const (
	VirtualNetworkInterfaceLifecycleStateDeletingConst  = "deleting"
	VirtualNetworkInterfaceLifecycleStateFailedConst    = "failed"
	VirtualNetworkInterfaceLifecycleStatePendingConst   = "pending"
	VirtualNetworkInterfaceLifecycleStateStableConst    = "stable"
	VirtualNetworkInterfaceLifecycleStateSuspendedConst = "suspended"
	VirtualNetworkInterfaceLifecycleStateUpdatingConst  = "updating"
	VirtualNetworkInterfaceLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VirtualNetworkInterface.ResourceType property.
// The resource type.
const (
	VirtualNetworkInterfaceResourceTypeVirtualNetworkInterfaceConst = "virtual_network_interface"
)

// UnmarshalVirtualNetworkInterface unmarshals an instance of VirtualNetworkInterface from the specified map of raw messages.
func UnmarshalVirtualNetworkInterface(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterface)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalVirtualNetworkInterfaceTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfaceCollection : VirtualNetworkInterfaceCollection struct
type VirtualNetworkInterfaceCollection struct {
	// A link to the first page of resources.
	First *VirtualNetworkInterfaceCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VirtualNetworkInterfaceCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of virtual network interfaces.
	VirtualNetworkInterfaces []VirtualNetworkInterface `json:"virtual_network_interfaces" validate:"required"`
}

// UnmarshalVirtualNetworkInterfaceCollection unmarshals an instance of VirtualNetworkInterfaceCollection from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVirtualNetworkInterfaceCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVirtualNetworkInterfaceCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtual_network_interfaces", &obj.VirtualNetworkInterfaces, UnmarshalVirtualNetworkInterface)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VirtualNetworkInterfaceCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VirtualNetworkInterfaceCollectionFirst : A link to the first page of resources.
type VirtualNetworkInterfaceCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVirtualNetworkInterfaceCollectionFirst unmarshals an instance of VirtualNetworkInterfaceCollectionFirst from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfaceCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VirtualNetworkInterfaceCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVirtualNetworkInterfaceCollectionNext unmarshals an instance of VirtualNetworkInterfaceCollectionNext from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfacePatch : VirtualNetworkInterfacePatch struct
type VirtualNetworkInterfacePatch struct {
	// The name for this virtual network interface. The name is unique across all virtual network interfaces in the VPC.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVirtualNetworkInterfacePatch unmarshals an instance of VirtualNetworkInterfacePatch from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfacePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfacePatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VirtualNetworkInterfacePatch
func (virtualNetworkInterfacePatch *VirtualNetworkInterfacePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(virtualNetworkInterfacePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VirtualNetworkInterfacePrimaryIPPrototype : VirtualNetworkInterfacePrimaryIPPrototype struct
// Models which "extend" this model:
// - VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext
// - VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext
type VirtualNetworkInterfacePrimaryIPPrototype struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href,omitempty"`

	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`
}

func (*VirtualNetworkInterfacePrimaryIPPrototype) isaVirtualNetworkInterfacePrimaryIPPrototype() bool {
	return true
}

type VirtualNetworkInterfacePrimaryIPPrototypeIntf interface {
	isaVirtualNetworkInterfacePrimaryIPPrototype() bool
}

// UnmarshalVirtualNetworkInterfacePrimaryIPPrototype unmarshals an instance of VirtualNetworkInterfacePrimaryIPPrototype from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfacePrimaryIPPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfacePrimaryIPPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfaceReferenceAttachmentContext : VirtualNetworkInterfaceReferenceAttachmentContext struct
type VirtualNetworkInterfaceReferenceAttachmentContext struct {
	// The CRN for this virtual network interface.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this virtual network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this virtual network interface. The name is unique across all virtual network interfaces in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VirtualNetworkInterfaceReferenceAttachmentContext.ResourceType property.
// The resource type.
const (
	VirtualNetworkInterfaceReferenceAttachmentContextResourceTypeVirtualNetworkInterfaceConst = "virtual_network_interface"
)

// UnmarshalVirtualNetworkInterfaceReferenceAttachmentContext unmarshals an instance of VirtualNetworkInterfaceReferenceAttachmentContext from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceReferenceAttachmentContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceReferenceAttachmentContext)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfaceReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VirtualNetworkInterfaceReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVirtualNetworkInterfaceReferenceDeleted unmarshals an instance of VirtualNetworkInterfaceReferenceDeleted from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfaceTarget : A virtual network interface target.
//
// The resource types that can be virtual network interface targets are expected to expand in the future. When iterating
// over virtual network interface targets, do not assume that every target resource will be from a known set of resource
// types. Optionally halt processing and surface an error, or bypass resources of unrecognized types.
// Models which "extend" this model:
// - VirtualNetworkInterfaceTargetShareMountTargetReference
type VirtualNetworkInterfaceTarget struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ShareMountTargetReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this share mount target.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this share mount target.
	ID *string `json:"id,omitempty"`

	// The name for this share mount target. The name is unique across all mount targets for the file share.
	Name *string `json:"name,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the VirtualNetworkInterfaceTarget.ResourceType property.
// The resource type.
const (
	VirtualNetworkInterfaceTargetResourceTypeShareMountTargetConst = "share_mount_target"
)

func (*VirtualNetworkInterfaceTarget) isaVirtualNetworkInterfaceTarget() bool {
	return true
}

type VirtualNetworkInterfaceTargetIntf interface {
	isaVirtualNetworkInterfaceTarget() bool
}

// UnmarshalVirtualNetworkInterfaceTarget unmarshals an instance of VirtualNetworkInterfaceTarget from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceTarget)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalShareMountTargetReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Volume : Volume struct
type Volume struct {
	// Indicates whether a running virtual server instance has an attachment to this volume.
	Active *bool `json:"active" validate:"required"`

	// The attachment state of the volume
	// - `unattached`: Not attached to any virtual server instances
	// - `attached`: Attached to a virtual server instance (even if the instance is stopped)
	// - `unusable`: Not able to be attached to any virtual server instances.
	AttachmentState *string `json:"attachment_state" validate:"required"`

	// The maximum bandwidth (in megabits per second) for the volume.
	Bandwidth *int64 `json:"bandwidth" validate:"required"`

	// Indicates whether this volume is performing an operation that must be serialized. This must be `false` to perform an
	// operation that is specified to require serialization.
	Busy *bool `json:"busy" validate:"required"`

	// The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The date and time that the volume was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`

	// The type of encryption used on the volume.
	Encryption *string `json:"encryption" validate:"required"`

	// The root key used to wrap the data encryption key for the volume.
	//
	// This property will be present for volumes with an `encryption` type of
	// `user_managed`.
	EncryptionKey *EncryptionKeyReference `json:"encryption_key,omitempty"`

	// The reasons for the current `health_state` (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VolumeHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The maximum I/O operations per second (IOPS) for this volume.
	Iops *int64 `json:"iops" validate:"required"`

	// The name for this volume. The name is unique across all volumes in the region.
	Name *string `json:"name" validate:"required"`

	// The operating system associated with this volume. If absent, this volume was not
	// created from an image, or the image did not include an operating system.
	OperatingSystem *OperatingSystem `json:"operating_system,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) for
	// this volume.
	Profile *VolumeProfileReference `json:"profile" validate:"required"`

	// The resource group for this volume.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The image from which this volume was created (this may be
	// [deleted](https://cloud.ibm.com/apidocs/vpc#deleted-resources)).
	// If absent, this volume was not created from an image.
	SourceImage *ImageReference `json:"source_image,omitempty"`

	// The snapshot from which this volume was cloned.
	SourceSnapshot *SnapshotReference `json:"source_snapshot,omitempty"`

	// The status of the volume.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the volume on which the unexpected
	// property value was encountered.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current status (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []VolumeStatusReason `json:"status_reasons" validate:"required"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags" validate:"required"`

	// The volume attachments for this volume.
	VolumeAttachments []VolumeAttachmentReferenceVolumeContext `json:"volume_attachments" validate:"required"`

	// The zone this volume resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Volume.AttachmentState property.
// The attachment state of the volume
// - `unattached`: Not attached to any virtual server instances
// - `attached`: Attached to a virtual server instance (even if the instance is stopped)
// - `unusable`: Not able to be attached to any virtual server instances.
const (
	VolumeAttachmentStateAttachedConst   = "attached"
	VolumeAttachmentStateUnattachedConst = "unattached"
	VolumeAttachmentStateUnusableConst   = "unusable"
)

// Constants associated with the Volume.Encryption property.
// The type of encryption used on the volume.
const (
	VolumeEncryptionProviderManagedConst = "provider_managed"
	VolumeEncryptionUserManagedConst     = "user_managed"
)

// Constants associated with the Volume.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VolumeHealthStateDegradedConst     = "degraded"
	VolumeHealthStateFaultedConst      = "faulted"
	VolumeHealthStateInapplicableConst = "inapplicable"
	VolumeHealthStateOkConst           = "ok"
)

// Constants associated with the Volume.ResourceType property.
// The resource type.
const (
	VolumeResourceTypeVolumeConst = "volume"
)

// Constants associated with the Volume.Status property.
// The status of the volume.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the volume on which the unexpected
// property value was encountered.
const (
	VolumeStatusAvailableConst       = "available"
	VolumeStatusFailedConst          = "failed"
	VolumeStatusPendingConst         = "pending"
	VolumeStatusPendingDeletionConst = "pending_deletion"
	VolumeStatusUnusableConst        = "unusable"
	VolumeStatusUpdatingConst        = "updating"
)

// UnmarshalVolume unmarshals an instance of Volume from the specified map of raw messages.
func UnmarshalVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Volume)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_state", &obj.AttachmentState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bandwidth", &obj.Bandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "busy", &obj.Busy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVolumeHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_image", &obj.SourceImage, UnmarshalImageReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalVolumeStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentReferenceVolumeContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachment : VolumeAttachment struct
type VolumeAttachment struct {
	// The maximum bandwidth (in megabits per second) for the volume when attached to this instance. This may be lower than
	// the volume bandwidth depending on the configuration of the instance.
	Bandwidth *int64 `json:"bandwidth" validate:"required"`

	// The date and time that the volume was attached.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete" validate:"required"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The name for this volume attachment. The name is unique across all volume attachments on the instance.
	Name *string `json:"name" validate:"required"`

	// The status of this volume attachment.
	Status *string `json:"status" validate:"required"`

	// The type of volume attachment.
	Type *string `json:"type" validate:"required"`

	// The attached volume.
	//
	// This property will be absent if the volume has not yet been provisioned.
	Volume *VolumeReferenceVolumeAttachmentContext `json:"volume,omitempty"`
}

// Constants associated with the VolumeAttachment.Status property.
// The status of this volume attachment.
const (
	VolumeAttachmentStatusAttachedConst  = "attached"
	VolumeAttachmentStatusAttachingConst = "attaching"
	VolumeAttachmentStatusDeletingConst  = "deleting"
	VolumeAttachmentStatusDetachingConst = "detaching"
)

// Constants associated with the VolumeAttachment.Type property.
// The type of volume attachment.
const (
	VolumeAttachmentTypeBootConst = "boot"
	VolumeAttachmentTypeDataConst = "data"
)

// UnmarshalVolumeAttachment unmarshals an instance of VolumeAttachment from the specified map of raw messages.
func UnmarshalVolumeAttachment(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachment)
	err = core.UnmarshalPrimitive(m, "bandwidth", &obj.Bandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalVolumeAttachmentDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeReferenceVolumeAttachmentContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentCollection : VolumeAttachmentCollection struct
type VolumeAttachmentCollection struct {
	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachment `json:"volume_attachments" validate:"required"`
}

// UnmarshalVolumeAttachmentCollection unmarshals an instance of VolumeAttachmentCollection from the specified map of raw messages.
func UnmarshalVolumeAttachmentCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentCollection)
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentDevice : VolumeAttachmentDevice struct
type VolumeAttachmentDevice struct {
	// A unique identifier for the device which is exposed to the instance operating system.
	ID *string `json:"id,omitempty"`
}

// UnmarshalVolumeAttachmentDevice unmarshals an instance of VolumeAttachmentDevice from the specified map of raw messages.
func UnmarshalVolumeAttachmentDevice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentDevice)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPatch : VolumeAttachmentPatch struct
type VolumeAttachmentPatch struct {
	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The name for this volume attachment. The name must not be used by another volume attachment on the instance.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVolumeAttachmentPatch unmarshals an instance of VolumeAttachmentPatch from the specified map of raw messages.
func UnmarshalVolumeAttachmentPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPatch)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VolumeAttachmentPatch
func (volumeAttachmentPatch *VolumeAttachmentPatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(volumeAttachmentPatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VolumeAttachmentPrototype : VolumeAttachmentPrototype struct
type VolumeAttachmentPrototype struct {
	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The name for this volume attachment. The name must not be used by another volume attachment on the instance. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// An existing volume to attach to the instance, or a prototype object for a new volume.
	Volume VolumeAttachmentPrototypeVolumeIntf `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototype : Instantiate VolumeAttachmentPrototype (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototype(volume VolumeAttachmentPrototypeVolumeIntf) (_model *VolumeAttachmentPrototype, err error) {
	_model = &VolumeAttachmentPrototype{
		Volume: volume,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototype unmarshals an instance of VolumeAttachmentPrototype from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototype)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeAttachmentPrototypeVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceByImageContext : VolumeAttachmentPrototypeInstanceByImageContext struct
type VolumeAttachmentPrototypeInstanceByImageContext struct {
	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The name for this volume attachment. The name must not be used by another volume attachment on the instance. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// A prototype object for a new volume.
	Volume *VolumePrototypeInstanceByImageContext `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceByImageContext : Instantiate VolumeAttachmentPrototypeInstanceByImageContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceByImageContext(volume *VolumePrototypeInstanceByImageContext) (_model *VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	_model = &VolumeAttachmentPrototypeInstanceByImageContext{
		Volume: volume,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByImageContext unmarshals an instance of VolumeAttachmentPrototypeInstanceByImageContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceByImageContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceByImageContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumePrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceBySourceSnapshotContext : VolumeAttachmentPrototypeInstanceBySourceSnapshotContext struct
type VolumeAttachmentPrototypeInstanceBySourceSnapshotContext struct {
	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The name for this volume attachment. The name must not be used by another volume attachment on the instance. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// A prototype object for a new volume from a snapshot.
	Volume *VolumePrototypeInstanceBySourceSnapshotContext `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceBySourceSnapshotContext : Instantiate VolumeAttachmentPrototypeInstanceBySourceSnapshotContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceBySourceSnapshotContext(volume *VolumePrototypeInstanceBySourceSnapshotContext) (_model *VolumeAttachmentPrototypeInstanceBySourceSnapshotContext, err error) {
	_model = &VolumeAttachmentPrototypeInstanceBySourceSnapshotContext{
		Volume: volume,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceBySourceSnapshotContext unmarshals an instance of VolumeAttachmentPrototypeInstanceBySourceSnapshotContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceBySourceSnapshotContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceBySourceSnapshotContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumePrototypeInstanceBySourceSnapshotContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceByVolumeContext : VolumeAttachmentPrototypeInstanceByVolumeContext struct
type VolumeAttachmentPrototypeInstanceByVolumeContext struct {
	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The name for this volume attachment. The name must not be used by another volume attachment on the instance. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// An existing volume to attach.
	Volume VolumeIdentityIntf `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceByVolumeContext : Instantiate VolumeAttachmentPrototypeInstanceByVolumeContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceByVolumeContext(volume VolumeIdentityIntf) (_model *VolumeAttachmentPrototypeInstanceByVolumeContext, err error) {
	_model = &VolumeAttachmentPrototypeInstanceByVolumeContext{
		Volume: volume,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByVolumeContext unmarshals an instance of VolumeAttachmentPrototypeInstanceByVolumeContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceByVolumeContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceByVolumeContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolume : An existing volume to attach to the instance, or a prototype object for a new volume.
// Models which "extend" this model:
// - VolumeAttachmentPrototypeVolumeVolumeIdentity
// - VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeVolume struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`

	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to
	// use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use for this volume. If unspecified, the instance's resource
	// group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The snapshot from which to clone the volume.
	SourceSnapshot SnapshotIdentityIntf `json:"source_snapshot,omitempty"`
}

func (*VolumeAttachmentPrototypeVolume) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

type VolumeAttachmentPrototypeVolumeIntf interface {
	isaVolumeAttachmentPrototypeVolume() bool
}

// UnmarshalVolumeAttachmentPrototypeVolume unmarshals an instance of VolumeAttachmentPrototypeVolume from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolume)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentReferenceInstanceContext : VolumeAttachmentReferenceInstanceContext struct
type VolumeAttachmentReferenceInstanceContext struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VolumeAttachmentReferenceInstanceContextDeleted `json:"deleted,omitempty"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The name for this volume attachment. The name is unique across all volume attachments on the instance.
	Name *string `json:"name" validate:"required"`

	// The attached volume.
	//
	// This property will be absent if the volume has not yet been provisioned.
	Volume *VolumeReferenceVolumeAttachmentContext `json:"volume,omitempty"`
}

// UnmarshalVolumeAttachmentReferenceInstanceContext unmarshals an instance of VolumeAttachmentReferenceInstanceContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentReferenceInstanceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentReferenceInstanceContext)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVolumeAttachmentReferenceInstanceContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalVolumeAttachmentDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeReferenceVolumeAttachmentContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentReferenceInstanceContextDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VolumeAttachmentReferenceInstanceContextDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVolumeAttachmentReferenceInstanceContextDeleted unmarshals an instance of VolumeAttachmentReferenceInstanceContextDeleted from the specified map of raw messages.
func UnmarshalVolumeAttachmentReferenceInstanceContextDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentReferenceInstanceContextDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentReferenceVolumeContext : VolumeAttachmentReferenceVolumeContext struct
type VolumeAttachmentReferenceVolumeContext struct {
	// Indicates whether deleting the instance will also delete the attached volume.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VolumeAttachmentReferenceVolumeContextDeleted `json:"deleted,omitempty"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The attached instance.
	Instance *InstanceReference `json:"instance" validate:"required"`

	// The name for this volume attachment. The name is unique across all volume attachments on the instance.
	Name *string `json:"name" validate:"required"`

	// The type of volume attachment.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the VolumeAttachmentReferenceVolumeContext.Type property.
// The type of volume attachment.
const (
	VolumeAttachmentReferenceVolumeContextTypeBootConst = "boot"
	VolumeAttachmentReferenceVolumeContextTypeDataConst = "data"
)

// UnmarshalVolumeAttachmentReferenceVolumeContext unmarshals an instance of VolumeAttachmentReferenceVolumeContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentReferenceVolumeContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentReferenceVolumeContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVolumeAttachmentReferenceVolumeContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalVolumeAttachmentDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentReferenceVolumeContextDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VolumeAttachmentReferenceVolumeContextDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVolumeAttachmentReferenceVolumeContextDeleted unmarshals an instance of VolumeAttachmentReferenceVolumeContextDeleted from the specified map of raw messages.
func UnmarshalVolumeAttachmentReferenceVolumeContextDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentReferenceVolumeContextDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeCollection : VolumeCollection struct
type VolumeCollection struct {
	// A link to the first page of resources.
	First *VolumeCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VolumeCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of volumes.
	Volumes []Volume `json:"volumes" validate:"required"`
}

// UnmarshalVolumeCollection unmarshals an instance of VolumeCollection from the specified map of raw messages.
func UnmarshalVolumeCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVolumeCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVolumeCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VolumeCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VolumeCollectionFirst : A link to the first page of resources.
type VolumeCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeCollectionFirst unmarshals an instance of VolumeCollectionFirst from the specified map of raw messages.
func UnmarshalVolumeCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VolumeCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeCollectionNext unmarshals an instance of VolumeCollectionNext from the specified map of raw messages.
func UnmarshalVolumeCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeHealthReason : VolumeHealthReason struct
type VolumeHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VolumeHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	VolumeHealthReasonCodeInitializingFromSnapshotConst = "initializing_from_snapshot"
)

// UnmarshalVolumeHealthReason unmarshals an instance of VolumeHealthReason from the specified map of raw messages.
func UnmarshalVolumeHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentity : Identifies a volume by a unique property.
// Models which "extend" this model:
// - VolumeIdentityByID
// - VolumeIdentityByCRN
// - VolumeIdentityByHref
type VolumeIdentity struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`
}

func (*VolumeIdentity) isaVolumeIdentity() bool {
	return true
}

type VolumeIdentityIntf interface {
	isaVolumeIdentity() bool
}

// UnmarshalVolumeIdentity unmarshals an instance of VolumeIdentity from the specified map of raw messages.
func UnmarshalVolumeIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePatch : VolumePatch struct
type VolumePatch struct {
	// The capacity to use for the volume (in gigabytes). The volume must be attached to a running virtual server instance,
	// and the specified value must not be less than the current capacity. Additionally, if the volume is attached as a
	// boot volume, the maximum value is 250 gigabytes.
	//
	// The minimum and maximum capacity limits for creating or updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`

	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`. The volume must be attached as a data volume to a running virtual server instance.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume. The requested profile must be in the same
	// `family` as the current profile. The volume must be attached as a data volume to
	// a running virtual server instance, and must have a `capacity` within the range
	// supported by the specified profile.
	Profile VolumeProfileIdentityIntf `json:"profile,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`
}

// UnmarshalVolumePatch unmarshals an instance of VolumePatch from the specified map of raw messages.
func UnmarshalVolumePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePatch)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VolumePatch
func (volumePatch *VolumePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(volumePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VolumeProfile : VolumeProfile struct
type VolumeProfile struct {
	// The product family this volume profile belongs to.
	//
	// The enumerated values for this property will expand in the future. When processing this property, check for and log
	// unknown values. Optionally halt processing and surface the error, or bypass the volume profile on which the
	// unexpected property value was encountered.
	Family *string `json:"family" validate:"required"`

	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// Constants associated with the VolumeProfile.Family property.
// The product family this volume profile belongs to.
//
// The enumerated values for this property will expand in the future. When processing this property, check for and log
// unknown values. Optionally halt processing and surface the error, or bypass the volume profile on which the
// unexpected property value was encountered.
const (
	VolumeProfileFamilyCustomConst = "custom"
	VolumeProfileFamilyTieredConst = "tiered"
)

// UnmarshalVolumeProfile unmarshals an instance of VolumeProfile from the specified map of raw messages.
func UnmarshalVolumeProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfile)
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileCollection : VolumeProfileCollection struct
type VolumeProfileCollection struct {
	// A link to the first page of resources.
	First *VolumeProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *VolumeProfileCollectionNext `json:"next,omitempty"`

	// Collection of volume profiles.
	Profiles []VolumeProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalVolumeProfileCollection unmarshals an instance of VolumeProfileCollection from the specified map of raw messages.
func UnmarshalVolumeProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVolumeProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVolumeProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalVolumeProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *VolumeProfileCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// VolumeProfileCollectionFirst : A link to the first page of resources.
type VolumeProfileCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeProfileCollectionFirst unmarshals an instance of VolumeProfileCollectionFirst from the specified map of raw messages.
func UnmarshalVolumeProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VolumeProfileCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeProfileCollectionNext unmarshals an instance of VolumeProfileCollectionNext from the specified map of raw messages.
func UnmarshalVolumeProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileIdentity : Identifies a volume profile by a unique property.
// Models which "extend" this model:
// - VolumeProfileIdentityByName
// - VolumeProfileIdentityByHref
type VolumeProfileIdentity struct {
	// The globally unique name for this volume profile.
	Name *string `json:"name,omitempty"`

	// The URL for this volume profile.
	Href *string `json:"href,omitempty"`
}

func (*VolumeProfileIdentity) isaVolumeProfileIdentity() bool {
	return true
}

type VolumeProfileIdentityIntf interface {
	isaVolumeProfileIdentity() bool
}

// UnmarshalVolumeProfileIdentity unmarshals an instance of VolumeProfileIdentity from the specified map of raw messages.
func UnmarshalVolumeProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileReference : VolumeProfileReference struct
type VolumeProfileReference struct {
	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeProfileReference unmarshals an instance of VolumeProfileReference from the specified map of raw messages.
func UnmarshalVolumeProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototype : VolumePrototype struct
// Models which "extend" this model:
// - VolumePrototypeVolumeByCapacity
// - VolumePrototypeVolumeBySourceSnapshot
type VolumePrototype struct {
	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to
	// use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this volume will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The snapshot from which to clone the volume.
	SourceSnapshot SnapshotIdentityIntf `json:"source_snapshot,omitempty"`
}

func (*VolumePrototype) isaVolumePrototype() bool {
	return true
}

type VolumePrototypeIntf interface {
	isaVolumePrototype() bool
}

// UnmarshalVolumePrototype unmarshals an instance of VolumePrototype from the specified map of raw messages.
func UnmarshalVolumePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototype)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototypeInstanceByImageContext : VolumePrototypeInstanceByImageContext struct
type VolumePrototypeInstanceByImageContext struct {
	// The capacity to use for the volume (in gigabytes). Must be at least the image's
	// `minimum_provisioned_size`. The maximum value may increase in the future.
	//
	// If unspecified, the capacity will be the image's `minimum_provisioned_size`.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to
	// use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use for this volume. If unspecified, the instance's resource
	// group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`
}

// NewVolumePrototypeInstanceByImageContext : Instantiate VolumePrototypeInstanceByImageContext (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeInstanceByImageContext(profile VolumeProfileIdentityIntf) (_model *VolumePrototypeInstanceByImageContext, err error) {
	_model = &VolumePrototypeInstanceByImageContext{
		Profile: profile,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumePrototypeInstanceByImageContext unmarshals an instance of VolumePrototypeInstanceByImageContext from the specified map of raw messages.
func UnmarshalVolumePrototypeInstanceByImageContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototypeInstanceByImageContext)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototypeInstanceBySourceSnapshotContext : VolumePrototypeInstanceBySourceSnapshotContext struct
type VolumePrototypeInstanceBySourceSnapshotContext struct {
	// The capacity to use for the volume (in gigabytes). Must be at least the snapshot's
	// `minimum_capacity`. The maximum value may increase in the future.
	//
	// If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to
	// use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use for this volume. If unspecified, the instance's resource
	// group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The snapshot from which to clone the volume.
	SourceSnapshot SnapshotIdentityIntf `json:"source_snapshot" validate:"required"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`
}

// NewVolumePrototypeInstanceBySourceSnapshotContext : Instantiate VolumePrototypeInstanceBySourceSnapshotContext (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeInstanceBySourceSnapshotContext(profile VolumeProfileIdentityIntf, sourceSnapshot SnapshotIdentityIntf) (_model *VolumePrototypeInstanceBySourceSnapshotContext, err error) {
	_model = &VolumePrototypeInstanceBySourceSnapshotContext{
		Profile:        profile,
		SourceSnapshot: sourceSnapshot,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumePrototypeInstanceBySourceSnapshotContext unmarshals an instance of VolumePrototypeInstanceBySourceSnapshotContext from the specified map of raw messages.
func UnmarshalVolumePrototypeInstanceBySourceSnapshotContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototypeInstanceBySourceSnapshotContext)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeReference : VolumeReference struct
type VolumeReference struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VolumeReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The name for this volume. The name is unique across all volumes in the region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *VolumeRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VolumeReference.ResourceType property.
// The resource type.
const (
	VolumeReferenceResourceTypeVolumeConst = "volume"
)

// UnmarshalVolumeReference unmarshals an instance of VolumeReference from the specified map of raw messages.
func UnmarshalVolumeReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVolumeReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalVolumeRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VolumeReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVolumeReferenceDeleted unmarshals an instance of VolumeReferenceDeleted from the specified map of raw messages.
func UnmarshalVolumeReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeReferenceVolumeAttachmentContext : VolumeReferenceVolumeAttachmentContext struct
type VolumeReferenceVolumeAttachmentContext struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VolumeReferenceVolumeAttachmentContextDeleted `json:"deleted,omitempty"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The name for this volume. The name is unique across all volumes in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VolumeReferenceVolumeAttachmentContext.ResourceType property.
// The resource type.
const (
	VolumeReferenceVolumeAttachmentContextResourceTypeVolumeConst = "volume"
)

// UnmarshalVolumeReferenceVolumeAttachmentContext unmarshals an instance of VolumeReferenceVolumeAttachmentContext from the specified map of raw messages.
func UnmarshalVolumeReferenceVolumeAttachmentContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeReferenceVolumeAttachmentContext)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVolumeReferenceVolumeAttachmentContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeReferenceVolumeAttachmentContextDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VolumeReferenceVolumeAttachmentContextDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVolumeReferenceVolumeAttachmentContextDeleted unmarshals an instance of VolumeReferenceVolumeAttachmentContextDeleted from the specified map of raw messages.
func UnmarshalVolumeReferenceVolumeAttachmentContextDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeReferenceVolumeAttachmentContextDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeRemote : If present, this property indicates that the resource associated with this reference is remote and therefore may not
// be directly retrievable.
type VolumeRemote struct {
	// If present, this property indicates that the referenced resource is remote to this
	// region, and identifies the native region.
	Region *RegionReference `json:"region,omitempty"`
}

// UnmarshalVolumeRemote unmarshals an instance of VolumeRemote from the specified map of raw messages.
func UnmarshalVolumeRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeRemote)
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeStatusReason : VolumeStatusReason struct
type VolumeStatusReason struct {
	// A snake case string succinctly identifying the status reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the VolumeStatusReason.Code property.
// A snake case string succinctly identifying the status reason.
const (
	VolumeStatusReasonCodeEncryptionKeyDeletedConst = "encryption_key_deleted"
)

// UnmarshalVolumeStatusReason unmarshals an instance of VolumeStatusReason from the specified map of raw messages.
func UnmarshalVolumeStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolutionBindingCollectionFirst : A link to the first page of resources.
type VpcdnsResolutionBindingCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVpcdnsResolutionBindingCollectionFirst unmarshals an instance of VpcdnsResolutionBindingCollectionFirst from the specified map of raw messages.
func UnmarshalVpcdnsResolutionBindingCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolutionBindingCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolutionBindingCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type VpcdnsResolutionBindingCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVpcdnsResolutionBindingCollectionNext unmarshals an instance of VpcdnsResolutionBindingCollectionNext from the specified map of raw messages.
func UnmarshalVpcdnsResolutionBindingCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolutionBindingCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Zone : Zone struct
type Zone struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this zone.
	Name *string `json:"name" validate:"required"`

	// The region this zone resides in.
	Region *RegionReference `json:"region" validate:"required"`

	// The availability status of this zone.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the Zone.Status property.
// The availability status of this zone.
const (
	ZoneStatusAvailableConst   = "available"
	ZoneStatusImpairedConst    = "impaired"
	ZoneStatusUnavailableConst = "unavailable"
)

// UnmarshalZone unmarshals an instance of Zone from the specified map of raw messages.
func UnmarshalZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Zone)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneCollection : ZoneCollection struct
type ZoneCollection struct {
	// Collection of zones.
	Zones []Zone `json:"zones" validate:"required"`
}

// UnmarshalZoneCollection unmarshals an instance of ZoneCollection from the specified map of raw messages.
func UnmarshalZoneCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneCollection)
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentity : Identifies a zone by a unique property.
// Models which "extend" this model:
// - ZoneIdentityByName
// - ZoneIdentityByHref
type ZoneIdentity struct {
	// The globally unique name for this zone.
	Name *string `json:"name,omitempty"`

	// The URL for this zone.
	Href *string `json:"href,omitempty"`
}

func (*ZoneIdentity) isaZoneIdentity() bool {
	return true
}

type ZoneIdentityIntf interface {
	isaZoneIdentity() bool
}

// UnmarshalZoneIdentity unmarshals an instance of ZoneIdentity from the specified map of raw messages.
func UnmarshalZoneIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneReference : ZoneReference struct
type ZoneReference struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The globally unique name for this zone.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalZoneReference unmarshals an instance of ZoneReference from the specified map of raw messages.
func UnmarshalZoneReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyJobSourceVolumeReference : BackupPolicyJobSourceVolumeReference struct
// This model "extends" BackupPolicyJobSource
type BackupPolicyJobSourceVolumeReference struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VolumeReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The name for this volume. The name is unique across all volumes in the region.
	Name *string `json:"name" validate:"required"`

	// If present, this property indicates that the resource associated with this reference
	// is remote and therefore may not be directly retrievable.
	Remote *VolumeRemote `json:"remote,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BackupPolicyJobSourceVolumeReference.ResourceType property.
// The resource type.
const (
	BackupPolicyJobSourceVolumeReferenceResourceTypeVolumeConst = "volume"
)

func (*BackupPolicyJobSourceVolumeReference) isaBackupPolicyJobSource() bool {
	return true
}

// UnmarshalBackupPolicyJobSourceVolumeReference unmarshals an instance of BackupPolicyJobSourceVolumeReference from the specified map of raw messages.
func UnmarshalBackupPolicyJobSourceVolumeReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyJobSourceVolumeReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVolumeReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalVolumeRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyScopePrototypeEnterpriseIdentity : Identifies an enterprise by a unique property.
// Models which "extend" this model:
// - BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN
// This model "extends" BackupPolicyScopePrototype
type BackupPolicyScopePrototypeEnterpriseIdentity struct {
	// The CRN for this enterprise.
	CRN *string `json:"crn,omitempty"`
}

func (*BackupPolicyScopePrototypeEnterpriseIdentity) isaBackupPolicyScopePrototypeEnterpriseIdentity() bool {
	return true
}

type BackupPolicyScopePrototypeEnterpriseIdentityIntf interface {
	BackupPolicyScopePrototypeIntf
	isaBackupPolicyScopePrototypeEnterpriseIdentity() bool
}

func (*BackupPolicyScopePrototypeEnterpriseIdentity) isaBackupPolicyScopePrototype() bool {
	return true
}

// UnmarshalBackupPolicyScopePrototypeEnterpriseIdentity unmarshals an instance of BackupPolicyScopePrototypeEnterpriseIdentity from the specified map of raw messages.
func UnmarshalBackupPolicyScopePrototypeEnterpriseIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyScopePrototypeEnterpriseIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyScopeAccountReference : BackupPolicyScopeAccountReference struct
// This model "extends" BackupPolicyScope
type BackupPolicyScopeAccountReference struct {
	// The unique identifier for this account.
	ID *string `json:"id" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BackupPolicyScopeAccountReference.ResourceType property.
// The resource type.
const (
	BackupPolicyScopeAccountReferenceResourceTypeAccountConst = "account"
)

func (*BackupPolicyScopeAccountReference) isaBackupPolicyScope() bool {
	return true
}

// UnmarshalBackupPolicyScopeAccountReference unmarshals an instance of BackupPolicyScopeAccountReference from the specified map of raw messages.
func UnmarshalBackupPolicyScopeAccountReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyScopeAccountReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyScopeEnterpriseReference : BackupPolicyScopeEnterpriseReference struct
// This model "extends" BackupPolicyScope
type BackupPolicyScopeEnterpriseReference struct {
	// The CRN for this enterprise.
	CRN *string `json:"crn" validate:"required"`

	// The unique identifier for this enterprise.
	ID *string `json:"id" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BackupPolicyScopeEnterpriseReference.ResourceType property.
// The resource type.
const (
	BackupPolicyScopeEnterpriseReferenceResourceTypeEnterpriseConst = "enterprise"
)

func (*BackupPolicyScopeEnterpriseReference) isaBackupPolicyScope() bool {
	return true
}

// UnmarshalBackupPolicyScopeEnterpriseReference unmarshals an instance of BackupPolicyScopeEnterpriseReference from the specified map of raw messages.
func UnmarshalBackupPolicyScopeEnterpriseReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyScopeEnterpriseReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerBootTargetBareMetalServerDiskReference : BareMetalServerBootTargetBareMetalServerDiskReference struct
// This model "extends" BareMetalServerBootTarget
type BareMetalServerBootTargetBareMetalServerDiskReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *BareMetalServerDiskReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this bare metal server disk.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server disk.
	ID *string `json:"id" validate:"required"`

	// The name for this bare metal server disk. The name is unique across all disks on the bare metal server.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the BareMetalServerBootTargetBareMetalServerDiskReference.ResourceType property.
// The resource type.
const (
	BareMetalServerBootTargetBareMetalServerDiskReferenceResourceTypeBareMetalServerDiskConst = "bare_metal_server_disk"
)

func (*BareMetalServerBootTargetBareMetalServerDiskReference) isaBareMetalServerBootTarget() bool {
	return true
}

// UnmarshalBareMetalServerBootTargetBareMetalServerDiskReference unmarshals an instance of BareMetalServerBootTargetBareMetalServerDiskReference from the specified map of raw messages.
func UnmarshalBareMetalServerBootTargetBareMetalServerDiskReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerBootTargetBareMetalServerDiskReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalBareMetalServerDiskReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount : BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount struct
// This model "extends" BareMetalServerInitializationUserAccount
type BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount struct {
	// The password at initialization, encrypted using `encryption_key`, and returned base64-encoded.
	EncryptedPassword *[]byte `json:"encrypted_password" validate:"required"`

	// The public SSH key used to encrypt the password.
	EncryptionKey *KeyReference `json:"encryption_key" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The username for the account created at initialization.
	Username *string `json:"username" validate:"required"`
}

// Constants associated with the BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount.ResourceType property.
// The resource type.
const (
	BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccountResourceTypeHostUserAccountConst = "host_user_account"
)

func (*BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount) isaBareMetalServerInitializationUserAccount() bool {
	return true
}

// UnmarshalBareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount unmarshals an instance of BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount from the specified map of raw messages.
func UnmarshalBareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerInitializationUserAccountBareMetalServerInitializationHostUserAccount)
	err = core.UnmarshalPrimitive(m, "encrypted_password", &obj.EncryptedPassword)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfaceByHiperSocket : BareMetalServerNetworkInterfaceByHiperSocket struct
// This model "extends" BareMetalServerNetworkInterface
type BareMetalServerNetworkInterfaceByHiperSocket struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing" validate:"required"`

	// The date and time that the bare metal server network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat" validate:"required"`

	// The floating IPs associated with this bare metal server network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips" validate:"required"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The MAC address of this bare metal server network interface. If the MAC address has not yet been selected, the value
	// will be an empty string.
	MacAddress *string `json:"mac_address" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	// The bare metal server network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this bare metal server network interface.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the bare metal server network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The bare metal server network interface type.
	Type *string `json:"type" validate:"required"`

	// - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
	//   within a `s390x` based system.
	InterfaceType *string `json:"interface_type" validate:"required"`
}

// Constants associated with the BareMetalServerNetworkInterfaceByHiperSocket.ResourceType property.
// The resource type.
const (
	BareMetalServerNetworkInterfaceByHiperSocketResourceTypeNetworkInterfaceConst = "network_interface"
)

// Constants associated with the BareMetalServerNetworkInterfaceByHiperSocket.Status property.
// The status of the bare metal server network interface.
const (
	BareMetalServerNetworkInterfaceByHiperSocketStatusAvailableConst = "available"
	BareMetalServerNetworkInterfaceByHiperSocketStatusDeletingConst  = "deleting"
	BareMetalServerNetworkInterfaceByHiperSocketStatusFailedConst    = "failed"
	BareMetalServerNetworkInterfaceByHiperSocketStatusPendingConst   = "pending"
)

// Constants associated with the BareMetalServerNetworkInterfaceByHiperSocket.Type property.
// The bare metal server network interface type.
const (
	BareMetalServerNetworkInterfaceByHiperSocketTypePrimaryConst   = "primary"
	BareMetalServerNetworkInterfaceByHiperSocketTypeSecondaryConst = "secondary"
)

// Constants associated with the BareMetalServerNetworkInterfaceByHiperSocket.InterfaceType property.
//   - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
//     within a `s390x` based system.
const (
	BareMetalServerNetworkInterfaceByHiperSocketInterfaceTypeHipersocketConst = "hipersocket"
)

func (*BareMetalServerNetworkInterfaceByHiperSocket) isaBareMetalServerNetworkInterface() bool {
	return true
}

// UnmarshalBareMetalServerNetworkInterfaceByHiperSocket unmarshals an instance of BareMetalServerNetworkInterfaceByHiperSocket from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceByHiperSocket(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceByHiperSocket)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mac_address", &obj.MacAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_speed", &obj.PortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfaceByPci : BareMetalServerNetworkInterfaceByPci struct
// This model "extends" BareMetalServerNetworkInterface
type BareMetalServerNetworkInterfaceByPci struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing" validate:"required"`

	// The date and time that the bare metal server network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat" validate:"required"`

	// The floating IPs associated with this bare metal server network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips" validate:"required"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The MAC address of this bare metal server network interface. If the MAC address has not yet been selected, the value
	// will be an empty string.
	MacAddress *string `json:"mac_address" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	// The bare metal server network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this bare metal server network interface.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the bare metal server network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The bare metal server network interface type.
	Type *string `json:"type" validate:"required"`

	// Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface.
	AllowedVlans []int64 `json:"allowed_vlans" validate:"required"`

	// - `pci`: a physical PCI device which can only be created or deleted when the bare metal
	//   server is stopped
	//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
	//     to use the PCI interface
	//   - Cannot directly use an IEEE 802.1q VLAN tag.
	InterfaceType *string `json:"interface_type" validate:"required"`
}

// Constants associated with the BareMetalServerNetworkInterfaceByPci.ResourceType property.
// The resource type.
const (
	BareMetalServerNetworkInterfaceByPciResourceTypeNetworkInterfaceConst = "network_interface"
)

// Constants associated with the BareMetalServerNetworkInterfaceByPci.Status property.
// The status of the bare metal server network interface.
const (
	BareMetalServerNetworkInterfaceByPciStatusAvailableConst = "available"
	BareMetalServerNetworkInterfaceByPciStatusDeletingConst  = "deleting"
	BareMetalServerNetworkInterfaceByPciStatusFailedConst    = "failed"
	BareMetalServerNetworkInterfaceByPciStatusPendingConst   = "pending"
)

// Constants associated with the BareMetalServerNetworkInterfaceByPci.Type property.
// The bare metal server network interface type.
const (
	BareMetalServerNetworkInterfaceByPciTypePrimaryConst   = "primary"
	BareMetalServerNetworkInterfaceByPciTypeSecondaryConst = "secondary"
)

// Constants associated with the BareMetalServerNetworkInterfaceByPci.InterfaceType property.
//   - `pci`: a physical PCI device which can only be created or deleted when the bare metal
//     server is stopped
//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
//     to use the PCI interface
//   - Cannot directly use an IEEE 802.1q VLAN tag.
const (
	BareMetalServerNetworkInterfaceByPciInterfaceTypePciConst = "pci"
)

func (*BareMetalServerNetworkInterfaceByPci) isaBareMetalServerNetworkInterface() bool {
	return true
}

// UnmarshalBareMetalServerNetworkInterfaceByPci unmarshals an instance of BareMetalServerNetworkInterfaceByPci from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceByPci(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceByPci)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mac_address", &obj.MacAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_speed", &obj.PortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allowed_vlans", &obj.AllowedVlans)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfaceByVlan : BareMetalServerNetworkInterfaceByVlan struct
// This model "extends" BareMetalServerNetworkInterface
type BareMetalServerNetworkInterfaceByVlan struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing" validate:"required"`

	// The date and time that the bare metal server network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat" validate:"required"`

	// The floating IPs associated with this bare metal server network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips" validate:"required"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The MAC address of this bare metal server network interface. If the MAC address has not yet been selected, the value
	// will be an empty string.
	MacAddress *string `json:"mac_address" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	// The bare metal server network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security groups targeting this bare metal server network interface.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the bare metal server network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The bare metal server network interface type.
	Type *string `json:"type" validate:"required"`

	// Indicates if the interface can float to any other server within the same
	// `resource_group`. The interface will float automatically if the network detects a GARP or RARP on another bare metal
	// server in the resource group.  Applies only to `vlan` type interfaces.
	AllowInterfaceToFloat *bool `json:"allow_interface_to_float" validate:"required"`

	// - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
	//    of `allowed_vlans`.
	//   - Must use an IEEE 802.1q tag.
	//   - Has its own security groups and does not inherit those of the PCI device through
	//     which traffic flows.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// Indicates the 802.1Q VLAN ID tag that must be used for all traffic on this interface.
	Vlan *int64 `json:"vlan" validate:"required"`
}

// Constants associated with the BareMetalServerNetworkInterfaceByVlan.ResourceType property.
// The resource type.
const (
	BareMetalServerNetworkInterfaceByVlanResourceTypeNetworkInterfaceConst = "network_interface"
)

// Constants associated with the BareMetalServerNetworkInterfaceByVlan.Status property.
// The status of the bare metal server network interface.
const (
	BareMetalServerNetworkInterfaceByVlanStatusAvailableConst = "available"
	BareMetalServerNetworkInterfaceByVlanStatusDeletingConst  = "deleting"
	BareMetalServerNetworkInterfaceByVlanStatusFailedConst    = "failed"
	BareMetalServerNetworkInterfaceByVlanStatusPendingConst   = "pending"
)

// Constants associated with the BareMetalServerNetworkInterfaceByVlan.Type property.
// The bare metal server network interface type.
const (
	BareMetalServerNetworkInterfaceByVlanTypePrimaryConst   = "primary"
	BareMetalServerNetworkInterfaceByVlanTypeSecondaryConst = "secondary"
)

// Constants associated with the BareMetalServerNetworkInterfaceByVlan.InterfaceType property.
//   - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
//     of `allowed_vlans`.
//   - Must use an IEEE 802.1q tag.
//   - Has its own security groups and does not inherit those of the PCI device through
//     which traffic flows.
const (
	BareMetalServerNetworkInterfaceByVlanInterfaceTypeVlanConst = "vlan"
)

func (*BareMetalServerNetworkInterfaceByVlan) isaBareMetalServerNetworkInterface() bool {
	return true
}

// UnmarshalBareMetalServerNetworkInterfaceByVlan unmarshals an instance of BareMetalServerNetworkInterfaceByVlan from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfaceByVlan(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfaceByVlan)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mac_address", &obj.MacAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_speed", &obj.PortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allow_interface_to_float", &obj.AllowInterfaceToFloat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype : BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype struct
// This model "extends" BareMetalServerNetworkInterfacePrototype
type BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat,omitempty"`

	// The name for this bare metal server network interface. The name must not be used by another network interface on the
	// bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the bare metal server network interface. This can be specified using an existing
	// reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must be available on the bare
	// metal server network interface's subnet. Otherwise, an available address on the subnet will be automatically
	// selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this bare metal server network interface. If unspecified, the VPC's default security
	// group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
	//   within a `s390x` based system.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `amd64`.
	InterfaceType *string `json:"interface_type" validate:"required"`
}

// Constants associated with the BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype.InterfaceType property.
//   - `hipersocket`: a virtual network device that provides high-speed TCP/IP connectivity
//     within a `s390x` based system.
//   - Not supported on bare metal servers with a `cpu.architecture` of `amd64`.
const (
	BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototypeInterfaceTypeHipersocketConst = "hipersocket"
)

// NewBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype : Instantiate BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype(subnet SubnetIdentityIntf, interfaceType string) (_model *BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype, err error) {
	_model = &BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype{
		Subnet:        subnet,
		InterfaceType: core.StringPtr(interfaceType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype) isaBareMetalServerNetworkInterfacePrototype() bool {
	return true
}

// UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype unmarshals an instance of BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByHiperSocketPrototype)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalNetworkInterfaceIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype : BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype struct
// This model "extends" BareMetalServerNetworkInterfacePrototype
type BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat,omitempty"`

	// The name for this bare metal server network interface. The name must not be used by another network interface on the
	// bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the bare metal server network interface. This can be specified using an existing
	// reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must be available on the bare
	// metal server network interface's subnet. Otherwise, an available address on the subnet will be automatically
	// selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this bare metal server network interface. If unspecified, the VPC's default security
	// group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Indicates what VLAN IDs (for VLAN type only) can use this physical (PCI type) interface.
	AllowedVlans []int64 `json:"allowed_vlans,omitempty"`

	// - `pci`: a physical PCI device which can only be created or deleted when the bare metal
	//   server is stopped
	//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
	//     to use the PCI interface
	//   - Cannot directly use an IEEE 802.1q VLAN tag.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
	InterfaceType *string `json:"interface_type" validate:"required"`
}

// Constants associated with the BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype.InterfaceType property.
//   - `pci`: a physical PCI device which can only be created or deleted when the bare metal
//     server is stopped
//   - Has an `allowed_vlans` property which controls the VLANs that will be permitted
//     to use the PCI interface
//   - Cannot directly use an IEEE 802.1q VLAN tag.
//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
const (
	BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototypeInterfaceTypePciConst = "pci"
)

// NewBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype : Instantiate BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype(subnet SubnetIdentityIntf, interfaceType string) (_model *BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype, err error) {
	_model = &BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype{
		Subnet:        subnet,
		InterfaceType: core.StringPtr(interfaceType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype) isaBareMetalServerNetworkInterfacePrototype() bool {
	return true
}

// UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype unmarshals an instance of BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByPciPrototype)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalNetworkInterfaceIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allowed_vlans", &obj.AllowedVlans)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype : BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype struct
// This model "extends" BareMetalServerNetworkInterfacePrototype
type BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype struct {
	// Indicates whether source IP spoofing is allowed on this bare metal server network interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// If `true`:
	// - The VPC infrastructure performs any needed NAT operations.
	// - `floating_ips` must not have more than one floating IP.
	//
	// If `false`:
	// - Packets are passed unchanged to/from the bare metal server network interface,
	//   allowing the workload to perform any needed NAT operations.
	// - `allow_ip_spoofing` must be `false`.
	// - `interface_type` must not be `hipersocket`.
	EnableInfrastructureNat *bool `json:"enable_infrastructure_nat,omitempty"`

	// The name for this bare metal server network interface. The name must not be used by another network interface on the
	// bare metal server. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the bare metal server network interface. This can be specified using an existing
	// reserved IP, or a prototype object for a new reserved IP.
	//
	// If an existing reserved IP or a prototype object with an address is specified, it must be available on the bare
	// metal server network interface's subnet. Otherwise, an available address on the subnet will be automatically
	// selected and reserved.
	PrimaryIP NetworkInterfaceIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The security groups to use for this bare metal server network interface. If unspecified, the VPC's default security
	// group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Indicates if the interface can float to any other server within the same
	// `resource_group`. The interface will float automatically if the network detects a GARP or RARP on another bare metal
	// server in the resource group.  Applies only to `vlan` type interfaces.
	AllowInterfaceToFloat *bool `json:"allow_interface_to_float,omitempty"`

	// - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
	//    of `allowed_vlans`.
	//   - Must use an IEEE 802.1q tag.
	//   - Has its own security groups and does not inherit those of the PCI device through
	//     which traffic flows.
	//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
	InterfaceType *string `json:"interface_type" validate:"required"`

	// Indicates the 802.1Q VLAN ID tag that must be used for all traffic on this interface.
	Vlan *int64 `json:"vlan" validate:"required"`
}

// Constants associated with the BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype.InterfaceType property.
//   - `vlan`: a virtual device, used through a `pci` device that has the `vlan` in its array
//     of `allowed_vlans`.
//   - Must use an IEEE 802.1q tag.
//   - Has its own security groups and does not inherit those of the PCI device through
//     which traffic flows.
//   - Not supported on bare metal servers with a `cpu.architecture` of `s390x`.
const (
	BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototypeInterfaceTypeVlanConst = "vlan"
)

// NewBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype : Instantiate BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype(subnet SubnetIdentityIntf, interfaceType string, vlan int64) (_model *BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype, err error) {
	_model = &BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype{
		Subnet:        subnet,
		InterfaceType: core.StringPtr(interfaceType),
		Vlan:          core.Int64Ptr(vlan),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype) isaBareMetalServerNetworkInterfacePrototype() bool {
	return true
}

// UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype unmarshals an instance of BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype from the specified map of raw messages.
func UnmarshalBareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerNetworkInterfacePrototypeBareMetalServerNetworkInterfaceByVlanPrototype)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_infrastructure_nat", &obj.EnableInfrastructureNat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalNetworkInterfaceIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "allow_interface_to_float", &obj.AllowInterfaceToFloat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interface_type", &obj.InterfaceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileBandwidthDependent : The total bandwidth shared across the bare metal server network interfaces of a bare metal server with this profile
// depends on its configuration.
// This model "extends" BareMetalServerProfileBandwidth
type BareMetalServerProfileBandwidthDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileBandwidthDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileBandwidthDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileBandwidthDependent) isaBareMetalServerProfileBandwidth() bool {
	return true
}

// UnmarshalBareMetalServerProfileBandwidthDependent unmarshals an instance of BareMetalServerProfileBandwidthDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileBandwidthDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileBandwidthDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileBandwidthEnum : The permitted total bandwidth values (in megabits per second) shared across the bare metal server network interfaces
// of a bare metal server with this profile.
// This model "extends" BareMetalServerProfileBandwidth
type BareMetalServerProfileBandwidthEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileBandwidthEnum.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileBandwidthEnumTypeEnumConst = "enum"
)

func (*BareMetalServerProfileBandwidthEnum) isaBareMetalServerProfileBandwidth() bool {
	return true
}

// UnmarshalBareMetalServerProfileBandwidthEnum unmarshals an instance of BareMetalServerProfileBandwidthEnum from the specified map of raw messages.
func UnmarshalBareMetalServerProfileBandwidthEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileBandwidthEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileBandwidthFixed : The total bandwidth (in megabits per second) shared across the bare metal server network interfaces of a bare metal
// server with this profile.
// This model "extends" BareMetalServerProfileBandwidth
type BareMetalServerProfileBandwidthFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileBandwidthFixed.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileBandwidthFixedTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileBandwidthFixed) isaBareMetalServerProfileBandwidth() bool {
	return true
}

// UnmarshalBareMetalServerProfileBandwidthFixed unmarshals an instance of BareMetalServerProfileBandwidthFixed from the specified map of raw messages.
func UnmarshalBareMetalServerProfileBandwidthFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileBandwidthFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileBandwidthRange : The permitted total bandwidth range (in megabits per second) shared across the bare metal server network interfaces
// of a bare metal server with this profile.
// This model "extends" BareMetalServerProfileBandwidth
type BareMetalServerProfileBandwidthRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileBandwidthRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileBandwidthRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileBandwidthRange) isaBareMetalServerProfileBandwidth() bool {
	return true
}

// UnmarshalBareMetalServerProfileBandwidthRange unmarshals an instance of BareMetalServerProfileBandwidthRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileBandwidthRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileBandwidthRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuCoreCountDependent : The CPU core count for a bare metal server with this profile depends on its configuration.
// This model "extends" BareMetalServerProfileCpuCoreCount
type BareMetalServerProfileCpuCoreCountDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuCoreCountDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuCoreCountDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileCpuCoreCountDependent) isaBareMetalServerProfileCpuCoreCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuCoreCountDependent unmarshals an instance of BareMetalServerProfileCpuCoreCountDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuCoreCountDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuCoreCountDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuCoreCountEnum : The permitted values for CPU cores for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileCpuCoreCount
type BareMetalServerProfileCpuCoreCountEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuCoreCountEnum.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuCoreCountEnumTypeEnumConst = "enum"
)

func (*BareMetalServerProfileCpuCoreCountEnum) isaBareMetalServerProfileCpuCoreCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuCoreCountEnum unmarshals an instance of BareMetalServerProfileCpuCoreCountEnum from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuCoreCountEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuCoreCountEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuCoreCountFixed : The CPU core count for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileCpuCoreCount
type BareMetalServerProfileCpuCoreCountFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuCoreCountFixed.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuCoreCountFixedTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileCpuCoreCountFixed) isaBareMetalServerProfileCpuCoreCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuCoreCountFixed unmarshals an instance of BareMetalServerProfileCpuCoreCountFixed from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuCoreCountFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuCoreCountFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuCoreCountRange : The permitted range for the number of CPU cores for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileCpuCoreCount
type BareMetalServerProfileCpuCoreCountRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuCoreCountRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuCoreCountRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileCpuCoreCountRange) isaBareMetalServerProfileCpuCoreCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuCoreCountRange unmarshals an instance of BareMetalServerProfileCpuCoreCountRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuCoreCountRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuCoreCountRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuSocketCountDependent : The CPU socket count for a bare metal server with this profile depends on its configuration.
// This model "extends" BareMetalServerProfileCpuSocketCount
type BareMetalServerProfileCpuSocketCountDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuSocketCountDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuSocketCountDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileCpuSocketCountDependent) isaBareMetalServerProfileCpuSocketCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuSocketCountDependent unmarshals an instance of BareMetalServerProfileCpuSocketCountDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuSocketCountDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuSocketCountDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuSocketCountEnum : The permitted values for CPU sockets for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileCpuSocketCount
type BareMetalServerProfileCpuSocketCountEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuSocketCountEnum.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuSocketCountEnumTypeEnumConst = "enum"
)

func (*BareMetalServerProfileCpuSocketCountEnum) isaBareMetalServerProfileCpuSocketCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuSocketCountEnum unmarshals an instance of BareMetalServerProfileCpuSocketCountEnum from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuSocketCountEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuSocketCountEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuSocketCountFixed : The number of CPU sockets for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileCpuSocketCount
type BareMetalServerProfileCpuSocketCountFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuSocketCountFixed.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuSocketCountFixedTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileCpuSocketCountFixed) isaBareMetalServerProfileCpuSocketCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuSocketCountFixed unmarshals an instance of BareMetalServerProfileCpuSocketCountFixed from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuSocketCountFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuSocketCountFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileCpuSocketCountRange : The permitted range for the number of CPU sockets for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileCpuSocketCount
type BareMetalServerProfileCpuSocketCountRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileCpuSocketCountRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileCpuSocketCountRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileCpuSocketCountRange) isaBareMetalServerProfileCpuSocketCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileCpuSocketCountRange unmarshals an instance of BareMetalServerProfileCpuSocketCountRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileCpuSocketCountRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileCpuSocketCountRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskQuantityDependent : The number of disks of this configuration for a bare metal server with this profile depends on its bare metal server
// configuration.
// This model "extends" BareMetalServerProfileDiskQuantity
type BareMetalServerProfileDiskQuantityDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskQuantityDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskQuantityDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileDiskQuantityDependent) isaBareMetalServerProfileDiskQuantity() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskQuantityDependent unmarshals an instance of BareMetalServerProfileDiskQuantityDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskQuantityDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskQuantityDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskQuantityEnum : The permitted the number of disks of this configuration for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileDiskQuantity
type BareMetalServerProfileDiskQuantityEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskQuantityEnum.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskQuantityEnumTypeEnumConst = "enum"
)

func (*BareMetalServerProfileDiskQuantityEnum) isaBareMetalServerProfileDiskQuantity() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskQuantityEnum unmarshals an instance of BareMetalServerProfileDiskQuantityEnum from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskQuantityEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskQuantityEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskQuantityFixed : The number of disks of this configuration for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileDiskQuantity
type BareMetalServerProfileDiskQuantityFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskQuantityFixed.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskQuantityFixedTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileDiskQuantityFixed) isaBareMetalServerProfileDiskQuantity() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskQuantityFixed unmarshals an instance of BareMetalServerProfileDiskQuantityFixed from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskQuantityFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskQuantityFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskQuantityRange : The permitted range for the number of disks of this configuration for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileDiskQuantity
type BareMetalServerProfileDiskQuantityRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskQuantityRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskQuantityRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileDiskQuantityRange) isaBareMetalServerProfileDiskQuantity() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskQuantityRange unmarshals an instance of BareMetalServerProfileDiskQuantityRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskQuantityRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskQuantityRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskSizeDependent : The disk size in GB (gigabytes) of this configuration for a bare metal server with this profile depends on its bare
// metal server configuration.
// This model "extends" BareMetalServerProfileDiskSize
type BareMetalServerProfileDiskSizeDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskSizeDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskSizeDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileDiskSizeDependent) isaBareMetalServerProfileDiskSize() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskSizeDependent unmarshals an instance of BareMetalServerProfileDiskSizeDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskSizeDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskSizeDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskSizeEnum : The permitted disk size in GB (gigabytes) of this configuration for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileDiskSize
type BareMetalServerProfileDiskSizeEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskSizeEnum.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskSizeEnumTypeEnumConst = "enum"
)

func (*BareMetalServerProfileDiskSizeEnum) isaBareMetalServerProfileDiskSize() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskSizeEnum unmarshals an instance of BareMetalServerProfileDiskSizeEnum from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskSizeEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskSizeEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskSizeFixed : The size of the disk in GB (gigabytes).
// This model "extends" BareMetalServerProfileDiskSize
type BareMetalServerProfileDiskSizeFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskSizeFixed.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskSizeFixedTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileDiskSizeFixed) isaBareMetalServerProfileDiskSize() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskSizeFixed unmarshals an instance of BareMetalServerProfileDiskSizeFixed from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskSizeFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskSizeFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileDiskSizeRange : The permitted range for the disk size of this configuration in GB (gigabytes) for a bare metal server with this
// profile.
// This model "extends" BareMetalServerProfileDiskSize
type BareMetalServerProfileDiskSizeRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileDiskSizeRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileDiskSizeRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileDiskSizeRange) isaBareMetalServerProfileDiskSize() bool {
	return true
}

// UnmarshalBareMetalServerProfileDiskSizeRange unmarshals an instance of BareMetalServerProfileDiskSizeRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileDiskSizeRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileDiskSizeRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileIdentityByHref : BareMetalServerProfileIdentityByHref struct
// This model "extends" BareMetalServerProfileIdentity
type BareMetalServerProfileIdentityByHref struct {
	// The URL for this bare metal server profile.
	Href *string `json:"href" validate:"required"`
}

// NewBareMetalServerProfileIdentityByHref : Instantiate BareMetalServerProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerProfileIdentityByHref(href string) (_model *BareMetalServerProfileIdentityByHref, err error) {
	_model = &BareMetalServerProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*BareMetalServerProfileIdentityByHref) isaBareMetalServerProfileIdentity() bool {
	return true
}

// UnmarshalBareMetalServerProfileIdentityByHref unmarshals an instance of BareMetalServerProfileIdentityByHref from the specified map of raw messages.
func UnmarshalBareMetalServerProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileIdentityByName : BareMetalServerProfileIdentityByName struct
// This model "extends" BareMetalServerProfileIdentity
type BareMetalServerProfileIdentityByName struct {
	// The name for this bare metal server profile.
	Name *string `json:"name" validate:"required"`
}

// NewBareMetalServerProfileIdentityByName : Instantiate BareMetalServerProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewBareMetalServerProfileIdentityByName(name string) (_model *BareMetalServerProfileIdentityByName, err error) {
	_model = &BareMetalServerProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*BareMetalServerProfileIdentityByName) isaBareMetalServerProfileIdentity() bool {
	return true
}

// UnmarshalBareMetalServerProfileIdentityByName unmarshals an instance of BareMetalServerProfileIdentityByName from the specified map of raw messages.
func UnmarshalBareMetalServerProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileMemoryDependent : The memory value for a bare metal server with this profile depends on its configuration.
// This model "extends" BareMetalServerProfileMemory
type BareMetalServerProfileMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileMemoryDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileMemoryDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileMemoryDependent) isaBareMetalServerProfileMemory() bool {
	return true
}

// UnmarshalBareMetalServerProfileMemoryDependent unmarshals an instance of BareMetalServerProfileMemoryDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileMemoryEnum : The permitted memory values (in gibibytes) for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileMemory
type BareMetalServerProfileMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the BareMetalServerProfileMemoryEnum.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileMemoryEnumTypeEnumConst = "enum"
)

func (*BareMetalServerProfileMemoryEnum) isaBareMetalServerProfileMemory() bool {
	return true
}

// UnmarshalBareMetalServerProfileMemoryEnum unmarshals an instance of BareMetalServerProfileMemoryEnum from the specified map of raw messages.
func UnmarshalBareMetalServerProfileMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileMemoryFixed : The memory (in gibibytes) for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileMemory
type BareMetalServerProfileMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the BareMetalServerProfileMemoryFixed.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileMemoryFixedTypeFixedConst = "fixed"
)

func (*BareMetalServerProfileMemoryFixed) isaBareMetalServerProfileMemory() bool {
	return true
}

// UnmarshalBareMetalServerProfileMemoryFixed unmarshals an instance of BareMetalServerProfileMemoryFixed from the specified map of raw messages.
func UnmarshalBareMetalServerProfileMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileMemoryRange : The permitted memory range (in gibibytes) for a bare metal server with this profile.
// This model "extends" BareMetalServerProfileMemory
type BareMetalServerProfileMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileMemoryRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileMemoryRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileMemoryRange) isaBareMetalServerProfileMemory() bool {
	return true
}

// UnmarshalBareMetalServerProfileMemoryRange unmarshals an instance of BareMetalServerProfileMemoryRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileNetworkInterfaceCountDependent : The number of bare metal server network interfaces supported on a bare metal server with this profile is dependent on
// its configuration.
// This model "extends" BareMetalServerProfileNetworkInterfaceCount
type BareMetalServerProfileNetworkInterfaceCountDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileNetworkInterfaceCountDependent.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileNetworkInterfaceCountDependentTypeDependentConst = "dependent"
)

func (*BareMetalServerProfileNetworkInterfaceCountDependent) isaBareMetalServerProfileNetworkInterfaceCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileNetworkInterfaceCountDependent unmarshals an instance of BareMetalServerProfileNetworkInterfaceCountDependent from the specified map of raw messages.
func UnmarshalBareMetalServerProfileNetworkInterfaceCountDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileNetworkInterfaceCountDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BareMetalServerProfileNetworkInterfaceCountRange : The number of bare metal server network interfaces supported on a bare metal server with this profile.
// This model "extends" BareMetalServerProfileNetworkInterfaceCount
type BareMetalServerProfileNetworkInterfaceCountRange struct {
	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the BareMetalServerProfileNetworkInterfaceCountRange.Type property.
// The type for this profile field.
const (
	BareMetalServerProfileNetworkInterfaceCountRangeTypeRangeConst = "range"
)

func (*BareMetalServerProfileNetworkInterfaceCountRange) isaBareMetalServerProfileNetworkInterfaceCount() bool {
	return true
}

// UnmarshalBareMetalServerProfileNetworkInterfaceCountRange unmarshals an instance of BareMetalServerProfileNetworkInterfaceCountRange from the specified map of raw messages.
func UnmarshalBareMetalServerProfileNetworkInterfaceCountRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BareMetalServerProfileNetworkInterfaceCountRange)
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogOfferingIdentityCatalogOfferingByCRN : CatalogOfferingIdentityCatalogOfferingByCRN struct
// This model "extends" CatalogOfferingIdentity
type CatalogOfferingIdentityCatalogOfferingByCRN struct {
	// The CRN for this
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
	CRN *string `json:"crn" validate:"required"`
}

// NewCatalogOfferingIdentityCatalogOfferingByCRN : Instantiate CatalogOfferingIdentityCatalogOfferingByCRN (Generic Model Constructor)
func (*VpcV1) NewCatalogOfferingIdentityCatalogOfferingByCRN(crn string) (_model *CatalogOfferingIdentityCatalogOfferingByCRN, err error) {
	_model = &CatalogOfferingIdentityCatalogOfferingByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*CatalogOfferingIdentityCatalogOfferingByCRN) isaCatalogOfferingIdentity() bool {
	return true
}

// UnmarshalCatalogOfferingIdentityCatalogOfferingByCRN unmarshals an instance of CatalogOfferingIdentityCatalogOfferingByCRN from the specified map of raw messages.
func UnmarshalCatalogOfferingIdentityCatalogOfferingByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogOfferingIdentityCatalogOfferingByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN : CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN struct
// This model "extends" CatalogOfferingVersionIdentity
type CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN struct {
	// The CRN for this version of a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering.
	CRN *string `json:"crn" validate:"required"`
}

// NewCatalogOfferingVersionIdentityCatalogOfferingVersionByCRN : Instantiate CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN (Generic Model Constructor)
func (*VpcV1) NewCatalogOfferingVersionIdentityCatalogOfferingVersionByCRN(crn string) (_model *CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN, err error) {
	_model = &CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN) isaCatalogOfferingVersionIdentity() bool {
	return true
}

// UnmarshalCatalogOfferingVersionIdentityCatalogOfferingVersionByCRN unmarshals an instance of CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN from the specified map of raw messages.
func UnmarshalCatalogOfferingVersionIdentityCatalogOfferingVersionByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CatalogOfferingVersionIdentityCatalogOfferingVersionByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CertificateInstanceIdentityByCRN : CertificateInstanceIdentityByCRN struct
// This model "extends" CertificateInstanceIdentity
type CertificateInstanceIdentityByCRN struct {
	// The CRN for this certificate instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewCertificateInstanceIdentityByCRN : Instantiate CertificateInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewCertificateInstanceIdentityByCRN(crn string) (_model *CertificateInstanceIdentityByCRN, err error) {
	_model = &CertificateInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*CertificateInstanceIdentityByCRN) isaCertificateInstanceIdentity() bool {
	return true
}

// UnmarshalCertificateInstanceIdentityByCRN unmarshals an instance of CertificateInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalCertificateInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CertificateInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudObjectStorageBucketIdentityByCRN : CloudObjectStorageBucketIdentityByCRN struct
// This model "extends" CloudObjectStorageBucketIdentity
type CloudObjectStorageBucketIdentityByCRN struct {
	// The CRN of this Cloud Object Storage bucket.
	CRN *string `json:"crn" validate:"required"`
}

// NewCloudObjectStorageBucketIdentityByCRN : Instantiate CloudObjectStorageBucketIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewCloudObjectStorageBucketIdentityByCRN(crn string) (_model *CloudObjectStorageBucketIdentityByCRN, err error) {
	_model = &CloudObjectStorageBucketIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*CloudObjectStorageBucketIdentityByCRN) isaCloudObjectStorageBucketIdentity() bool {
	return true
}

// UnmarshalCloudObjectStorageBucketIdentityByCRN unmarshals an instance of CloudObjectStorageBucketIdentityByCRN from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName : CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName struct
// This model "extends" CloudObjectStorageBucketIdentity
type CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName struct {
	// The globally unique name of this Cloud Object Storage bucket.
	Name *string `json:"name" validate:"required"`
}

// NewCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName : Instantiate CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName (Generic Model Constructor)
func (*VpcV1) NewCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName(name string) (_model *CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName, err error) {
	_model = &CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName) isaCloudObjectStorageBucketIdentity() bool {
	return true
}

// UnmarshalCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName unmarshals an instance of CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsInstanceIdentityByCRN : DnsInstanceIdentityByCRN struct
// This model "extends" DnsInstanceIdentity
type DnsInstanceIdentityByCRN struct {
	// The CRN for this DNS instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewDnsInstanceIdentityByCRN : Instantiate DnsInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewDnsInstanceIdentityByCRN(crn string) (_model *DnsInstanceIdentityByCRN, err error) {
	_model = &DnsInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DnsInstanceIdentityByCRN) isaDnsInstanceIdentity() bool {
	return true
}

// UnmarshalDnsInstanceIdentityByCRN unmarshals an instance of DnsInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalDnsInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DnsZoneIdentityByID : DnsZoneIdentityByID struct
// This model "extends" DnsZoneIdentity
type DnsZoneIdentityByID struct {
	ID *string `json:"id" validate:"required"`
}

// NewDnsZoneIdentityByID : Instantiate DnsZoneIdentityByID (Generic Model Constructor)
func (*VpcV1) NewDnsZoneIdentityByID(id string) (_model *DnsZoneIdentityByID, err error) {
	_model = &DnsZoneIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DnsZoneIdentityByID) isaDnsZoneIdentity() bool {
	return true
}

// UnmarshalDnsZoneIdentityByID unmarshals an instance of DnsZoneIdentityByID from the specified map of raw messages.
func UnmarshalDnsZoneIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DnsZoneIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupIdentityByCRN : DedicatedHostGroupIdentityByCRN struct
// This model "extends" DedicatedHostGroupIdentity
type DedicatedHostGroupIdentityByCRN struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`
}

// NewDedicatedHostGroupIdentityByCRN : Instantiate DedicatedHostGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostGroupIdentityByCRN(crn string) (_model *DedicatedHostGroupIdentityByCRN, err error) {
	_model = &DedicatedHostGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostGroupIdentityByCRN) isaDedicatedHostGroupIdentity() bool {
	return true
}

// UnmarshalDedicatedHostGroupIdentityByCRN unmarshals an instance of DedicatedHostGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalDedicatedHostGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupIdentityByHref : DedicatedHostGroupIdentityByHref struct
// This model "extends" DedicatedHostGroupIdentity
type DedicatedHostGroupIdentityByHref struct {
	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`
}

// NewDedicatedHostGroupIdentityByHref : Instantiate DedicatedHostGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostGroupIdentityByHref(href string) (_model *DedicatedHostGroupIdentityByHref, err error) {
	_model = &DedicatedHostGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostGroupIdentityByHref) isaDedicatedHostGroupIdentity() bool {
	return true
}

// UnmarshalDedicatedHostGroupIdentityByHref unmarshals an instance of DedicatedHostGroupIdentityByHref from the specified map of raw messages.
func UnmarshalDedicatedHostGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupIdentityByID : DedicatedHostGroupIdentityByID struct
// This model "extends" DedicatedHostGroupIdentity
type DedicatedHostGroupIdentityByID struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`
}

// NewDedicatedHostGroupIdentityByID : Instantiate DedicatedHostGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostGroupIdentityByID(id string) (_model *DedicatedHostGroupIdentityByID, err error) {
	_model = &DedicatedHostGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostGroupIdentityByID) isaDedicatedHostGroupIdentity() bool {
	return true
}

// UnmarshalDedicatedHostGroupIdentityByID unmarshals an instance of DedicatedHostGroupIdentityByID from the specified map of raw messages.
func UnmarshalDedicatedHostGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileIdentityByHref : DedicatedHostProfileIdentityByHref struct
// This model "extends" DedicatedHostProfileIdentity
type DedicatedHostProfileIdentityByHref struct {
	// The URL for this dedicated host profile.
	Href *string `json:"href" validate:"required"`
}

// NewDedicatedHostProfileIdentityByHref : Instantiate DedicatedHostProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostProfileIdentityByHref(href string) (_model *DedicatedHostProfileIdentityByHref, err error) {
	_model = &DedicatedHostProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostProfileIdentityByHref) isaDedicatedHostProfileIdentity() bool {
	return true
}

// UnmarshalDedicatedHostProfileIdentityByHref unmarshals an instance of DedicatedHostProfileIdentityByHref from the specified map of raw messages.
func UnmarshalDedicatedHostProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileIdentityByName : DedicatedHostProfileIdentityByName struct
// This model "extends" DedicatedHostProfileIdentity
type DedicatedHostProfileIdentityByName struct {
	// The globally unique name for this dedicated host profile.
	Name *string `json:"name" validate:"required"`
}

// NewDedicatedHostProfileIdentityByName : Instantiate DedicatedHostProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostProfileIdentityByName(name string) (_model *DedicatedHostProfileIdentityByName, err error) {
	_model = &DedicatedHostProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostProfileIdentityByName) isaDedicatedHostProfileIdentity() bool {
	return true
}

// UnmarshalDedicatedHostProfileIdentityByName unmarshals an instance of DedicatedHostProfileIdentityByName from the specified map of raw messages.
func UnmarshalDedicatedHostProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryDependent : The memory value for a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfileMemoryDependent) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryDependent unmarshals an instance of DedicatedHostProfileMemoryDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryEnum : The permitted memory values (in gibibytes) for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryEnum.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryEnumTypeEnumConst = "enum"
)

func (*DedicatedHostProfileMemoryEnum) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryEnum unmarshals an instance of DedicatedHostProfileMemoryEnum from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryFixed : The memory (in gibibytes) for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileMemoryFixed) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryFixed unmarshals an instance of DedicatedHostProfileMemoryFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryRange : The permitted memory range (in gibibytes) for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryRange.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryRangeTypeRangeConst = "range"
)

func (*DedicatedHostProfileMemoryRange) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryRange unmarshals an instance of DedicatedHostProfileMemoryRange from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketDependent : The CPU socket count for a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfileSocketDependent) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketDependent unmarshals an instance of DedicatedHostProfileSocketDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketEnum : The permitted values for CPU socket count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketEnum.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketEnumTypeEnumConst = "enum"
)

func (*DedicatedHostProfileSocketEnum) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketEnum unmarshals an instance of DedicatedHostProfileSocketEnum from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketFixed : The CPU socket count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileSocketFixed) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketFixed unmarshals an instance of DedicatedHostProfileSocketFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketRange : The permitted range for CPU socket count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketRange.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketRangeTypeRangeConst = "range"
)

func (*DedicatedHostProfileSocketRange) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketRange unmarshals an instance of DedicatedHostProfileSocketRange from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuDependent : The VCPU count for a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfileVcpuDependent) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuDependent unmarshals an instance of DedicatedHostProfileVcpuDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuEnum : The permitted values for VCPU count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuEnum.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuEnumTypeEnumConst = "enum"
)

func (*DedicatedHostProfileVcpuEnum) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuEnum unmarshals an instance of DedicatedHostProfileVcpuEnum from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuFixed : The VCPU count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileVcpuFixed) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuFixed unmarshals an instance of DedicatedHostProfileVcpuFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuRange : The permitted range for VCPU count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuRange.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuRangeTypeRangeConst = "range"
)

func (*DedicatedHostProfileVcpuRange) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuRange unmarshals an instance of DedicatedHostProfileVcpuRange from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeDedicatedHostByGroup : DedicatedHostPrototypeDedicatedHostByGroup struct
// This model "extends" DedicatedHostPrototype
type DedicatedHostPrototypeDedicatedHostByGroup struct {
	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled,omitempty"`

	// The name for this dedicated host. The name must not be used by another dedicated host in the region. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) to use for this dedicated host.
	Profile DedicatedHostProfileIdentityIntf `json:"profile" validate:"required"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The dedicated host group for this dedicated host.
	Group DedicatedHostGroupIdentityIntf `json:"group" validate:"required"`
}

// NewDedicatedHostPrototypeDedicatedHostByGroup : Instantiate DedicatedHostPrototypeDedicatedHostByGroup (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeDedicatedHostByGroup(profile DedicatedHostProfileIdentityIntf, group DedicatedHostGroupIdentityIntf) (_model *DedicatedHostPrototypeDedicatedHostByGroup, err error) {
	_model = &DedicatedHostPrototypeDedicatedHostByGroup{
		Profile: profile,
		Group:   group,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostPrototypeDedicatedHostByGroup) isaDedicatedHostPrototype() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeDedicatedHostByGroup unmarshals an instance of DedicatedHostPrototypeDedicatedHostByGroup from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeDedicatedHostByGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeDedicatedHostByGroup)
	err = core.UnmarshalPrimitive(m, "instance_placement_enabled", &obj.InstancePlacementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalDedicatedHostProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalDedicatedHostGroupIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeDedicatedHostByZone : DedicatedHostPrototypeDedicatedHostByZone struct
// This model "extends" DedicatedHostPrototype
type DedicatedHostPrototypeDedicatedHostByZone struct {
	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled,omitempty"`

	// The name for this dedicated host. The name must not be used by another dedicated host in the region. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-dh-profiles) to use for this dedicated host.
	Profile DedicatedHostProfileIdentityIntf `json:"profile" validate:"required"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	Group *DedicatedHostGroupPrototypeDedicatedHostByZoneContext `json:"group,omitempty"`

	// The zone this dedicated host will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewDedicatedHostPrototypeDedicatedHostByZone : Instantiate DedicatedHostPrototypeDedicatedHostByZone (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeDedicatedHostByZone(profile DedicatedHostProfileIdentityIntf, zone ZoneIdentityIntf) (_model *DedicatedHostPrototypeDedicatedHostByZone, err error) {
	_model = &DedicatedHostPrototypeDedicatedHostByZone{
		Profile: profile,
		Zone:    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DedicatedHostPrototypeDedicatedHostByZone) isaDedicatedHostPrototype() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeDedicatedHostByZone unmarshals an instance of DedicatedHostPrototypeDedicatedHostByZone from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeDedicatedHostByZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeDedicatedHostByZone)
	err = core.UnmarshalPrimitive(m, "instance_placement_enabled", &obj.InstancePlacementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalDedicatedHostProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalDedicatedHostGroupPrototypeDedicatedHostByZoneContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EncryptionKeyIdentityByCRN : EncryptionKeyIdentityByCRN struct
// This model "extends" EncryptionKeyIdentity
type EncryptionKeyIdentityByCRN struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	CRN *string `json:"crn" validate:"required"`
}

// NewEncryptionKeyIdentityByCRN : Instantiate EncryptionKeyIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewEncryptionKeyIdentityByCRN(crn string) (_model *EncryptionKeyIdentityByCRN, err error) {
	_model = &EncryptionKeyIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EncryptionKeyIdentityByCRN) isaEncryptionKeyIdentity() bool {
	return true
}

// UnmarshalEncryptionKeyIdentityByCRN unmarshals an instance of EncryptionKeyIdentityByCRN from the specified map of raw messages.
func UnmarshalEncryptionKeyIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayReservedIPReservedIPIdentity : Identifies a reserved IP by a unique property.
// Models which "extend" this model:
// - EndpointGatewayReservedIPReservedIPIdentityByID
// - EndpointGatewayReservedIPReservedIPIdentityByHref
// This model "extends" EndpointGatewayReservedIP
type EndpointGatewayReservedIPReservedIPIdentity struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href,omitempty"`
}

func (*EndpointGatewayReservedIPReservedIPIdentity) isaEndpointGatewayReservedIPReservedIPIdentity() bool {
	return true
}

type EndpointGatewayReservedIPReservedIPIdentityIntf interface {
	EndpointGatewayReservedIPIntf
	isaEndpointGatewayReservedIPReservedIPIdentity() bool
}

func (*EndpointGatewayReservedIPReservedIPIdentity) isaEndpointGatewayReservedIP() bool {
	return true
}

// UnmarshalEndpointGatewayReservedIPReservedIPIdentity unmarshals an instance of EndpointGatewayReservedIPReservedIPIdentity from the specified map of raw messages.
func UnmarshalEndpointGatewayReservedIPReservedIPIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReservedIPReservedIPIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayReservedIPReservedIPPrototypeTargetContext : EndpointGatewayReservedIPReservedIPPrototypeTargetContext struct
// This model "extends" EndpointGatewayReservedIP
type EndpointGatewayReservedIPReservedIPPrototypeTargetContext struct {
	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The subnet in which to create this reserved IP.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`
}

// NewEndpointGatewayReservedIPReservedIPPrototypeTargetContext : Instantiate EndpointGatewayReservedIPReservedIPPrototypeTargetContext (Generic Model Constructor)
func (*VpcV1) NewEndpointGatewayReservedIPReservedIPPrototypeTargetContext(subnet SubnetIdentityIntf) (_model *EndpointGatewayReservedIPReservedIPPrototypeTargetContext, err error) {
	_model = &EndpointGatewayReservedIPReservedIPPrototypeTargetContext{
		Subnet: subnet,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EndpointGatewayReservedIPReservedIPPrototypeTargetContext) isaEndpointGatewayReservedIP() bool {
	return true
}

// UnmarshalEndpointGatewayReservedIPReservedIPPrototypeTargetContext unmarshals an instance of EndpointGatewayReservedIPReservedIPPrototypeTargetContext from the specified map of raw messages.
func UnmarshalEndpointGatewayReservedIPReservedIPPrototypeTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReservedIPReservedIPPrototypeTargetContext)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetPrototypeProviderCloudServiceIdentity : EndpointGatewayTargetPrototypeProviderCloudServiceIdentity struct
// Models which "extend" this model:
// - EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN
// This model "extends" EndpointGatewayTargetPrototype
type EndpointGatewayTargetPrototypeProviderCloudServiceIdentity struct {
	// The type of target for this endpoint gateway.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service.
	CRN *string `json:"crn,omitempty"`
}

// Constants associated with the EndpointGatewayTargetPrototypeProviderCloudServiceIdentity.ResourceType property.
// The type of target for this endpoint gateway.
const (
	EndpointGatewayTargetPrototypeProviderCloudServiceIdentityResourceTypeProviderCloudServiceConst          = "provider_cloud_service"
	EndpointGatewayTargetPrototypeProviderCloudServiceIdentityResourceTypeProviderInfrastructureServiceConst = "provider_infrastructure_service"
)

func (*EndpointGatewayTargetPrototypeProviderCloudServiceIdentity) isaEndpointGatewayTargetPrototypeProviderCloudServiceIdentity() bool {
	return true
}

type EndpointGatewayTargetPrototypeProviderCloudServiceIdentityIntf interface {
	EndpointGatewayTargetPrototypeIntf
	isaEndpointGatewayTargetPrototypeProviderCloudServiceIdentity() bool
}

func (*EndpointGatewayTargetPrototypeProviderCloudServiceIdentity) isaEndpointGatewayTargetPrototype() bool {
	return true
}

// UnmarshalEndpointGatewayTargetPrototypeProviderCloudServiceIdentity unmarshals an instance of EndpointGatewayTargetPrototypeProviderCloudServiceIdentity from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetPrototypeProviderCloudServiceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTargetPrototypeProviderCloudServiceIdentity)
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity : EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity struct
// Models which "extend" this model:
// - EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName
// This model "extends" EndpointGatewayTargetPrototype
type EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity struct {
	// The type of target for this endpoint gateway.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The name of a provider infrastructure service. Must be:
	// - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
	Name *string `json:"name,omitempty"`
}

// Constants associated with the EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity.ResourceType property.
// The type of target for this endpoint gateway.
const (
	EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityResourceTypeProviderCloudServiceConst          = "provider_cloud_service"
	EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityResourceTypeProviderInfrastructureServiceConst = "provider_infrastructure_service"
)

func (*EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity) isaEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity() bool {
	return true
}

type EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityIntf interface {
	EndpointGatewayTargetPrototypeIntf
	isaEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity() bool
}

func (*EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity) isaEndpointGatewayTargetPrototype() bool {
	return true
}

// UnmarshalEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity unmarshals an instance of EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity)
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetProviderCloudServiceReference : EndpointGatewayTargetProviderCloudServiceReference struct
// This model "extends" EndpointGatewayTarget
type EndpointGatewayTargetProviderCloudServiceReference struct {
	// The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service.
	CRN *string `json:"crn" validate:"required"`

	// The type of target.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the EndpointGatewayTargetProviderCloudServiceReference.ResourceType property.
// The type of target.
const (
	EndpointGatewayTargetProviderCloudServiceReferenceResourceTypeProviderCloudServiceConst = "provider_cloud_service"
)

func (*EndpointGatewayTargetProviderCloudServiceReference) isaEndpointGatewayTarget() bool {
	return true
}

// UnmarshalEndpointGatewayTargetProviderCloudServiceReference unmarshals an instance of EndpointGatewayTargetProviderCloudServiceReference from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetProviderCloudServiceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTargetProviderCloudServiceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetProviderInfrastructureServiceReference : The name of this provider infrastructure service.
// This model "extends" EndpointGatewayTarget
type EndpointGatewayTargetProviderInfrastructureServiceReference struct {
	// The name of a provider infrastructure service. Must be:
	// - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
	Name *string `json:"name" validate:"required"`

	// The type of target.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the EndpointGatewayTargetProviderInfrastructureServiceReference.ResourceType property.
// The type of target.
const (
	EndpointGatewayTargetProviderInfrastructureServiceReferenceResourceTypeProviderInfrastructureServiceConst = "provider_infrastructure_service"
)

func (*EndpointGatewayTargetProviderInfrastructureServiceReference) isaEndpointGatewayTarget() bool {
	return true
}

// UnmarshalEndpointGatewayTargetProviderInfrastructureServiceReference unmarshals an instance of EndpointGatewayTargetProviderInfrastructureServiceReference from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetProviderInfrastructureServiceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTargetProviderInfrastructureServiceReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPPrototypeFloatingIPByTarget : FloatingIPPrototypeFloatingIPByTarget struct
// This model "extends" FloatingIPPrototype
type FloatingIPPrototypeFloatingIPByTarget struct {
	// The name for this floating IP. The name must not be used by another floating IP in the region. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The target resource to bind this floating IP to.
	//
	// The target resource must not already have a floating IP bound to it if the target
	// resource is:
	//
	// - an instance network interface
	// - a bare metal server network interface with `enable_infrastructure_nat` set to `true`.
	Target FloatingIPTargetPrototypeIntf `json:"target" validate:"required"`
}

// NewFloatingIPPrototypeFloatingIPByTarget : Instantiate FloatingIPPrototypeFloatingIPByTarget (Generic Model Constructor)
func (*VpcV1) NewFloatingIPPrototypeFloatingIPByTarget(target FloatingIPTargetPrototypeIntf) (_model *FloatingIPPrototypeFloatingIPByTarget, err error) {
	_model = &FloatingIPPrototypeFloatingIPByTarget{
		Target: target,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPPrototypeFloatingIPByTarget) isaFloatingIPPrototype() bool {
	return true
}

// UnmarshalFloatingIPPrototypeFloatingIPByTarget unmarshals an instance of FloatingIPPrototypeFloatingIPByTarget from the specified map of raw messages.
func UnmarshalFloatingIPPrototypeFloatingIPByTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPrototypeFloatingIPByTarget)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFloatingIPTargetPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPPrototypeFloatingIPByZone : FloatingIPPrototypeFloatingIPByZone struct
// This model "extends" FloatingIPPrototype
type FloatingIPPrototypeFloatingIPByZone struct {
	// The name for this floating IP. The name must not be used by another floating IP in the region. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The zone this floating IP will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewFloatingIPPrototypeFloatingIPByZone : Instantiate FloatingIPPrototypeFloatingIPByZone (Generic Model Constructor)
func (*VpcV1) NewFloatingIPPrototypeFloatingIPByZone(zone ZoneIdentityIntf) (_model *FloatingIPPrototypeFloatingIPByZone, err error) {
	_model = &FloatingIPPrototypeFloatingIPByZone{
		Zone: zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPPrototypeFloatingIPByZone) isaFloatingIPPrototype() bool {
	return true
}

// UnmarshalFloatingIPPrototypeFloatingIPByZone unmarshals an instance of FloatingIPPrototypeFloatingIPByZone from the specified map of raw messages.
func UnmarshalFloatingIPPrototypeFloatingIPByZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPrototypeFloatingIPByZone)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity : Identifies a bare metal server network interface by a unique property.
// Models which "extend" this model:
// - FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID
// - FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref
// This model "extends" FloatingIPTargetPatch
type FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity struct {
	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href,omitempty"`
}

func (*FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity) isaFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity() bool {
	return true
}

type FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityIntf interface {
	FloatingIPTargetPatchIntf
	isaFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity() bool
}

func (*FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity) isaFloatingIPTargetPatch() bool {
	return true
}

// UnmarshalFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity unmarshals an instance of FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatchNetworkInterfaceIdentity : Identifies an instance network interface by a unique property.
// Models which "extend" this model:
// - FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID
// - FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref
// This model "extends" FloatingIPTargetPatch
type FloatingIPTargetPatchNetworkInterfaceIdentity struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`
}

func (*FloatingIPTargetPatchNetworkInterfaceIdentity) isaFloatingIPTargetPatchNetworkInterfaceIdentity() bool {
	return true
}

type FloatingIPTargetPatchNetworkInterfaceIdentityIntf interface {
	FloatingIPTargetPatchIntf
	isaFloatingIPTargetPatchNetworkInterfaceIdentity() bool
}

func (*FloatingIPTargetPatchNetworkInterfaceIdentity) isaFloatingIPTargetPatch() bool {
	return true
}

// UnmarshalFloatingIPTargetPatchNetworkInterfaceIdentity unmarshals an instance of FloatingIPTargetPatchNetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatchNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatchNetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity : Identifies a bare metal server network interface by a unique property.
// Models which "extend" this model:
// - FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID
// - FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref
// This model "extends" FloatingIPTargetPrototype
type FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity struct {
	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href,omitempty"`
}

func (*FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity) isaFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity() bool {
	return true
}

type FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityIntf interface {
	FloatingIPTargetPrototypeIntf
	isaFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity() bool
}

func (*FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity) isaFloatingIPTargetPrototype() bool {
	return true
}

// UnmarshalFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity unmarshals an instance of FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototypeNetworkInterfaceIdentity : Identifies an instance network interface by a unique property.
// Models which "extend" this model:
// - FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID
// - FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref
// This model "extends" FloatingIPTargetPrototype
type FloatingIPTargetPrototypeNetworkInterfaceIdentity struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`
}

func (*FloatingIPTargetPrototypeNetworkInterfaceIdentity) isaFloatingIPTargetPrototypeNetworkInterfaceIdentity() bool {
	return true
}

type FloatingIPTargetPrototypeNetworkInterfaceIdentityIntf interface {
	FloatingIPTargetPrototypeIntf
	isaFloatingIPTargetPrototypeNetworkInterfaceIdentity() bool
}

func (*FloatingIPTargetPrototypeNetworkInterfaceIdentity) isaFloatingIPTargetPrototype() bool {
	return true
}

// UnmarshalFloatingIPTargetPrototypeNetworkInterfaceIdentity unmarshals an instance of FloatingIPTargetPrototypeNetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototypeNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototypeNetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetBareMetalServerNetworkInterfaceReference : FloatingIPTargetBareMetalServerNetworkInterfaceReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetBareMetalServerNetworkInterfaceReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *BareMetalServerNetworkInterfaceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetBareMetalServerNetworkInterfaceReference.ResourceType property.
// The resource type.
const (
	FloatingIPTargetBareMetalServerNetworkInterfaceReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FloatingIPTargetBareMetalServerNetworkInterfaceReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetBareMetalServerNetworkInterfaceReference unmarshals an instance of FloatingIPTargetBareMetalServerNetworkInterfaceReference from the specified map of raw messages.
func UnmarshalFloatingIPTargetBareMetalServerNetworkInterfaceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetBareMetalServerNetworkInterfaceReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalBareMetalServerNetworkInterfaceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetNetworkInterfaceReference : FloatingIPTargetNetworkInterfaceReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetNetworkInterfaceReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this instance network interface.
	Name *string `json:"name" validate:"required"`

	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetNetworkInterfaceReference.ResourceType property.
// The resource type.
const (
	FloatingIPTargetNetworkInterfaceReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FloatingIPTargetNetworkInterfaceReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetNetworkInterfaceReference unmarshals an instance of FloatingIPTargetNetworkInterfaceReference from the specified map of raw messages.
func UnmarshalFloatingIPTargetNetworkInterfaceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetNetworkInterfaceReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPublicGatewayReference : FloatingIPTargetPublicGatewayReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetPublicGatewayReference struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *PublicGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this public gateway. The name is unique across all public gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetPublicGatewayReference.ResourceType property.
// The resource type.
const (
	FloatingIPTargetPublicGatewayReferenceResourceTypePublicGatewayConst = "public_gateway"
)

func (*FloatingIPTargetPublicGatewayReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetPublicGatewayReference unmarshals an instance of FloatingIPTargetPublicGatewayReference from the specified map of raw messages.
func UnmarshalFloatingIPTargetPublicGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPublicGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalPublicGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeInstanceIdentity : Identifies a virtual server instance by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID
// - FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN
// - FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref
// This model "extends" FlowLogCollectorTargetPrototype
type FlowLogCollectorTargetPrototypeInstanceIdentity struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentity) isaFlowLogCollectorTargetPrototypeInstanceIdentity() bool {
	return true
}

type FlowLogCollectorTargetPrototypeInstanceIdentityIntf interface {
	FlowLogCollectorTargetPrototypeIntf
	isaFlowLogCollectorTargetPrototypeInstanceIdentity() bool
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentity) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentity unmarshals an instance of FlowLogCollectorTargetPrototypeInstanceIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity : Identifies an instance network interface by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID
// - FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref
// This model "extends" FlowLogCollectorTargetPrototype
type FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity) isaFlowLogCollectorTargetPrototypeNetworkInterfaceIdentity() bool {
	return true
}

type FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityIntf interface {
	FlowLogCollectorTargetPrototypeIntf
	isaFlowLogCollectorTargetPrototypeNetworkInterfaceIdentity() bool
}

func (*FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeNetworkInterfaceIdentity unmarshals an instance of FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeSubnetIdentity : Identifies a subnet by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID
// - FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN
// - FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref
// This model "extends" FlowLogCollectorTargetPrototype
type FlowLogCollectorTargetPrototypeSubnetIdentity struct {
	// The unique identifier for this subnet.
	ID *string `json:"id,omitempty"`

	// The CRN for this subnet.
	CRN *string `json:"crn,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentity) isaFlowLogCollectorTargetPrototypeSubnetIdentity() bool {
	return true
}

type FlowLogCollectorTargetPrototypeSubnetIdentityIntf interface {
	FlowLogCollectorTargetPrototypeIntf
	isaFlowLogCollectorTargetPrototypeSubnetIdentity() bool
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentity) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentity unmarshals an instance of FlowLogCollectorTargetPrototypeSubnetIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeSubnetIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeVPCIdentity : Identifies a VPC by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID
// - FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN
// - FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref
// This model "extends" FlowLogCollectorTargetPrototype
type FlowLogCollectorTargetPrototypeVPCIdentity struct {
	// The unique identifier for this VPC.
	ID *string `json:"id,omitempty"`

	// The CRN for this VPC.
	CRN *string `json:"crn,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorTargetPrototypeVPCIdentity) isaFlowLogCollectorTargetPrototypeVPCIdentity() bool {
	return true
}

type FlowLogCollectorTargetPrototypeVPCIdentityIntf interface {
	FlowLogCollectorTargetPrototypeIntf
	isaFlowLogCollectorTargetPrototypeVPCIdentity() bool
}

func (*FlowLogCollectorTargetPrototypeVPCIdentity) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeVPCIdentity unmarshals an instance of FlowLogCollectorTargetPrototypeVPCIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeVPCIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeVPCIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetInstanceReference : FlowLogCollectorTargetInstanceReference struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetInstanceReference struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The name for this virtual server instance. The name is unique across all virtual server instances in the region.
	Name *string `json:"name" validate:"required"`
}

func (*FlowLogCollectorTargetInstanceReference) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetInstanceReference unmarshals an instance of FlowLogCollectorTargetInstanceReference from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext : FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this instance network interface.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext.ResourceType property.
// The resource type.
const (
	FlowLogCollectorTargetNetworkInterfaceReferenceTargetContextResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetNetworkInterfaceReferenceTargetContext unmarshals an instance of FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetNetworkInterfaceReferenceTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetSubnetReference : FlowLogCollectorTargetSubnetReference struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetSubnetReference struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SubnetReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The name for this subnet. The name is unique across all subnets in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetSubnetReference.ResourceType property.
// The resource type.
const (
	FlowLogCollectorTargetSubnetReferenceResourceTypeSubnetConst = "subnet"
)

func (*FlowLogCollectorTargetSubnetReference) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetSubnetReference unmarshals an instance of FlowLogCollectorTargetSubnetReference from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetSubnetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetSubnetReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSubnetReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetVPCReference : FlowLogCollectorTargetVPCReference struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetVPCReference struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPCReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The name for this VPC. The name is unique across all VPCs in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetVPCReference.ResourceType property.
// The resource type.
const (
	FlowLogCollectorTargetVPCReferenceResourceTypeVPCConst = "vpc"
)

func (*FlowLogCollectorTargetVPCReference) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetVPCReference unmarshals an instance of FlowLogCollectorTargetVPCReference from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetVPCReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetVPCReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPCReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentityByCRN : ImageIdentityByCRN struct
// This model "extends" ImageIdentity
type ImageIdentityByCRN struct {
	// The CRN for this image.
	CRN *string `json:"crn" validate:"required"`
}

// NewImageIdentityByCRN : Instantiate ImageIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByCRN(crn string) (_model *ImageIdentityByCRN, err error) {
	_model = &ImageIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ImageIdentityByCRN) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByCRN unmarshals an instance of ImageIdentityByCRN from the specified map of raw messages.
func UnmarshalImageIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentityByHref : ImageIdentityByHref struct
// This model "extends" ImageIdentity
type ImageIdentityByHref struct {
	// The URL for this image.
	Href *string `json:"href" validate:"required"`
}

// NewImageIdentityByHref : Instantiate ImageIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByHref(href string) (_model *ImageIdentityByHref, err error) {
	_model = &ImageIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ImageIdentityByHref) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByHref unmarshals an instance of ImageIdentityByHref from the specified map of raw messages.
func UnmarshalImageIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentityByID : ImageIdentityByID struct
// This model "extends" ImageIdentity
type ImageIdentityByID struct {
	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`
}

// NewImageIdentityByID : Instantiate ImageIdentityByID (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByID(id string) (_model *ImageIdentityByID, err error) {
	_model = &ImageIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ImageIdentityByID) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByID unmarshals an instance of ImageIdentityByID from the specified map of raw messages.
func UnmarshalImageIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImagePrototypeImageByFile : ImagePrototypeImageByFile struct
// This model "extends" ImagePrototype
type ImagePrototypeImageByFile struct {
	// The deprecation date and time to set for this image.
	//
	// The date and time must not be in the past, and must be earlier than `obsolescence_at`
	// (if `obsolescence_at` is set).
	//
	// If unspecified, no deprecation date and time will be set.
	//
	// If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
	// transition to `deprecated` upon its successful creation (or
	// `obsolete` if the obsolescence date and time was also reached).
	DeprecationAt *strfmt.DateTime `json:"deprecation_at,omitempty"`

	// The name for this image. The name must not be used by another image in the region. Names starting with `ibm-` are
	// reserved for system-provided images, and are not allowed. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The obsolescence date and time to set for this image.
	//
	// The date and time must not be in the past, and must be later than `deprecation_at` (if
	// `deprecation_at` is set).
	//
	// If unspecified, no obsolescence date and time will be set.
	//
	// If the obsolescence date and time is reached while the image has a status of
	// `pending`, the image's status will transition to `obsolete` upon its successful creation.
	ObsolescenceAt *strfmt.DateTime `json:"obsolescence_at,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// A base64-encoded, encrypted representation of the key that was used to encrypt the data for this image.
	//
	// That representation is created by wrapping the key's value with the `encryption_key` root key (which must also be
	// specified), using either [Key Protect](https://cloud.ibm.com/docs/key-protect?topic=key-protect-wrap-keys) or the
	// [Hyper Protect Crypto Services](https://cloud.ibm.com/docs/services/hs-crypto?topic=hs-crypto-wrap-keys).
	//
	// If unspecified, the imported image is treated as unencrypted.
	EncryptedDataKey *string `json:"encrypted_data_key,omitempty"`

	// The root key that was used to wrap the data key (which is ultimately represented as
	// `encrypted_data_key`). Additionally, the root key will be used to encrypt volumes
	// created from this image (unless an alternate `encryption_key` is specified at volume
	// creation).
	//
	// If unspecified, the imported image is treated as unencrypted.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The file from which to create the image.
	File *ImageFilePrototype `json:"file" validate:"required"`

	// The [supported operating
	// system](https://cloud.ibm.com/apidocs/vpc#list-operating-systems) included in this
	// image.
	OperatingSystem OperatingSystemIdentityIntf `json:"operating_system" validate:"required"`
}

// NewImagePrototypeImageByFile : Instantiate ImagePrototypeImageByFile (Generic Model Constructor)
func (*VpcV1) NewImagePrototypeImageByFile(file *ImageFilePrototype, operatingSystem OperatingSystemIdentityIntf) (_model *ImagePrototypeImageByFile, err error) {
	_model = &ImagePrototypeImageByFile{
		File:            file,
		OperatingSystem: operatingSystem,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ImagePrototypeImageByFile) isaImagePrototype() bool {
	return true
}

// UnmarshalImagePrototypeImageByFile unmarshals an instance of ImagePrototypeImageByFile from the specified map of raw messages.
func UnmarshalImagePrototypeImageByFile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImagePrototypeImageByFile)
	err = core.UnmarshalPrimitive(m, "deprecation_at", &obj.DeprecationAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "obsolescence_at", &obj.ObsolescenceAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encrypted_data_key", &obj.EncryptedDataKey)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "file", &obj.File, UnmarshalImageFilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystemIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImagePrototypeImageBySourceVolume : ImagePrototypeImageBySourceVolume struct
// This model "extends" ImagePrototype
type ImagePrototypeImageBySourceVolume struct {
	// The deprecation date and time to set for this image.
	//
	// The date and time must not be in the past, and must be earlier than `obsolescence_at`
	// (if `obsolescence_at` is set).
	//
	// If unspecified, no deprecation date and time will be set.
	//
	// If the deprecation date and time is reached while the image has a status of `pending`, the image's status will
	// transition to `deprecated` upon its successful creation (or
	// `obsolete` if the obsolescence date and time was also reached).
	DeprecationAt *strfmt.DateTime `json:"deprecation_at,omitempty"`

	// The name for this image. The name must not be used by another image in the region. Names starting with `ibm-` are
	// reserved for system-provided images, and are not allowed. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The obsolescence date and time to set for this image.
	//
	// The date and time must not be in the past, and must be later than `deprecation_at` (if
	// `deprecation_at` is set).
	//
	// If unspecified, no obsolescence date and time will be set.
	//
	// If the obsolescence date and time is reached while the image has a status of
	// `pending`, the image's status will transition to `obsolete` upon its successful creation.
	ObsolescenceAt *strfmt.DateTime `json:"obsolescence_at,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The root key used to wrap the system-generated data encryption key for the image.
	//
	// If unspecified, the root key from `source_volume` will be used.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The volume from which to create the image. The specified volume must:
	// - Have an `operating_system`, which will be used to populate this image's
	//   operating system information.
	// - Not be `active` or `busy`.
	//
	// During image creation, the specified volume may briefly become `busy`.
	SourceVolume VolumeIdentityIntf `json:"source_volume" validate:"required"`
}

// NewImagePrototypeImageBySourceVolume : Instantiate ImagePrototypeImageBySourceVolume (Generic Model Constructor)
func (*VpcV1) NewImagePrototypeImageBySourceVolume(sourceVolume VolumeIdentityIntf) (_model *ImagePrototypeImageBySourceVolume, err error) {
	_model = &ImagePrototypeImageBySourceVolume{
		SourceVolume: sourceVolume,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ImagePrototypeImageBySourceVolume) isaImagePrototype() bool {
	return true
}

// UnmarshalImagePrototypeImageBySourceVolume unmarshals an instance of ImagePrototypeImageBySourceVolume from the specified map of raw messages.
func UnmarshalImagePrototypeImageBySourceVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImagePrototypeImageBySourceVolume)
	err = core.UnmarshalPrimitive(m, "deprecation_at", &obj.DeprecationAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "obsolescence_at", &obj.ObsolescenceAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_volume", &obj.SourceVolume, UnmarshalVolumeIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCatalogOfferingPrototypeCatalogOfferingByOffering : InstanceCatalogOfferingPrototypeCatalogOfferingByOffering struct
// This model "extends" InstanceCatalogOfferingPrototype
type InstanceCatalogOfferingPrototypeCatalogOfferingByOffering struct {
	// Identifies a [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
	// offering by a unique property.
	Offering CatalogOfferingIdentityIntf `json:"offering" validate:"required"`
}

// NewInstanceCatalogOfferingPrototypeCatalogOfferingByOffering : Instantiate InstanceCatalogOfferingPrototypeCatalogOfferingByOffering (Generic Model Constructor)
func (*VpcV1) NewInstanceCatalogOfferingPrototypeCatalogOfferingByOffering(offering CatalogOfferingIdentityIntf) (_model *InstanceCatalogOfferingPrototypeCatalogOfferingByOffering, err error) {
	_model = &InstanceCatalogOfferingPrototypeCatalogOfferingByOffering{
		Offering: offering,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceCatalogOfferingPrototypeCatalogOfferingByOffering) isaInstanceCatalogOfferingPrototype() bool {
	return true
}

// UnmarshalInstanceCatalogOfferingPrototypeCatalogOfferingByOffering unmarshals an instance of InstanceCatalogOfferingPrototypeCatalogOfferingByOffering from the specified map of raw messages.
func UnmarshalInstanceCatalogOfferingPrototypeCatalogOfferingByOffering(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCatalogOfferingPrototypeCatalogOfferingByOffering)
	err = core.UnmarshalModel(m, "offering", &obj.Offering, UnmarshalCatalogOfferingIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCatalogOfferingPrototypeCatalogOfferingByVersion : InstanceCatalogOfferingPrototypeCatalogOfferingByVersion struct
// This model "extends" InstanceCatalogOfferingPrototype
type InstanceCatalogOfferingPrototypeCatalogOfferingByVersion struct {
	// Identifies a version of a
	// [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering by a
	// unique property.
	Version CatalogOfferingVersionIdentityIntf `json:"version" validate:"required"`
}

// NewInstanceCatalogOfferingPrototypeCatalogOfferingByVersion : Instantiate InstanceCatalogOfferingPrototypeCatalogOfferingByVersion (Generic Model Constructor)
func (*VpcV1) NewInstanceCatalogOfferingPrototypeCatalogOfferingByVersion(version CatalogOfferingVersionIdentityIntf) (_model *InstanceCatalogOfferingPrototypeCatalogOfferingByVersion, err error) {
	_model = &InstanceCatalogOfferingPrototypeCatalogOfferingByVersion{
		Version: version,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceCatalogOfferingPrototypeCatalogOfferingByVersion) isaInstanceCatalogOfferingPrototype() bool {
	return true
}

// UnmarshalInstanceCatalogOfferingPrototypeCatalogOfferingByVersion unmarshals an instance of InstanceCatalogOfferingPrototypeCatalogOfferingByVersion from the specified map of raw messages.
func UnmarshalInstanceCatalogOfferingPrototypeCatalogOfferingByVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCatalogOfferingPrototypeCatalogOfferingByVersion)
	err = core.UnmarshalModel(m, "version", &obj.Version, UnmarshalCatalogOfferingVersionIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototype : InstanceGroupManagerActionPrototypeScheduledActionPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt
// - InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec
// This model "extends" InstanceGroupManagerActionPrototype
type InstanceGroupManagerActionPrototypeScheduledActionPrototype struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The date and time the scheduled action will run.
	RunAt *strfmt.DateTime `json:"run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroupPrototype `json:"group,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerPrototypeIntf `json:"manager,omitempty"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototype) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

type InstanceGroupManagerActionPrototypeScheduledActionPrototypeIntf interface {
	InstanceGroupManagerActionPrototypeIntf
	isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototype) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototype unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "run_at", &obj.RunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroupPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManagerPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionScheduledAction : InstanceGroupManagerActionScheduledAction struct
// Models which "extend" this model:
// - InstanceGroupManagerActionScheduledActionGroupTarget
// - InstanceGroupManagerActionScheduledActionManagerTarget
// This model "extends" InstanceGroupManagerAction
type InstanceGroupManagerActionScheduledAction struct {
	// Indicates whether this scheduled action will be automatically deleted after it has completed and
	// `auto_delete_timeout` hours have passed. At present, this is always
	// `true`, but may be modifiable in the future.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be automatically
	// deleted. If the value is `0`, the action will be deleted once it has finished. This value may be modifiable in the
	// future.
	AutoDeleteTimeout *int64 `json:"auto_delete_timeout" validate:"required"`

	// The date and time that the instance group manager action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager action.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager action.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager action. The name is unique across all actions for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the instance group action
	// - `active`: Action is ready to be run
	// - `completed`: Action was completed successfully
	// - `failed`: Action could not be completed successfully
	// - `incompatible`: Action parameters are not compatible with the group or manager
	// - `omitted`: Action was not applied because this action's manager was disabled.
	Status *string `json:"status" validate:"required"`

	// The date and time that the instance group manager action was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The type of action for the instance group.
	ActionType *string `json:"action_type" validate:"required"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	// The date and time the scheduled action was last applied. If absent, the action has never been applied.
	LastAppliedAt *strfmt.DateTime `json:"last_applied_at,omitempty"`

	// The date and time the scheduled action will next run. If absent, the system is currently calculating the next run
	// time.
	NextRunAt *strfmt.DateTime `json:"next_run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroup `json:"group,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerIntf `json:"manager,omitempty"`
}

// Constants associated with the InstanceGroupManagerActionScheduledAction.ResourceType property.
// The resource type.
const (
	InstanceGroupManagerActionScheduledActionResourceTypeInstanceGroupManagerActionConst = "instance_group_manager_action"
)

// Constants associated with the InstanceGroupManagerActionScheduledAction.Status property.
// The status of the instance group action
// - `active`: Action is ready to be run
// - `completed`: Action was completed successfully
// - `failed`: Action could not be completed successfully
// - `incompatible`: Action parameters are not compatible with the group or manager
// - `omitted`: Action was not applied because this action's manager was disabled.
const (
	InstanceGroupManagerActionScheduledActionStatusActiveConst       = "active"
	InstanceGroupManagerActionScheduledActionStatusCompletedConst    = "completed"
	InstanceGroupManagerActionScheduledActionStatusFailedConst       = "failed"
	InstanceGroupManagerActionScheduledActionStatusIncompatibleConst = "incompatible"
	InstanceGroupManagerActionScheduledActionStatusOmittedConst      = "omitted"
)

// Constants associated with the InstanceGroupManagerActionScheduledAction.ActionType property.
// The type of action for the instance group.
const (
	InstanceGroupManagerActionScheduledActionActionTypeScheduledConst = "scheduled"
)

func (*InstanceGroupManagerActionScheduledAction) isaInstanceGroupManagerActionScheduledAction() bool {
	return true
}

type InstanceGroupManagerActionScheduledActionIntf interface {
	InstanceGroupManagerActionIntf
	isaInstanceGroupManagerActionScheduledAction() bool
}

func (*InstanceGroupManagerActionScheduledAction) isaInstanceGroupManagerAction() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionScheduledAction unmarshals an instance of InstanceGroupManagerActionScheduledAction from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionScheduledAction(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionScheduledAction)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete_timeout", &obj.AutoDeleteTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "action_type", &obj.ActionType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "last_applied_at", &obj.LastAppliedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "next_run_at", &obj.NextRunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManager)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerAutoScale : InstanceGroupManagerAutoScale struct
// This model "extends" InstanceGroupManager
type InstanceGroupManagerAutoScale struct {
	// The date and time that the instance group manager was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled" validate:"required"`

	// The name for this instance group manager. The name is unique across all managers for the instance group.
	Name *string `json:"name" validate:"required"`

	// The date and time that the instance group manager was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window" validate:"required"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown" validate:"required"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type" validate:"required"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count" validate:"required"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count" validate:"required"`

	// The policies of the instance group manager.
	Policies []InstanceGroupManagerPolicyReference `json:"policies" validate:"required"`
}

// Constants associated with the InstanceGroupManagerAutoScale.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerAutoScaleManagerTypeAutoscaleConst = "autoscale"
)

func (*InstanceGroupManagerAutoScale) isaInstanceGroupManager() bool {
	return true
}

// UnmarshalInstanceGroupManagerAutoScale unmarshals an instance of InstanceGroupManagerAutoScale from the specified map of raw messages.
func UnmarshalInstanceGroupManagerAutoScale(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerAutoScale)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalInstanceGroupManagerPolicyReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype : InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype struct
// This model "extends" InstanceGroupManagerPolicyPrototype
type InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype struct {
	// The name for this instance group manager policy. The name must not be used by another policy for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type" validate:"required"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value" validate:"required"`

	// The type of policy for the instance group.
	PolicyType *string `json:"policy_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.PolicyType property.
// The type of policy for the instance group.
const (
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypePolicyTypeTargetConst = "target"
)

// NewInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype : Instantiate InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype(metricType string, metricValue int64, policyType string) (_model *InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype, err error) {
	_model = &InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype{
		MetricType:  core.StringPtr(metricType),
		MetricValue: core.Int64Ptr(metricValue),
		PolicyType:  core.StringPtr(policyType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype) isaInstanceGroupManagerPolicyPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype unmarshals an instance of InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy : InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy struct
// This model "extends" InstanceGroupManagerPolicy
type InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy struct {
	// The date and time that the instance group manager policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager policy.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager policy. The name is unique across all policies for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The date and time that the instance group manager policy was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type" validate:"required"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value" validate:"required"`

	// The type of policy for the instance group.
	PolicyType *string `json:"policy_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.PolicyType property.
// The type of policy for the instance group.
const (
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyPolicyTypeTargetConst = "target"
)

func (*InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy) isaInstanceGroupManagerPolicy() bool {
	return true
}

// UnmarshalInstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy unmarshals an instance of InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype : InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype struct
// This model "extends" InstanceGroupManagerPrototype
type InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype struct {
	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The name for this instance group manager. The name must not be used by another manager for the instance group. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type" validate:"required"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count" validate:"required"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

// Constants associated with the InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototypeManagerTypeAutoscaleConst = "autoscale"
)

// NewInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype : Instantiate InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype(managerType string, maxMembershipCount int64) (_model *InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype, err error) {
	_model = &InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype{
		ManagerType:        core.StringPtr(managerType),
		MaxMembershipCount: core.Int64Ptr(maxMembershipCount),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype) isaInstanceGroupManagerPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype unmarshals an instance of InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype)
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype : InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype struct
// This model "extends" InstanceGroupManagerPrototype
type InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype struct {
	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The name for this instance group manager. The name must not be used by another manager for the instance group. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototypeManagerTypeScheduledConst = "scheduled"
)

// NewInstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype : Instantiate InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype(managerType string) (_model *InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype, err error) {
	_model = &InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype{
		ManagerType: core.StringPtr(managerType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype) isaInstanceGroupManagerPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype unmarshals an instance of InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPrototypeInstanceGroupManagerScheduledPrototype)
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduled : InstanceGroupManagerScheduled struct
// This model "extends" InstanceGroupManager
type InstanceGroupManagerScheduled struct {
	// The date and time that the instance group manager was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled" validate:"required"`

	// The name for this instance group manager. The name is unique across all managers for the instance group.
	Name *string `json:"name" validate:"required"`

	// The date and time that the instance group manager was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The actions of the instance group manager.
	Actions []InstanceGroupManagerActionReference `json:"actions" validate:"required"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerScheduled.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerScheduledManagerTypeScheduledConst = "scheduled"
)

func (*InstanceGroupManagerScheduled) isaInstanceGroupManager() bool {
	return true
}

// UnmarshalInstanceGroupManagerScheduled unmarshals an instance of InstanceGroupManagerScheduled from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduled(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduled)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "actions", &obj.Actions, UnmarshalInstanceGroupManagerActionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionManagerAutoScale : InstanceGroupManagerScheduledActionManagerAutoScale struct
// This model "extends" InstanceGroupManagerScheduledActionManager
type InstanceGroupManagerScheduledActionManagerAutoScale struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceGroupManagerReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager. The name is unique across all managers for the instance group.
	Name *string `json:"name" validate:"required"`

	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

func (*InstanceGroupManagerScheduledActionManagerAutoScale) isaInstanceGroupManagerScheduledActionManager() bool {
	return true
}

// UnmarshalInstanceGroupManagerScheduledActionManagerAutoScale unmarshals an instance of InstanceGroupManagerScheduledActionManagerAutoScale from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionManagerAutoScale(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionManagerAutoScale)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceGroupManagerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype : The auto scale manager to update, and one or more properties to be updated. Either `id` or `href` must be specified,
// in addition to at least one of `min_membership_count` and
// `max_membership_count`.
// Models which "extend" this model:
// - InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID
// - InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref
// This model "extends" InstanceGroupManagerScheduledActionManagerPrototype
type InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype struct {
	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href,omitempty"`
}

func (*InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype) isaInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype() bool {
	return true
}

type InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeIntf interface {
	InstanceGroupManagerScheduledActionManagerPrototypeIntf
	isaInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype() bool
}

func (*InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype) isaInstanceGroupManagerScheduledActionManagerPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype unmarshals an instance of InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype)
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePatchProfileInstanceProfileIdentityByHref : InstancePatchProfileInstanceProfileIdentityByHref struct
// This model "extends" InstancePatchProfile
type InstancePatchProfileInstanceProfileIdentityByHref struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePatchProfileInstanceProfileIdentityByHref : Instantiate InstancePatchProfileInstanceProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePatchProfileInstanceProfileIdentityByHref(href string) (_model *InstancePatchProfileInstanceProfileIdentityByHref, err error) {
	_model = &InstancePatchProfileInstanceProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePatchProfileInstanceProfileIdentityByHref) isaInstancePatchProfile() bool {
	return true
}

// UnmarshalInstancePatchProfileInstanceProfileIdentityByHref unmarshals an instance of InstancePatchProfileInstanceProfileIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePatchProfileInstanceProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePatchProfileInstanceProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePatchProfileInstanceProfileIdentityByName : InstancePatchProfileInstanceProfileIdentityByName struct
// This model "extends" InstancePatchProfile
type InstancePatchProfileInstanceProfileIdentityByName struct {
	// The globally unique name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// NewInstancePatchProfileInstanceProfileIdentityByName : Instantiate InstancePatchProfileInstanceProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewInstancePatchProfileInstanceProfileIdentityByName(name string) (_model *InstancePatchProfileInstanceProfileIdentityByName, err error) {
	_model = &InstancePatchProfileInstanceProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePatchProfileInstanceProfileIdentityByName) isaInstancePatchProfile() bool {
	return true
}

// UnmarshalInstancePatchProfileInstanceProfileIdentityByName unmarshals an instance of InstancePatchProfileInstanceProfileIdentityByName from the specified map of raw messages.
func UnmarshalInstancePatchProfileInstanceProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePatchProfileInstanceProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostGroupIdentity : Identifies a dedicated host group by a unique property.
// Models which "extend" this model:
// - InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID
// - InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN
// - InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref
// This model "extends" InstancePlacementTargetPatch
type InstancePlacementTargetPatchDedicatedHostGroupIdentity struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentity) isaInstancePlacementTargetPatchDedicatedHostGroupIdentity() bool {
	return true
}

type InstancePlacementTargetPatchDedicatedHostGroupIdentityIntf interface {
	InstancePlacementTargetPatchIntf
	isaInstancePlacementTargetPatchDedicatedHostGroupIdentity() bool
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentity) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentity unmarshals an instance of InstancePlacementTargetPatchDedicatedHostGroupIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostIdentity : Identifies a dedicated host by a unique property.
// Models which "extend" this model:
// - InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID
// - InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN
// - InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref
// This model "extends" InstancePlacementTargetPatch
type InstancePlacementTargetPatchDedicatedHostIdentity struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPatchDedicatedHostIdentity) isaInstancePlacementTargetPatchDedicatedHostIdentity() bool {
	return true
}

type InstancePlacementTargetPatchDedicatedHostIdentityIntf interface {
	InstancePlacementTargetPatchIntf
	isaInstancePlacementTargetPatchDedicatedHostIdentity() bool
}

func (*InstancePlacementTargetPatchDedicatedHostIdentity) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostIdentity unmarshals an instance of InstancePlacementTargetPatchDedicatedHostIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostGroupIdentity : Identifies a dedicated host group by a unique property.
// Models which "extend" this model:
// - InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID
// - InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN
// - InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref
// This model "extends" InstancePlacementTargetPrototype
type InstancePlacementTargetPrototypeDedicatedHostGroupIdentity struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentity) isaInstancePlacementTargetPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

type InstancePlacementTargetPrototypeDedicatedHostGroupIdentityIntf interface {
	InstancePlacementTargetPrototypeIntf
	isaInstancePlacementTargetPrototypeDedicatedHostGroupIdentity() bool
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentity) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentity unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostGroupIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostIdentity : Identifies a dedicated host by a unique property.
// Models which "extend" this model:
// - InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID
// - InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN
// - InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref
// This model "extends" InstancePlacementTargetPrototype
type InstancePlacementTargetPrototypeDedicatedHostIdentity struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentity) isaInstancePlacementTargetPrototypeDedicatedHostIdentity() bool {
	return true
}

type InstancePlacementTargetPrototypeDedicatedHostIdentityIntf interface {
	InstancePlacementTargetPrototypeIntf
	isaInstancePlacementTargetPrototypeDedicatedHostIdentity() bool
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentity) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentity unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypePlacementGroupIdentity : Identifies a placement group by a unique property.
// Models which "extend" this model:
// - InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID
// - InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN
// - InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref
// This model "extends" InstancePlacementTargetPrototype
type InstancePlacementTargetPrototypePlacementGroupIdentity struct {
	// The unique identifier for this placement group.
	ID *string `json:"id,omitempty"`

	// The CRN for this placement group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this placement group.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentity) isaInstancePlacementTargetPrototypePlacementGroupIdentity() bool {
	return true
}

type InstancePlacementTargetPrototypePlacementGroupIdentityIntf interface {
	InstancePlacementTargetPrototypeIntf
	isaInstancePlacementTargetPrototypePlacementGroupIdentity() bool
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentity) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentity unmarshals an instance of InstancePlacementTargetPrototypePlacementGroupIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypePlacementGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetDedicatedHostGroupReference : InstancePlacementTargetDedicatedHostGroupReference struct
// This model "extends" InstancePlacementTarget
type InstancePlacementTargetDedicatedHostGroupReference struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *DedicatedHostGroupReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`

	// The name for this dedicated host group. The name is unique across all dedicated host groups in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstancePlacementTargetDedicatedHostGroupReference.ResourceType property.
// The resource type.
const (
	InstancePlacementTargetDedicatedHostGroupReferenceResourceTypeDedicatedHostGroupConst = "dedicated_host_group"
)

func (*InstancePlacementTargetDedicatedHostGroupReference) isaInstancePlacementTarget() bool {
	return true
}

// UnmarshalInstancePlacementTargetDedicatedHostGroupReference unmarshals an instance of InstancePlacementTargetDedicatedHostGroupReference from the specified map of raw messages.
func UnmarshalInstancePlacementTargetDedicatedHostGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetDedicatedHostGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalDedicatedHostGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetDedicatedHostReference : InstancePlacementTargetDedicatedHostReference struct
// This model "extends" InstancePlacementTarget
type InstancePlacementTargetDedicatedHostReference struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *DedicatedHostReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`

	// The name for this dedicated host. The name is unique across all dedicated hosts in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstancePlacementTargetDedicatedHostReference.ResourceType property.
// The resource type.
const (
	InstancePlacementTargetDedicatedHostReferenceResourceTypeDedicatedHostConst = "dedicated_host"
)

func (*InstancePlacementTargetDedicatedHostReference) isaInstancePlacementTarget() bool {
	return true
}

// UnmarshalInstancePlacementTargetDedicatedHostReference unmarshals an instance of InstancePlacementTargetDedicatedHostReference from the specified map of raw messages.
func UnmarshalInstancePlacementTargetDedicatedHostReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetDedicatedHostReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalDedicatedHostReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPlacementGroupReference : InstancePlacementTargetPlacementGroupReference struct
// This model "extends" InstancePlacementTarget
type InstancePlacementTargetPlacementGroupReference struct {
	// The CRN for this placement group.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *PlacementGroupReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this placement group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this placement group.
	ID *string `json:"id" validate:"required"`

	// The name for this placement group. The name is unique across all placement groups in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstancePlacementTargetPlacementGroupReference.ResourceType property.
// The resource type.
const (
	InstancePlacementTargetPlacementGroupReferenceResourceTypePlacementGroupConst = "placement_group"
)

func (*InstancePlacementTargetPlacementGroupReference) isaInstancePlacementTarget() bool {
	return true
}

// UnmarshalInstancePlacementTargetPlacementGroupReference unmarshals an instance of InstancePlacementTargetPlacementGroupReference from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPlacementGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPlacementGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalPlacementGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthDependent : The total bandwidth shared across the network interfaces and storage volumes of an instance with this profile depends
// on its configuration.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileBandwidthDependent) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthDependent unmarshals an instance of InstanceProfileBandwidthDependent from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthEnum : The permitted total bandwidth values (in megabits per second) shared across the network interfaces and storage
// volumes of an instance with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthEnumTypeEnumConst = "enum"
)

func (*InstanceProfileBandwidthEnum) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthEnum unmarshals an instance of InstanceProfileBandwidthEnum from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthFixed : The total bandwidth (in megabits per second) shared across the network interfaces and storage volumes of an instance
// with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileBandwidthFixed) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthFixed unmarshals an instance of InstanceProfileBandwidthFixed from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthRange : The permitted total bandwidth range (in megabits per second) shared across the network interfaces and storage volumes
// of an instance with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthRange.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthRangeTypeRangeConst = "range"
)

func (*InstanceProfileBandwidthRange) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthRange unmarshals an instance of InstanceProfileBandwidthRange from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskQuantityDependent : The number of disks of this configuration for an instance with this profile depends on its instance configuration.
// This model "extends" InstanceProfileDiskQuantity
type InstanceProfileDiskQuantityDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileDiskQuantityDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskQuantityDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileDiskQuantityDependent) isaInstanceProfileDiskQuantity() bool {
	return true
}

// UnmarshalInstanceProfileDiskQuantityDependent unmarshals an instance of InstanceProfileDiskQuantityDependent from the specified map of raw messages.
func UnmarshalInstanceProfileDiskQuantityDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskQuantityDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskQuantityEnum : The permitted the number of disks of this configuration for an instance with this profile.
// This model "extends" InstanceProfileDiskQuantity
type InstanceProfileDiskQuantityEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileDiskQuantityEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskQuantityEnumTypeEnumConst = "enum"
)

func (*InstanceProfileDiskQuantityEnum) isaInstanceProfileDiskQuantity() bool {
	return true
}

// UnmarshalInstanceProfileDiskQuantityEnum unmarshals an instance of InstanceProfileDiskQuantityEnum from the specified map of raw messages.
func UnmarshalInstanceProfileDiskQuantityEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskQuantityEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskQuantityFixed : The number of disks of this configuration for an instance with this profile.
// This model "extends" InstanceProfileDiskQuantity
type InstanceProfileDiskQuantityFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileDiskQuantityFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskQuantityFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileDiskQuantityFixed) isaInstanceProfileDiskQuantity() bool {
	return true
}

// UnmarshalInstanceProfileDiskQuantityFixed unmarshals an instance of InstanceProfileDiskQuantityFixed from the specified map of raw messages.
func UnmarshalInstanceProfileDiskQuantityFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskQuantityFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskQuantityRange : The permitted range for the number of disks of this configuration for an instance with this profile.
// This model "extends" InstanceProfileDiskQuantity
type InstanceProfileDiskQuantityRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileDiskQuantityRange.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskQuantityRangeTypeRangeConst = "range"
)

func (*InstanceProfileDiskQuantityRange) isaInstanceProfileDiskQuantity() bool {
	return true
}

// UnmarshalInstanceProfileDiskQuantityRange unmarshals an instance of InstanceProfileDiskQuantityRange from the specified map of raw messages.
func UnmarshalInstanceProfileDiskQuantityRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskQuantityRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskSizeDependent : The disk size in GB (gigabytes) of this configuration for an instance with this profile depends on its instance
// configuration.
// This model "extends" InstanceProfileDiskSize
type InstanceProfileDiskSizeDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileDiskSizeDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskSizeDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileDiskSizeDependent) isaInstanceProfileDiskSize() bool {
	return true
}

// UnmarshalInstanceProfileDiskSizeDependent unmarshals an instance of InstanceProfileDiskSizeDependent from the specified map of raw messages.
func UnmarshalInstanceProfileDiskSizeDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskSizeDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskSizeEnum : The permitted disk size in GB (gigabytes) of this configuration for an instance with this profile.
// This model "extends" InstanceProfileDiskSize
type InstanceProfileDiskSizeEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileDiskSizeEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskSizeEnumTypeEnumConst = "enum"
)

func (*InstanceProfileDiskSizeEnum) isaInstanceProfileDiskSize() bool {
	return true
}

// UnmarshalInstanceProfileDiskSizeEnum unmarshals an instance of InstanceProfileDiskSizeEnum from the specified map of raw messages.
func UnmarshalInstanceProfileDiskSizeEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskSizeEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskSizeFixed : The size of the disk in GB (gigabytes).
// This model "extends" InstanceProfileDiskSize
type InstanceProfileDiskSizeFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileDiskSizeFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskSizeFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileDiskSizeFixed) isaInstanceProfileDiskSize() bool {
	return true
}

// UnmarshalInstanceProfileDiskSizeFixed unmarshals an instance of InstanceProfileDiskSizeFixed from the specified map of raw messages.
func UnmarshalInstanceProfileDiskSizeFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskSizeFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileDiskSizeRange : The permitted range for the disk size of this configuration in GB (gigabytes) for an instance with this profile.
// This model "extends" InstanceProfileDiskSize
type InstanceProfileDiskSizeRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileDiskSizeRange.Type property.
// The type for this profile field.
const (
	InstanceProfileDiskSizeRangeTypeRangeConst = "range"
)

func (*InstanceProfileDiskSizeRange) isaInstanceProfileDiskSize() bool {
	return true
}

// UnmarshalInstanceProfileDiskSizeRange unmarshals an instance of InstanceProfileDiskSizeRange from the specified map of raw messages.
func UnmarshalInstanceProfileDiskSizeRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileDiskSizeRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuDependent : The GPU count for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileGpuDependent) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuDependent unmarshals an instance of InstanceProfileGpuDependent from the specified map of raw messages.
func UnmarshalInstanceProfileGpuDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuEnum : The permitted GPU count values for an instance with this profile.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuEnumTypeEnumConst = "enum"
)

func (*InstanceProfileGpuEnum) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuEnum unmarshals an instance of InstanceProfileGpuEnum from the specified map of raw messages.
func UnmarshalInstanceProfileGpuEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuFixed : The GPU count for an instance with this profile.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileGpuFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileGpuFixed) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuFixed unmarshals an instance of InstanceProfileGpuFixed from the specified map of raw messages.
func UnmarshalInstanceProfileGpuFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryDependent : The overall GPU memory value for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileGpuMemoryDependent) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryDependent unmarshals an instance of InstanceProfileGpuMemoryDependent from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryEnum : The permitted overall GPU memory values in GiB (gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryEnumTypeEnumConst = "enum"
)

func (*InstanceProfileGpuMemoryEnum) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryEnum unmarshals an instance of InstanceProfileGpuMemoryEnum from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryFixed : The overall GPU memory in GiB (gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileGpuMemoryFixed) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryFixed unmarshals an instance of InstanceProfileGpuMemoryFixed from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryRange : The permitted overall GPU memory range in GiB (gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryRange.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryRangeTypeRangeConst = "range"
)

func (*InstanceProfileGpuMemoryRange) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryRange unmarshals an instance of InstanceProfileGpuMemoryRange from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuRange : The permitted GPU count range for an instance with this profile.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuRange.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuRangeTypeRangeConst = "range"
)

func (*InstanceProfileGpuRange) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuRange unmarshals an instance of InstanceProfileGpuRange from the specified map of raw messages.
func UnmarshalInstanceProfileGpuRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileIdentityByHref : InstanceProfileIdentityByHref struct
// This model "extends" InstanceProfileIdentity
type InstanceProfileIdentityByHref struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`
}

// NewInstanceProfileIdentityByHref : Instantiate InstanceProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstanceProfileIdentityByHref(href string) (_model *InstanceProfileIdentityByHref, err error) {
	_model = &InstanceProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceProfileIdentityByHref) isaInstanceProfileIdentity() bool {
	return true
}

// UnmarshalInstanceProfileIdentityByHref unmarshals an instance of InstanceProfileIdentityByHref from the specified map of raw messages.
func UnmarshalInstanceProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileIdentityByName : InstanceProfileIdentityByName struct
// This model "extends" InstanceProfileIdentity
type InstanceProfileIdentityByName struct {
	// The globally unique name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// NewInstanceProfileIdentityByName : Instantiate InstanceProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewInstanceProfileIdentityByName(name string) (_model *InstanceProfileIdentityByName, err error) {
	_model = &InstanceProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceProfileIdentityByName) isaInstanceProfileIdentity() bool {
	return true
}

// UnmarshalInstanceProfileIdentityByName unmarshals an instance of InstanceProfileIdentityByName from the specified map of raw messages.
func UnmarshalInstanceProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryDependent : The memory value for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileMemoryDependent) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryDependent unmarshals an instance of InstanceProfileMemoryDependent from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryEnum : The permitted memory values (in gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryEnumTypeEnumConst = "enum"
)

func (*InstanceProfileMemoryEnum) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryEnum unmarshals an instance of InstanceProfileMemoryEnum from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryFixed : The memory (in gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileMemoryFixed) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryFixed unmarshals an instance of InstanceProfileMemoryFixed from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryRange : The permitted memory range (in gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryRange.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryRangeTypeRangeConst = "range"
)

func (*InstanceProfileMemoryRange) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryRange unmarshals an instance of InstanceProfileMemoryRange from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileNumaCountDependent : The total number of NUMA nodes for an instance with this profile depends on its configuration and the capacity
// constraints within the zone.
// This model "extends" InstanceProfileNumaCount
type InstanceProfileNumaCountDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileNumaCountDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileNumaCountDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileNumaCountDependent) isaInstanceProfileNumaCount() bool {
	return true
}

// UnmarshalInstanceProfileNumaCountDependent unmarshals an instance of InstanceProfileNumaCountDependent from the specified map of raw messages.
func UnmarshalInstanceProfileNumaCountDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileNumaCountDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileNumaCountFixed : The total number of NUMA nodes for an instance with this profile.
// This model "extends" InstanceProfileNumaCount
type InstanceProfileNumaCountFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileNumaCountFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileNumaCountFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileNumaCountFixed) isaInstanceProfileNumaCount() bool {
	return true
}

// UnmarshalInstanceProfileNumaCountFixed unmarshals an instance of InstanceProfileNumaCountFixed from the specified map of raw messages.
func UnmarshalInstanceProfileNumaCountFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileNumaCountFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileNetworkInterfaceCountDependent : The number of network interfaces supported on an instance with this profile is dependent on its configuration.
// This model "extends" InstanceProfileNetworkInterfaceCount
type InstanceProfileNetworkInterfaceCountDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileNetworkInterfaceCountDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileNetworkInterfaceCountDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileNetworkInterfaceCountDependent) isaInstanceProfileNetworkInterfaceCount() bool {
	return true
}

// UnmarshalInstanceProfileNetworkInterfaceCountDependent unmarshals an instance of InstanceProfileNetworkInterfaceCountDependent from the specified map of raw messages.
func UnmarshalInstanceProfileNetworkInterfaceCountDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileNetworkInterfaceCountDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileNetworkInterfaceCountRange : The number of network interfaces supported on an instance with this profile.
// This model "extends" InstanceProfileNetworkInterfaceCount
type InstanceProfileNetworkInterfaceCountRange struct {
	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileNetworkInterfaceCountRange.Type property.
// The type for this profile field.
const (
	InstanceProfileNetworkInterfaceCountRangeTypeRangeConst = "range"
)

func (*InstanceProfileNetworkInterfaceCountRange) isaInstanceProfileNetworkInterfaceCount() bool {
	return true
}

// UnmarshalInstanceProfileNetworkInterfaceCountRange unmarshals an instance of InstanceProfileNetworkInterfaceCountRange from the specified map of raw messages.
func UnmarshalInstanceProfileNetworkInterfaceCountRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileNetworkInterfaceCountRange)
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfilePortSpeedDependent : The port speed of each network interface of an instance with this profile depends on its configuration.
// This model "extends" InstanceProfilePortSpeed
type InstanceProfilePortSpeedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfilePortSpeedDependent.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedDependentTypeDependentConst = "dependent"
)

func (*InstanceProfilePortSpeedDependent) isaInstanceProfilePortSpeed() bool {
	return true
}

// UnmarshalInstanceProfilePortSpeedDependent unmarshals an instance of InstanceProfilePortSpeedDependent from the specified map of raw messages.
func UnmarshalInstanceProfilePortSpeedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfilePortSpeedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfilePortSpeedFixed : The maximum speed (in megabits per second) of each network interface of an instance with this profile.
// This model "extends" InstanceProfilePortSpeed
type InstanceProfilePortSpeedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfilePortSpeedFixed.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedFixedTypeFixedConst = "fixed"
)

func (*InstanceProfilePortSpeedFixed) isaInstanceProfilePortSpeed() bool {
	return true
}

// UnmarshalInstanceProfilePortSpeedFixed unmarshals an instance of InstanceProfilePortSpeedFixed from the specified map of raw messages.
func UnmarshalInstanceProfilePortSpeedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfilePortSpeedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuDependent : The VCPU count for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileVcpuDependent) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuDependent unmarshals an instance of InstanceProfileVcpuDependent from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuEnum : The permitted values for VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuEnumTypeEnumConst = "enum"
)

func (*InstanceProfileVcpuEnum) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuEnum unmarshals an instance of InstanceProfileVcpuEnum from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuFixed : The VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileVcpuFixed) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuFixed unmarshals an instance of InstanceProfileVcpuFixed from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuRange : The permitted range for VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuRange.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuRangeTypeRangeConst = "range"
)

func (*InstanceProfileVcpuRange) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuRange unmarshals an instance of InstanceProfileVcpuRange from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVolumeBandwidthDependent : The storage bandwidth shared across the storage volumes of an instance with this profile depends on its
// configuration.
// This model "extends" InstanceProfileVolumeBandwidth
type InstanceProfileVolumeBandwidthDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVolumeBandwidthDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileVolumeBandwidthDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileVolumeBandwidthDependent) isaInstanceProfileVolumeBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileVolumeBandwidthDependent unmarshals an instance of InstanceProfileVolumeBandwidthDependent from the specified map of raw messages.
func UnmarshalInstanceProfileVolumeBandwidthDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVolumeBandwidthDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVolumeBandwidthEnum : The permitted storage bandwidth values (in megabits per second) shared across the storage volumes of an instance with
// this profile.
// This model "extends" InstanceProfileVolumeBandwidth
type InstanceProfileVolumeBandwidthEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileVolumeBandwidthEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileVolumeBandwidthEnumTypeEnumConst = "enum"
)

func (*InstanceProfileVolumeBandwidthEnum) isaInstanceProfileVolumeBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileVolumeBandwidthEnum unmarshals an instance of InstanceProfileVolumeBandwidthEnum from the specified map of raw messages.
func UnmarshalInstanceProfileVolumeBandwidthEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVolumeBandwidthEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVolumeBandwidthFixed : The storage bandwidth (in megabits per second) shared across the storage volumes of an instance with this profile.
// This model "extends" InstanceProfileVolumeBandwidth
type InstanceProfileVolumeBandwidthFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVolumeBandwidthFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileVolumeBandwidthFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileVolumeBandwidthFixed) isaInstanceProfileVolumeBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileVolumeBandwidthFixed unmarshals an instance of InstanceProfileVolumeBandwidthFixed from the specified map of raw messages.
func UnmarshalInstanceProfileVolumeBandwidthFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVolumeBandwidthFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVolumeBandwidthRange : The permitted storage bandwidth range (in megabits per second) shared across the storage volumes of an instance with
// this profile.
// This model "extends" InstanceProfileVolumeBandwidth
type InstanceProfileVolumeBandwidthRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVolumeBandwidthRange.Type property.
// The type for this profile field.
const (
	InstanceProfileVolumeBandwidthRangeTypeRangeConst = "range"
)

func (*InstanceProfileVolumeBandwidthRange) isaInstanceProfileVolumeBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileVolumeBandwidthRange unmarshals an instance of InstanceProfileVolumeBandwidthRange from the specified map of raw messages.
func UnmarshalInstanceProfileVolumeBandwidthRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVolumeBandwidthRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceByCatalogOffering : Create an instance by using a catalog offering.
// This model "extends" InstancePrototype
type InstancePrototypeInstanceByCatalogOffering struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. If unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
	// or offering version to use when provisioning this virtual server instance.
	//
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account in the same
	// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
	// to IAM policies.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstancePrototypeInstanceByCatalogOffering : Instantiate InstancePrototypeInstanceByCatalogOffering (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceByCatalogOffering(catalogOffering InstanceCatalogOfferingPrototypeIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstancePrototypeInstanceByCatalogOffering, err error) {
	_model = &InstancePrototypeInstanceByCatalogOffering{
		CatalogOffering:         catalogOffering,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePrototypeInstanceByCatalogOffering) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceByCatalogOffering unmarshals an instance of InstancePrototypeInstanceByCatalogOffering from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceByCatalogOffering(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceByCatalogOffering)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceByImage : Create an instance by using an image.
// This model "extends" InstancePrototype
type InstancePrototypeInstanceByImage struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. If unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstancePrototypeInstanceByImage : Instantiate InstancePrototypeInstanceByImage (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceByImage(image ImageIdentityIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstancePrototypeInstanceByImage, err error) {
	_model = &InstancePrototypeInstanceByImage{
		Image:                   image,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePrototypeInstanceByImage) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceByImage unmarshals an instance of InstancePrototypeInstanceByImage from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceByImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceByImage)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceBySourceSnapshot : Create an instance by using a snapshot.
// This model "extends" InstancePrototype
type InstancePrototypeInstanceBySourceSnapshot struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. If unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceBySourceSnapshotContext `json:"boot_volume_attachment" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstancePrototypeInstanceBySourceSnapshot : Instantiate InstancePrototypeInstanceBySourceSnapshot (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceBySourceSnapshot(bootVolumeAttachment *VolumeAttachmentPrototypeInstanceBySourceSnapshotContext, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstancePrototypeInstanceBySourceSnapshot, err error) {
	_model = &InstancePrototypeInstanceBySourceSnapshot{
		BootVolumeAttachment:    bootVolumeAttachment,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePrototypeInstanceBySourceSnapshot) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceBySourceSnapshot unmarshals an instance of InstancePrototypeInstanceBySourceSnapshot from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceBySourceSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceBySourceSnapshot)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceBySourceSnapshotContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceBySourceTemplate : Create an instance by using an instance template.
//
// The `primary_network_interface` and `network_interfaces` properties may only be specified if
// `primary_network_interface` is specified in the source template.
// This model "extends" InstancePrototype
type InstancePrototypeInstanceBySourceTemplate struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. If unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
	// offering version to use when provisioning this virtual server instance.
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account, subject to
	// IAM policies.
	//
	// If specified, `image` must not be specified, and `source_template` must not have
	// `image` specified.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The template to create this virtual server instance from.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// NewInstancePrototypeInstanceBySourceTemplate : Instantiate InstancePrototypeInstanceBySourceTemplate (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceBySourceTemplate(sourceTemplate InstanceTemplateIdentityIntf) (_model *InstancePrototypeInstanceBySourceTemplate, err error) {
	_model = &InstancePrototypeInstanceBySourceTemplate{
		SourceTemplate: sourceTemplate,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePrototypeInstanceBySourceTemplate) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceBySourceTemplate unmarshals an instance of InstancePrototypeInstanceBySourceTemplate from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceBySourceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceBySourceTemplate)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceByVolume : Create an instance by using a boot volume.
// This model "extends" InstancePrototype
type InstancePrototypeInstanceByVolume struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this virtual server instance. The name must not be used by another virtual server instance in the
	// region. If unspecified, the name will be a hyphenated list of randomly-selected words.
	//
	// The system hostname will be based on this name.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByVolumeContext `json:"boot_volume_attachment" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstancePrototypeInstanceByVolume : Instantiate InstancePrototypeInstanceByVolume (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceByVolume(bootVolumeAttachment *VolumeAttachmentPrototypeInstanceByVolumeContext, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstancePrototypeInstanceByVolume, err error) {
	_model = &InstancePrototypeInstanceByVolume{
		BootVolumeAttachment:    bootVolumeAttachment,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePrototypeInstanceByVolume) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceByVolume unmarshals an instance of InstancePrototypeInstanceByVolume from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceByVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceByVolume)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByVolumeContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentityByCRN : InstanceTemplateIdentityByCRN struct
// This model "extends" InstanceTemplateIdentity
type InstanceTemplateIdentityByCRN struct {
	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstanceTemplateIdentityByCRN : Instantiate InstanceTemplateIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplateIdentityByCRN(crn string) (_model *InstanceTemplateIdentityByCRN, err error) {
	_model = &InstanceTemplateIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplateIdentityByCRN) isaInstanceTemplateIdentity() bool {
	return true
}

// UnmarshalInstanceTemplateIdentityByCRN unmarshals an instance of InstanceTemplateIdentityByCRN from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentityByHref : InstanceTemplateIdentityByHref struct
// This model "extends" InstanceTemplateIdentity
type InstanceTemplateIdentityByHref struct {
	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`
}

// NewInstanceTemplateIdentityByHref : Instantiate InstanceTemplateIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplateIdentityByHref(href string) (_model *InstanceTemplateIdentityByHref, err error) {
	_model = &InstanceTemplateIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplateIdentityByHref) isaInstanceTemplateIdentity() bool {
	return true
}

// UnmarshalInstanceTemplateIdentityByHref unmarshals an instance of InstanceTemplateIdentityByHref from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentityByID : InstanceTemplateIdentityByID struct
// This model "extends" InstanceTemplateIdentity
type InstanceTemplateIdentityByID struct {
	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`
}

// NewInstanceTemplateIdentityByID : Instantiate InstanceTemplateIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplateIdentityByID(id string) (_model *InstanceTemplateIdentityByID, err error) {
	_model = &InstanceTemplateIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplateIdentityByID) isaInstanceTemplateIdentity() bool {
	return true
}

// UnmarshalInstanceTemplateIdentityByID unmarshals an instance of InstanceTemplateIdentityByID from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototypeInstanceTemplateByCatalogOffering : Create an instance template that creates instances by using a catalog offering.
// This model "extends" InstanceTemplatePrototype
type InstanceTemplatePrototypeInstanceTemplateByCatalogOffering struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name must not be used by another instance template in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
	// or offering version to use when provisioning this virtual server instance.
	//
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account in the same
	// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
	// to IAM policies.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstanceTemplatePrototypeInstanceTemplateByCatalogOffering : Instantiate InstanceTemplatePrototypeInstanceTemplateByCatalogOffering (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplatePrototypeInstanceTemplateByCatalogOffering(catalogOffering InstanceCatalogOfferingPrototypeIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstanceTemplatePrototypeInstanceTemplateByCatalogOffering, err error) {
	_model = &InstanceTemplatePrototypeInstanceTemplateByCatalogOffering{
		CatalogOffering:         catalogOffering,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplatePrototypeInstanceTemplateByCatalogOffering) isaInstanceTemplatePrototype() bool {
	return true
}

// UnmarshalInstanceTemplatePrototypeInstanceTemplateByCatalogOffering unmarshals an instance of InstanceTemplatePrototypeInstanceTemplateByCatalogOffering from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototypeInstanceTemplateByCatalogOffering(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototypeInstanceTemplateByCatalogOffering)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototypeInstanceTemplateByImage : Create an instance template that creates instances by using an image.
// This model "extends" InstanceTemplatePrototype
type InstanceTemplatePrototypeInstanceTemplateByImage struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name must not be used by another instance template in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstanceTemplatePrototypeInstanceTemplateByImage : Instantiate InstanceTemplatePrototypeInstanceTemplateByImage (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplatePrototypeInstanceTemplateByImage(image ImageIdentityIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstanceTemplatePrototypeInstanceTemplateByImage, err error) {
	_model = &InstanceTemplatePrototypeInstanceTemplateByImage{
		Image:                   image,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplatePrototypeInstanceTemplateByImage) isaInstanceTemplatePrototype() bool {
	return true
}

// UnmarshalInstanceTemplatePrototypeInstanceTemplateByImage unmarshals an instance of InstanceTemplatePrototypeInstanceTemplateByImage from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototypeInstanceTemplateByImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototypeInstanceTemplateByImage)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot : Create an instance template that creates instances by using a snapshot.
// This model "extends" InstanceTemplatePrototype
type InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name must not be used by another instance template in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceBySourceSnapshotContext `json:"boot_volume_attachment" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstanceTemplatePrototypeInstanceTemplateBySourceSnapshot : Instantiate InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplatePrototypeInstanceTemplateBySourceSnapshot(bootVolumeAttachment *VolumeAttachmentPrototypeInstanceBySourceSnapshotContext, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (_model *InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot, err error) {
	_model = &InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot{
		BootVolumeAttachment:    bootVolumeAttachment,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot) isaInstanceTemplatePrototype() bool {
	return true
}

// UnmarshalInstanceTemplatePrototypeInstanceTemplateBySourceSnapshot unmarshals an instance of InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototypeInstanceTemplateBySourceSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototypeInstanceTemplateBySourceSnapshot)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceBySourceSnapshotContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototypeInstanceTemplateBySourceTemplate : Create an instance template from an existing instance template.
// This model "extends" InstanceTemplatePrototype
type InstanceTemplatePrototypeInstanceTemplateBySourceTemplate struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name must not be used by another instance template in the region. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user)
	// offering version to use when provisioning this virtual server instance.
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account, subject to
	// IAM policies.
	//
	// If specified, `image` must not be specified, and `source_template` must not have
	// `image` specified.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The template to create this virtual server instance from.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template" validate:"required"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// NewInstanceTemplatePrototypeInstanceTemplateBySourceTemplate : Instantiate InstanceTemplatePrototypeInstanceTemplateBySourceTemplate (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplatePrototypeInstanceTemplateBySourceTemplate(sourceTemplate InstanceTemplateIdentityIntf) (_model *InstanceTemplatePrototypeInstanceTemplateBySourceTemplate, err error) {
	_model = &InstanceTemplatePrototypeInstanceTemplateBySourceTemplate{
		SourceTemplate: sourceTemplate,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceTemplatePrototypeInstanceTemplateBySourceTemplate) isaInstanceTemplatePrototype() bool {
	return true
}

// UnmarshalInstanceTemplatePrototypeInstanceTemplateBySourceTemplate unmarshals an instance of InstanceTemplatePrototypeInstanceTemplateBySourceTemplate from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototypeInstanceTemplateBySourceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototypeInstanceTemplateBySourceTemplate)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext : Create an instance by using a catalog offering.
// This model "extends" InstanceTemplate
type InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name is unique across all instance templates in the region.
	Name *string `json:"name" validate:"required"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group for this instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The [catalog](https://cloud.ibm.com/docs/account?topic=account-restrict-by-user) offering
	// or offering version to use when provisioning this virtual server instance.
	//
	// If an offering is specified, the latest version of that offering will be used.
	//
	// The specified offering or offering version may be in a different account in the same
	// [enterprise](https://cloud.ibm.com/docs/account?topic=account-what-is-enterprise), subject
	// to IAM policies.
	CatalogOffering InstanceCatalogOfferingPrototypeIntf `json:"catalog_offering" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

func (*InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext) isaInstanceTemplate() bool {
	return true
}

// UnmarshalInstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext unmarshals an instance of InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext from the specified map of raw messages.
func UnmarshalInstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateInstanceByCatalogOfferingInstanceTemplateContext)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "catalog_offering", &obj.CatalogOffering, UnmarshalInstanceCatalogOfferingPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateInstanceByImageInstanceTemplateContext : Create an instance by using an image.
// This model "extends" InstanceTemplate
type InstanceTemplateInstanceByImageInstanceTemplateContext struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name is unique across all instance templates in the region.
	Name *string `json:"name" validate:"required"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group for this instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The image to use when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

func (*InstanceTemplateInstanceByImageInstanceTemplateContext) isaInstanceTemplate() bool {
	return true
}

// UnmarshalInstanceTemplateInstanceByImageInstanceTemplateContext unmarshals an instance of InstanceTemplateInstanceByImageInstanceTemplateContext from the specified map of raw messages.
func UnmarshalInstanceTemplateInstanceByImageInstanceTemplateContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateInstanceByImageInstanceTemplateContext)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext : Create an instance by using a snapshot.
// This model "extends" InstanceTemplate
type InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext struct {
	// The availability policy to use for this virtual server instance.
	AvailabilityPolicy *InstanceAvailabilityPolicyPrototype `json:"availability_policy,omitempty"`

	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The default trusted profile configuration to use for this virtual server instance
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	DefaultTrustedProfile *InstanceDefaultTrustedProfilePrototype `json:"default_trusted_profile,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys for the administrative user of the virtual server instance. Keys will be made available to the
	// virtual server instance as cloud-init vendor data. For cloud-init enabled images, these keys will also be added as
	// SSH authorized keys for the administrative user.
	//
	// For Windows images, the keys of type `rsa` must be specified, and one will be selected to encrypt [the administrator
	// password](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization). Keys are optional for other images, but if
	// no keys are specified, the instance will be inaccessible unless the specified image provides another means of
	// access.
	//
	// This property's value is used when provisioning the virtual server instance, but not subsequently managed.
	// Accordingly, it is reflected as an [instance
	// initialization](https://cloud.ibm.com/apidocs/vpc#get-instance-initialization) property.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	MetadataService *InstanceMetadataServicePrototype `json:"metadata_service,omitempty"`

	// The name for this instance template. The name is unique across all instance templates in the region.
	Name *string `json:"name" validate:"required"`

	// The placement restrictions to use for the virtual server instance.
	PlacementTarget InstancePlacementTargetPrototypeIntf `json:"placement_target,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-profiles) to use for this virtual server instance.
	//
	// If unspecified, `bx2-2x8` will be used, but this default value is expected to change in the future.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group for this instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The amount of bandwidth (in megabits per second) allocated exclusively to instance storage volumes. An increase in
	// this value will result in a corresponding decrease to
	// `total_network_bandwidth`.
	TotalVolumeBandwidth *int64 `json:"total_volume_bandwidth,omitempty"`

	// [User data](https://cloud.ibm.com/docs/vpc?topic=vpc-user-data) to make available when setting up the virtual server
	// instance.
	UserData *string `json:"user_data,omitempty"`

	// The additional volume attachments to create for the virtual server instance.
	VolumeAttachments []VolumeAttachmentPrototype `json:"volume_attachments,omitempty"`

	// The VPC this virtual server instance will reside in.
	//
	// If specified, it must match the VPC for the subnets of the instance network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment to create for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceBySourceSnapshotContext `json:"boot_volume_attachment" validate:"required"`

	// The additional instance network interfaces to create.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The primary instance network interface to create.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The zone this virtual server instance will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

func (*InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext) isaInstanceTemplate() bool {
	return true
}

// UnmarshalInstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext unmarshals an instance of InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext from the specified map of raw messages.
func UnmarshalInstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateInstanceBySourceSnapshotInstanceTemplateContext)
	err = core.UnmarshalModel(m, "availability_policy", &obj.AvailabilityPolicy, UnmarshalInstanceAvailabilityPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_trusted_profile", &obj.DefaultTrustedProfile, UnmarshalInstanceDefaultTrustedProfilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata_service", &obj.MetadataService, UnmarshalInstanceMetadataServicePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_volume_bandwidth", &obj.TotalVolumeBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceBySourceSnapshotContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByCRN : KeyIdentityByCRN struct
// This model "extends" KeyIdentity
type KeyIdentityByCRN struct {
	// The CRN for this key.
	CRN *string `json:"crn" validate:"required"`
}

// NewKeyIdentityByCRN : Instantiate KeyIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByCRN(crn string) (_model *KeyIdentityByCRN, err error) {
	_model = &KeyIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*KeyIdentityByCRN) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByCRN unmarshals an instance of KeyIdentityByCRN from the specified map of raw messages.
func UnmarshalKeyIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByFingerprint : KeyIdentityByFingerprint struct
// This model "extends" KeyIdentity
type KeyIdentityByFingerprint struct {
	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`
}

// NewKeyIdentityByFingerprint : Instantiate KeyIdentityByFingerprint (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByFingerprint(fingerprint string) (_model *KeyIdentityByFingerprint, err error) {
	_model = &KeyIdentityByFingerprint{
		Fingerprint: core.StringPtr(fingerprint),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*KeyIdentityByFingerprint) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByFingerprint unmarshals an instance of KeyIdentityByFingerprint from the specified map of raw messages.
func UnmarshalKeyIdentityByFingerprint(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByFingerprint)
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByHref : KeyIdentityByHref struct
// This model "extends" KeyIdentity
type KeyIdentityByHref struct {
	// The URL for this key.
	Href *string `json:"href" validate:"required"`
}

// NewKeyIdentityByHref : Instantiate KeyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByHref(href string) (_model *KeyIdentityByHref, err error) {
	_model = &KeyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*KeyIdentityByHref) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByHref unmarshals an instance of KeyIdentityByHref from the specified map of raw messages.
func UnmarshalKeyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByID : KeyIdentityByID struct
// This model "extends" KeyIdentity
type KeyIdentityByID struct {
	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`
}

// NewKeyIdentityByID : Instantiate KeyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByID(id string) (_model *KeyIdentityByID, err error) {
	_model = &KeyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*KeyIdentityByID) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByID unmarshals an instance of KeyIdentityByID from the specified map of raw messages.
func UnmarshalKeyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName : LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName struct
// This model "extends" LegacyCloudObjectStorageBucketIdentity
type LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName struct {
	// The globally unique name of this Cloud Object Storage bucket.
	Name *string `json:"name" validate:"required"`
}

// NewLegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName : Instantiate LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName (Generic Model Constructor)
func (*VpcV1) NewLegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName(name string) (_model *LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName, err error) {
	_model = &LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName) isaLegacyCloudObjectStorageBucketIdentity() bool {
	return true
}

// UnmarshalLegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName unmarshals an instance of LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName from the specified map of raw messages.
func UnmarshalLegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LegacyCloudObjectStorageBucketIdentityCloudObjectStorageBucketIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentityByCRN : LoadBalancerIdentityByCRN struct
// This model "extends" LoadBalancerIdentity
type LoadBalancerIdentityByCRN struct {
	// The load balancer's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewLoadBalancerIdentityByCRN : Instantiate LoadBalancerIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerIdentityByCRN(crn string) (_model *LoadBalancerIdentityByCRN, err error) {
	_model = &LoadBalancerIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerIdentityByCRN) isaLoadBalancerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerIdentityByCRN unmarshals an instance of LoadBalancerIdentityByCRN from the specified map of raw messages.
func UnmarshalLoadBalancerIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentityByHref : LoadBalancerIdentityByHref struct
// This model "extends" LoadBalancerIdentity
type LoadBalancerIdentityByHref struct {
	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerIdentityByHref : Instantiate LoadBalancerIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerIdentityByHref(href string) (_model *LoadBalancerIdentityByHref, err error) {
	_model = &LoadBalancerIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerIdentityByHref) isaLoadBalancerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerIdentityByHref unmarshals an instance of LoadBalancerIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentityByID : LoadBalancerIdentityByID struct
// This model "extends" LoadBalancerIdentity
type LoadBalancerIdentityByID struct {
	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerIdentityByID : Instantiate LoadBalancerIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerIdentityByID(id string) (_model *LoadBalancerIdentityByID, err error) {
	_model = &LoadBalancerIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerIdentityByID) isaLoadBalancerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerIdentityByID unmarshals an instance of LoadBalancerIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerIdentityByHref : LoadBalancerListenerIdentityByHref struct
// This model "extends" LoadBalancerListenerIdentity
type LoadBalancerListenerIdentityByHref struct {
	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerIdentityByHref : Instantiate LoadBalancerListenerIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerIdentityByHref(href string) (_model *LoadBalancerListenerIdentityByHref, err error) {
	_model = &LoadBalancerListenerIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerIdentityByHref) isaLoadBalancerListenerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerListenerIdentityByHref unmarshals an instance of LoadBalancerListenerIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerListenerIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerIdentityByID : LoadBalancerListenerIdentityByID struct
// This model "extends" LoadBalancerListenerIdentity
type LoadBalancerListenerIdentityByID struct {
	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerIdentityByID : Instantiate LoadBalancerListenerIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerIdentityByID(id string) (_model *LoadBalancerListenerIdentityByID, err error) {
	_model = &LoadBalancerListenerIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerIdentityByID) isaLoadBalancerListenerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerListenerIdentityByID unmarshals an instance of LoadBalancerListenerIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerListenerIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch : LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch struct
// This model "extends" LoadBalancerListenerPolicyTargetPatch
type LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// Identifies a load balancer listener by a unique property.
	Listener LoadBalancerListenerIdentityIntf `json:"listener,omitempty"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch) isaLoadBalancerListenerPolicyTargetPatch() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch unmarshals an instance of LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerHTTPSRedirectPatch)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch : LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch struct
// This model "extends" LoadBalancerListenerPolicyTargetPatch
type LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch) isaLoadBalancerListenerPolicyTargetPatch() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch unmarshals an instance of LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPatchLoadBalancerListenerPolicyRedirectURLPatch)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID
// - LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref
// This model "extends" LoadBalancerListenerPolicyTargetPatch
type LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityIntf interface {
	LoadBalancerListenerPolicyTargetPatchIntf
	isaLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity() bool
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyTargetPatch() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity unmarshals an instance of LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype : LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype struct
// This model "extends" LoadBalancerListenerPolicyTargetPrototype
type LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	// Identifies a load balancer listener by a unique property.
	Listener LoadBalancerListenerIdentityIntf `json:"listener" validate:"required"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

// NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype : Instantiate LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype(httpStatusCode int64, listener LoadBalancerListenerIdentityIntf) (_model *LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype, err error) {
	_model = &LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype{
		HTTPStatusCode: core.Int64Ptr(httpStatusCode),
		Listener:       listener,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype) isaLoadBalancerListenerPolicyTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype unmarshals an instance of LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerHTTPSRedirectPrototype)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype : LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype struct
// This model "extends" LoadBalancerListenerPolicyTargetPrototype
type LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	// The redirect target URL.
	URL *string `json:"url" validate:"required"`
}

// NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype : Instantiate LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype(httpStatusCode int64, url string) (_model *LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	_model = &LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype{
		HTTPStatusCode: core.Int64Ptr(httpStatusCode),
		URL:            core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype) isaLoadBalancerListenerPolicyTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype unmarshals an instance of LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPrototypeLoadBalancerListenerPolicyRedirectURLPrototype)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID
// - LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref
// This model "extends" LoadBalancerListenerPolicyTargetPrototype
type LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityIntf interface {
	LoadBalancerListenerPolicyTargetPrototypeIntf
	isaLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity() bool
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity unmarshals an instance of LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect : LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect struct
// This model "extends" LoadBalancerListenerPolicyTarget
type LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	Listener *LoadBalancerListenerReference `json:"listener" validate:"required"`

	// The redirect relative target URI.
	URI *string `json:"uri,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect) isaLoadBalancerListenerPolicyTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect unmarshals an instance of LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetLoadBalancerListenerHTTPSRedirect)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listener", &obj.Listener, UnmarshalLoadBalancerListenerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uri", &obj.URI)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL : LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL struct
// This model "extends" LoadBalancerListenerPolicyTarget
type LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL struct {
	// The HTTP status code for this redirect.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	// The redirect target URL.
	URL *string `json:"url" validate:"required"`
}

func (*LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL) isaLoadBalancerListenerPolicyTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL unmarshals an instance of LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetLoadBalancerListenerPolicyRedirectURL)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetLoadBalancerPoolReference : LoadBalancerListenerPolicyTargetLoadBalancerPoolReference struct
// This model "extends" LoadBalancerListenerPolicyTarget
type LoadBalancerListenerPolicyTargetLoadBalancerPoolReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerPoolReferenceDeleted `json:"deleted,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The name for this load balancer pool. The name is unique across all pools for the load balancer.
	Name *string `json:"name" validate:"required"`
}

func (*LoadBalancerListenerPolicyTargetLoadBalancerPoolReference) isaLoadBalancerListenerPolicyTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetLoadBalancerPoolReference unmarshals an instance of LoadBalancerListenerPolicyTargetLoadBalancerPoolReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetLoadBalancerPoolReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetLoadBalancerPoolReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerPoolReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentityByHref : LoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerPoolIdentity
type LoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByHref(href string) (_model *LoadBalancerPoolIdentityByHref, err error) {
	_model = &LoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerPoolIdentityByHref) isaLoadBalancerPoolIdentity() bool {
	return true
}

// UnmarshalLoadBalancerPoolIdentityByHref unmarshals an instance of LoadBalancerPoolIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentityByID : LoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerPoolIdentity
type LoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerPoolIdentityByID : Instantiate LoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByID(id string) (_model *LoadBalancerPoolIdentityByID, err error) {
	_model = &LoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerPoolIdentityByID) isaLoadBalancerPoolIdentity() bool {
	return true
}

// UnmarshalLoadBalancerPoolIdentityByID unmarshals an instance of LoadBalancerPoolIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeIP : LoadBalancerPoolMemberTargetPrototypeIP struct
// This model "extends" LoadBalancerPoolMemberTargetPrototype
type LoadBalancerPoolMemberTargetPrototypeIP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeIP : Instantiate LoadBalancerPoolMemberTargetPrototypeIP (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeIP(address string) (_model *LoadBalancerPoolMemberTargetPrototypeIP, err error) {
	_model = &LoadBalancerPoolMemberTargetPrototypeIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeIP) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeIP unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeIP from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentity : Identifies a virtual server instance by a unique property.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref
// This model "extends" LoadBalancerPoolMemberTargetPrototype
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentity struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentity) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityIntf interface {
	LoadBalancerPoolMemberTargetPrototypeIntf
	isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentity) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentity unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetIP : LoadBalancerPoolMemberTargetIP struct
// This model "extends" LoadBalancerPoolMemberTarget
type LoadBalancerPoolMemberTargetIP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*LoadBalancerPoolMemberTargetIP) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetIP unmarshals an instance of LoadBalancerPoolMemberTargetIP from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetInstanceReference : LoadBalancerPoolMemberTargetInstanceReference struct
// This model "extends" LoadBalancerPoolMemberTarget
type LoadBalancerPoolMemberTargetInstanceReference struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *InstanceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The name for this virtual server instance. The name is unique across all virtual server instances in the region.
	Name *string `json:"name" validate:"required"`
}

func (*LoadBalancerPoolMemberTargetInstanceReference) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetInstanceReference unmarshals an instance of LoadBalancerPoolMemberTargetInstanceReference from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalInstanceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileIdentityByHref : LoadBalancerProfileIdentityByHref struct
// This model "extends" LoadBalancerProfileIdentity
type LoadBalancerProfileIdentityByHref struct {
	// The URL for this load balancer profile.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerProfileIdentityByHref : Instantiate LoadBalancerProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerProfileIdentityByHref(href string) (_model *LoadBalancerProfileIdentityByHref, err error) {
	_model = &LoadBalancerProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerProfileIdentityByHref) isaLoadBalancerProfileIdentity() bool {
	return true
}

// UnmarshalLoadBalancerProfileIdentityByHref unmarshals an instance of LoadBalancerProfileIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileIdentityByName : LoadBalancerProfileIdentityByName struct
// This model "extends" LoadBalancerProfileIdentity
type LoadBalancerProfileIdentityByName struct {
	// The globally unique name for this load balancer profile.
	Name *string `json:"name" validate:"required"`
}

// NewLoadBalancerProfileIdentityByName : Instantiate LoadBalancerProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerProfileIdentityByName(name string) (_model *LoadBalancerProfileIdentityByName, err error) {
	_model = &LoadBalancerProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerProfileIdentityByName) isaLoadBalancerProfileIdentity() bool {
	return true
}

// UnmarshalLoadBalancerProfileIdentityByName unmarshals an instance of LoadBalancerProfileIdentityByName from the specified map of raw messages.
func UnmarshalLoadBalancerProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileInstanceGroupsSupportedDependent : The instance groups support for a load balancer with this profile depends on its configuration.
// This model "extends" LoadBalancerProfileInstanceGroupsSupported
type LoadBalancerProfileInstanceGroupsSupportedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerProfileInstanceGroupsSupportedDependent.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileInstanceGroupsSupportedDependentTypeDependentConst = "dependent"
)

func (*LoadBalancerProfileInstanceGroupsSupportedDependent) isaLoadBalancerProfileInstanceGroupsSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileInstanceGroupsSupportedDependent unmarshals an instance of LoadBalancerProfileInstanceGroupsSupportedDependent from the specified map of raw messages.
func UnmarshalLoadBalancerProfileInstanceGroupsSupportedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileInstanceGroupsSupportedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileInstanceGroupsSupportedFixed : The instance groups support for a load balancer with this profile.
// This model "extends" LoadBalancerProfileInstanceGroupsSupported
type LoadBalancerProfileInstanceGroupsSupportedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *bool `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerProfileInstanceGroupsSupportedFixed.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileInstanceGroupsSupportedFixedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileInstanceGroupsSupportedFixed) isaLoadBalancerProfileInstanceGroupsSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileInstanceGroupsSupportedFixed unmarshals an instance of LoadBalancerProfileInstanceGroupsSupportedFixed from the specified map of raw messages.
func UnmarshalLoadBalancerProfileInstanceGroupsSupportedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileInstanceGroupsSupportedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileRouteModeSupportedDependent : The route mode support for a load balancer with this profile depends on its configuration.
// This model "extends" LoadBalancerProfileRouteModeSupported
type LoadBalancerProfileRouteModeSupportedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerProfileRouteModeSupportedDependent.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileRouteModeSupportedDependentTypeDependentConst = "dependent"
)

func (*LoadBalancerProfileRouteModeSupportedDependent) isaLoadBalancerProfileRouteModeSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileRouteModeSupportedDependent unmarshals an instance of LoadBalancerProfileRouteModeSupportedDependent from the specified map of raw messages.
func UnmarshalLoadBalancerProfileRouteModeSupportedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileRouteModeSupportedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileRouteModeSupportedFixed : The route mode support for a load balancer with this profile.
// This model "extends" LoadBalancerProfileRouteModeSupported
type LoadBalancerProfileRouteModeSupportedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *bool `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerProfileRouteModeSupportedFixed.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileRouteModeSupportedFixedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileRouteModeSupportedFixed) isaLoadBalancerProfileRouteModeSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileRouteModeSupportedFixed unmarshals an instance of LoadBalancerProfileRouteModeSupportedFixed from the specified map of raw messages.
func UnmarshalLoadBalancerProfileRouteModeSupportedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileRouteModeSupportedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileSecurityGroupsSupportedDependent : The security group support for a load balancer with this profile depends on its configuration.
// This model "extends" LoadBalancerProfileSecurityGroupsSupported
type LoadBalancerProfileSecurityGroupsSupportedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerProfileSecurityGroupsSupportedDependent.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileSecurityGroupsSupportedDependentTypeDependentConst = "dependent"
)

func (*LoadBalancerProfileSecurityGroupsSupportedDependent) isaLoadBalancerProfileSecurityGroupsSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileSecurityGroupsSupportedDependent unmarshals an instance of LoadBalancerProfileSecurityGroupsSupportedDependent from the specified map of raw messages.
func UnmarshalLoadBalancerProfileSecurityGroupsSupportedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileSecurityGroupsSupportedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileSecurityGroupsSupportedFixed : The security group support for a load balancer with this profile.
// This model "extends" LoadBalancerProfileSecurityGroupsSupported
type LoadBalancerProfileSecurityGroupsSupportedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *bool `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerProfileSecurityGroupsSupportedFixed.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileSecurityGroupsSupportedFixedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileSecurityGroupsSupportedFixed) isaLoadBalancerProfileSecurityGroupsSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileSecurityGroupsSupportedFixed unmarshals an instance of LoadBalancerProfileSecurityGroupsSupportedFixed from the specified map of raw messages.
func UnmarshalLoadBalancerProfileSecurityGroupsSupportedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileSecurityGroupsSupportedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileUDPSupportedDependent : The UDP support for a load balancer with this profile depends on its configuration.
// This model "extends" LoadBalancerProfileUDPSupported
type LoadBalancerProfileUDPSupportedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerProfileUDPSupportedDependent.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileUDPSupportedDependentTypeDependentConst = "dependent"
)

func (*LoadBalancerProfileUDPSupportedDependent) isaLoadBalancerProfileUDPSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileUDPSupportedDependent unmarshals an instance of LoadBalancerProfileUDPSupportedDependent from the specified map of raw messages.
func UnmarshalLoadBalancerProfileUDPSupportedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileUDPSupportedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileUDPSupportedFixed : The UDP support for a load balancer with this profile.
// This model "extends" LoadBalancerProfileUDPSupported
type LoadBalancerProfileUDPSupportedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *bool `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerProfileUDPSupportedFixed.Type property.
// The type for this profile field.
const (
	LoadBalancerProfileUDPSupportedFixedTypeFixedConst = "fixed"
)

func (*LoadBalancerProfileUDPSupportedFixed) isaLoadBalancerProfileUDPSupported() bool {
	return true
}

// UnmarshalLoadBalancerProfileUDPSupportedFixed unmarshals an instance of LoadBalancerProfileUDPSupportedFixed from the specified map of raw messages.
func UnmarshalLoadBalancerProfileUDPSupportedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileUDPSupportedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentityByCRN : NetworkACLIdentityByCRN struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByCRN struct {
	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`
}

// NewNetworkACLIdentityByCRN : Instantiate NetworkACLIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByCRN(crn string) (_model *NetworkACLIdentityByCRN, err error) {
	_model = &NetworkACLIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLIdentityByCRN) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByCRN unmarshals an instance of NetworkACLIdentityByCRN from the specified map of raw messages.
func UnmarshalNetworkACLIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentityByHref : NetworkACLIdentityByHref struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByHref struct {
	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLIdentityByHref : Instantiate NetworkACLIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByHref(href string) (_model *NetworkACLIdentityByHref, err error) {
	_model = &NetworkACLIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLIdentityByHref) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByHref unmarshals an instance of NetworkACLIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkACLIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentityByID : NetworkACLIdentityByID struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByID struct {
	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLIdentityByID : Instantiate NetworkACLIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByID(id string) (_model *NetworkACLIdentityByID, err error) {
	_model = &NetworkACLIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLIdentityByID) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByID unmarshals an instance of NetworkACLIdentityByID from the specified map of raw messages.
func UnmarshalNetworkACLIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLPrototypeNetworkACLByRules : NetworkACLPrototypeNetworkACLByRules struct
// This model "extends" NetworkACLPrototype
type NetworkACLPrototypeNetworkACLByRules struct {
	// The name for this network ACL. The name must not be used by another network ACL for the VPC. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The prototype objects for rules to create along with this network ACL. If unspecified, no rules will be created,
	// resulting in all traffic being denied.
	Rules []NetworkACLRulePrototypeNetworkACLContextIntf `json:"rules,omitempty"`
}

// NewNetworkACLPrototypeNetworkACLByRules : Instantiate NetworkACLPrototypeNetworkACLByRules (Generic Model Constructor)
func (*VpcV1) NewNetworkACLPrototypeNetworkACLByRules(vpc VPCIdentityIntf) (_model *NetworkACLPrototypeNetworkACLByRules, err error) {
	_model = &NetworkACLPrototypeNetworkACLByRules{
		VPC: vpc,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLPrototypeNetworkACLByRules) isaNetworkACLPrototype() bool {
	return true
}

// UnmarshalNetworkACLPrototypeNetworkACLByRules unmarshals an instance of NetworkACLPrototypeNetworkACLByRules from the specified map of raw messages.
func UnmarshalNetworkACLPrototypeNetworkACLByRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPrototypeNetworkACLByRules)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRulePrototypeNetworkACLContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLPrototypeNetworkACLBySourceNetworkACL : NetworkACLPrototypeNetworkACLBySourceNetworkACL struct
// This model "extends" NetworkACLPrototype
type NetworkACLPrototypeNetworkACLBySourceNetworkACL struct {
	// The name for this network ACL. The name must not be used by another network ACL for the VPC. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// Network ACL to copy rules from.
	SourceNetworkACL NetworkACLIdentityIntf `json:"source_network_acl" validate:"required"`
}

// NewNetworkACLPrototypeNetworkACLBySourceNetworkACL : Instantiate NetworkACLPrototypeNetworkACLBySourceNetworkACL (Generic Model Constructor)
func (*VpcV1) NewNetworkACLPrototypeNetworkACLBySourceNetworkACL(vpc VPCIdentityIntf, sourceNetworkACL NetworkACLIdentityIntf) (_model *NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	_model = &NetworkACLPrototypeNetworkACLBySourceNetworkACL{
		VPC:              vpc,
		SourceNetworkACL: sourceNetworkACL,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLPrototypeNetworkACLBySourceNetworkACL) isaNetworkACLPrototype() bool {
	return true
}

// UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL unmarshals an instance of NetworkACLPrototypeNetworkACLBySourceNetworkACL from the specified map of raw messages.
func UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPrototypeNetworkACLBySourceNetworkACL)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_network_acl", &obj.SourceNetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref : NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref struct
// This model "extends" NetworkACLRuleBeforePatch
type NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref struct {
	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref : Instantiate NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref(href string) (_model *NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref, err error) {
	_model = &NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref) isaNetworkACLRuleBeforePatch() bool {
	return true
}

// UnmarshalNetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref unmarshals an instance of NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleBeforePatchNetworkACLRuleIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID : NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID struct
// This model "extends" NetworkACLRuleBeforePatch
type NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID struct {
	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLRuleBeforePatchNetworkACLRuleIdentityByID : Instantiate NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRuleBeforePatchNetworkACLRuleIdentityByID(id string) (_model *NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID, err error) {
	_model = &NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID) isaNetworkACLRuleBeforePatch() bool {
	return true
}

// UnmarshalNetworkACLRuleBeforePatchNetworkACLRuleIdentityByID unmarshals an instance of NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID from the specified map of raw messages.
func UnmarshalNetworkACLRuleBeforePatchNetworkACLRuleIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleBeforePatchNetworkACLRuleIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref : NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref struct
// This model "extends" NetworkACLRuleBeforePrototype
type NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref struct {
	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref : Instantiate NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref(href string) (_model *NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref, err error) {
	_model = &NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref) isaNetworkACLRuleBeforePrototype() bool {
	return true
}

// UnmarshalNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref unmarshals an instance of NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID : NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID struct
// This model "extends" NetworkACLRuleBeforePrototype
type NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID struct {
	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID : Instantiate NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID(id string) (_model *NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID, err error) {
	_model = &NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID) isaNetworkACLRuleBeforePrototype() bool {
	return true
}

// UnmarshalNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID unmarshals an instance of NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID from the specified map of raw messages.
func UnmarshalNetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleBeforePrototypeNetworkACLRuleIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolAll : NetworkACLRuleItemNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolAll struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. In a rule collection, this always refers to the next item in the
	// collection. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllActionAllowConst = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolAllActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllDirectionInboundConst  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllProtocolAllConst = "all"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolAll) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolAll from the specified map of raw messages.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolIcmp : NetworkACLRuleItemNetworkACLRuleProtocolIcmp struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolIcmp struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. In a rule collection, this always refers to the next item in the
	// collection. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to match.
	//
	// If absent, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The ICMP traffic type to match.
	//
	// If absent, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpActionAllowConst = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpDirectionInboundConst  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpProtocolIcmpConst = "icmp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolIcmp) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolIcmp unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolTcpudp : NetworkACLRuleItemNetworkACLRuleProtocolTcpudp struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolTcpudp struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. In a rule collection, this always refers to the next item in the
	// collection. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max" validate:"required"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max" validate:"required"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min" validate:"required"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpActionAllowConst = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpProtocolTCPConst = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpProtocolUDPConst = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolTcpudp) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototypeProtocolAllConst = "all"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype(action string, destination string, direction string, source string, protocol string) (_model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype, err error) {
	_model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype{
		Action:      core.StringPtr(action),
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Source:      core.StringPtr(source),
		Protocol:    core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to match.
	//
	// If specified, `type` must also be specified.  If unspecified, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The ICMP traffic type to match.
	//
	// If unspecified, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototypeProtocolIcmpConst = "icmp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype(action string, destination string, direction string, source string, protocol string) (_model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype, err error) {
	_model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype{
		Action:      core.StringPtr(action),
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Source:      core.StringPtr(source),
		Protocol:    core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeProtocolTCPConst = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototypeProtocolUDPConst = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype(action string, destination string, direction string, source string, protocol string) (_model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype, err error) {
	_model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype{
		Action:      core.StringPtr(action),
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Source:      core.StringPtr(source),
		Protocol:    core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype : NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	Before NetworkACLRuleBeforePrototypeIntf `json:"before,omitempty"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototypeProtocolAllConst = "all"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype(action string, destination string, direction string, source string, protocol string) (_model *NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype, err error) {
	_model = &NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype{
		Action:      core.StringPtr(action),
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Source:      core.StringPtr(source),
		Protocol:    core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolAllPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleBeforePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype : NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	Before NetworkACLRuleBeforePrototypeIntf `json:"before,omitempty"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to match.
	//
	// If specified, `type` must also be specified.  If unspecified, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The ICMP traffic type to match.
	//
	// If unspecified, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototypeProtocolIcmpConst = "icmp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype(action string, destination string, direction string, source string, protocol string) (_model *NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype, err error) {
	_model = &NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype{
		Action:      core.StringPtr(action),
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Source:      core.StringPtr(source),
		Protocol:    core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleBeforePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype : NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	Before NetworkACLRuleBeforePrototypeIntf `json:"before,omitempty"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this network ACL rule. The name must not be used by another rule for the network ACL. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeProtocolTCPConst = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototypeProtocolUDPConst = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype(action string, destination string, direction string, source string, protocol string) (_model *NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype, err error) {
	_model = &NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype{
		Action:      core.StringPtr(action),
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Source:      core.StringPtr(source),
		Protocol:    core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleBeforePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleNetworkACLRuleProtocolAll : NetworkACLRuleNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRule
type NetworkACLRuleNetworkACLRuleProtocolAll struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolAll.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleNetworkACLRuleProtocolAllActionAllowConst = "allow"
	NetworkACLRuleNetworkACLRuleProtocolAllActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolAll.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleNetworkACLRuleProtocolAllDirectionInboundConst  = "inbound"
	NetworkACLRuleNetworkACLRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolAll.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleNetworkACLRuleProtocolAllIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleNetworkACLRuleProtocolAllProtocolAllConst = "all"
)

func (*NetworkACLRuleNetworkACLRuleProtocolAll) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleNetworkACLRuleProtocolAll unmarshals an instance of NetworkACLRuleNetworkACLRuleProtocolAll from the specified map of raw messages.
func UnmarshalNetworkACLRuleNetworkACLRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleNetworkACLRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleNetworkACLRuleProtocolIcmp : NetworkACLRuleNetworkACLRuleProtocolIcmp struct
// This model "extends" NetworkACLRule
type NetworkACLRuleNetworkACLRuleProtocolIcmp struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to match.
	//
	// If absent, all codes are matched.
	Code *int64 `json:"code,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The ICMP traffic type to match.
	//
	// If absent, all types are matched.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolIcmp.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleNetworkACLRuleProtocolIcmpActionAllowConst = "allow"
	NetworkACLRuleNetworkACLRuleProtocolIcmpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolIcmp.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleNetworkACLRuleProtocolIcmpDirectionInboundConst  = "inbound"
	NetworkACLRuleNetworkACLRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolIcmp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleNetworkACLRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleNetworkACLRuleProtocolIcmpProtocolIcmpConst = "icmp"
)

func (*NetworkACLRuleNetworkACLRuleProtocolIcmp) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleNetworkACLRuleProtocolIcmp unmarshals an instance of NetworkACLRuleNetworkACLRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalNetworkACLRuleNetworkACLRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleNetworkACLRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleNetworkACLRuleProtocolTcpudp : NetworkACLRuleNetworkACLRuleProtocolTcpudp struct
// This model "extends" NetworkACLRule
type NetworkACLRuleNetworkACLRuleProtocolTcpudp struct {
	// The action to perform for a packet matching the rule.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all destination addresses.
	Destination *string `json:"destination" validate:"required"`

	// The direction of traffic to match.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The name for this network ACL rule. The name is unique across all rules for the network ACL.
	Name *string `json:"name" validate:"required"`

	// The source IP address or CIDR block to match. The CIDR block `0.0.0.0/0` matches all source addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max" validate:"required"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max" validate:"required"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min" validate:"required"`
}

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolTcpudp.Action property.
// The action to perform for a packet matching the rule.
const (
	NetworkACLRuleNetworkACLRuleProtocolTcpudpActionAllowConst = "allow"
	NetworkACLRuleNetworkACLRuleProtocolTcpudpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolTcpudp.Direction property.
// The direction of traffic to match.
const (
	NetworkACLRuleNetworkACLRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	NetworkACLRuleNetworkACLRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolTcpudp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleNetworkACLRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the NetworkACLRuleNetworkACLRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleNetworkACLRuleProtocolTcpudpProtocolTCPConst = "tcp"
	NetworkACLRuleNetworkACLRuleProtocolTcpudpProtocolUDPConst = "udp"
)

func (*NetworkACLRuleNetworkACLRuleProtocolTcpudp) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleNetworkACLRuleProtocolTcpudp unmarshals an instance of NetworkACLRuleNetworkACLRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalNetworkACLRuleNetworkACLRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleNetworkACLRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIPPrototypeReservedIPIdentity : Identifies a reserved IP by a unique property.
// Models which "extend" this model:
// - NetworkInterfaceIPPrototypeReservedIPIdentityByID
// - NetworkInterfaceIPPrototypeReservedIPIdentityByHref
// This model "extends" NetworkInterfaceIPPrototype
type NetworkInterfaceIPPrototypeReservedIPIdentity struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href,omitempty"`
}

func (*NetworkInterfaceIPPrototypeReservedIPIdentity) isaNetworkInterfaceIPPrototypeReservedIPIdentity() bool {
	return true
}

type NetworkInterfaceIPPrototypeReservedIPIdentityIntf interface {
	NetworkInterfaceIPPrototypeIntf
	isaNetworkInterfaceIPPrototypeReservedIPIdentity() bool
}

func (*NetworkInterfaceIPPrototypeReservedIPIdentity) isaNetworkInterfaceIPPrototype() bool {
	return true
}

// UnmarshalNetworkInterfaceIPPrototypeReservedIPIdentity unmarshals an instance of NetworkInterfaceIPPrototypeReservedIPIdentity from the specified map of raw messages.
func UnmarshalNetworkInterfaceIPPrototypeReservedIPIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIPPrototypeReservedIPIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext : NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext struct
// This model "extends" NetworkInterfaceIPPrototype
type NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext struct {
	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`
}

func (*NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext) isaNetworkInterfaceIPPrototype() bool {
	return true
}

// UnmarshalNetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext unmarshals an instance of NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext from the specified map of raw messages.
func UnmarshalNetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIPPrototypeReservedIPPrototypeNetworkInterfaceContext)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemIdentityByHref : OperatingSystemIdentityByHref struct
// This model "extends" OperatingSystemIdentity
type OperatingSystemIdentityByHref struct {
	// The URL for this operating system.
	Href *string `json:"href" validate:"required"`
}

// NewOperatingSystemIdentityByHref : Instantiate OperatingSystemIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewOperatingSystemIdentityByHref(href string) (_model *OperatingSystemIdentityByHref, err error) {
	_model = &OperatingSystemIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*OperatingSystemIdentityByHref) isaOperatingSystemIdentity() bool {
	return true
}

// UnmarshalOperatingSystemIdentityByHref unmarshals an instance of OperatingSystemIdentityByHref from the specified map of raw messages.
func UnmarshalOperatingSystemIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemIdentityByName : OperatingSystemIdentityByName struct
// This model "extends" OperatingSystemIdentity
type OperatingSystemIdentityByName struct {
	// The globally unique name for this operating system.
	Name *string `json:"name" validate:"required"`
}

// NewOperatingSystemIdentityByName : Instantiate OperatingSystemIdentityByName (Generic Model Constructor)
func (*VpcV1) NewOperatingSystemIdentityByName(name string) (_model *OperatingSystemIdentityByName, err error) {
	_model = &OperatingSystemIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*OperatingSystemIdentityByName) isaOperatingSystemIdentity() bool {
	return true
}

// UnmarshalOperatingSystemIdentityByName unmarshals an instance of OperatingSystemIdentityByName from the specified map of raw messages.
func UnmarshalOperatingSystemIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototypeFloatingIPIdentity : Identifies a floating IP by a unique property.
// Models which "extend" this model:
// - PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID
// - PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN
// - PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref
// - PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress
// This model "extends" PublicGatewayFloatingIPPrototype
type PublicGatewayFloatingIPPrototypeFloatingIPIdentity struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id,omitempty"`

	// The CRN for this floating IP.
	CRN *string `json:"crn,omitempty"`

	// The URL for this floating IP.
	Href *string `json:"href,omitempty"`

	// The globally unique IP address.
	Address *string `json:"address,omitempty"`
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentity) isaPublicGatewayFloatingIPPrototypeFloatingIPIdentity() bool {
	return true
}

type PublicGatewayFloatingIPPrototypeFloatingIPIdentityIntf interface {
	PublicGatewayFloatingIPPrototypeIntf
	isaPublicGatewayFloatingIPPrototypeFloatingIPIdentity() bool
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentity) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

// UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentity unmarshals an instance of PublicGatewayFloatingIPPrototypeFloatingIPIdentity from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototypeFloatingIPIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext : PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext struct
// This model "extends" PublicGatewayFloatingIPPrototype
type PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext struct {
	// The name for this floating IP. The name must not be used by another floating IP in the region. If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

// UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext unmarshals an instance of PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototypeFloatingIPPrototypeTargetContext)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentityPublicGatewayIdentityByCRN : PublicGatewayIdentityPublicGatewayIdentityByCRN struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityPublicGatewayIdentityByCRN struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`
}

// NewPublicGatewayIdentityPublicGatewayIdentityByCRN : Instantiate PublicGatewayIdentityPublicGatewayIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityPublicGatewayIdentityByCRN(crn string) (_model *PublicGatewayIdentityPublicGatewayIdentityByCRN, err error) {
	_model = &PublicGatewayIdentityPublicGatewayIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayIdentityPublicGatewayIdentityByCRN) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityPublicGatewayIdentityByCRN unmarshals an instance of PublicGatewayIdentityPublicGatewayIdentityByCRN from the specified map of raw messages.
func UnmarshalPublicGatewayIdentityPublicGatewayIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentityPublicGatewayIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentityPublicGatewayIdentityByHref : PublicGatewayIdentityPublicGatewayIdentityByHref struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityPublicGatewayIdentityByHref struct {
	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`
}

// NewPublicGatewayIdentityPublicGatewayIdentityByHref : Instantiate PublicGatewayIdentityPublicGatewayIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityPublicGatewayIdentityByHref(href string) (_model *PublicGatewayIdentityPublicGatewayIdentityByHref, err error) {
	_model = &PublicGatewayIdentityPublicGatewayIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayIdentityPublicGatewayIdentityByHref) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityPublicGatewayIdentityByHref unmarshals an instance of PublicGatewayIdentityPublicGatewayIdentityByHref from the specified map of raw messages.
func UnmarshalPublicGatewayIdentityPublicGatewayIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentityPublicGatewayIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentityPublicGatewayIdentityByID : PublicGatewayIdentityPublicGatewayIdentityByID struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityPublicGatewayIdentityByID struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`
}

// NewPublicGatewayIdentityPublicGatewayIdentityByID : Instantiate PublicGatewayIdentityPublicGatewayIdentityByID (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityPublicGatewayIdentityByID(id string) (_model *PublicGatewayIdentityPublicGatewayIdentityByID, err error) {
	_model = &PublicGatewayIdentityPublicGatewayIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayIdentityPublicGatewayIdentityByID) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityPublicGatewayIdentityByID unmarshals an instance of PublicGatewayIdentityPublicGatewayIdentityByID from the specified map of raw messages.
func UnmarshalPublicGatewayIdentityPublicGatewayIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentityPublicGatewayIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionIdentityByHref : RegionIdentityByHref struct
// This model "extends" RegionIdentity
type RegionIdentityByHref struct {
	// The URL for this region.
	Href *string `json:"href" validate:"required"`
}

// NewRegionIdentityByHref : Instantiate RegionIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewRegionIdentityByHref(href string) (_model *RegionIdentityByHref, err error) {
	_model = &RegionIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RegionIdentityByHref) isaRegionIdentity() bool {
	return true
}

// UnmarshalRegionIdentityByHref unmarshals an instance of RegionIdentityByHref from the specified map of raw messages.
func UnmarshalRegionIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionIdentityByName : RegionIdentityByName struct
// This model "extends" RegionIdentity
type RegionIdentityByName struct {
	// The globally unique name for this region.
	Name *string `json:"name" validate:"required"`
}

// NewRegionIdentityByName : Instantiate RegionIdentityByName (Generic Model Constructor)
func (*VpcV1) NewRegionIdentityByName(name string) (_model *RegionIdentityByName, err error) {
	_model = &RegionIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RegionIdentityByName) isaRegionIdentity() bool {
	return true
}

// UnmarshalRegionIdentityByName unmarshals an instance of RegionIdentityByName from the specified map of raw messages.
func UnmarshalRegionIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetPrototypeEndpointGatewayIdentity : ReservedIPTargetPrototypeEndpointGatewayIdentity struct
// Models which "extend" this model:
// - ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID
// - ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN
// - ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref
// This model "extends" ReservedIPTargetPrototype
type ReservedIPTargetPrototypeEndpointGatewayIdentity struct {
	// The unique identifier for this endpoint gateway.
	ID *string `json:"id,omitempty"`

	// The CRN for this endpoint gateway.
	CRN *string `json:"crn,omitempty"`

	// The URL for this endpoint gateway.
	Href *string `json:"href,omitempty"`
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentity) isaReservedIPTargetPrototypeEndpointGatewayIdentity() bool {
	return true
}

type ReservedIPTargetPrototypeEndpointGatewayIdentityIntf interface {
	ReservedIPTargetPrototypeIntf
	isaReservedIPTargetPrototypeEndpointGatewayIdentity() bool
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentity) isaReservedIPTargetPrototype() bool {
	return true
}

// UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentity unmarshals an instance of ReservedIPTargetPrototypeEndpointGatewayIdentity from the specified map of raw messages.
func UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetPrototypeEndpointGatewayIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext : ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *BareMetalServerNetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext.ResourceType property.
// The resource type.
const (
	ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContextResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext unmarshals an instance of ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext from the specified map of raw messages.
func UnmarshalReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetBareMetalServerNetworkInterfaceReferenceTargetContext)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalBareMetalServerNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetEndpointGatewayReference : ReservedIPTargetEndpointGatewayReference struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetEndpointGatewayReference struct {
	// The CRN for this endpoint gateway.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *EndpointGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this endpoint gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this endpoint gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetEndpointGatewayReference.ResourceType property.
// The resource type.
const (
	ReservedIPTargetEndpointGatewayReferenceResourceTypeEndpointGatewayConst = "endpoint_gateway"
)

func (*ReservedIPTargetEndpointGatewayReference) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetEndpointGatewayReference unmarshals an instance of ReservedIPTargetEndpointGatewayReference from the specified map of raw messages.
func UnmarshalReservedIPTargetEndpointGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetEndpointGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalEndpointGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetGenericResourceReference : Identifying information for a resource that is not native to the VPC API.
// This model "extends" ReservedIPTarget
type ReservedIPTargetGenericResourceReference struct {
	// The CRN for the resource.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *GenericResourceReferenceDeleted `json:"deleted,omitempty"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetGenericResourceReference.ResourceType property.
// The resource type.
const (
	ReservedIPTargetGenericResourceReferenceResourceTypeCloudResourceConst = "cloud_resource"
)

func (*ReservedIPTargetGenericResourceReference) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetGenericResourceReference unmarshals an instance of ReservedIPTargetGenericResourceReference from the specified map of raw messages.
func UnmarshalReservedIPTargetGenericResourceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetGenericResourceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalGenericResourceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetLoadBalancerReference : ReservedIPTargetLoadBalancerReference struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetLoadBalancerReference struct {
	// The load balancer's CRN.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerReferenceDeleted `json:"deleted,omitempty"`

	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`

	// The name for this load balancer. The name is unique across all load balancers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetLoadBalancerReference.ResourceType property.
// The resource type.
const (
	ReservedIPTargetLoadBalancerReferenceResourceTypeLoadBalancerConst = "load_balancer"
)

func (*ReservedIPTargetLoadBalancerReference) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetLoadBalancerReference unmarshals an instance of ReservedIPTargetLoadBalancerReference from the specified map of raw messages.
func UnmarshalReservedIPTargetLoadBalancerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetLoadBalancerReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetNetworkInterfaceReferenceTargetContext : ReservedIPTargetNetworkInterfaceReferenceTargetContext struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetNetworkInterfaceReferenceTargetContext struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this instance network interface.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetNetworkInterfaceReferenceTargetContext.ResourceType property.
// The resource type.
const (
	ReservedIPTargetNetworkInterfaceReferenceTargetContextResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*ReservedIPTargetNetworkInterfaceReferenceTargetContext) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetNetworkInterfaceReferenceTargetContext unmarshals an instance of ReservedIPTargetNetworkInterfaceReferenceTargetContext from the specified map of raw messages.
func UnmarshalReservedIPTargetNetworkInterfaceReferenceTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetNetworkInterfaceReferenceTargetContext)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetVPNGatewayReference : ReservedIPTargetVPNGatewayReference struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetVPNGatewayReference struct {
	// The VPN gateway's CRN.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN gateway. The name is unique across all VPN gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetVPNGatewayReference.ResourceType property.
// The resource type.
const (
	ReservedIPTargetVPNGatewayReferenceResourceTypeVPNGatewayConst = "vpn_gateway"
)

func (*ReservedIPTargetVPNGatewayReference) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetVPNGatewayReference unmarshals an instance of ReservedIPTargetVPNGatewayReference from the specified map of raw messages.
func UnmarshalReservedIPTargetVPNGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetVPNGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetVPNServerReference : ReservedIPTargetVPNServerReference struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetVPNServerReference struct {
	// The CRN for this VPN server.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNServerReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this VPN server.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN server.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN server. The name is unique across all VPN servers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetVPNServerReference.ResourceType property.
// The resource type.
const (
	ReservedIPTargetVPNServerReferenceResourceTypeVPNServerConst = "vpn_server"
)

func (*ReservedIPTargetVPNServerReference) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetVPNServerReference unmarshals an instance of ReservedIPTargetVPNServerReference from the specified map of raw messages.
func UnmarshalReservedIPTargetVPNServerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetVPNServerReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNServerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext : ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext struct
// This model "extends" ReservedIPTarget
type ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext struct {
	// The CRN for this virtual network interface.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this virtual network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this virtual network interface. The name is unique across all virtual network interfaces in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext.ResourceType property.
// The resource type.
const (
	ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContextResourceTypeVirtualNetworkInterfaceConst = "virtual_network_interface"
)

func (*ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext) isaReservedIPTarget() bool {
	return true
}

// UnmarshalReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext unmarshals an instance of ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext from the specified map of raw messages.
func UnmarshalReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetVirtualNetworkInterfaceReferenceReservedIPTargetContext)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupIdentityByID : ResourceGroupIdentityByID struct
// This model "extends" ResourceGroupIdentity
type ResourceGroupIdentityByID struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentityByID : Instantiate ResourceGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewResourceGroupIdentityByID(id string) (_model *ResourceGroupIdentityByID, err error) {
	_model = &ResourceGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ResourceGroupIdentityByID) isaResourceGroupIdentity() bool {
	return true
}

// UnmarshalResourceGroupIdentityByID unmarshals an instance of ResourceGroupIdentityByID from the specified map of raw messages.
func UnmarshalResourceGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCreatorVPNGatewayReference : RouteCreatorVPNGatewayReference struct
// This model "extends" RouteCreator
type RouteCreatorVPNGatewayReference struct {
	// The VPN gateway's CRN.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN gateway. The name is unique across all VPN gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the RouteCreatorVPNGatewayReference.ResourceType property.
// The resource type.
const (
	RouteCreatorVPNGatewayReferenceResourceTypeVPNGatewayConst = "vpn_gateway"
)

func (*RouteCreatorVPNGatewayReference) isaRouteCreator() bool {
	return true
}

// UnmarshalRouteCreatorVPNGatewayReference unmarshals an instance of RouteCreatorVPNGatewayReference from the specified map of raw messages.
func UnmarshalRouteCreatorVPNGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCreatorVPNGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCreatorVPNServerReference : RouteCreatorVPNServerReference struct
// This model "extends" RouteCreator
type RouteCreatorVPNServerReference struct {
	// The CRN for this VPN server.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNServerReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this VPN server.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN server.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN server. The name is unique across all VPN servers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the RouteCreatorVPNServerReference.ResourceType property.
// The resource type.
const (
	RouteCreatorVPNServerReferenceResourceTypeVPNServerConst = "vpn_server"
)

func (*RouteCreatorVPNServerReference) isaRouteCreator() bool {
	return true
}

// UnmarshalRouteCreatorVPNServerReference unmarshals an instance of RouteCreatorVPNServerReference from the specified map of raw messages.
func UnmarshalRouteCreatorVPNServerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCreatorVPNServerReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNServerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopIP : RouteNextHopIP struct
// This model "extends" RouteNextHop
type RouteNextHopIP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*RouteNextHopIP) isaRouteNextHop() bool {
	return true
}

// UnmarshalRouteNextHopIP unmarshals an instance of RouteNextHopIP from the specified map of raw messages.
func UnmarshalRouteNextHopIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatchRouteNextHopIP : RouteNextHopPatchRouteNextHopIP struct
// Models which "extend" this model:
// - RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP
// - RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP
// This model "extends" RouteNextHopPatch
type RouteNextHopPatchRouteNextHopIP struct {
	// The sentinel IP address (`0.0.0.0`).
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*RouteNextHopPatchRouteNextHopIP) isaRouteNextHopPatchRouteNextHopIP() bool {
	return true
}

type RouteNextHopPatchRouteNextHopIPIntf interface {
	RouteNextHopPatchIntf
	isaRouteNextHopPatchRouteNextHopIP() bool
}

func (*RouteNextHopPatchRouteNextHopIP) isaRouteNextHopPatch() bool {
	return true
}

// UnmarshalRouteNextHopPatchRouteNextHopIP unmarshals an instance of RouteNextHopPatchRouteNextHopIP from the specified map of raw messages.
func UnmarshalRouteNextHopPatchRouteNextHopIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatchRouteNextHopIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatchVPNGatewayConnectionIdentity : Identifies a VPN gateway connection by a unique property.
// Models which "extend" this model:
// - RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID
// - RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref
// This model "extends" RouteNextHopPatch
type RouteNextHopPatchVPNGatewayConnectionIdentity struct {
	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*RouteNextHopPatchVPNGatewayConnectionIdentity) isaRouteNextHopPatchVPNGatewayConnectionIdentity() bool {
	return true
}

type RouteNextHopPatchVPNGatewayConnectionIdentityIntf interface {
	RouteNextHopPatchIntf
	isaRouteNextHopPatchVPNGatewayConnectionIdentity() bool
}

func (*RouteNextHopPatchVPNGatewayConnectionIdentity) isaRouteNextHopPatch() bool {
	return true
}

// UnmarshalRouteNextHopPatchVPNGatewayConnectionIdentity unmarshals an instance of RouteNextHopPatchVPNGatewayConnectionIdentity from the specified map of raw messages.
func UnmarshalRouteNextHopPatchVPNGatewayConnectionIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatchVPNGatewayConnectionIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopVPNGatewayConnectionReference : RouteNextHopVPNGatewayConnectionReference struct
// This model "extends" RouteNextHop
type RouteNextHopVPNGatewayConnectionReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNGatewayConnectionReferenceDeleted `json:"deleted,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the RouteNextHopVPNGatewayConnectionReference.ResourceType property.
// The resource type.
const (
	RouteNextHopVPNGatewayConnectionReferenceResourceTypeVPNGatewayConnectionConst = "vpn_gateway_connection"
)

func (*RouteNextHopVPNGatewayConnectionReference) isaRouteNextHop() bool {
	return true
}

// UnmarshalRouteNextHopVPNGatewayConnectionReference unmarshals an instance of RouteNextHopVPNGatewayConnectionReference from the specified map of raw messages.
func UnmarshalRouteNextHopVPNGatewayConnectionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopVPNGatewayConnectionReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNGatewayConnectionReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP : RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP struct
// Models which "extend" this model:
// - RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP
// - RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP
// This model "extends" RoutePrototypeNextHop
type RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP struct {
	// The sentinel IP address (`0.0.0.0`).
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP) isaRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP() bool {
	return true
}

type RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPIntf interface {
	RoutePrototypeNextHopIntf
	isaRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP() bool
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP) isaRoutePrototypeNextHop() bool {
	return true
}

// UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP unmarshals an instance of RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity : Identifies a VPN gateway connection by a unique property.
// Models which "extend" this model:
// - RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID
// - RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref
// This model "extends" RoutePrototypeNextHop
type RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity struct {
	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity) isaRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity() bool {
	return true
}

type RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityIntf interface {
	RoutePrototypeNextHopIntf
	isaRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity() bool
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity) isaRoutePrototypeNextHop() bool {
	return true
}

// UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity unmarshals an instance of RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentityByHref : RoutingTableIdentityByHref struct
// This model "extends" RoutingTableIdentity
type RoutingTableIdentityByHref struct {
	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`
}

// NewRoutingTableIdentityByHref : Instantiate RoutingTableIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewRoutingTableIdentityByHref(href string) (_model *RoutingTableIdentityByHref, err error) {
	_model = &RoutingTableIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutingTableIdentityByHref) isaRoutingTableIdentity() bool {
	return true
}

// UnmarshalRoutingTableIdentityByHref unmarshals an instance of RoutingTableIdentityByHref from the specified map of raw messages.
func UnmarshalRoutingTableIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentityByID : RoutingTableIdentityByID struct
// This model "extends" RoutingTableIdentity
type RoutingTableIdentityByID struct {
	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`
}

// NewRoutingTableIdentityByID : Instantiate RoutingTableIdentityByID (Generic Model Constructor)
func (*VpcV1) NewRoutingTableIdentityByID(id string) (_model *RoutingTableIdentityByID, err error) {
	_model = &RoutingTableIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutingTableIdentityByID) isaRoutingTableIdentity() bool {
	return true
}

// UnmarshalRoutingTableIdentityByID unmarshals an instance of RoutingTableIdentityByID from the specified map of raw messages.
func UnmarshalRoutingTableIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByCRN : SecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewSecurityGroupIdentityByCRN : Instantiate SecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByCRN(crn string) (_model *SecurityGroupIdentityByCRN, err error) {
	_model = &SecurityGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupIdentityByCRN) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByHref : SecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupIdentityByHref : Instantiate SecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByHref(href string) (_model *SecurityGroupIdentityByHref, err error) {
	_model = &SecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupIdentityByHref) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByHref unmarshals an instance of SecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByID : SecurityGroupIdentityByID struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupIdentityByID : Instantiate SecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByID(id string) (_model *SecurityGroupIdentityByID, err error) {
	_model = &SecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupIdentityByID) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByID unmarshals an instance of SecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll : A rule allowing traffic for all supported protocols.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The remote IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group within the VPC.
	//
	// If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
	// (or to any destination, for outbound rules).
	Remote SecurityGroupRuleRemotePrototypeIntf `json:"remote,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllProtocolAllConst = "all"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(direction string, protocol string) (_model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	_model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll{
		Direction: core.StringPtr(direction),
		Protocol:  core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemotePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp : A rule specifying the ICMP traffic to allow.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp struct {
	// The ICMP traffic code to allow.
	//
	// If specified, `type` must also be specified.  If unspecified, all codes are allowed.
	Code *int64 `json:"code,omitempty"`

	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The remote IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group within the VPC.
	//
	// If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
	// (or to any destination, for outbound rules).
	Remote SecurityGroupRuleRemotePrototypeIntf `json:"remote,omitempty"`

	// The ICMP traffic type to allow.
	//
	// If unspecified, all types are allowed.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpProtocolIcmpConst = "icmp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp(direction string, protocol string) (_model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp, err error) {
	_model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp{
		Direction: core.StringPtr(direction),
		Protocol:  core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemotePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp : A rule specifying the TCP or UDP traffic to allow.
//
// Either both `port_min` and `port_max` will be present, or neither. When neither is present, all destination ports are
// allowed for the protocol. When both have the same value, that single destination port is allowed.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	//
	// If specified, `port_min` must also be specified, and must not be larger. If unspecified,
	// `port_min` must also be unspecified, allowing traffic on all destination ports.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range
	//
	// If specified, `port_max` must also be specified, and must not be smaller. If unspecified, `port_max` must also be
	// unspecified, allowing traffic on all destination ports.
	PortMin *int64 `json:"port_min,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The remote IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group within the VPC.
	//
	// If unspecified, a CIDR block of `0.0.0.0/0` will be used to allow traffic from any source
	// (or to any destination, for outbound rules).
	Remote SecurityGroupRuleRemotePrototypeIntf `json:"remote,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpProtocolTCPConst = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpProtocolUDPConst = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp(direction string, protocol string) (_model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp, err error) {
	_model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp{
		Direction: core.StringPtr(direction),
		Protocol:  core.StringPtr(protocol),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemotePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatchCIDR : SecurityGroupRuleRemotePatchCIDR struct
// This model "extends" SecurityGroupRuleRemotePatch
type SecurityGroupRuleRemotePatchCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRuleRemotePatchCIDR : Instantiate SecurityGroupRuleRemotePatchCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePatchCIDR(cidrBlock string) (_model *SecurityGroupRuleRemotePatchCIDR, err error) {
	_model = &SecurityGroupRuleRemotePatchCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePatchCIDR) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePatchCIDR unmarshals an instance of SecurityGroupRuleRemotePatchCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatchCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatchCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatchIP : SecurityGroupRuleRemotePatchIP struct
// This model "extends" SecurityGroupRuleRemotePatch
type SecurityGroupRuleRemotePatchIP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRuleRemotePatchIP : Instantiate SecurityGroupRuleRemotePatchIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePatchIP(address string) (_model *SecurityGroupRuleRemotePatchIP, err error) {
	_model = &SecurityGroupRuleRemotePatchIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePatchIP) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePatchIP unmarshals an instance of SecurityGroupRuleRemotePatchIP from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatchIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatchIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatchSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRuleRemotePatch
type SecurityGroupRuleRemotePatchSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentity) isaSecurityGroupRuleRemotePatchSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRuleRemotePatchSecurityGroupIdentityIntf interface {
	SecurityGroupRuleRemotePatchIntf
	isaSecurityGroupRuleRemotePatchSecurityGroupIdentity() bool
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentity) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentity unmarshals an instance of SecurityGroupRuleRemotePatchSecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatchSecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototypeCIDR : SecurityGroupRuleRemotePrototypeCIDR struct
// This model "extends" SecurityGroupRuleRemotePrototype
type SecurityGroupRuleRemotePrototypeCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRuleRemotePrototypeCIDR : Instantiate SecurityGroupRuleRemotePrototypeCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePrototypeCIDR(cidrBlock string) (_model *SecurityGroupRuleRemotePrototypeCIDR, err error) {
	_model = &SecurityGroupRuleRemotePrototypeCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePrototypeCIDR) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePrototypeCIDR unmarshals an instance of SecurityGroupRuleRemotePrototypeCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototypeCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototypeCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototypeIP : SecurityGroupRuleRemotePrototypeIP struct
// This model "extends" SecurityGroupRuleRemotePrototype
type SecurityGroupRuleRemotePrototypeIP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRuleRemotePrototypeIP : Instantiate SecurityGroupRuleRemotePrototypeIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePrototypeIP(address string) (_model *SecurityGroupRuleRemotePrototypeIP, err error) {
	_model = &SecurityGroupRuleRemotePrototypeIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePrototypeIP) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePrototypeIP unmarshals an instance of SecurityGroupRuleRemotePrototypeIP from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototypeIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototypeIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototypeSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRuleRemotePrototype
type SecurityGroupRuleRemotePrototypeSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentity) isaSecurityGroupRuleRemotePrototypeSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRuleRemotePrototypeSecurityGroupIdentityIntf interface {
	SecurityGroupRuleRemotePrototypeIntf
	isaSecurityGroupRuleRemotePrototypeSecurityGroupIdentity() bool
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentity) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentity unmarshals an instance of SecurityGroupRuleRemotePrototypeSecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototypeSecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemoteCIDR : SecurityGroupRuleRemoteCIDR struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

func (*SecurityGroupRuleRemoteCIDR) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteCIDR unmarshals an instance of SecurityGroupRuleRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemoteIP : SecurityGroupRuleRemoteIP struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteIP struct {
	// The IP address.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*SecurityGroupRuleRemoteIP) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteIP unmarshals an instance of SecurityGroupRuleRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemoteSecurityGroupReference : SecurityGroupRuleRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SecurityGroupReferenceDeleted `json:"deleted,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name for this security group. The name is unique across all security groups for the VPC.
	Name *string `json:"name" validate:"required"`
}

func (*SecurityGroupRuleRemoteSecurityGroupReference) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRuleRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSecurityGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleSecurityGroupRuleProtocolAll : A rule allowing traffic for all supported protocols.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleSecurityGroupRuleProtocolAll struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version" validate:"required"`

	Remote SecurityGroupRuleRemoteIntf `json:"remote" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolAll.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolAllDirectionInboundConst  = "inbound"
	SecurityGroupRuleSecurityGroupRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolAll.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolAllIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolAllProtocolAllConst = "all"
)

func (*SecurityGroupRuleSecurityGroupRuleProtocolAll) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolAll unmarshals an instance of SecurityGroupRuleSecurityGroupRuleProtocolAll from the specified map of raw messages.
func UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleSecurityGroupRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleSecurityGroupRuleProtocolIcmp : A rule specifying the ICMP traffic to allow.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleSecurityGroupRuleProtocolIcmp struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version" validate:"required"`

	Remote SecurityGroupRuleRemoteIntf `json:"remote" validate:"required"`

	// The ICMP traffic code to allow. If absent, all codes are allowed.
	Code *int64 `json:"code,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`

	// The ICMP traffic type to allow. If absent, all types are allowed.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolIcmp.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolIcmpDirectionInboundConst  = "inbound"
	SecurityGroupRuleSecurityGroupRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolIcmp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolIcmpProtocolIcmpConst = "icmp"
)

func (*SecurityGroupRuleSecurityGroupRuleProtocolIcmp) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolIcmp unmarshals an instance of SecurityGroupRuleSecurityGroupRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleSecurityGroupRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleSecurityGroupRuleProtocolTcpudp : A rule specifying the TCP or UDP traffic to allow.
//
// Either both `port_min` and `port_max` will be present, or neither. When neither is present, all destination ports are
// allowed for the protocol. When both have the same value, that single destination port is allowed.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleSecurityGroupRuleProtocolTcpudp struct {
	// The direction of traffic to enforce.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
	// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
	// (network interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version" validate:"required"`

	Remote SecurityGroupRuleRemoteIntf `json:"remote" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	PortMin *int64 `json:"port_min,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolTcpudp.Direction property.
// The direction of traffic to enforce.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	SecurityGroupRuleSecurityGroupRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolTcpudp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this property, if they
// are used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses
// (network interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRuleSecurityGroupRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleSecurityGroupRuleProtocolTcpudpProtocolTCPConst = "tcp"
	SecurityGroupRuleSecurityGroupRuleProtocolTcpudpProtocolUDPConst = "udp"
)

func (*SecurityGroupRuleSecurityGroupRuleProtocolTcpudp) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolTcpudp unmarshals an instance of SecurityGroupRuleSecurityGroupRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalSecurityGroupRuleSecurityGroupRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleSecurityGroupRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext : SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext struct
// This model "extends" SecurityGroupTargetReference
type SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *BareMetalServerNetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this bare metal server network interface.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContextResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext) isaSecurityGroupTargetReference() bool {
	return true
}

// UnmarshalSecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext unmarshals an instance of SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReferenceBareMetalServerNetworkInterfaceReferenceTargetContext)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalBareMetalServerNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReferenceEndpointGatewayReference : SecurityGroupTargetReferenceEndpointGatewayReference struct
// This model "extends" SecurityGroupTargetReference
type SecurityGroupTargetReferenceEndpointGatewayReference struct {
	// The CRN for this endpoint gateway.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *EndpointGatewayReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this endpoint gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this endpoint gateway.
	ID *string `json:"id" validate:"required"`

	// The name for this endpoint gateway. The name is unique across all endpoint gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SecurityGroupTargetReferenceEndpointGatewayReference.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceEndpointGatewayReferenceResourceTypeEndpointGatewayConst = "endpoint_gateway"
)

func (*SecurityGroupTargetReferenceEndpointGatewayReference) isaSecurityGroupTargetReference() bool {
	return true
}

// UnmarshalSecurityGroupTargetReferenceEndpointGatewayReference unmarshals an instance of SecurityGroupTargetReferenceEndpointGatewayReference from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReferenceEndpointGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReferenceEndpointGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalEndpointGatewayReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReferenceLoadBalancerReference : SecurityGroupTargetReferenceLoadBalancerReference struct
// This model "extends" SecurityGroupTargetReference
type SecurityGroupTargetReferenceLoadBalancerReference struct {
	// The load balancer's CRN.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *LoadBalancerReferenceDeleted `json:"deleted,omitempty"`

	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`

	// The name for this load balancer. The name is unique across all load balancers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SecurityGroupTargetReferenceLoadBalancerReference.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceLoadBalancerReferenceResourceTypeLoadBalancerConst = "load_balancer"
)

func (*SecurityGroupTargetReferenceLoadBalancerReference) isaSecurityGroupTargetReference() bool {
	return true
}

// UnmarshalSecurityGroupTargetReferenceLoadBalancerReference unmarshals an instance of SecurityGroupTargetReferenceLoadBalancerReference from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReferenceLoadBalancerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReferenceLoadBalancerReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalLoadBalancerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext : SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext struct
// This model "extends" SecurityGroupTargetReference
type SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *NetworkInterfaceReferenceTargetContextDeleted `json:"deleted,omitempty"`

	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this instance network interface.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContextResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext) isaSecurityGroupTargetReference() bool {
	return true
}

// UnmarshalSecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext unmarshals an instance of SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReferenceNetworkInterfaceReferenceTargetContext)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalNetworkInterfaceReferenceTargetContextDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReferenceVPNServerReference : SecurityGroupTargetReferenceVPNServerReference struct
// This model "extends" SecurityGroupTargetReference
type SecurityGroupTargetReferenceVPNServerReference struct {
	// The CRN for this VPN server.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPNServerReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this VPN server.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN server.
	ID *string `json:"id" validate:"required"`

	// The name for this VPN server. The name is unique across all VPN servers in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SecurityGroupTargetReferenceVPNServerReference.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceVPNServerReferenceResourceTypeVPNServerConst = "vpn_server"
)

func (*SecurityGroupTargetReferenceVPNServerReference) isaSecurityGroupTargetReference() bool {
	return true
}

// UnmarshalSecurityGroupTargetReferenceVPNServerReference unmarshals an instance of SecurityGroupTargetReferenceVPNServerReference from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReferenceVPNServerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReferenceVPNServerReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPNServerReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupTargetReferenceVirtualNetworkInterfaceReference : SecurityGroupTargetReferenceVirtualNetworkInterfaceReference struct
// This model "extends" SecurityGroupTargetReference
type SecurityGroupTargetReferenceVirtualNetworkInterfaceReference struct {
	// The CRN for this virtual network interface.
	CRN *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VirtualNetworkInterfaceReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this virtual network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual network interface.
	ID *string `json:"id" validate:"required"`

	// The name for this virtual network interface. The name is unique across all virtual network interfaces in the VPC.
	Name *string `json:"name" validate:"required"`

	// The primary IP for this virtual network interface.
	PrimaryIP *ReservedIPReference `json:"primary_ip" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the SecurityGroupTargetReferenceVirtualNetworkInterfaceReference.ResourceType property.
// The resource type.
const (
	SecurityGroupTargetReferenceVirtualNetworkInterfaceReferenceResourceTypeVirtualNetworkInterfaceConst = "virtual_network_interface"
)

func (*SecurityGroupTargetReferenceVirtualNetworkInterfaceReference) isaSecurityGroupTargetReference() bool {
	return true
}

// UnmarshalSecurityGroupTargetReferenceVirtualNetworkInterfaceReference unmarshals an instance of SecurityGroupTargetReferenceVirtualNetworkInterfaceReference from the specified map of raw messages.
func UnmarshalSecurityGroupTargetReferenceVirtualNetworkInterfaceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupTargetReferenceVirtualNetworkInterfaceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVirtualNetworkInterfaceReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalReservedIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareIdentityByCRN : ShareIdentityByCRN struct
// This model "extends" ShareIdentity
type ShareIdentityByCRN struct {
	// The CRN for this file share.
	CRN *string `json:"crn" validate:"required"`
}

// NewShareIdentityByCRN : Instantiate ShareIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewShareIdentityByCRN(crn string) (_model *ShareIdentityByCRN, err error) {
	_model = &ShareIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareIdentityByCRN) isaShareIdentity() bool {
	return true
}

// UnmarshalShareIdentityByCRN unmarshals an instance of ShareIdentityByCRN from the specified map of raw messages.
func UnmarshalShareIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareIdentityByHref : ShareIdentityByHref struct
// This model "extends" ShareIdentity
type ShareIdentityByHref struct {
	// The URL for this file share.
	Href *string `json:"href" validate:"required"`
}

// NewShareIdentityByHref : Instantiate ShareIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewShareIdentityByHref(href string) (_model *ShareIdentityByHref, err error) {
	_model = &ShareIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareIdentityByHref) isaShareIdentity() bool {
	return true
}

// UnmarshalShareIdentityByHref unmarshals an instance of ShareIdentityByHref from the specified map of raw messages.
func UnmarshalShareIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareIdentityByID : ShareIdentityByID struct
// This model "extends" ShareIdentity
type ShareIdentityByID struct {
	// The unique identifier for this file share.
	ID *string `json:"id" validate:"required"`
}

// NewShareIdentityByID : Instantiate ShareIdentityByID (Generic Model Constructor)
func (*VpcV1) NewShareIdentityByID(id string) (_model *ShareIdentityByID, err error) {
	_model = &ShareIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareIdentityByID) isaShareIdentity() bool {
	return true
}

// UnmarshalShareIdentityByID unmarshals an instance of ShareIdentityByID from the specified map of raw messages.
func UnmarshalShareIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup : The virtual network interface for this share mount target. The virtual network interface's VPC must not be used by a
// virtual network interface for another mount target for this share.
//
// Required if the share's `access_control_mode` is `security_group`.
// This model "extends" ShareMountTargetPrototype
type ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup struct {
	// The name for this share mount target. The name must not be used by another mount target for the file share.
	Name *string `json:"name,omitempty"`

	// The transit encryption mode to use for this share mount target:
	// - `none`: Not encrypted in transit.
	// - `user_managed`: Encrypted in transit using an instance identity certificate.  The
	//                   `access_control_mode` for the share must be `security_group`.
	TransitEncryption *string `json:"transit_encryption,omitempty"`

	VirtualNetworkInterface ShareMountTargetVirtualNetworkInterfacePrototypeIntf `json:"virtual_network_interface" validate:"required"`
}

// Constants associated with the ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup.TransitEncryption property.
// The transit encryption mode to use for this share mount target:
//   - `none`: Not encrypted in transit.
//   - `user_managed`: Encrypted in transit using an instance identity certificate.  The
//     `access_control_mode` for the share must be `security_group`.
const (
	ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroupTransitEncryptionNoneConst        = "none"
	ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroupTransitEncryptionUserManagedConst = "user_managed"
)

// NewShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup : Instantiate ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup (Generic Model Constructor)
func (*VpcV1) NewShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup(virtualNetworkInterface ShareMountTargetVirtualNetworkInterfacePrototypeIntf) (_model *ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup, err error) {
	_model = &ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup{
		VirtualNetworkInterface: virtualNetworkInterface,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup) isaShareMountTargetPrototype() bool {
	return true
}

// UnmarshalShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup unmarshals an instance of ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup from the specified map of raw messages.
func UnmarshalShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetPrototypeShareMountTargetByAccessControlModeSecurityGroup)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_encryption", &obj.TransitEncryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtual_network_interface", &obj.VirtualNetworkInterface, UnmarshalShareMountTargetVirtualNetworkInterfacePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC : The VPC in which clients can mount the file share using this mount target.  The VPC must not be used by another mount
// target for this share.
//
// Required if the share's `access_control_mode` is `vpc`.
// This model "extends" ShareMountTargetPrototype
type ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC struct {
	// The name for this share mount target. The name must not be used by another mount target for the file share.
	Name *string `json:"name,omitempty"`

	// The transit encryption mode to use for this share mount target:
	// - `none`: Not encrypted in transit.
	// - `user_managed`: Encrypted in transit using an instance identity certificate.  The
	//                   `access_control_mode` for the share must be `security_group`.
	TransitEncryption *string `json:"transit_encryption,omitempty"`

	// Identifies a VPC by a unique property.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`
}

// Constants associated with the ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC.TransitEncryption property.
// The transit encryption mode to use for this share mount target:
//   - `none`: Not encrypted in transit.
//   - `user_managed`: Encrypted in transit using an instance identity certificate.  The
//     `access_control_mode` for the share must be `security_group`.
const (
	ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPCTransitEncryptionNoneConst        = "none"
	ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPCTransitEncryptionUserManagedConst = "user_managed"
)

// NewShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC : Instantiate ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC (Generic Model Constructor)
func (*VpcV1) NewShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC(vpc VPCIdentityIntf) (_model *ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC, err error) {
	_model = &ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC{
		VPC: vpc,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC) isaShareMountTargetPrototype() bool {
	return true
}

// UnmarshalShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC unmarshals an instance of ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC from the specified map of raw messages.
func UnmarshalShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetPrototypeShareMountTargetByAccessControlModeVPC)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_encryption", &obj.TransitEncryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext : The virtual network interface for this target.
// This model "extends" ShareMountTargetVirtualNetworkInterfacePrototype
type ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext struct {
	// The name for this virtual network interface. The name must not be used by another virtual network interface in the
	// VPC. If unspecified, the name will be a hyphenated list of randomly-selected words. Names beginning with `ibm-` are
	// reserved for provider-owned resources, and are not allowed.
	Name *string `json:"name,omitempty"`

	// The primary IP address to bind to the virtual network interface. May be either a
	// reserved IP identity, or a reserved IP prototype object which will be used to create a
	// new reserved IP.
	//
	// If a reserved IP identity is provided, the specified reserved IP must be unbound.
	//
	// If a reserved IP prototype object with an address is provided, the address must be
	// available on the virtual network interface's subnet. If no address is specified,
	// an available address on the subnet will be automatically selected and reserved.
	PrimaryIP VirtualNetworkInterfacePrimaryIPPrototypeIntf `json:"primary_ip,omitempty"`

	// The resource group to use for this virtual network interface. If unspecified, the
	// share's resource group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The security groups to use for this virtual network interface. If unspecified, the default security group of the VPC
	// for the subnet is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet. Required if `primary_ip` does not specify a reserved IP.
	Subnet SubnetIdentityIntf `json:"subnet,omitempty"`
}

func (*ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext) isaShareMountTargetVirtualNetworkInterfacePrototype() bool {
	return true
}

// UnmarshalShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext unmarshals an instance of ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext from the specified map of raw messages.
func UnmarshalShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareMountTargetVirtualNetworkInterfacePrototypeVirtualNetworkInterfacePrototypeShareMountTargetContext)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_ip", &obj.PrimaryIP, UnmarshalVirtualNetworkInterfacePrimaryIPPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCapacityDependentRange : The permitted total capacity (in gigabytes) of a share with this profile depends on its configuration.
// This model "extends" ShareProfileCapacity
type ShareProfileCapacityDependentRange struct {
	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the ShareProfileCapacityDependentRange.Type property.
// The type for this profile field.
const (
	ShareProfileCapacityDependentRangeTypeDependentConst      = "dependent"
	ShareProfileCapacityDependentRangeTypeDependentRangeConst = "dependent_range"
)

func (*ShareProfileCapacityDependentRange) isaShareProfileCapacity() bool {
	return true
}

// UnmarshalShareProfileCapacityDependentRange unmarshals an instance of ShareProfileCapacityDependentRange from the specified map of raw messages.
func UnmarshalShareProfileCapacityDependentRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCapacityDependentRange)
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCapacityEnum : The permitted total capacities (in gigabytes) of a share with this profile.
// This model "extends" ShareProfileCapacity
type ShareProfileCapacityEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the ShareProfileCapacityEnum.Type property.
// The type for this profile field.
const (
	ShareProfileCapacityEnumTypeEnumConst = "enum"
)

func (*ShareProfileCapacityEnum) isaShareProfileCapacity() bool {
	return true
}

// UnmarshalShareProfileCapacityEnum unmarshals an instance of ShareProfileCapacityEnum from the specified map of raw messages.
func UnmarshalShareProfileCapacityEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCapacityEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCapacityFixed : The permitted total capacity (in gigabytes) of a share with this profile is fixed.
// This model "extends" ShareProfileCapacity
type ShareProfileCapacityFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the ShareProfileCapacityFixed.Type property.
// The type for this profile field.
const (
	ShareProfileCapacityFixedTypeFixedConst = "fixed"
)

func (*ShareProfileCapacityFixed) isaShareProfileCapacity() bool {
	return true
}

// UnmarshalShareProfileCapacityFixed unmarshals an instance of ShareProfileCapacityFixed from the specified map of raw messages.
func UnmarshalShareProfileCapacityFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCapacityFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileCapacityRange : The permitted total capacity range (in gigabytes) of a share with this profile.
// This model "extends" ShareProfileCapacity
type ShareProfileCapacityRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the ShareProfileCapacityRange.Type property.
// The type for this profile field.
const (
	ShareProfileCapacityRangeTypeRangeConst = "range"
)

func (*ShareProfileCapacityRange) isaShareProfileCapacity() bool {
	return true
}

// UnmarshalShareProfileCapacityRange unmarshals an instance of ShareProfileCapacityRange from the specified map of raw messages.
func UnmarshalShareProfileCapacityRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileCapacityRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIopsDependentRange : The permitted IOPS range of a share with this profile depends on its configuration.
// This model "extends" ShareProfileIops
type ShareProfileIopsDependentRange struct {
	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the ShareProfileIopsDependentRange.Type property.
// The type for this profile field.
const (
	ShareProfileIopsDependentRangeTypeDependentConst      = "dependent"
	ShareProfileIopsDependentRangeTypeDependentRangeConst = "dependent_range"
)

func (*ShareProfileIopsDependentRange) isaShareProfileIops() bool {
	return true
}

// UnmarshalShareProfileIopsDependentRange unmarshals an instance of ShareProfileIopsDependentRange from the specified map of raw messages.
func UnmarshalShareProfileIopsDependentRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIopsDependentRange)
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIopsEnum : The permitted IOPS values of a share with this profile.
// This model "extends" ShareProfileIops
type ShareProfileIopsEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the ShareProfileIopsEnum.Type property.
// The type for this profile field.
const (
	ShareProfileIopsEnumTypeEnumConst = "enum"
)

func (*ShareProfileIopsEnum) isaShareProfileIops() bool {
	return true
}

// UnmarshalShareProfileIopsEnum unmarshals an instance of ShareProfileIopsEnum from the specified map of raw messages.
func UnmarshalShareProfileIopsEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIopsEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIopsFixed : The permitted IOPS of a share with this profile is fixed.
// This model "extends" ShareProfileIops
type ShareProfileIopsFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the ShareProfileIopsFixed.Type property.
// The type for this profile field.
const (
	ShareProfileIopsFixedTypeFixedConst = "fixed"
)

func (*ShareProfileIopsFixed) isaShareProfileIops() bool {
	return true
}

// UnmarshalShareProfileIopsFixed unmarshals an instance of ShareProfileIopsFixed from the specified map of raw messages.
func UnmarshalShareProfileIopsFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIopsFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIopsRange : The permitted IOPS range of a share with this profile.
// This model "extends" ShareProfileIops
type ShareProfileIopsRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the ShareProfileIopsRange.Type property.
// The type for this profile field.
const (
	ShareProfileIopsRangeTypeRangeConst = "range"
)

func (*ShareProfileIopsRange) isaShareProfileIops() bool {
	return true
}

// UnmarshalShareProfileIopsRange unmarshals an instance of ShareProfileIopsRange from the specified map of raw messages.
func UnmarshalShareProfileIopsRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIopsRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIdentityByHref : ShareProfileIdentityByHref struct
// This model "extends" ShareProfileIdentity
type ShareProfileIdentityByHref struct {
	// The URL for this share profile.
	Href *string `json:"href" validate:"required"`
}

// NewShareProfileIdentityByHref : Instantiate ShareProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewShareProfileIdentityByHref(href string) (_model *ShareProfileIdentityByHref, err error) {
	_model = &ShareProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareProfileIdentityByHref) isaShareProfileIdentity() bool {
	return true
}

// UnmarshalShareProfileIdentityByHref unmarshals an instance of ShareProfileIdentityByHref from the specified map of raw messages.
func UnmarshalShareProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShareProfileIdentityByName : ShareProfileIdentityByName struct
// This model "extends" ShareProfileIdentity
type ShareProfileIdentityByName struct {
	// The globally unique name for this share profile.
	Name *string `json:"name" validate:"required"`
}

// NewShareProfileIdentityByName : Instantiate ShareProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewShareProfileIdentityByName(name string) (_model *ShareProfileIdentityByName, err error) {
	_model = &ShareProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ShareProfileIdentityByName) isaShareProfileIdentity() bool {
	return true
}

// UnmarshalShareProfileIdentityByName unmarshals an instance of ShareProfileIdentityByName from the specified map of raw messages.
func UnmarshalShareProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShareProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharePrototypeShareBySize : Create a file share by size.
// This model "extends" SharePrototype
type SharePrototypeShareBySize struct {
	// The maximum input/output operations per second (IOPS) for the file share. The share must be in the
	// `defined_performance` profile family, and the value must be in the range supported by the share's specified size.
	//
	// In addition, each client accessing the share will be restricted to 48,000 IOPS.
	Iops *int64 `json:"iops,omitempty"`

	// The mount targets for the file share. Each mount target must be in a unique VPC.
	MountTargets []ShareMountTargetPrototypeIntf `json:"mount_targets,omitempty"`

	// The name for this share. The name must not be used by another share in the region. If unspecified, the name will be
	// a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use for this file share. The
	// profile must support the share's specified IOPS and size.
	Profile ShareProfileIdentityIntf `json:"profile" validate:"required"`

	ReplicaShare *SharePrototypeShareContext `json:"replica_share,omitempty"`

	// Tags for this resource.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this file share will reside in. For a replica share, this must be a different zone in the same region as
	// the source share.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The access control mode for the share:
	//
	// - `security_group`: The security groups on the virtual network interface for a
	//   mount target control access to the mount target. Mount targets for this share
	//   require a virtual network interface.
	// - `vpc`: All clients in the VPC for a mount target have access to the mount target.
	//   Mount targets for this share require a VPC.
	AccessControlMode *string `json:"access_control_mode,omitempty"`

	// The root key to use to wrap the data encryption key for the share.
	//
	// If unspecified, the `encryption` type for the share will be `provider_managed`.
	//
	// The specified key may be in a different account, subject to IAM policies.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The owner assigned to the file share at creation. Subsequent changes to the owner
	// must be performed by a client that has mounted the file share.
	InitialOwner *ShareInitialOwner `json:"initial_owner,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The size of the file share rounded up to the next gigabyte.
	//
	// The maximum size for a share may increase in the future.
	Size *int64 `json:"size" validate:"required"`
}

// Constants associated with the SharePrototypeShareBySize.AccessControlMode property.
// The access control mode for the share:
//
//   - `security_group`: The security groups on the virtual network interface for a
//     mount target control access to the mount target. Mount targets for this share
//     require a virtual network interface.
//   - `vpc`: All clients in the VPC for a mount target have access to the mount target.
//     Mount targets for this share require a VPC.
const (
	SharePrototypeShareBySizeAccessControlModeSecurityGroupConst = "security_group"
	SharePrototypeShareBySizeAccessControlModeVPCConst           = "vpc"
)

// NewSharePrototypeShareBySize : Instantiate SharePrototypeShareBySize (Generic Model Constructor)
func (*VpcV1) NewSharePrototypeShareBySize(profile ShareProfileIdentityIntf, zone ZoneIdentityIntf, size int64) (_model *SharePrototypeShareBySize, err error) {
	_model = &SharePrototypeShareBySize{
		Profile: profile,
		Zone:    zone,
		Size:    core.Int64Ptr(size),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SharePrototypeShareBySize) isaSharePrototype() bool {
	return true
}

// UnmarshalSharePrototypeShareBySize unmarshals an instance of SharePrototypeShareBySize from the specified map of raw messages.
func UnmarshalSharePrototypeShareBySize(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharePrototypeShareBySize)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "mount_targets", &obj.MountTargets, UnmarshalShareMountTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalShareProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "replica_share", &obj.ReplicaShare, UnmarshalSharePrototypeShareContext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "access_control_mode", &obj.AccessControlMode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "initial_owner", &obj.InitialOwner, UnmarshalShareInitialOwner)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharePrototypeShareBySourceShare : Create a replica file share for an existing file share. The values for `access_control_mode`,
// `encryption_key`, `initial_owner`, and `size` will be inherited from `source_share`.
// This model "extends" SharePrototype
type SharePrototypeShareBySourceShare struct {
	// The maximum input/output operations per second (IOPS) for the file share. The share must be in the
	// `defined_performance` profile family, and the value must be in the range supported by the share's specified size.
	//
	// In addition, each client accessing the share will be restricted to 48,000 IOPS.
	Iops *int64 `json:"iops,omitempty"`

	// The mount targets for the file share. Each mount target must be in a unique VPC.
	MountTargets []ShareMountTargetPrototypeIntf `json:"mount_targets,omitempty"`

	// The name for this share. The name must not be used by another share in the region. If unspecified, the name will be
	// a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles) to use for this file share. The
	// profile must support the share's specified IOPS and size.
	Profile ShareProfileIdentityIntf `json:"profile" validate:"required"`

	ReplicaShare *SharePrototypeShareContext `json:"replica_share,omitempty"`

	// Tags for this resource.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this file share will reside in. For a replica share, this must be a different zone in the same region as
	// the source share.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The cron specification for the file share replication schedule.
	//
	// Replication of a share can be scheduled to occur at most once per hour.
	ReplicationCronSpec *string `json:"replication_cron_spec" validate:"required"`

	// The resource group to use. If unspecified, the resource group from
	// the source share will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The source file share for this replica file share. The specified file share must not
	// already have a replica, and must not be a replica.
	SourceShare ShareIdentityIntf `json:"source_share" validate:"required"`
}

// NewSharePrototypeShareBySourceShare : Instantiate SharePrototypeShareBySourceShare (Generic Model Constructor)
func (*VpcV1) NewSharePrototypeShareBySourceShare(profile ShareProfileIdentityIntf, zone ZoneIdentityIntf, replicationCronSpec string, sourceShare ShareIdentityIntf) (_model *SharePrototypeShareBySourceShare, err error) {
	_model = &SharePrototypeShareBySourceShare{
		Profile:             profile,
		Zone:                zone,
		ReplicationCronSpec: core.StringPtr(replicationCronSpec),
		SourceShare:         sourceShare,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SharePrototypeShareBySourceShare) isaSharePrototype() bool {
	return true
}

// UnmarshalSharePrototypeShareBySourceShare unmarshals an instance of SharePrototypeShareBySourceShare from the specified map of raw messages.
func UnmarshalSharePrototypeShareBySourceShare(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharePrototypeShareBySourceShare)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "mount_targets", &obj.MountTargets, UnmarshalShareMountTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalShareProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "replica_share", &obj.ReplicaShare, UnmarshalSharePrototypeShareContext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replication_cron_spec", &obj.ReplicationCronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_share", &obj.SourceShare, UnmarshalShareIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotIdentityByCRN : SnapshotIdentityByCRN struct
// This model "extends" SnapshotIdentity
type SnapshotIdentityByCRN struct {
	// The CRN of this snapshot.
	CRN *string `json:"crn" validate:"required"`
}

// NewSnapshotIdentityByCRN : Instantiate SnapshotIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSnapshotIdentityByCRN(crn string) (_model *SnapshotIdentityByCRN, err error) {
	_model = &SnapshotIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SnapshotIdentityByCRN) isaSnapshotIdentity() bool {
	return true
}

// UnmarshalSnapshotIdentityByCRN unmarshals an instance of SnapshotIdentityByCRN from the specified map of raw messages.
func UnmarshalSnapshotIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotIdentityByHref : SnapshotIdentityByHref struct
// This model "extends" SnapshotIdentity
type SnapshotIdentityByHref struct {
	// The URL for this snapshot.
	Href *string `json:"href" validate:"required"`
}

// NewSnapshotIdentityByHref : Instantiate SnapshotIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSnapshotIdentityByHref(href string) (_model *SnapshotIdentityByHref, err error) {
	_model = &SnapshotIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SnapshotIdentityByHref) isaSnapshotIdentity() bool {
	return true
}

// UnmarshalSnapshotIdentityByHref unmarshals an instance of SnapshotIdentityByHref from the specified map of raw messages.
func UnmarshalSnapshotIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotIdentityByID : SnapshotIdentityByID struct
// This model "extends" SnapshotIdentity
type SnapshotIdentityByID struct {
	// The unique identifier for this snapshot.
	ID *string `json:"id" validate:"required"`
}

// NewSnapshotIdentityByID : Instantiate SnapshotIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSnapshotIdentityByID(id string) (_model *SnapshotIdentityByID, err error) {
	_model = &SnapshotIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SnapshotIdentityByID) isaSnapshotIdentity() bool {
	return true
}

// UnmarshalSnapshotIdentityByID unmarshals an instance of SnapshotIdentityByID from the specified map of raw messages.
func UnmarshalSnapshotIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotPrototypeSnapshotBySourceSnapshot : SnapshotPrototypeSnapshotBySourceSnapshot struct
// This model "extends" SnapshotPrototype
type SnapshotPrototypeSnapshotBySourceSnapshot struct {
	// Clones to create for this snapshot.
	Clones []SnapshotClonePrototype `json:"clones,omitempty"`

	// The name for this snapshot. The name must not be used by another snapshot in the region. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot.
	UserTags []string `json:"user_tags,omitempty"`

	// The root key to use to wrap the data encryption key for this snapshot.
	//
	// A key must be specified if and only if the source snapshot has an `encryption` type of
	// `user_managed`. To maximize snapshot availability and sharing of snapshot data, specify
	// a key in the same region as the new snapshot, and use the same encryption key for all
	// snapshots using the same source volume.
	//
	// The specified key may be in a different account, subject to IAM policies.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The source snapshot (in another region) to create this snapshot from.
	// The specified snapshot must not already be the source of another snapshot in this
	// region.
	SourceSnapshot *SnapshotIdentityByCRN `json:"source_snapshot" validate:"required"`
}

// NewSnapshotPrototypeSnapshotBySourceSnapshot : Instantiate SnapshotPrototypeSnapshotBySourceSnapshot (Generic Model Constructor)
func (*VpcV1) NewSnapshotPrototypeSnapshotBySourceSnapshot(sourceSnapshot *SnapshotIdentityByCRN) (_model *SnapshotPrototypeSnapshotBySourceSnapshot, err error) {
	_model = &SnapshotPrototypeSnapshotBySourceSnapshot{
		SourceSnapshot: sourceSnapshot,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SnapshotPrototypeSnapshotBySourceSnapshot) isaSnapshotPrototype() bool {
	return true
}

// UnmarshalSnapshotPrototypeSnapshotBySourceSnapshot unmarshals an instance of SnapshotPrototypeSnapshotBySourceSnapshot from the specified map of raw messages.
func UnmarshalSnapshotPrototypeSnapshotBySourceSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotPrototypeSnapshotBySourceSnapshot)
	err = core.UnmarshalModel(m, "clones", &obj.Clones, UnmarshalSnapshotClonePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentityByCRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotPrototypeSnapshotBySourceVolume : SnapshotPrototypeSnapshotBySourceVolume struct
// This model "extends" SnapshotPrototype
type SnapshotPrototypeSnapshotBySourceVolume struct {
	// Clones to create for this snapshot.
	Clones []SnapshotClonePrototype `json:"clones,omitempty"`

	// The name for this snapshot. The name must not be used by another snapshot in the region. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this snapshot.
	UserTags []string `json:"user_tags,omitempty"`

	// The volume to create this snapshot from.
	SourceVolume VolumeIdentityIntf `json:"source_volume" validate:"required"`
}

// NewSnapshotPrototypeSnapshotBySourceVolume : Instantiate SnapshotPrototypeSnapshotBySourceVolume (Generic Model Constructor)
func (*VpcV1) NewSnapshotPrototypeSnapshotBySourceVolume(sourceVolume VolumeIdentityIntf) (_model *SnapshotPrototypeSnapshotBySourceVolume, err error) {
	_model = &SnapshotPrototypeSnapshotBySourceVolume{
		SourceVolume: sourceVolume,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SnapshotPrototypeSnapshotBySourceVolume) isaSnapshotPrototype() bool {
	return true
}

// UnmarshalSnapshotPrototypeSnapshotBySourceVolume unmarshals an instance of SnapshotPrototypeSnapshotBySourceVolume from the specified map of raw messages.
func UnmarshalSnapshotPrototypeSnapshotBySourceVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotPrototypeSnapshotBySourceVolume)
	err = core.UnmarshalModel(m, "clones", &obj.Clones, UnmarshalSnapshotClonePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_volume", &obj.SourceVolume, UnmarshalVolumeIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByCRN : SubnetIdentityByCRN struct
// This model "extends" SubnetIdentity
type SubnetIdentityByCRN struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`
}

// NewSubnetIdentityByCRN : Instantiate SubnetIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByCRN(crn string) (_model *SubnetIdentityByCRN, err error) {
	_model = &SubnetIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetIdentityByCRN) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByCRN unmarshals an instance of SubnetIdentityByCRN from the specified map of raw messages.
func UnmarshalSubnetIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByHref : SubnetIdentityByHref struct
// This model "extends" SubnetIdentity
type SubnetIdentityByHref struct {
	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`
}

// NewSubnetIdentityByHref : Instantiate SubnetIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByHref(href string) (_model *SubnetIdentityByHref, err error) {
	_model = &SubnetIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetIdentityByHref) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByHref unmarshals an instance of SubnetIdentityByHref from the specified map of raw messages.
func UnmarshalSubnetIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByID : SubnetIdentityByID struct
// This model "extends" SubnetIdentity
type SubnetIdentityByID struct {
	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`
}

// NewSubnetIdentityByID : Instantiate SubnetIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByID(id string) (_model *SubnetIdentityByID, err error) {
	_model = &SubnetIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetIdentityByID) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByID unmarshals an instance of SubnetIdentityByID from the specified map of raw messages.
func UnmarshalSubnetIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPrototypeSubnetByCIDR : SubnetPrototypeSubnetByCIDR struct
// This model "extends" SubnetPrototype
type SubnetPrototypeSubnetByCIDR struct {
	// The IP version(s) to support for this subnet.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this subnet. The name must not be used by another subnet in the VPC. If unspecified, the name will be a
	// hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to use for internet-bound traffic for this subnet. If unspecified, the subnet will not be
	// attached to a public gateway.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The routing table to use for this subnet. If unspecified, the default routing table for the VPC is used. The routing
	// table properties `route_direct_link_ingress`,
	// `route_internet_ingress`, `route_transit_gateway_ingress`, and
	// `route_vpc_zone_ingress` must be `false`.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// The VPC the subnet will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be between `/9`
	// (8,388,608 addresses) and `/29` (8 addresses). The IPv4 range of the subnet's CIDR must fall within an existing
	// address prefix in the VPC and must not overlap with any existing subnet. The subnet will be created in the zone of
	// the address prefix that contains the IPv4 CIDR. If zone is specified, it must match the zone of the address prefix
	// that contains the subnet's IPv4 CIDR.
	Ipv4CIDRBlock *string `json:"ipv4_cidr_block" validate:"required"`

	// The zone this subnet will reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// Constants associated with the SubnetPrototypeSubnetByCIDR.IPVersion property.
// The IP version(s) to support for this subnet.
const (
	SubnetPrototypeSubnetByCIDRIPVersionIpv4Const = "ipv4"
)

// NewSubnetPrototypeSubnetByCIDR : Instantiate SubnetPrototypeSubnetByCIDR (Generic Model Constructor)
func (*VpcV1) NewSubnetPrototypeSubnetByCIDR(vpc VPCIdentityIntf, ipv4CIDRBlock string) (_model *SubnetPrototypeSubnetByCIDR, err error) {
	_model = &SubnetPrototypeSubnetByCIDR{
		VPC:           vpc,
		Ipv4CIDRBlock: core.StringPtr(ipv4CIDRBlock),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetPrototypeSubnetByCIDR) isaSubnetPrototype() bool {
	return true
}

// UnmarshalSubnetPrototypeSubnetByCIDR unmarshals an instance of SubnetPrototypeSubnetByCIDR from the specified map of raw messages.
func UnmarshalSubnetPrototypeSubnetByCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPrototypeSubnetByCIDR)
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4_cidr_block", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPrototypeSubnetByTotalCount : SubnetPrototypeSubnetByTotalCount struct
// This model "extends" SubnetPrototype
type SubnetPrototypeSubnetByTotalCount struct {
	// The IP version(s) to support for this subnet.
	IPVersion *string `json:"ip_version,omitempty"`

	// The name for this subnet. The name must not be used by another subnet in the VPC. If unspecified, the name will be a
	// hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to use for internet-bound traffic for this subnet. If unspecified, the subnet will not be
	// attached to a public gateway.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The routing table to use for this subnet. If unspecified, the default routing table for the VPC is used. The routing
	// table properties `route_direct_link_ingress`,
	// `route_internet_ingress`, `route_transit_gateway_ingress`, and
	// `route_vpc_zone_ingress` must be `false`.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// The VPC the subnet will reside in.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address prefix in the
	// specified zone, and that prefix must have a free CIDR range with at least this number of addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count" validate:"required"`

	// The zone this subnet will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// Constants associated with the SubnetPrototypeSubnetByTotalCount.IPVersion property.
// The IP version(s) to support for this subnet.
const (
	SubnetPrototypeSubnetByTotalCountIPVersionIpv4Const = "ipv4"
)

// NewSubnetPrototypeSubnetByTotalCount : Instantiate SubnetPrototypeSubnetByTotalCount (Generic Model Constructor)
func (*VpcV1) NewSubnetPrototypeSubnetByTotalCount(vpc VPCIdentityIntf, totalIpv4AddressCount int64, zone ZoneIdentityIntf) (_model *SubnetPrototypeSubnetByTotalCount, err error) {
	_model = &SubnetPrototypeSubnetByTotalCount{
		VPC:                   vpc,
		TotalIpv4AddressCount: core.Int64Ptr(totalIpv4AddressCount),
		Zone:                  zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetPrototypeSubnetByTotalCount) isaSubnetPrototype() bool {
	return true
}

// UnmarshalSubnetPrototypeSubnetByTotalCount unmarshals an instance of SubnetPrototypeSubnetByTotalCount from the specified map of raw messages.
func UnmarshalSubnetPrototypeSubnetByTotalCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPrototypeSubnetByTotalCount)
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_ipv4_address_count", &obj.TotalIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPublicGatewayPatchPublicGatewayIdentityByCRN : SubnetPublicGatewayPatchPublicGatewayIdentityByCRN struct
// This model "extends" SubnetPublicGatewayPatch
type SubnetPublicGatewayPatchPublicGatewayIdentityByCRN struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`
}

// NewSubnetPublicGatewayPatchPublicGatewayIdentityByCRN : Instantiate SubnetPublicGatewayPatchPublicGatewayIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSubnetPublicGatewayPatchPublicGatewayIdentityByCRN(crn string) (_model *SubnetPublicGatewayPatchPublicGatewayIdentityByCRN, err error) {
	_model = &SubnetPublicGatewayPatchPublicGatewayIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetPublicGatewayPatchPublicGatewayIdentityByCRN) isaSubnetPublicGatewayPatch() bool {
	return true
}

// UnmarshalSubnetPublicGatewayPatchPublicGatewayIdentityByCRN unmarshals an instance of SubnetPublicGatewayPatchPublicGatewayIdentityByCRN from the specified map of raw messages.
func UnmarshalSubnetPublicGatewayPatchPublicGatewayIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPublicGatewayPatchPublicGatewayIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPublicGatewayPatchPublicGatewayIdentityByHref : SubnetPublicGatewayPatchPublicGatewayIdentityByHref struct
// This model "extends" SubnetPublicGatewayPatch
type SubnetPublicGatewayPatchPublicGatewayIdentityByHref struct {
	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`
}

// NewSubnetPublicGatewayPatchPublicGatewayIdentityByHref : Instantiate SubnetPublicGatewayPatchPublicGatewayIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSubnetPublicGatewayPatchPublicGatewayIdentityByHref(href string) (_model *SubnetPublicGatewayPatchPublicGatewayIdentityByHref, err error) {
	_model = &SubnetPublicGatewayPatchPublicGatewayIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetPublicGatewayPatchPublicGatewayIdentityByHref) isaSubnetPublicGatewayPatch() bool {
	return true
}

// UnmarshalSubnetPublicGatewayPatchPublicGatewayIdentityByHref unmarshals an instance of SubnetPublicGatewayPatchPublicGatewayIdentityByHref from the specified map of raw messages.
func UnmarshalSubnetPublicGatewayPatchPublicGatewayIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPublicGatewayPatchPublicGatewayIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPublicGatewayPatchPublicGatewayIdentityByID : SubnetPublicGatewayPatchPublicGatewayIdentityByID struct
// This model "extends" SubnetPublicGatewayPatch
type SubnetPublicGatewayPatchPublicGatewayIdentityByID struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`
}

// NewSubnetPublicGatewayPatchPublicGatewayIdentityByID : Instantiate SubnetPublicGatewayPatchPublicGatewayIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSubnetPublicGatewayPatchPublicGatewayIdentityByID(id string) (_model *SubnetPublicGatewayPatchPublicGatewayIdentityByID, err error) {
	_model = &SubnetPublicGatewayPatchPublicGatewayIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetPublicGatewayPatchPublicGatewayIdentityByID) isaSubnetPublicGatewayPatch() bool {
	return true
}

// UnmarshalSubnetPublicGatewayPatchPublicGatewayIdentityByID unmarshals an instance of SubnetPublicGatewayPatchPublicGatewayIdentityByID from the specified map of raw messages.
func UnmarshalSubnetPublicGatewayPatchPublicGatewayIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPublicGatewayPatchPublicGatewayIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TrustedProfileIdentityTrustedProfileByCRN : TrustedProfileIdentityTrustedProfileByCRN struct
// This model "extends" TrustedProfileIdentity
type TrustedProfileIdentityTrustedProfileByCRN struct {
	// The CRN for this trusted profile.
	CRN *string `json:"crn" validate:"required"`
}

// NewTrustedProfileIdentityTrustedProfileByCRN : Instantiate TrustedProfileIdentityTrustedProfileByCRN (Generic Model Constructor)
func (*VpcV1) NewTrustedProfileIdentityTrustedProfileByCRN(crn string) (_model *TrustedProfileIdentityTrustedProfileByCRN, err error) {
	_model = &TrustedProfileIdentityTrustedProfileByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*TrustedProfileIdentityTrustedProfileByCRN) isaTrustedProfileIdentity() bool {
	return true
}

// UnmarshalTrustedProfileIdentityTrustedProfileByCRN unmarshals an instance of TrustedProfileIdentityTrustedProfileByCRN from the specified map of raw messages.
func UnmarshalTrustedProfileIdentityTrustedProfileByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TrustedProfileIdentityTrustedProfileByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TrustedProfileIdentityTrustedProfileByID : TrustedProfileIdentityTrustedProfileByID struct
// This model "extends" TrustedProfileIdentity
type TrustedProfileIdentityTrustedProfileByID struct {
	// The unique identifier for this trusted profile.
	ID *string `json:"id" validate:"required"`
}

// NewTrustedProfileIdentityTrustedProfileByID : Instantiate TrustedProfileIdentityTrustedProfileByID (Generic Model Constructor)
func (*VpcV1) NewTrustedProfileIdentityTrustedProfileByID(id string) (_model *TrustedProfileIdentityTrustedProfileByID, err error) {
	_model = &TrustedProfileIdentityTrustedProfileByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*TrustedProfileIdentityTrustedProfileByID) isaTrustedProfileIdentity() bool {
	return true
}

// UnmarshalTrustedProfileIdentityTrustedProfileByID unmarshals an instance of TrustedProfileIdentityTrustedProfileByID from the specified map of raw messages.
func UnmarshalTrustedProfileIdentityTrustedProfileByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TrustedProfileIdentityTrustedProfileByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype : Manually specify the DNS server addresses for this VPC.
// This model "extends" VpcdnsResolverPrototype
type VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype struct {
	// The DNS servers to use for this VPC. All the DNS servers must either:
	//
	// - have a unique `zone_affinity`, or
	// - not have a `zone_affinity`.
	ManualServers []DnsServerPrototype `json:"manual_servers" validate:"required"`

	// The type of the DNS resolver to use.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype.Type property.
// The type of the DNS resolver to use.
const (
	VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototypeTypeManualConst = "manual"
)

// NewVpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype : Instantiate VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype (Generic Model Constructor)
func (*VpcV1) NewVpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype(manualServers []DnsServerPrototype, typeVar string) (_model *VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype, err error) {
	_model = &VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype{
		ManualServers: manualServers,
		Type:          core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype) isaVpcdnsResolverPrototype() bool {
	return true
}

// UnmarshalVpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype unmarshals an instance of VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype from the specified map of raw messages.
func UnmarshalVpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverPrototypeVpcdnsResolverTypeManualPrototype)
	err = core.UnmarshalModel(m, "manual_servers", &obj.ManualServers, UnmarshalDnsServerPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype : The system will provide DNS server addresses for this VPC. The system-provided DNS server addresses depend on whether
// any endpoint gateways reside in the VPC, and whether a
// [DNS Services](https://cloud.ibm.com/docs/dns-svcs) instance is configured for the VPC.
// This model "extends" VpcdnsResolverPrototype
type VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype struct {
	// The type of the DNS resolver to use.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype.Type property.
// The type of the DNS resolver to use.
const (
	VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototypeTypeSystemConst = "system"
)

func (*VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype) isaVpcdnsResolverPrototype() bool {
	return true
}

// UnmarshalVpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype unmarshals an instance of VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype from the specified map of raw messages.
func UnmarshalVpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverPrototypeVpcdnsResolverTypeSystemPrototype)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverTypeDelegated : The DNS server addresses are delegated to the DNS resolver of another VPC.
// This model "extends" VpcdnsResolver
type VpcdnsResolverTypeDelegated struct {
	// The DNS servers for this VPC. The servers are populated:
	//
	// - by the system when `dns.resolver.type` is `system`
	// - using the DNS servers in `dns.resolver.vpc` when `dns.resolver.type` is `delegated`
	// - using `dns.resolver.manual_servers` when the `dns.resolver.type` is `manual`.
	Servers []DnsServer `json:"servers" validate:"required"`

	// The type of the DNS resolver used for the VPC.
	Type *string `json:"type" validate:"required"`

	// The VPC whose DNS resolver provides the DNS server addresses for this VPC.
	//
	// The VPC may be remote and therefore may not be directly retrievable.
	VPC *VPCReferenceDnsResolverContext `json:"vpc" validate:"required"`
}

// Constants associated with the VpcdnsResolverTypeDelegated.Type property.
// The type of the DNS resolver used for the VPC.
const (
	VpcdnsResolverTypeDelegatedTypeDelegatedConst = "delegated"
)

func (*VpcdnsResolverTypeDelegated) isaVpcdnsResolver() bool {
	return true
}

// UnmarshalVpcdnsResolverTypeDelegated unmarshals an instance of VpcdnsResolverTypeDelegated from the specified map of raw messages.
func UnmarshalVpcdnsResolverTypeDelegated(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverTypeDelegated)
	err = core.UnmarshalModel(m, "servers", &obj.Servers, UnmarshalDnsServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReferenceDnsResolverContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverTypeManual : The DNS server addresses are manually specified.
// This model "extends" VpcdnsResolver
type VpcdnsResolverTypeManual struct {
	// The DNS servers for this VPC. The servers are populated:
	//
	// - by the system when `dns.resolver.type` is `system`
	// - using the DNS servers in `dns.resolver.vpc` when `dns.resolver.type` is `delegated`
	// - using `dns.resolver.manual_servers` when the `dns.resolver.type` is `manual`.
	Servers []DnsServer `json:"servers" validate:"required"`

	// The manually specified DNS servers for this VPC.
	ManualServers []DnsServer `json:"manual_servers" validate:"required"`

	// The type of the DNS resolver used for the VPC.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the VpcdnsResolverTypeManual.Type property.
// The type of the DNS resolver used for the VPC.
const (
	VpcdnsResolverTypeManualTypeManualConst = "manual"
)

func (*VpcdnsResolverTypeManual) isaVpcdnsResolver() bool {
	return true
}

// UnmarshalVpcdnsResolverTypeManual unmarshals an instance of VpcdnsResolverTypeManual from the specified map of raw messages.
func UnmarshalVpcdnsResolverTypeManual(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverTypeManual)
	err = core.UnmarshalModel(m, "servers", &obj.Servers, UnmarshalDnsServer)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manual_servers", &obj.ManualServers, UnmarshalDnsServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverTypeSystem : The DNS server addresses are provided by the system and depend on the configuration.
// This model "extends" VpcdnsResolver
type VpcdnsResolverTypeSystem struct {
	// The DNS servers for this VPC. The servers are populated:
	//
	// - by the system when `dns.resolver.type` is `system`
	// - using the DNS servers in `dns.resolver.vpc` when `dns.resolver.type` is `delegated`
	// - using `dns.resolver.manual_servers` when the `dns.resolver.type` is `manual`.
	Servers []DnsServer `json:"servers" validate:"required"`

	// The configuration of the system DNS resolver for this VPC.
	//
	// - `custom_resolver`: A custom DNS resolver is configured for this VPC.
	//
	// - `private_resolver`: A private DNS resolver is configured for this VPC. Applicable when
	//   the VPC has either or both of the following:
	//
	//     - at least one endpoint gateway residing in it
	//     - a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it
	//
	// - `default`: The provider default DNS resolvers are configured for this VPC.
	//
	//   This system DNS resolver configuration is used when the VPC has:
	//
	//   - no custom DNS resolver configured for it, and
	//   - no endpoint gateways residing in it, and
	//   - no [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it.
	Configuration *string `json:"configuration" validate:"required"`

	// The type of the DNS resolver used for the VPC.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the VpcdnsResolverTypeSystem.Configuration property.
// The configuration of the system DNS resolver for this VPC.
//
// - `custom_resolver`: A custom DNS resolver is configured for this VPC.
//
//   - `private_resolver`: A private DNS resolver is configured for this VPC. Applicable when
//     the VPC has either or both of the following:
//
//   - at least one endpoint gateway residing in it
//
//   - a [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it
//
// - `default`: The provider default DNS resolvers are configured for this VPC.
//
//	This system DNS resolver configuration is used when the VPC has:
//
//	- no custom DNS resolver configured for it, and
//	- no endpoint gateways residing in it, and
//	- no [DNS Services](https://cloud.ibm.com/docs/dns-svcs) private zone configured for it.
const (
	VpcdnsResolverTypeSystemConfigurationCustomResolverConst  = "custom_resolver"
	VpcdnsResolverTypeSystemConfigurationDefaultConst         = "default"
	VpcdnsResolverTypeSystemConfigurationPrivateResolverConst = "private_resolver"
)

// Constants associated with the VpcdnsResolverTypeSystem.Type property.
// The type of the DNS resolver used for the VPC.
const (
	VpcdnsResolverTypeSystemTypeSystemConst = "system"
)

func (*VpcdnsResolverTypeSystem) isaVpcdnsResolver() bool {
	return true
}

// UnmarshalVpcdnsResolverTypeSystem unmarshals an instance of VpcdnsResolverTypeSystem from the specified map of raw messages.
func UnmarshalVpcdnsResolverTypeSystem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverTypeSystem)
	err = core.UnmarshalModel(m, "servers", &obj.Servers, UnmarshalDnsServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "configuration", &obj.Configuration)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverVPCPatchVPCIdentityByCRN : VpcdnsResolverVPCPatchVPCIdentityByCRN struct
// This model "extends" VpcdnsResolverVPCPatch
type VpcdnsResolverVPCPatchVPCIdentityByCRN struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`
}

// NewVpcdnsResolverVPCPatchVPCIdentityByCRN : Instantiate VpcdnsResolverVPCPatchVPCIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVpcdnsResolverVPCPatchVPCIdentityByCRN(crn string) (_model *VpcdnsResolverVPCPatchVPCIdentityByCRN, err error) {
	_model = &VpcdnsResolverVPCPatchVPCIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VpcdnsResolverVPCPatchVPCIdentityByCRN) isaVpcdnsResolverVPCPatch() bool {
	return true
}

// UnmarshalVpcdnsResolverVPCPatchVPCIdentityByCRN unmarshals an instance of VpcdnsResolverVPCPatchVPCIdentityByCRN from the specified map of raw messages.
func UnmarshalVpcdnsResolverVPCPatchVPCIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverVPCPatchVPCIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverVPCPatchVPCIdentityByHref : VpcdnsResolverVPCPatchVPCIdentityByHref struct
// This model "extends" VpcdnsResolverVPCPatch
type VpcdnsResolverVPCPatchVPCIdentityByHref struct {
	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`
}

// NewVpcdnsResolverVPCPatchVPCIdentityByHref : Instantiate VpcdnsResolverVPCPatchVPCIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVpcdnsResolverVPCPatchVPCIdentityByHref(href string) (_model *VpcdnsResolverVPCPatchVPCIdentityByHref, err error) {
	_model = &VpcdnsResolverVPCPatchVPCIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VpcdnsResolverVPCPatchVPCIdentityByHref) isaVpcdnsResolverVPCPatch() bool {
	return true
}

// UnmarshalVpcdnsResolverVPCPatchVPCIdentityByHref unmarshals an instance of VpcdnsResolverVPCPatchVPCIdentityByHref from the specified map of raw messages.
func UnmarshalVpcdnsResolverVPCPatchVPCIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverVPCPatchVPCIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcdnsResolverVPCPatchVPCIdentityByID : VpcdnsResolverVPCPatchVPCIdentityByID struct
// This model "extends" VpcdnsResolverVPCPatch
type VpcdnsResolverVPCPatchVPCIdentityByID struct {
	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`
}

// NewVpcdnsResolverVPCPatchVPCIdentityByID : Instantiate VpcdnsResolverVPCPatchVPCIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVpcdnsResolverVPCPatchVPCIdentityByID(id string) (_model *VpcdnsResolverVPCPatchVPCIdentityByID, err error) {
	_model = &VpcdnsResolverVPCPatchVPCIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VpcdnsResolverVPCPatchVPCIdentityByID) isaVpcdnsResolverVPCPatch() bool {
	return true
}

// UnmarshalVpcdnsResolverVPCPatchVPCIdentityByID unmarshals an instance of VpcdnsResolverVPCPatchVPCIdentityByID from the specified map of raw messages.
func UnmarshalVpcdnsResolverVPCPatchVPCIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcdnsResolverVPCPatchVPCIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentityByCRN : VPCIdentityByCRN struct
// This model "extends" VPCIdentity
type VPCIdentityByCRN struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`
}

// NewVPCIdentityByCRN : Instantiate VPCIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByCRN(crn string) (_model *VPCIdentityByCRN, err error) {
	_model = &VPCIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPCIdentityByCRN) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByCRN unmarshals an instance of VPCIdentityByCRN from the specified map of raw messages.
func UnmarshalVPCIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentityByHref : VPCIdentityByHref struct
// This model "extends" VPCIdentity
type VPCIdentityByHref struct {
	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`
}

// NewVPCIdentityByHref : Instantiate VPCIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByHref(href string) (_model *VPCIdentityByHref, err error) {
	_model = &VPCIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPCIdentityByHref) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByHref unmarshals an instance of VPCIdentityByHref from the specified map of raw messages.
func UnmarshalVPCIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentityByID : VPCIdentityByID struct
// This model "extends" VPCIdentity
type VPCIdentityByID struct {
	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`
}

// NewVPCIdentityByID : Instantiate VPCIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByID(id string) (_model *VPCIdentityByID, err error) {
	_model = &VPCIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPCIdentityByID) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByID unmarshals an instance of VPCIdentityByID from the specified map of raw messages.
func UnmarshalVPCIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref : VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref struct
// This model "extends" VPNGatewayConnectionIkePolicyPatch
type VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref struct {
	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref : Instantiate VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref(href string) (_model *VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref, err error) {
	_model = &VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref) isaVPNGatewayConnectionIkePolicyPatch() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref unmarshals an instance of VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID : VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID struct
// This model "extends" VPNGatewayConnectionIkePolicyPatch
type VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`
}

// NewVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID : Instantiate VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID(id string) (_model *VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID, err error) {
	_model = &VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID) isaVPNGatewayConnectionIkePolicyPatch() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID unmarshals an instance of VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIkePolicyPatchIkePolicyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref : VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref struct
// This model "extends" VPNGatewayConnectionIkePolicyPrototype
type VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref struct {
	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref : Instantiate VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref(href string) (_model *VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref, err error) {
	_model = &VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref) isaVPNGatewayConnectionIkePolicyPrototype() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref unmarshals an instance of VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID : VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID struct
// This model "extends" VPNGatewayConnectionIkePolicyPrototype
type VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`
}

// NewVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID : Instantiate VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID(id string) (_model *VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID, err error) {
	_model = &VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID) isaVPNGatewayConnectionIkePolicyPrototype() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID unmarshals an instance of VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIkePolicyPrototypeIkePolicyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref : VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref struct
// This model "extends" VPNGatewayConnectionIPsecPolicyPatch
type VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref struct {
	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref : Instantiate VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref(href string) (_model *VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref, err error) {
	_model = &VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref) isaVPNGatewayConnectionIPsecPolicyPatch() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref unmarshals an instance of VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID : VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID struct
// This model "extends" VPNGatewayConnectionIPsecPolicyPatch
type VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`
}

// NewVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID : Instantiate VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID(id string) (_model *VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID, err error) {
	_model = &VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID) isaVPNGatewayConnectionIPsecPolicyPatch() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID unmarshals an instance of VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIPsecPolicyPatchIPsecPolicyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref : VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref struct
// This model "extends" VPNGatewayConnectionIPsecPolicyPrototype
type VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref struct {
	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref : Instantiate VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref(href string) (_model *VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref, err error) {
	_model = &VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref) isaVPNGatewayConnectionIPsecPolicyPrototype() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref unmarshals an instance of VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID : VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID struct
// This model "extends" VPNGatewayConnectionIPsecPolicyPrototype
type VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`
}

// NewVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID : Instantiate VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID(id string) (_model *VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID, err error) {
	_model = &VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID) isaVPNGatewayConnectionIPsecPolicyPrototype() bool {
	return true
}

// UnmarshalVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID unmarshals an instance of VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionIPsecPolicyPrototypeIPsecPolicyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch : VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch struct
// This model "extends" VPNGatewayConnectionPatch
type VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	DeadPeerDetection *VPNGatewayConnectionDpdPatch `json:"dead_peer_detection,omitempty"`

	IkePolicy VPNGatewayConnectionIkePolicyPatchIntf `json:"ike_policy,omitempty"`

	IpsecPolicy VPNGatewayConnectionIPsecPolicyPatchIntf `json:"ipsec_policy,omitempty"`

	// The name for this VPN gateway connection. The name must not be used by another connection for the VPN gateway.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address,omitempty"`

	// The pre-shared key.
	Psk *string `json:"psk,omitempty"`

	// Routing protocols are disabled for this VPN gateway connection.
	RoutingProtocol *string `json:"routing_protocol,omitempty"`
}

// Constants associated with the VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch.RoutingProtocol property.
// Routing protocols are disabled for this VPN gateway connection.
const (
	VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatchRoutingProtocolNoneConst = "none"
)

func (*VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch) isaVPNGatewayConnectionPatch() bool {
	return true
}

// UnmarshalVPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch unmarshals an instance of VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpdPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalVPNGatewayConnectionIkePolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalVPNGatewayConnectionIPsecPolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_protocol", &obj.RoutingProtocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch
func (vpnGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch *VPNGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(vpnGatewayConnectionPatchVPNGatewayConnectionStaticRouteModePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// VPNGatewayConnectionPolicyMode : VPNGatewayConnectionPolicyMode struct
// This model "extends" VPNGatewayConnection
type VPNGatewayConnectionPolicyMode struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up" validate:"required"`

	// The authentication mode. Only `psk` is currently supported.
	AuthenticationMode *string `json:"authentication_mode" validate:"required"`

	// The date and time that this VPN gateway connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	DeadPeerDetection *VPNGatewayConnectionDpd `json:"dead_peer_detection" validate:"required"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`

	// The IKE policy. If absent, [auto-negotiation is
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
	IkePolicy *IkePolicyReference `json:"ike_policy,omitempty"`

	// The IPsec policy. If absent, [auto-negotiation is
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
	IpsecPolicy *IPsecPolicyReference `json:"ipsec_policy,omitempty"`

	// The mode of the VPN gateway.
	Mode *string `json:"mode" validate:"required"`

	// The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The pre-shared key.
	Psk *string `json:"psk" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of a VPN gateway connection.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current VPN gateway connection status (if any):
	// - `cannot_authenticate_connection`: Failed to authenticate a connection because of
	//   mismatched IKE ID and PSK (check IKE ID and PSK in peer VPN configuration)
	// - `internal_error`: Internal error (contact IBM support)
	// - `ike_policy_mismatch`: None of the proposed IKE crypto suites was acceptable (check
	//    the IKE policies on both sides of the VPN)
	// - `ike_v1_id_local_remote_cidr_mismatch`: Invalid IKE ID or mismatched local CIDRs and
	//   remote CIDRs in IKE V1 (check the IKE ID or the local CIDRs and remote CIDRs in IKE
	//   V1 configuration)
	// - `ike_v2_local_remote_cidr_mismatch`: Mismatched local CIDRs and remote CIDRs in IKE
	//   V2 (check the local CIDRs and remote CIDRs in IKE V2 configuration)
	// - `ipsec_policy_mismatch`: None of the proposed IPsec crypto suites was acceptable
	//   (check the IPsec policies on both sides of the VPN)
	// - `peer_not_responding`: No response from peer (check network ACL configuration, peer
	//   availability, and on-premise firewall configuration)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []VPNGatewayConnectionStatusReason `json:"status_reasons" validate:"required"`

	// The local CIDRs for this resource.
	LocalCIDRs []string `json:"local_cidrs" validate:"required"`

	// The peer CIDRs for this resource.
	PeerCIDRs []string `json:"peer_cidrs" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionPolicyMode.AuthenticationMode property.
// The authentication mode. Only `psk` is currently supported.
const (
	VPNGatewayConnectionPolicyModeAuthenticationModePskConst = "psk"
)

// Constants associated with the VPNGatewayConnectionPolicyMode.Mode property.
// The mode of the VPN gateway.
const (
	VPNGatewayConnectionPolicyModeModePolicyConst = "policy"
	VPNGatewayConnectionPolicyModeModeRouteConst  = "route"
)

// Constants associated with the VPNGatewayConnectionPolicyMode.ResourceType property.
// The resource type.
const (
	VPNGatewayConnectionPolicyModeResourceTypeVPNGatewayConnectionConst = "vpn_gateway_connection"
)

// Constants associated with the VPNGatewayConnectionPolicyMode.Status property.
// The status of a VPN gateway connection.
const (
	VPNGatewayConnectionPolicyModeStatusDownConst = "down"
	VPNGatewayConnectionPolicyModeStatusUpConst   = "up"
)

func (*VPNGatewayConnectionPolicyMode) isaVPNGatewayConnection() bool {
	return true
}

// UnmarshalVPNGatewayConnectionPolicyMode unmarshals an instance of VPNGatewayConnectionPolicyMode from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPolicyMode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPolicyMode)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authentication_mode", &obj.AuthenticationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalIkePolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalIPsecPolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalVPNGatewayConnectionStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCIDRs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCIDRs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype : VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype struct
// This model "extends" VPNGatewayConnectionPrototype
type VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	DeadPeerDetection *VPNGatewayConnectionDpdPrototype `json:"dead_peer_detection,omitempty"`

	IkePolicy VPNGatewayConnectionIkePolicyPrototypeIntf `json:"ike_policy,omitempty"`

	IpsecPolicy VPNGatewayConnectionIPsecPolicyPrototypeIntf `json:"ipsec_policy,omitempty"`

	// The name for this VPN gateway connection. The name must not be used by another connection for the VPN gateway. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The pre-shared key.
	Psk *string `json:"psk" validate:"required"`

	// The local CIDRs for this resource.
	LocalCIDRs []string `json:"local_cidrs" validate:"required"`

	// The peer CIDRs for this resource.
	PeerCIDRs []string `json:"peer_cidrs" validate:"required"`
}

// NewVPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype : Instantiate VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype(peerAddress string, psk string, localCIDRs []string, peerCIDRs []string) (_model *VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype, err error) {
	_model = &VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype{
		PeerAddress: core.StringPtr(peerAddress),
		Psk:         core.StringPtr(psk),
		LocalCIDRs:  localCIDRs,
		PeerCIDRs:   peerCIDRs,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype) isaVPNGatewayConnectionPrototype() bool {
	return true
}

// UnmarshalVPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype unmarshals an instance of VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPrototypeVPNGatewayConnectionPolicyModePrototype)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpdPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalVPNGatewayConnectionIkePolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalVPNGatewayConnectionIPsecPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCIDRs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCIDRs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype : VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype struct
// This model "extends" VPNGatewayConnectionPrototype
type VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	DeadPeerDetection *VPNGatewayConnectionDpdPrototype `json:"dead_peer_detection,omitempty"`

	IkePolicy VPNGatewayConnectionIkePolicyPrototypeIntf `json:"ike_policy,omitempty"`

	IpsecPolicy VPNGatewayConnectionIPsecPolicyPrototypeIntf `json:"ipsec_policy,omitempty"`

	// The name for this VPN gateway connection. The name must not be used by another connection for the VPN gateway. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The pre-shared key.
	Psk *string `json:"psk" validate:"required"`

	// Routing protocols are disabled for this VPN gateway connection.
	RoutingProtocol *string `json:"routing_protocol,omitempty"`
}

// Constants associated with the VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype.RoutingProtocol property.
// Routing protocols are disabled for this VPN gateway connection.
const (
	VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototypeRoutingProtocolNoneConst = "none"
)

// NewVPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype : Instantiate VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype(peerAddress string, psk string) (_model *VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype, err error) {
	_model = &VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype{
		PeerAddress: core.StringPtr(peerAddress),
		Psk:         core.StringPtr(psk),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype) isaVPNGatewayConnectionPrototype() bool {
	return true
}

// UnmarshalVPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype unmarshals an instance of VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPrototypeVPNGatewayConnectionStaticRouteModePrototype)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpdPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalVPNGatewayConnectionIkePolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalVPNGatewayConnectionIPsecPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_protocol", &obj.RoutingProtocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionStaticRouteMode : VPNGatewayConnectionStaticRouteMode struct
// This model "extends" VPNGatewayConnection
type VPNGatewayConnectionStaticRouteMode struct {
	// If set to false, the VPN gateway connection is shut down.
	AdminStateUp *bool `json:"admin_state_up" validate:"required"`

	// The authentication mode. Only `psk` is currently supported.
	AuthenticationMode *string `json:"authentication_mode" validate:"required"`

	// The date and time that this VPN gateway connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	DeadPeerDetection *VPNGatewayConnectionDpd `json:"dead_peer_detection" validate:"required"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`

	// The IKE policy. If absent, [auto-negotiation is
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ike-auto-negotiation-phase-1).
	IkePolicy *IkePolicyReference `json:"ike_policy,omitempty"`

	// The IPsec policy. If absent, [auto-negotiation is
	// used](https://cloud.ibm.com/docs/vpc?topic=vpc-using-vpn&interface=ui#ipsec-auto-negotiation-phase-2).
	IpsecPolicy *IPsecPolicyReference `json:"ipsec_policy,omitempty"`

	// The mode of the VPN gateway.
	Mode *string `json:"mode" validate:"required"`

	// The name for this VPN gateway connection. The name is unique across all connections for the VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The pre-shared key.
	Psk *string `json:"psk" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of a VPN gateway connection.
	Status *string `json:"status" validate:"required"`

	// The reasons for the current VPN gateway connection status (if any):
	// - `cannot_authenticate_connection`: Failed to authenticate a connection because of
	//   mismatched IKE ID and PSK (check IKE ID and PSK in peer VPN configuration)
	// - `internal_error`: Internal error (contact IBM support)
	// - `ike_policy_mismatch`: None of the proposed IKE crypto suites was acceptable (check
	//    the IKE policies on both sides of the VPN)
	// - `ike_v1_id_local_remote_cidr_mismatch`: Invalid IKE ID or mismatched local CIDRs and
	//   remote CIDRs in IKE V1 (check the IKE ID or the local CIDRs and remote CIDRs in IKE
	//   V1 configuration)
	// - `ike_v2_local_remote_cidr_mismatch`: Mismatched local CIDRs and remote CIDRs in IKE
	//   V2 (check the local CIDRs and remote CIDRs in IKE V2 configuration)
	// - `ipsec_policy_mismatch`: None of the proposed IPsec crypto suites was acceptable
	//   (check the IPsec policies on both sides of the VPN)
	// - `peer_not_responding`: No response from peer (check network ACL configuration, peer
	//   availability, and on-premise firewall configuration)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	StatusReasons []VPNGatewayConnectionStatusReason `json:"status_reasons" validate:"required"`

	// Routing protocols are disabled for this VPN gateway connection.
	RoutingProtocol *string `json:"routing_protocol" validate:"required"`

	// The VPN tunnel configuration for this VPN gateway connection (in static route mode).
	Tunnels []VPNGatewayConnectionStaticRouteModeTunnel `json:"tunnels" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionStaticRouteMode.AuthenticationMode property.
// The authentication mode. Only `psk` is currently supported.
const (
	VPNGatewayConnectionStaticRouteModeAuthenticationModePskConst = "psk"
)

// Constants associated with the VPNGatewayConnectionStaticRouteMode.Mode property.
// The mode of the VPN gateway.
const (
	VPNGatewayConnectionStaticRouteModeModePolicyConst = "policy"
	VPNGatewayConnectionStaticRouteModeModeRouteConst  = "route"
)

// Constants associated with the VPNGatewayConnectionStaticRouteMode.ResourceType property.
// The resource type.
const (
	VPNGatewayConnectionStaticRouteModeResourceTypeVPNGatewayConnectionConst = "vpn_gateway_connection"
)

// Constants associated with the VPNGatewayConnectionStaticRouteMode.Status property.
// The status of a VPN gateway connection.
const (
	VPNGatewayConnectionStaticRouteModeStatusDownConst = "down"
	VPNGatewayConnectionStaticRouteModeStatusUpConst   = "up"
)

// Constants associated with the VPNGatewayConnectionStaticRouteMode.RoutingProtocol property.
// Routing protocols are disabled for this VPN gateway connection.
const (
	VPNGatewayConnectionStaticRouteModeRoutingProtocolNoneConst = "none"
)

func (*VPNGatewayConnectionStaticRouteMode) isaVPNGatewayConnection() bool {
	return true
}

// UnmarshalVPNGatewayConnectionStaticRouteMode unmarshals an instance of VPNGatewayConnectionStaticRouteMode from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionStaticRouteMode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionStaticRouteMode)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authentication_mode", &obj.AuthenticationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalIkePolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalIPsecPolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalVPNGatewayConnectionStatusReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_protocol", &obj.RoutingProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalVPNGatewayConnectionStaticRouteModeTunnel)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayPolicyMode : VPNGatewayPolicyMode struct
// This model "extends" VPNGateway
type VPNGatewayPolicyMode struct {
	// Connections for this VPN gateway.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this VPN gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The VPN gateway's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The reasons for the current VPN gateway health_state (if any):
	// - `cannot_create_vpc_route`: VPN cannot create route (check for conflict)
	// - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
	//   subnet)
	// - `internal_error`: Internal error (contact IBM support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPNGatewayHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current VPN gateway lifecycle_state (if any):
	// - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
	//   support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []VPNGatewayLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the VPN gateway.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// Collection of VPN gateway members.
	Members []VPNGatewayMember `json:"members" validate:"required"`

	// The name for this VPN gateway. The name is unique across all VPN gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPN gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The VPC this VPN gateway resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// Policy mode VPN gateway.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the VPNGatewayPolicyMode.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPNGatewayPolicyModeHealthStateDegradedConst     = "degraded"
	VPNGatewayPolicyModeHealthStateFaultedConst      = "faulted"
	VPNGatewayPolicyModeHealthStateInapplicableConst = "inapplicable"
	VPNGatewayPolicyModeHealthStateOkConst           = "ok"
)

// Constants associated with the VPNGatewayPolicyMode.LifecycleState property.
// The lifecycle state of the VPN gateway.
const (
	VPNGatewayPolicyModeLifecycleStateDeletingConst  = "deleting"
	VPNGatewayPolicyModeLifecycleStateFailedConst    = "failed"
	VPNGatewayPolicyModeLifecycleStatePendingConst   = "pending"
	VPNGatewayPolicyModeLifecycleStateStableConst    = "stable"
	VPNGatewayPolicyModeLifecycleStateSuspendedConst = "suspended"
	VPNGatewayPolicyModeLifecycleStateUpdatingConst  = "updating"
	VPNGatewayPolicyModeLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VPNGatewayPolicyMode.ResourceType property.
// The resource type.
const (
	VPNGatewayPolicyModeResourceTypeVPNGatewayConst = "vpn_gateway"
)

// Constants associated with the VPNGatewayPolicyMode.Mode property.
// Policy mode VPN gateway.
const (
	VPNGatewayPolicyModeModePolicyConst = "policy"
)

func (*VPNGatewayPolicyMode) isaVPNGateway() bool {
	return true
}

// UnmarshalVPNGatewayPolicyMode unmarshals an instance of VPNGatewayPolicyMode from the specified map of raw messages.
func UnmarshalVPNGatewayPolicyMode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayPolicyMode)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPNGatewayHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalVPNGatewayLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalVPNGatewayMember)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayPrototypeVPNGatewayPolicyModePrototype : VPNGatewayPrototypeVPNGatewayPolicyModePrototype struct
// This model "extends" VPNGatewayPrototype
type VPNGatewayPrototypeVPNGatewayPolicyModePrototype struct {
	// The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Policy mode VPN gateway.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the VPNGatewayPrototypeVPNGatewayPolicyModePrototype.Mode property.
// Policy mode VPN gateway.
const (
	VPNGatewayPrototypeVPNGatewayPolicyModePrototypeModePolicyConst = "policy"
)

// NewVPNGatewayPrototypeVPNGatewayPolicyModePrototype : Instantiate VPNGatewayPrototypeVPNGatewayPolicyModePrototype (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayPrototypeVPNGatewayPolicyModePrototype(subnet SubnetIdentityIntf) (_model *VPNGatewayPrototypeVPNGatewayPolicyModePrototype, err error) {
	_model = &VPNGatewayPrototypeVPNGatewayPolicyModePrototype{
		Subnet: subnet,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayPrototypeVPNGatewayPolicyModePrototype) isaVPNGatewayPrototype() bool {
	return true
}

// UnmarshalVPNGatewayPrototypeVPNGatewayPolicyModePrototype unmarshals an instance of VPNGatewayPrototypeVPNGatewayPolicyModePrototype from the specified map of raw messages.
func UnmarshalVPNGatewayPrototypeVPNGatewayPolicyModePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayPrototypeVPNGatewayPolicyModePrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayPrototypeVPNGatewayRouteModePrototype : VPNGatewayPrototypeVPNGatewayRouteModePrototype struct
// This model "extends" VPNGatewayPrototype
type VPNGatewayPrototypeVPNGatewayRouteModePrototype struct {
	// The name for this VPN gateway. The name must not be used by another VPN gateway in the VPC. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Route mode VPN gateway.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the VPNGatewayPrototypeVPNGatewayRouteModePrototype.Mode property.
// Route mode VPN gateway.
const (
	VPNGatewayPrototypeVPNGatewayRouteModePrototypeModeRouteConst = "route"
)

// NewVPNGatewayPrototypeVPNGatewayRouteModePrototype : Instantiate VPNGatewayPrototypeVPNGatewayRouteModePrototype (Generic Model Constructor)
func (*VpcV1) NewVPNGatewayPrototypeVPNGatewayRouteModePrototype(subnet SubnetIdentityIntf) (_model *VPNGatewayPrototypeVPNGatewayRouteModePrototype, err error) {
	_model = &VPNGatewayPrototypeVPNGatewayRouteModePrototype{
		Subnet: subnet,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNGatewayPrototypeVPNGatewayRouteModePrototype) isaVPNGatewayPrototype() bool {
	return true
}

// UnmarshalVPNGatewayPrototypeVPNGatewayRouteModePrototype unmarshals an instance of VPNGatewayPrototypeVPNGatewayRouteModePrototype from the specified map of raw messages.
func UnmarshalVPNGatewayPrototypeVPNGatewayRouteModePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayPrototypeVPNGatewayRouteModePrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayRouteMode : VPNGatewayRouteMode struct
// This model "extends" VPNGateway
type VPNGatewayRouteMode struct {
	// Connections for this VPN gateway.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this VPN gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The VPN gateway's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The reasons for the current VPN gateway health_state (if any):
	// - `cannot_create_vpc_route`: VPN cannot create route (check for conflict)
	// - `cannot_reserve_ip_address`: IP address exhaustion (release addresses on the VPN's
	//   subnet)
	// - `internal_error`: Internal error (contact IBM support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	HealthReasons []VPNGatewayHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current VPN gateway lifecycle_state (if any):
	// - `resource_suspended_by_provider`: The resource has been suspended (contact IBM
	//   support)
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []VPNGatewayLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the VPN gateway.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// Collection of VPN gateway members.
	Members []VPNGatewayMember `json:"members" validate:"required"`

	// The name for this VPN gateway. The name is unique across all VPN gateways in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPN gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The VPC this VPN gateway resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// Route mode VPN gateway.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the VPNGatewayRouteMode.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	VPNGatewayRouteModeHealthStateDegradedConst     = "degraded"
	VPNGatewayRouteModeHealthStateFaultedConst      = "faulted"
	VPNGatewayRouteModeHealthStateInapplicableConst = "inapplicable"
	VPNGatewayRouteModeHealthStateOkConst           = "ok"
)

// Constants associated with the VPNGatewayRouteMode.LifecycleState property.
// The lifecycle state of the VPN gateway.
const (
	VPNGatewayRouteModeLifecycleStateDeletingConst  = "deleting"
	VPNGatewayRouteModeLifecycleStateFailedConst    = "failed"
	VPNGatewayRouteModeLifecycleStatePendingConst   = "pending"
	VPNGatewayRouteModeLifecycleStateStableConst    = "stable"
	VPNGatewayRouteModeLifecycleStateSuspendedConst = "suspended"
	VPNGatewayRouteModeLifecycleStateUpdatingConst  = "updating"
	VPNGatewayRouteModeLifecycleStateWaitingConst   = "waiting"
)

// Constants associated with the VPNGatewayRouteMode.ResourceType property.
// The resource type.
const (
	VPNGatewayRouteModeResourceTypeVPNGatewayConst = "vpn_gateway"
)

// Constants associated with the VPNGatewayRouteMode.Mode property.
// Route mode VPN gateway.
const (
	VPNGatewayRouteModeModeRouteConst = "route"
)

func (*VPNGatewayRouteMode) isaVPNGateway() bool {
	return true
}

// UnmarshalVPNGatewayRouteMode unmarshals an instance of VPNGatewayRouteMode from the specified map of raw messages.
func UnmarshalVPNGatewayRouteMode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayRouteMode)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalVPNGatewayHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalVPNGatewayLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalVPNGatewayMember)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationByCertificate : VPNServerAuthenticationByCertificate struct
// This model "extends" VPNServerAuthentication
type VPNServerAuthenticationByCertificate struct {
	// The type of authentication.
	Method *string `json:"method" validate:"required"`

	// The certificate instance used for the VPN client certificate authority (CA).
	ClientCa *CertificateInstanceReference `json:"client_ca" validate:"required"`

	// The certificate revocation list contents, encoded in PEM format.
	Crl *string `json:"crl,omitempty"`
}

// Constants associated with the VPNServerAuthenticationByCertificate.Method property.
// The type of authentication.
const (
	VPNServerAuthenticationByCertificateMethodCertificateConst = "certificate"
	VPNServerAuthenticationByCertificateMethodUsernameConst    = "username"
)

func (*VPNServerAuthenticationByCertificate) isaVPNServerAuthentication() bool {
	return true
}

// UnmarshalVPNServerAuthenticationByCertificate unmarshals an instance of VPNServerAuthenticationByCertificate from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationByCertificate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthenticationByCertificate)
	err = core.UnmarshalPrimitive(m, "method", &obj.Method)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_ca", &obj.ClientCa, UnmarshalCertificateInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crl", &obj.Crl)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationByUsername : VPNServerAuthenticationByUsername struct
// This model "extends" VPNServerAuthentication
type VPNServerAuthenticationByUsername struct {
	// The type of authentication.
	Method *string `json:"method" validate:"required"`

	// The type of identity provider to be used by VPN client.
	IdentityProvider VPNServerAuthenticationByUsernameIDProviderIntf `json:"identity_provider" validate:"required"`
}

// Constants associated with the VPNServerAuthenticationByUsername.Method property.
// The type of authentication.
const (
	VPNServerAuthenticationByUsernameMethodCertificateConst = "certificate"
	VPNServerAuthenticationByUsernameMethodUsernameConst    = "username"
)

func (*VPNServerAuthenticationByUsername) isaVPNServerAuthentication() bool {
	return true
}

// UnmarshalVPNServerAuthenticationByUsername unmarshals an instance of VPNServerAuthenticationByUsername from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationByUsername(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthenticationByUsername)
	err = core.UnmarshalPrimitive(m, "method", &obj.Method)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "identity_provider", &obj.IdentityProvider, UnmarshalVPNServerAuthenticationByUsernameIDProvider)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationByUsernameIDProviderByIam : VPNServerAuthenticationByUsernameIDProviderByIam struct
// This model "extends" VPNServerAuthenticationByUsernameIDProvider
type VPNServerAuthenticationByUsernameIDProviderByIam struct {
	// The type of identity provider to be used by the VPN client.
	// - `iam`: IBM identity and access management
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
	// unexpected property value was encountered.
	ProviderType *string `json:"provider_type" validate:"required"`
}

// Constants associated with the VPNServerAuthenticationByUsernameIDProviderByIam.ProviderType property.
// The type of identity provider to be used by the VPN client.
// - `iam`: IBM identity and access management
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the route on which the
// unexpected property value was encountered.
const (
	VPNServerAuthenticationByUsernameIDProviderByIamProviderTypeIamConst = "iam"
)

// NewVPNServerAuthenticationByUsernameIDProviderByIam : Instantiate VPNServerAuthenticationByUsernameIDProviderByIam (Generic Model Constructor)
func (*VpcV1) NewVPNServerAuthenticationByUsernameIDProviderByIam(providerType string) (_model *VPNServerAuthenticationByUsernameIDProviderByIam, err error) {
	_model = &VPNServerAuthenticationByUsernameIDProviderByIam{
		ProviderType: core.StringPtr(providerType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNServerAuthenticationByUsernameIDProviderByIam) isaVPNServerAuthenticationByUsernameIDProvider() bool {
	return true
}

// UnmarshalVPNServerAuthenticationByUsernameIDProviderByIam unmarshals an instance of VPNServerAuthenticationByUsernameIDProviderByIam from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationByUsernameIDProviderByIam(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthenticationByUsernameIDProviderByIam)
	err = core.UnmarshalPrimitive(m, "provider_type", &obj.ProviderType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype : VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype struct
// This model "extends" VPNServerAuthenticationPrototype
type VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype struct {
	// The type of authentication.
	Method *string `json:"method" validate:"required"`

	// The certificate instance to use for the VPN client certificate authority (CA).
	ClientCa CertificateInstanceIdentityIntf `json:"client_ca" validate:"required"`

	// The certificate revocation list contents, encoded in PEM format.
	Crl *string `json:"crl,omitempty"`
}

// Constants associated with the VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype.Method property.
// The type of authentication.
const (
	VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototypeMethodCertificateConst = "certificate"
	VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototypeMethodUsernameConst    = "username"
)

// NewVPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype : Instantiate VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype (Generic Model Constructor)
func (*VpcV1) NewVPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype(method string, clientCa CertificateInstanceIdentityIntf) (_model *VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype, err error) {
	_model = &VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype{
		Method:   core.StringPtr(method),
		ClientCa: clientCa,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype) isaVPNServerAuthenticationPrototype() bool {
	return true
}

// UnmarshalVPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype unmarshals an instance of VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthenticationPrototypeVPNServerAuthenticationByCertificatePrototype)
	err = core.UnmarshalPrimitive(m, "method", &obj.Method)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "client_ca", &obj.ClientCa, UnmarshalCertificateInstanceIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crl", &obj.Crl)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype : VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype struct
// This model "extends" VPNServerAuthenticationPrototype
type VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype struct {
	// The type of authentication.
	Method *string `json:"method" validate:"required"`

	// The type of identity provider to be used by VPN client.
	IdentityProvider VPNServerAuthenticationByUsernameIDProviderIntf `json:"identity_provider" validate:"required"`
}

// Constants associated with the VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype.Method property.
// The type of authentication.
const (
	VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototypeMethodCertificateConst = "certificate"
	VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototypeMethodUsernameConst    = "username"
)

// NewVPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype : Instantiate VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype (Generic Model Constructor)
func (*VpcV1) NewVPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype(method string, identityProvider VPNServerAuthenticationByUsernameIDProviderIntf) (_model *VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype, err error) {
	_model = &VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype{
		Method:           core.StringPtr(method),
		IdentityProvider: identityProvider,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype) isaVPNServerAuthenticationPrototype() bool {
	return true
}

// UnmarshalVPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype unmarshals an instance of VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype from the specified map of raw messages.
func UnmarshalVPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNServerAuthenticationPrototypeVPNServerAuthenticationByUsernamePrototype)
	err = core.UnmarshalPrimitive(m, "method", &obj.Method)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "identity_provider", &obj.IdentityProvider, UnmarshalVPNServerAuthenticationByUsernameIDProvider)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext : Identifies a reserved IP by a unique property. Required if `subnet` is not specified. The reserved IP must be
// currently unbound.
// Models which "extend" this model:
// - VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID
// - VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref
// This model "extends" VirtualNetworkInterfacePrimaryIPPrototype
type VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id,omitempty"`

	// The URL for this reserved IP.
	Href *string `json:"href,omitempty"`
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext) isaVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext() bool {
	return true
}

type VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextIntf interface {
	VirtualNetworkInterfacePrimaryIPPrototypeIntf
	isaVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext() bool
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext) isaVirtualNetworkInterfacePrimaryIPPrototype() bool {
	return true
}

// UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext unmarshals an instance of VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext : The prototype for a new reserved IP. Requires `subnet` to be specified.
// This model "extends" VirtualNetworkInterfacePrimaryIPPrototype
type VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext struct {
	// The IP address to reserve, which must not already be reserved on the subnet.
	//
	// If unspecified, an available address on the subnet will automatically be selected.
	Address *string `json:"address,omitempty"`

	// Indicates whether this reserved IP member will be automatically deleted when either
	// `target` is deleted, or the reserved IP is unbound.
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The name for this reserved IP. The name must not be used by another reserved IP in the subnet. Names starting with
	// `ibm-` are reserved for provider-owned resources, and are not allowed. If unspecified, the name will be a hyphenated
	// list of randomly-selected words.
	Name *string `json:"name,omitempty"`
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext) isaVirtualNetworkInterfacePrimaryIPPrototype() bool {
	return true
}

// UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext unmarshals an instance of VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfacePrimaryIPPrototypeReservedIPPrototypeVirtualNetworkInterfacePrimaryIPContext)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfaceTargetShareMountTargetReference : VirtualNetworkInterfaceTargetShareMountTargetReference struct
// This model "extends" VirtualNetworkInterfaceTarget
type VirtualNetworkInterfaceTargetShareMountTargetReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *ShareMountTargetReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this share mount target.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this share mount target.
	ID *string `json:"id" validate:"required"`

	// The name for this share mount target. The name is unique across all mount targets for the file share.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VirtualNetworkInterfaceTargetShareMountTargetReference.ResourceType property.
// The resource type.
const (
	VirtualNetworkInterfaceTargetShareMountTargetReferenceResourceTypeShareMountTargetConst = "share_mount_target"
)

func (*VirtualNetworkInterfaceTargetShareMountTargetReference) isaVirtualNetworkInterfaceTarget() bool {
	return true
}

// UnmarshalVirtualNetworkInterfaceTargetShareMountTargetReference unmarshals an instance of VirtualNetworkInterfaceTargetShareMountTargetReference from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfaceTargetShareMountTargetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfaceTargetShareMountTargetReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalShareMountTargetReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumeIdentity : Identifies a volume by a unique property.
// Models which "extend" this model:
// - VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID
// - VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN
// - VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref
// This model "extends" VolumeAttachmentPrototypeVolume
type VolumeAttachmentPrototypeVolumeVolumeIdentity struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentity) isaVolumeAttachmentPrototypeVolumeVolumeIdentity() bool {
	return true
}

type VolumeAttachmentPrototypeVolumeVolumeIdentityIntf interface {
	VolumeAttachmentPrototypeVolumeIntf
	isaVolumeAttachmentPrototypeVolumeVolumeIdentity() bool
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentity) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentity unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumeIdentity from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumeIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext : VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext struct
// Models which "extend" this model:
// - VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity
// - VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot
// This model "extends" VolumeAttachmentPrototypeVolume
type VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext struct {
	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to
	// use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use for this volume. If unspecified, the instance's resource
	// group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The snapshot from which to clone the volume.
	SourceSnapshot SnapshotIdentityIntf `json:"source_snapshot,omitempty"`
}

func (*VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext) isaVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext() bool {
	return true
}

type VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextIntf interface {
	VolumeAttachmentPrototypeVolumeIntf
	isaVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext() bool
}

func (*VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentityByCRN : VolumeIdentityByCRN struct
// This model "extends" VolumeIdentity
type VolumeIdentityByCRN struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`
}

// NewVolumeIdentityByCRN : Instantiate VolumeIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByCRN(crn string) (_model *VolumeIdentityByCRN, err error) {
	_model = &VolumeIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeIdentityByCRN) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByCRN unmarshals an instance of VolumeIdentityByCRN from the specified map of raw messages.
func UnmarshalVolumeIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentityByHref : VolumeIdentityByHref struct
// This model "extends" VolumeIdentity
type VolumeIdentityByHref struct {
	// The URL for this volume.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeIdentityByHref : Instantiate VolumeIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByHref(href string) (_model *VolumeIdentityByHref, err error) {
	_model = &VolumeIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeIdentityByHref) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByHref unmarshals an instance of VolumeIdentityByHref from the specified map of raw messages.
func UnmarshalVolumeIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentityByID : VolumeIdentityByID struct
// This model "extends" VolumeIdentity
type VolumeIdentityByID struct {
	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`
}

// NewVolumeIdentityByID : Instantiate VolumeIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByID(id string) (_model *VolumeIdentityByID, err error) {
	_model = &VolumeIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeIdentityByID) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByID unmarshals an instance of VolumeIdentityByID from the specified map of raw messages.
func UnmarshalVolumeIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileIdentityByHref : VolumeProfileIdentityByHref struct
// This model "extends" VolumeProfileIdentity
type VolumeProfileIdentityByHref struct {
	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeProfileIdentityByHref : Instantiate VolumeProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeProfileIdentityByHref(href string) (_model *VolumeProfileIdentityByHref, err error) {
	_model = &VolumeProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeProfileIdentityByHref) isaVolumeProfileIdentity() bool {
	return true
}

// UnmarshalVolumeProfileIdentityByHref unmarshals an instance of VolumeProfileIdentityByHref from the specified map of raw messages.
func UnmarshalVolumeProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileIdentityByName : VolumeProfileIdentityByName struct
// This model "extends" VolumeProfileIdentity
type VolumeProfileIdentityByName struct {
	// The globally unique name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// NewVolumeProfileIdentityByName : Instantiate VolumeProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewVolumeProfileIdentityByName(name string) (_model *VolumeProfileIdentityByName, err error) {
	_model = &VolumeProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeProfileIdentityByName) isaVolumeProfileIdentity() bool {
	return true
}

// UnmarshalVolumeProfileIdentityByName unmarshals an instance of VolumeProfileIdentityByName from the specified map of raw messages.
func UnmarshalVolumeProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototypeVolumeByCapacity : VolumePrototypeVolumeByCapacity struct
// This model "extends" VolumePrototype
type VolumePrototypeVolumeByCapacity struct {
	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this volume will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`
}

// NewVolumePrototypeVolumeByCapacity : Instantiate VolumePrototypeVolumeByCapacity (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeVolumeByCapacity(profile VolumeProfileIdentityIntf, zone ZoneIdentityIntf, capacity int64) (_model *VolumePrototypeVolumeByCapacity, err error) {
	_model = &VolumePrototypeVolumeByCapacity{
		Profile:  profile,
		Zone:     zone,
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumePrototypeVolumeByCapacity) isaVolumePrototype() bool {
	return true
}

// UnmarshalVolumePrototypeVolumeByCapacity unmarshals an instance of VolumePrototypeVolumeByCapacity from the specified map of raw messages.
func UnmarshalVolumePrototypeVolumeByCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototypeVolumeByCapacity)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototypeVolumeBySourceSnapshot : VolumePrototypeVolumeBySourceSnapshot struct
// This model "extends" VolumePrototype
type VolumePrototypeVolumeBySourceSnapshot struct {
	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The zone this volume will reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity to use for the volume (in gigabytes). Must be at least the snapshot's
	// `minimum_capacity`. The maximum value may increase in the future.
	//
	// If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The snapshot from which to clone the volume.
	SourceSnapshot SnapshotIdentityIntf `json:"source_snapshot" validate:"required"`
}

// NewVolumePrototypeVolumeBySourceSnapshot : Instantiate VolumePrototypeVolumeBySourceSnapshot (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeVolumeBySourceSnapshot(profile VolumeProfileIdentityIntf, zone ZoneIdentityIntf, sourceSnapshot SnapshotIdentityIntf) (_model *VolumePrototypeVolumeBySourceSnapshot, err error) {
	_model = &VolumePrototypeVolumeBySourceSnapshot{
		Profile:        profile,
		Zone:           zone,
		SourceSnapshot: sourceSnapshot,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumePrototypeVolumeBySourceSnapshot) isaVolumePrototype() bool {
	return true
}

// UnmarshalVolumePrototypeVolumeBySourceSnapshot unmarshals an instance of VolumePrototypeVolumeBySourceSnapshot from the specified map of raw messages.
func UnmarshalVolumePrototypeVolumeBySourceSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototypeVolumeBySourceSnapshot)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByHref : ZoneIdentityByHref struct
// This model "extends" ZoneIdentity
type ZoneIdentityByHref struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`
}

// NewZoneIdentityByHref : Instantiate ZoneIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewZoneIdentityByHref(href string) (_model *ZoneIdentityByHref, err error) {
	_model = &ZoneIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ZoneIdentityByHref) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByHref unmarshals an instance of ZoneIdentityByHref from the specified map of raw messages.
func UnmarshalZoneIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByName : ZoneIdentityByName struct
// This model "extends" ZoneIdentity
type ZoneIdentityByName struct {
	// The globally unique name for this zone.
	Name *string `json:"name" validate:"required"`
}

// NewZoneIdentityByName : Instantiate ZoneIdentityByName (Generic Model Constructor)
func (*VpcV1) NewZoneIdentityByName(name string) (_model *ZoneIdentityByName, err error) {
	_model = &ZoneIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ZoneIdentityByName) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByName unmarshals an instance of ZoneIdentityByName from the specified map of raw messages.
func UnmarshalZoneIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN : BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN struct
// This model "extends" BackupPolicyScopePrototypeEnterpriseIdentity
type BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN struct {
	// The CRN for this enterprise.
	CRN *string `json:"crn" validate:"required"`
}

// NewBackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN : Instantiate BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewBackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN(crn string) (_model *BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN, err error) {
	_model = &BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN) isaBackupPolicyScopePrototypeEnterpriseIdentity() bool {
	return true
}

func (*BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN) isaBackupPolicyScopePrototype() bool {
	return true
}

// UnmarshalBackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN unmarshals an instance of BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN from the specified map of raw messages.
func UnmarshalBackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicyScopePrototypeEnterpriseIdentityEnterpriseIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayReservedIPReservedIPIdentityByHref : EndpointGatewayReservedIPReservedIPIdentityByHref struct
// This model "extends" EndpointGatewayReservedIPReservedIPIdentity
type EndpointGatewayReservedIPReservedIPIdentityByHref struct {
	// The URL for this reserved IP.
	Href *string `json:"href" validate:"required"`
}

// NewEndpointGatewayReservedIPReservedIPIdentityByHref : Instantiate EndpointGatewayReservedIPReservedIPIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewEndpointGatewayReservedIPReservedIPIdentityByHref(href string) (_model *EndpointGatewayReservedIPReservedIPIdentityByHref, err error) {
	_model = &EndpointGatewayReservedIPReservedIPIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EndpointGatewayReservedIPReservedIPIdentityByHref) isaEndpointGatewayReservedIPReservedIPIdentity() bool {
	return true
}

func (*EndpointGatewayReservedIPReservedIPIdentityByHref) isaEndpointGatewayReservedIP() bool {
	return true
}

// UnmarshalEndpointGatewayReservedIPReservedIPIdentityByHref unmarshals an instance of EndpointGatewayReservedIPReservedIPIdentityByHref from the specified map of raw messages.
func UnmarshalEndpointGatewayReservedIPReservedIPIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReservedIPReservedIPIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayReservedIPReservedIPIdentityByID : EndpointGatewayReservedIPReservedIPIdentityByID struct
// This model "extends" EndpointGatewayReservedIPReservedIPIdentity
type EndpointGatewayReservedIPReservedIPIdentityByID struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id" validate:"required"`
}

// NewEndpointGatewayReservedIPReservedIPIdentityByID : Instantiate EndpointGatewayReservedIPReservedIPIdentityByID (Generic Model Constructor)
func (*VpcV1) NewEndpointGatewayReservedIPReservedIPIdentityByID(id string) (_model *EndpointGatewayReservedIPReservedIPIdentityByID, err error) {
	_model = &EndpointGatewayReservedIPReservedIPIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EndpointGatewayReservedIPReservedIPIdentityByID) isaEndpointGatewayReservedIPReservedIPIdentity() bool {
	return true
}

func (*EndpointGatewayReservedIPReservedIPIdentityByID) isaEndpointGatewayReservedIP() bool {
	return true
}

// UnmarshalEndpointGatewayReservedIPReservedIPIdentityByID unmarshals an instance of EndpointGatewayReservedIPReservedIPIdentityByID from the specified map of raw messages.
func UnmarshalEndpointGatewayReservedIPReservedIPIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayReservedIPReservedIPIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN : EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN struct
// This model "extends" EndpointGatewayTargetPrototypeProviderCloudServiceIdentity
type EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN struct {
	// The type of target for this endpoint gateway.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The CRN for this provider cloud service, or the CRN for the user's instance of a provider cloud service.
	CRN *string `json:"crn" validate:"required"`
}

// Constants associated with the EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN.ResourceType property.
// The type of target for this endpoint gateway.
const (
	EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRNResourceTypeProviderCloudServiceConst          = "provider_cloud_service"
	EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRNResourceTypeProviderInfrastructureServiceConst = "provider_infrastructure_service"
)

// NewEndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN : Instantiate EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewEndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN(resourceType string, crn string) (_model *EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN, err error) {
	_model = &EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN{
		ResourceType: core.StringPtr(resourceType),
		CRN:          core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN) isaEndpointGatewayTargetPrototypeProviderCloudServiceIdentity() bool {
	return true
}

func (*EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN) isaEndpointGatewayTargetPrototype() bool {
	return true
}

// UnmarshalEndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN unmarshals an instance of EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTargetPrototypeProviderCloudServiceIdentityProviderCloudServiceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName : The name of this provider infrastructure service.
// This model "extends" EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity
type EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName struct {
	// The type of target for this endpoint gateway.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The name of a provider infrastructure service. Must be:
	// - `ibm-ntp-server`: An NTP (Network Time Protocol) server provided by IBM.
	Name *string `json:"name" validate:"required"`
}

// Constants associated with the EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName.ResourceType property.
// The type of target for this endpoint gateway.
const (
	EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByNameResourceTypeProviderCloudServiceConst          = "provider_cloud_service"
	EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByNameResourceTypeProviderInfrastructureServiceConst = "provider_infrastructure_service"
)

// NewEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName : Instantiate EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName (Generic Model Constructor)
func (*VpcV1) NewEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName(resourceType string, name string) (_model *EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName, err error) {
	_model = &EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName{
		ResourceType: core.StringPtr(resourceType),
		Name:         core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName) isaEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentity() bool {
	return true
}

func (*EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName) isaEndpointGatewayTargetPrototype() bool {
	return true
}

// UnmarshalEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName unmarshals an instance of EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName from the specified map of raw messages.
func UnmarshalEndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EndpointGatewayTargetPrototypeProviderInfrastructureServiceIdentityProviderInfrastructureServiceIdentityByName)
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref : FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref struct
// This model "extends" FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity
type FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref struct {
	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`
}

// NewFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref : Instantiate FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref(href string) (_model *FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref, err error) {
	_model = &FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref) isaFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref) isaFloatingIPTargetPatch() bool {
	return true
}

// UnmarshalFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref unmarshals an instance of FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID : FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID struct
// This model "extends" FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity
type FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID struct {
	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`
}

// NewFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID : Instantiate FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID(id string) (_model *FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID, err error) {
	_model = &FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID) isaFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID) isaFloatingIPTargetPatch() bool {
	return true
}

// UnmarshalFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID unmarshals an instance of FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatchBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct
// This model "extends" FloatingIPTargetPatchNetworkInterfaceIdentity
type FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct {
	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`
}

// NewFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : Instantiate FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(href string) (_model *FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref, err error) {
	_model = &FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFloatingIPTargetPatchNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFloatingIPTargetPatch() bool {
	return true
}

// UnmarshalFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref unmarshals an instance of FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID : FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct
// This model "extends" FloatingIPTargetPatchNetworkInterfaceIdentity
type FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`
}

// NewFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID : Instantiate FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID(id string) (_model *FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID, err error) {
	_model = &FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFloatingIPTargetPatchNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFloatingIPTargetPatch() bool {
	return true
}

// UnmarshalFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID unmarshals an instance of FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalFloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPatchNetworkInterfaceIdentityNetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref : FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref struct
// This model "extends" FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity
type FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref struct {
	// The URL for this bare metal server network interface.
	Href *string `json:"href" validate:"required"`
}

// NewFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref : Instantiate FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref(href string) (_model *FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref, err error) {
	_model = &FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref) isaFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref) isaFloatingIPTargetPrototype() bool {
	return true
}

// UnmarshalFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref unmarshals an instance of FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID : FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID struct
// This model "extends" FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity
type FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID struct {
	// The unique identifier for this bare metal server network interface.
	ID *string `json:"id" validate:"required"`
}

// NewFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID : Instantiate FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID(id string) (_model *FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID, err error) {
	_model = &FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID) isaFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID) isaFloatingIPTargetPrototype() bool {
	return true
}

// UnmarshalFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID unmarshals an instance of FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototypeBareMetalServerNetworkInterfaceIdentityBareMetalServerNetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct
// This model "extends" FloatingIPTargetPrototypeNetworkInterfaceIdentity
type FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct {
	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`
}

// NewFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : Instantiate FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(href string) (_model *FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref, err error) {
	_model = &FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFloatingIPTargetPrototypeNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFloatingIPTargetPrototype() bool {
	return true
}

// UnmarshalFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref unmarshals an instance of FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID : FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct
// This model "extends" FloatingIPTargetPrototypeNetworkInterfaceIdentity
type FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`
}

// NewFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID : Instantiate FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID(id string) (_model *FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID, err error) {
	_model = &FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFloatingIPTargetPrototypeNetworkInterfaceIdentity() bool {
	return true
}

func (*FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFloatingIPTargetPrototype() bool {
	return true
}

// UnmarshalFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID unmarshals an instance of FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalFloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN : FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN struct
// This model "extends" FlowLogCollectorTargetPrototypeInstanceIdentity
type FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN : Instantiate FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN(crn string) (_model *FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN, err error) {
	_model = &FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN) isaFlowLogCollectorTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN unmarshals an instance of FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref : FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref struct
// This model "extends" FlowLogCollectorTargetPrototypeInstanceIdentity
type FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref struct {
	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref : Instantiate FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref(href string) (_model *FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref, err error) {
	_model = &FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref) isaFlowLogCollectorTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref unmarshals an instance of FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID : FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID struct
// This model "extends" FlowLogCollectorTargetPrototypeInstanceIdentity
type FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID : Instantiate FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID(id string) (_model *FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID, err error) {
	_model = &FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID) isaFlowLogCollectorTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID unmarshals an instance of FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeInstanceIdentityInstanceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct
// This model "extends" FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity
type FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct {
	// The URL for this instance network interface.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : Instantiate FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(href string) (_model *FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref, err error) {
	_model = &FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFlowLogCollectorTargetPrototypeNetworkInterfaceIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref unmarshals an instance of FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID : FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct
// This model "extends" FlowLogCollectorTargetPrototypeNetworkInterfaceIdentity
type FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct {
	// The unique identifier for this instance network interface.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID : Instantiate FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID(id string) (_model *FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID, err error) {
	_model = &FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFlowLogCollectorTargetPrototypeNetworkInterfaceIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID unmarshals an instance of FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeNetworkInterfaceIdentityNetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN : FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN struct
// This model "extends" FlowLogCollectorTargetPrototypeSubnetIdentity
type FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN : Instantiate FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN(crn string) (_model *FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN, err error) {
	_model = &FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN) isaFlowLogCollectorTargetPrototypeSubnetIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN unmarshals an instance of FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref : FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref struct
// This model "extends" FlowLogCollectorTargetPrototypeSubnetIdentity
type FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref struct {
	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref : Instantiate FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref(href string) (_model *FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref, err error) {
	_model = &FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref) isaFlowLogCollectorTargetPrototypeSubnetIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref unmarshals an instance of FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID : FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID struct
// This model "extends" FlowLogCollectorTargetPrototypeSubnetIdentity
type FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID struct {
	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID : Instantiate FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID(id string) (_model *FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID, err error) {
	_model = &FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID) isaFlowLogCollectorTargetPrototypeSubnetIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID unmarshals an instance of FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeSubnetIdentitySubnetIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN : FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN struct
// This model "extends" FlowLogCollectorTargetPrototypeVPCIdentity
type FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN : Instantiate FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN(crn string) (_model *FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN, err error) {
	_model = &FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN) isaFlowLogCollectorTargetPrototypeVPCIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN unmarshals an instance of FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref : FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref struct
// This model "extends" FlowLogCollectorTargetPrototypeVPCIdentity
type FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref struct {
	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref : Instantiate FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref(href string) (_model *FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref, err error) {
	_model = &FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref) isaFlowLogCollectorTargetPrototypeVPCIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref unmarshals an instance of FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID : FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID struct
// This model "extends" FlowLogCollectorTargetPrototypeVPCIdentity
type FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID struct {
	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID : Instantiate FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID(id string) (_model *FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID, err error) {
	_model = &FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID) isaFlowLogCollectorTargetPrototypeVPCIdentity() bool {
	return true
}

func (*FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID) isaFlowLogCollectorTargetPrototype() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID unmarshals an instance of FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetPrototypeVPCIdentityVPCIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec : InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec struct
// Models which "extend" this model:
// - InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup
// - InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager
// This model "extends" InstanceGroupManagerActionPrototypeScheduledActionPrototype
type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroupPrototype `json:"group,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerPrototypeIntf `json:"manager,omitempty"`
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec) isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec() bool {
	return true
}

type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecIntf interface {
	InstanceGroupManagerActionPrototypeScheduledActionPrototypeIntf
	isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec() bool
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroupPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManagerPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt : InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt struct
// Models which "extend" this model:
// - InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup
// - InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager
// This model "extends" InstanceGroupManagerActionPrototypeScheduledActionPrototype
type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The date and time the scheduled action will run.
	RunAt *strfmt.DateTime `json:"run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroupPrototype `json:"group,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerPrototypeIntf `json:"manager,omitempty"`
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt) isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt() bool {
	return true
}

type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtIntf interface {
	InstanceGroupManagerActionPrototypeScheduledActionPrototypeIntf
	isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt() bool
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "run_at", &obj.RunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroupPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManagerPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionScheduledActionGroupTarget : InstanceGroupManagerActionScheduledActionGroupTarget struct
// This model "extends" InstanceGroupManagerActionScheduledAction
type InstanceGroupManagerActionScheduledActionGroupTarget struct {
	// Indicates whether this scheduled action will be automatically deleted after it has completed and
	// `auto_delete_timeout` hours have passed. At present, this is always
	// `true`, but may be modifiable in the future.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be automatically
	// deleted. If the value is `0`, the action will be deleted once it has finished. This value may be modifiable in the
	// future.
	AutoDeleteTimeout *int64 `json:"auto_delete_timeout" validate:"required"`

	// The date and time that the instance group manager action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager action.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager action.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager action. The name is unique across all actions for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the instance group action
	// - `active`: Action is ready to be run
	// - `completed`: Action was completed successfully
	// - `failed`: Action could not be completed successfully
	// - `incompatible`: Action parameters are not compatible with the group or manager
	// - `omitted`: Action was not applied because this action's manager was disabled.
	Status *string `json:"status" validate:"required"`

	// The date and time that the instance group manager action was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The type of action for the instance group.
	ActionType *string `json:"action_type" validate:"required"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	// The date and time the scheduled action was last applied. If absent, the action has never been applied.
	LastAppliedAt *strfmt.DateTime `json:"last_applied_at,omitempty"`

	// The date and time the scheduled action will next run. If absent, the system is currently calculating the next run
	// time.
	NextRunAt *strfmt.DateTime `json:"next_run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroup `json:"group" validate:"required"`
}

// Constants associated with the InstanceGroupManagerActionScheduledActionGroupTarget.ResourceType property.
// The resource type.
const (
	InstanceGroupManagerActionScheduledActionGroupTargetResourceTypeInstanceGroupManagerActionConst = "instance_group_manager_action"
)

// Constants associated with the InstanceGroupManagerActionScheduledActionGroupTarget.Status property.
// The status of the instance group action
// - `active`: Action is ready to be run
// - `completed`: Action was completed successfully
// - `failed`: Action could not be completed successfully
// - `incompatible`: Action parameters are not compatible with the group or manager
// - `omitted`: Action was not applied because this action's manager was disabled.
const (
	InstanceGroupManagerActionScheduledActionGroupTargetStatusActiveConst       = "active"
	InstanceGroupManagerActionScheduledActionGroupTargetStatusCompletedConst    = "completed"
	InstanceGroupManagerActionScheduledActionGroupTargetStatusFailedConst       = "failed"
	InstanceGroupManagerActionScheduledActionGroupTargetStatusIncompatibleConst = "incompatible"
	InstanceGroupManagerActionScheduledActionGroupTargetStatusOmittedConst      = "omitted"
)

// Constants associated with the InstanceGroupManagerActionScheduledActionGroupTarget.ActionType property.
// The type of action for the instance group.
const (
	InstanceGroupManagerActionScheduledActionGroupTargetActionTypeScheduledConst = "scheduled"
)

func (*InstanceGroupManagerActionScheduledActionGroupTarget) isaInstanceGroupManagerActionScheduledAction() bool {
	return true
}

func (*InstanceGroupManagerActionScheduledActionGroupTarget) isaInstanceGroupManagerAction() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionScheduledActionGroupTarget unmarshals an instance of InstanceGroupManagerActionScheduledActionGroupTarget from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionScheduledActionGroupTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionScheduledActionGroupTarget)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete_timeout", &obj.AutoDeleteTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "action_type", &obj.ActionType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "last_applied_at", &obj.LastAppliedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "next_run_at", &obj.NextRunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionScheduledActionManagerTarget : InstanceGroupManagerActionScheduledActionManagerTarget struct
// This model "extends" InstanceGroupManagerActionScheduledAction
type InstanceGroupManagerActionScheduledActionManagerTarget struct {
	// Indicates whether this scheduled action will be automatically deleted after it has completed and
	// `auto_delete_timeout` hours have passed. At present, this is always
	// `true`, but may be modifiable in the future.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// If `auto_delete` is `true`, and this scheduled action has finished, the hours after which it will be automatically
	// deleted. If the value is `0`, the action will be deleted once it has finished. This value may be modifiable in the
	// future.
	AutoDeleteTimeout *int64 `json:"auto_delete_timeout" validate:"required"`

	// The date and time that the instance group manager action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this instance group manager action.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager action.
	ID *string `json:"id" validate:"required"`

	// The name for this instance group manager action. The name is unique across all actions for the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the instance group action
	// - `active`: Action is ready to be run
	// - `completed`: Action was completed successfully
	// - `failed`: Action could not be completed successfully
	// - `incompatible`: Action parameters are not compatible with the group or manager
	// - `omitted`: Action was not applied because this action's manager was disabled.
	Status *string `json:"status" validate:"required"`

	// The date and time that the instance group manager action was updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The type of action for the instance group.
	ActionType *string `json:"action_type" validate:"required"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	// The date and time the scheduled action was last applied. If absent, the action has never been applied.
	LastAppliedAt *strfmt.DateTime `json:"last_applied_at,omitempty"`

	// The date and time the scheduled action will next run. If absent, the system is currently calculating the next run
	// time.
	NextRunAt *strfmt.DateTime `json:"next_run_at,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerIntf `json:"manager" validate:"required"`
}

// Constants associated with the InstanceGroupManagerActionScheduledActionManagerTarget.ResourceType property.
// The resource type.
const (
	InstanceGroupManagerActionScheduledActionManagerTargetResourceTypeInstanceGroupManagerActionConst = "instance_group_manager_action"
)

// Constants associated with the InstanceGroupManagerActionScheduledActionManagerTarget.Status property.
// The status of the instance group action
// - `active`: Action is ready to be run
// - `completed`: Action was completed successfully
// - `failed`: Action could not be completed successfully
// - `incompatible`: Action parameters are not compatible with the group or manager
// - `omitted`: Action was not applied because this action's manager was disabled.
const (
	InstanceGroupManagerActionScheduledActionManagerTargetStatusActiveConst       = "active"
	InstanceGroupManagerActionScheduledActionManagerTargetStatusCompletedConst    = "completed"
	InstanceGroupManagerActionScheduledActionManagerTargetStatusFailedConst       = "failed"
	InstanceGroupManagerActionScheduledActionManagerTargetStatusIncompatibleConst = "incompatible"
	InstanceGroupManagerActionScheduledActionManagerTargetStatusOmittedConst      = "omitted"
)

// Constants associated with the InstanceGroupManagerActionScheduledActionManagerTarget.ActionType property.
// The type of action for the instance group.
const (
	InstanceGroupManagerActionScheduledActionManagerTargetActionTypeScheduledConst = "scheduled"
)

func (*InstanceGroupManagerActionScheduledActionManagerTarget) isaInstanceGroupManagerActionScheduledAction() bool {
	return true
}

func (*InstanceGroupManagerActionScheduledActionManagerTarget) isaInstanceGroupManagerAction() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionScheduledActionManagerTarget unmarshals an instance of InstanceGroupManagerActionScheduledActionManagerTarget from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionScheduledActionManagerTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionScheduledActionManagerTarget)
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete_timeout", &obj.AutoDeleteTimeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "action_type", &obj.ActionType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "last_applied_at", &obj.LastAppliedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "next_run_at", &obj.NextRunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManager)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref : InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref struct
// This model "extends" InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype
type InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref struct {
	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`
}

// NewInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref : Instantiate InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref(href string) (_model *InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref, err error) {
	_model = &InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref) isaInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype() bool {
	return true
}

func (*InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref) isaInstanceGroupManagerScheduledActionManagerPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref unmarshals an instance of InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByHref)
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID : InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID struct
// This model "extends" InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype
type InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID struct {
	// The desired maximum number of instance group members at the scheduled time.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The desired minimum number of instance group members at the scheduled time.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`
}

// NewInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID : Instantiate InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID(id string) (_model *InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID, err error) {
	_model = &InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID) isaInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototype() bool {
	return true
}

func (*InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID) isaInstanceGroupManagerScheduledActionManagerPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID unmarshals an instance of InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID from the specified map of raw messages.
func UnmarshalInstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerScheduledActionManagerPrototypeAutoScalePrototypeByID)
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN : InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN struct
// This model "extends" InstancePlacementTargetPatchDedicatedHostGroupIdentity
type InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN : Instantiate InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN(crn string) (_model *InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN, err error) {
	_model = &InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN) isaInstancePlacementTargetPatchDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN unmarshals an instance of InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref : InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref struct
// This model "extends" InstancePlacementTargetPatchDedicatedHostGroupIdentity
type InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref struct {
	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref : Instantiate InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref(href string) (_model *InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref, err error) {
	_model = &InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref) isaInstancePlacementTargetPatchDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref unmarshals an instance of InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID : InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID struct
// This model "extends" InstancePlacementTargetPatchDedicatedHostGroupIdentity
type InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID : Instantiate InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID(id string) (_model *InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID, err error) {
	_model = &InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID) isaInstancePlacementTargetPatchDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID unmarshals an instance of InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN : InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN struct
// This model "extends" InstancePlacementTargetPatchDedicatedHostIdentity
type InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN : Instantiate InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN(crn string) (_model *InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN, err error) {
	_model = &InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN) isaInstancePlacementTargetPatchDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN unmarshals an instance of InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref : InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref struct
// This model "extends" InstancePlacementTargetPatchDedicatedHostIdentity
type InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref struct {
	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref : Instantiate InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref(href string) (_model *InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref, err error) {
	_model = &InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref) isaInstancePlacementTargetPatchDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref unmarshals an instance of InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID : InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID struct
// This model "extends" InstancePlacementTargetPatchDedicatedHostIdentity
type InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID : Instantiate InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID(id string) (_model *InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID, err error) {
	_model = &InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID) isaInstancePlacementTargetPatchDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID) isaInstancePlacementTargetPatch() bool {
	return true
}

// UnmarshalInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID unmarshals an instance of InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPatchDedicatedHostIdentityDedicatedHostIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN : InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN struct
// This model "extends" InstancePlacementTargetPrototypeDedicatedHostGroupIdentity
type InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN : Instantiate InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN(crn string) (_model *InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN, err error) {
	_model = &InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN) isaInstancePlacementTargetPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref : InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref struct
// This model "extends" InstancePlacementTargetPrototypeDedicatedHostGroupIdentity
type InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref struct {
	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref : Instantiate InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref(href string) (_model *InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref, err error) {
	_model = &InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref) isaInstancePlacementTargetPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID : InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID struct
// This model "extends" InstancePlacementTargetPrototypeDedicatedHostGroupIdentity
type InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID : Instantiate InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID(id string) (_model *InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID, err error) {
	_model = &InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID) isaInstancePlacementTargetPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN : InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN struct
// This model "extends" InstancePlacementTargetPrototypeDedicatedHostIdentity
type InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN : Instantiate InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN(crn string) (_model *InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN, err error) {
	_model = &InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN) isaInstancePlacementTargetPrototypeDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref : InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref struct
// This model "extends" InstancePlacementTargetPrototypeDedicatedHostIdentity
type InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref struct {
	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref : Instantiate InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref(href string) (_model *InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref, err error) {
	_model = &InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref) isaInstancePlacementTargetPrototypeDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID : InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID struct
// This model "extends" InstancePlacementTargetPrototypeDedicatedHostIdentity
type InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID : Instantiate InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID(id string) (_model *InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID, err error) {
	_model = &InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID) isaInstancePlacementTargetPrototypeDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID unmarshals an instance of InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypeDedicatedHostIdentityDedicatedHostIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN : InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN struct
// This model "extends" InstancePlacementTargetPrototypePlacementGroupIdentity
type InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN struct {
	// The CRN for this placement group.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN : Instantiate InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN(crn string) (_model *InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN, err error) {
	_model = &InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN) isaInstancePlacementTargetPrototypePlacementGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN unmarshals an instance of InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref : InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref struct
// This model "extends" InstancePlacementTargetPrototypePlacementGroupIdentity
type InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref struct {
	// The URL for this placement group.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref : Instantiate InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref(href string) (_model *InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref, err error) {
	_model = &InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref) isaInstancePlacementTargetPrototypePlacementGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref unmarshals an instance of InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID : InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID struct
// This model "extends" InstancePlacementTargetPrototypePlacementGroupIdentity
type InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID struct {
	// The unique identifier for this placement group.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID : Instantiate InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID(id string) (_model *InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID, err error) {
	_model = &InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID) isaInstancePlacementTargetPrototypePlacementGroupIdentity() bool {
	return true
}

func (*InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID) isaInstancePlacementTargetPrototype() bool {
	return true
}

// UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID unmarshals an instance of InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementTargetPrototypePlacementGroupIdentityPlacementGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(href string) (_model *LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	_model = &LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyTargetPatch() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref unmarshals an instance of LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : Instantiate LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(id string) (_model *LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	_model = &LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyTargetPatch() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID unmarshals an instance of LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPatchLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(href string) (_model *LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	_model = &LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref unmarshals an instance of LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : Instantiate LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(id string) (_model *LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	_model = &LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID unmarshals an instance of LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetPrototypeLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN : LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN struct
// This model "extends" LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN : Instantiate LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN(crn string) (_model *LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN, err error) {
	_model = &LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref : LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref struct
// This model "extends" LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref struct {
	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref : Instantiate LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref(href string) (_model *LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref, err error) {
	_model = &LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID : LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID struct
// This model "extends" LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID : Instantiate LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID(id string) (_model *LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID, err error) {
	_model = &LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIPPrototypeReservedIPIdentityByHref : NetworkInterfaceIPPrototypeReservedIPIdentityByHref struct
// This model "extends" NetworkInterfaceIPPrototypeReservedIPIdentity
type NetworkInterfaceIPPrototypeReservedIPIdentityByHref struct {
	// The URL for this reserved IP.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkInterfaceIPPrototypeReservedIPIdentityByHref : Instantiate NetworkInterfaceIPPrototypeReservedIPIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfaceIPPrototypeReservedIPIdentityByHref(href string) (_model *NetworkInterfaceIPPrototypeReservedIPIdentityByHref, err error) {
	_model = &NetworkInterfaceIPPrototypeReservedIPIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkInterfaceIPPrototypeReservedIPIdentityByHref) isaNetworkInterfaceIPPrototypeReservedIPIdentity() bool {
	return true
}

func (*NetworkInterfaceIPPrototypeReservedIPIdentityByHref) isaNetworkInterfaceIPPrototype() bool {
	return true
}

// UnmarshalNetworkInterfaceIPPrototypeReservedIPIdentityByHref unmarshals an instance of NetworkInterfaceIPPrototypeReservedIPIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkInterfaceIPPrototypeReservedIPIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIPPrototypeReservedIPIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIPPrototypeReservedIPIdentityByID : NetworkInterfaceIPPrototypeReservedIPIdentityByID struct
// This model "extends" NetworkInterfaceIPPrototypeReservedIPIdentity
type NetworkInterfaceIPPrototypeReservedIPIdentityByID struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkInterfaceIPPrototypeReservedIPIdentityByID : Instantiate NetworkInterfaceIPPrototypeReservedIPIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfaceIPPrototypeReservedIPIdentityByID(id string) (_model *NetworkInterfaceIPPrototypeReservedIPIdentityByID, err error) {
	_model = &NetworkInterfaceIPPrototypeReservedIPIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*NetworkInterfaceIPPrototypeReservedIPIdentityByID) isaNetworkInterfaceIPPrototypeReservedIPIdentity() bool {
	return true
}

func (*NetworkInterfaceIPPrototypeReservedIPIdentityByID) isaNetworkInterfaceIPPrototype() bool {
	return true
}

// UnmarshalNetworkInterfaceIPPrototypeReservedIPIdentityByID unmarshals an instance of NetworkInterfaceIPPrototypeReservedIPIdentityByID from the specified map of raw messages.
func UnmarshalNetworkInterfaceIPPrototypeReservedIPIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIPPrototypeReservedIPIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress : PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress struct
// This model "extends" PublicGatewayFloatingIPPrototypeFloatingIPIdentity
type PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`
}

// NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress : Instantiate PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress(address string) (_model *PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	_model = &PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress) isaPublicGatewayFloatingIPPrototypeFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

// UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress unmarshals an instance of PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByAddress)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN : PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN struct
// This model "extends" PublicGatewayFloatingIPPrototypeFloatingIPIdentity
type PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN struct {
	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`
}

// NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN : Instantiate PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN(crn string) (_model *PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	_model = &PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN) isaPublicGatewayFloatingIPPrototypeFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

// UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN unmarshals an instance of PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref : PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref struct
// This model "extends" PublicGatewayFloatingIPPrototypeFloatingIPIdentity
type PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref struct {
	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`
}

// NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref : Instantiate PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref(href string) (_model *PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	_model = &PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref) isaPublicGatewayFloatingIPPrototypeFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

// UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref unmarshals an instance of PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID : PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID struct
// This model "extends" PublicGatewayFloatingIPPrototypeFloatingIPIdentity
type PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`
}

// NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID : Instantiate PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID(id string) (_model *PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID, err error) {
	_model = &PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID) isaPublicGatewayFloatingIPPrototypeFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID) isaPublicGatewayFloatingIPPrototype() bool {
	return true
}

// UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID unmarshals an instance of PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIPPrototypeFloatingIPIdentityFloatingIPIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN : ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN struct
// This model "extends" ReservedIPTargetPrototypeEndpointGatewayIdentity
type ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN struct {
	// The CRN for this endpoint gateway.
	CRN *string `json:"crn" validate:"required"`
}

// NewReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN : Instantiate ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN(crn string) (_model *ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN, err error) {
	_model = &ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN) isaReservedIPTargetPrototypeEndpointGatewayIdentity() bool {
	return true
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN) isaReservedIPTargetPrototype() bool {
	return true
}

// UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN unmarshals an instance of ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN from the specified map of raw messages.
func UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref : ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref struct
// This model "extends" ReservedIPTargetPrototypeEndpointGatewayIdentity
type ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref struct {
	// The URL for this endpoint gateway.
	Href *string `json:"href" validate:"required"`
}

// NewReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref : Instantiate ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref(href string) (_model *ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref, err error) {
	_model = &ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref) isaReservedIPTargetPrototypeEndpointGatewayIdentity() bool {
	return true
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref) isaReservedIPTargetPrototype() bool {
	return true
}

// UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref unmarshals an instance of ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref from the specified map of raw messages.
func UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID : ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID struct
// This model "extends" ReservedIPTargetPrototypeEndpointGatewayIdentity
type ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID struct {
	// The unique identifier for this endpoint gateway.
	ID *string `json:"id" validate:"required"`
}

// NewReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID : Instantiate ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID (Generic Model Constructor)
func (*VpcV1) NewReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID(id string) (_model *ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID, err error) {
	_model = &ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID) isaReservedIPTargetPrototypeEndpointGatewayIdentity() bool {
	return true
}

func (*ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID) isaReservedIPTargetPrototype() bool {
	return true
}

// UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID unmarshals an instance of ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID from the specified map of raw messages.
func UnmarshalReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReservedIPTargetPrototypeEndpointGatewayIdentityEndpointGatewayIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP : RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP struct
// This model "extends" RouteNextHopPatchRouteNextHopIP
type RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP struct {
	// The sentinel IP address (`0.0.0.0`).
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewRouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP : Instantiate RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP(address string) (_model *RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP, err error) {
	_model = &RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP) isaRouteNextHopPatchRouteNextHopIP() bool {
	return true
}

func (*RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP) isaRouteNextHopPatch() bool {
	return true
}

// UnmarshalRouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP unmarshals an instance of RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP from the specified map of raw messages.
func UnmarshalRouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatchRouteNextHopIPRouteNextHopIPSentinelIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP : RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP struct
// This model "extends" RouteNextHopPatchRouteNextHopIP
type RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP struct {
	// A unicast IP address, which must not be any of the following values:
	//
	// - `0.0.0.0` (the sentinel IP address)
	// - `224.0.0.0` to `239.255.255.255` (multicast IP addresses)
	// - `255.255.255.255` (the broadcast IP address)
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewRouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP : Instantiate RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP(address string) (_model *RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP, err error) {
	_model = &RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP) isaRouteNextHopPatchRouteNextHopIP() bool {
	return true
}

func (*RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP) isaRouteNextHopPatch() bool {
	return true
}

// UnmarshalRouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP unmarshals an instance of RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP from the specified map of raw messages.
func UnmarshalRouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatchRouteNextHopIPRouteNextHopIPUnicastIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref : RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref struct
// This model "extends" RouteNextHopPatchVPNGatewayConnectionIdentity
type RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref struct {
	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref : Instantiate RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref(href string) (_model *RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref, err error) {
	_model = &RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref) isaRouteNextHopPatchVPNGatewayConnectionIdentity() bool {
	return true
}

func (*RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref) isaRouteNextHopPatch() bool {
	return true
}

// UnmarshalRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref unmarshals an instance of RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref from the specified map of raw messages.
func UnmarshalRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID : RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID struct
// This model "extends" RouteNextHopPatchVPNGatewayConnectionIdentity
type RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID struct {
	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`
}

// NewRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID : Instantiate RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID(id string) (_model *RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID, err error) {
	_model = &RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID) isaRouteNextHopPatchVPNGatewayConnectionIdentity() bool {
	return true
}

func (*RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID) isaRouteNextHopPatch() bool {
	return true
}

// UnmarshalRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID unmarshals an instance of RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID from the specified map of raw messages.
func UnmarshalRouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPatchVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP : RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP struct
// This model "extends" RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP
type RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP struct {
	// The sentinel IP address (`0.0.0.0`).
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP : Instantiate RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP (Generic Model Constructor)
func (*VpcV1) NewRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP(address string) (_model *RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP, err error) {
	_model = &RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP) isaRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP() bool {
	return true
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP) isaRoutePrototypeNextHop() bool {
	return true
}

// UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP unmarshals an instance of RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPSentinelIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP : RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP struct
// This model "extends" RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP
type RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP struct {
	// A unicast IP address, which must not be any of the following values:
	//
	// - `0.0.0.0` (the sentinel IP address)
	// - `224.0.0.0` to `239.255.255.255` (multicast IP addresses)
	// - `255.255.255.255` (the broadcast IP address)
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP : Instantiate RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP (Generic Model Constructor)
func (*VpcV1) NewRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP(address string) (_model *RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP, err error) {
	_model = &RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP) isaRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIP() bool {
	return true
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP) isaRoutePrototypeNextHop() bool {
	return true
}

// UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP unmarshals an instance of RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHopRouteNextHopPrototypeRouteNextHopIPRouteNextHopPrototypeRouteNextHopIPRouteNextHopIPUnicastIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref : RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref struct
// This model "extends" RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity
type RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref struct {
	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref : Instantiate RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref(href string) (_model *RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref, err error) {
	_model = &RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref) isaRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity() bool {
	return true
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref) isaRoutePrototypeNextHop() bool {
	return true
}

// UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref unmarshals an instance of RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID : RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID struct
// This model "extends" RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity
type RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID struct {
	// The unique identifier for this VPN gateway connection.
	ID *string `json:"id" validate:"required"`
}

// NewRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID : Instantiate RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID (Generic Model Constructor)
func (*VpcV1) NewRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID(id string) (_model *RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID, err error) {
	_model = &RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID) isaRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentity() bool {
	return true
}

func (*RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID) isaRoutePrototypeNextHop() bool {
	return true
}

// UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID unmarshals an instance of RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID from the specified map of raw messages.
func UnmarshalRoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototypeNextHopRouteNextHopPrototypeVPNGatewayConnectionIdentityRouteNextHopPrototypeVPNGatewayConnectionIdentityVPNGatewayConnectionIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRuleRemotePatchSecurityGroupIdentity
type SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (_model *SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	_model = &SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRuleRemotePatchSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRuleRemotePatchSecurityGroupIdentity
type SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (_model *SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	_model = &SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRuleRemotePatchSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref unmarshals an instance of SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRuleRemotePatchSecurityGroupIdentity
type SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID(id string) (_model *SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	_model = &SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRuleRemotePatchSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRuleRemotePatch() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID unmarshals an instance of SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePatchSecurityGroupIdentitySecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRuleRemotePrototypeSecurityGroupIdentity
type SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (_model *SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	_model = &SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRuleRemotePrototypeSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRuleRemotePrototypeSecurityGroupIdentity
type SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (_model *SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	_model = &SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRuleRemotePrototypeSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref unmarshals an instance of SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRuleRemotePrototypeSecurityGroupIdentity
type SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID(id string) (_model *SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	_model = &SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRuleRemotePrototypeSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRuleRemotePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID unmarshals an instance of SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemotePrototypeSecurityGroupIdentitySecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref : VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref struct
// This model "extends" VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext
type VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref struct {
	// The URL for this reserved IP.
	Href *string `json:"href" validate:"required"`
}

// NewVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref : Instantiate VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref (Generic Model Constructor)
func (*VpcV1) NewVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref(href string) (_model *VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref, err error) {
	_model = &VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref) isaVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext() bool {
	return true
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref) isaVirtualNetworkInterfacePrimaryIPPrototype() bool {
	return true
}

// UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref unmarshals an instance of VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID : VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID struct
// This model "extends" VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext
type VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID struct {
	// The unique identifier for this reserved IP.
	ID *string `json:"id" validate:"required"`
}

// NewVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID : Instantiate VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID (Generic Model Constructor)
func (*VpcV1) NewVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID(id string) (_model *VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID, err error) {
	_model = &VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID) isaVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContext() bool {
	return true
}

func (*VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID) isaVirtualNetworkInterfacePrimaryIPPrototype() bool {
	return true
}

// UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID unmarshals an instance of VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID from the specified map of raw messages.
func UnmarshalVirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualNetworkInterfacePrimaryIPPrototypeReservedIPIdentityVirtualNetworkInterfacePrimaryIPContextByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN : VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN struct
// This model "extends" VolumeAttachmentPrototypeVolumeVolumeIdentity
type VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`
}

// NewVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN : Instantiate VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN(crn string) (_model *VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	_model = &VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN) isaVolumeAttachmentPrototypeVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref : VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref struct
// This model "extends" VolumeAttachmentPrototypeVolumeVolumeIdentity
type VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref struct {
	// The URL for this volume.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref : Instantiate VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref(href string) (_model *VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	_model = &VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref) isaVolumeAttachmentPrototypeVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID : VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID struct
// This model "extends" VolumeAttachmentPrototypeVolumeVolumeIdentity
type VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID struct {
	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`
}

// NewVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID : Instantiate VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID(id string) (_model *VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID, err error) {
	_model = &VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID) isaVolumeAttachmentPrototypeVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumeIdentityVolumeIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity : VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity struct
// This model "extends" VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity struct {
	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use for this volume. If unspecified, the instance's resource group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The capacity to use for the volume (in gigabytes). The specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`
}

// NewVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity : Instantiate VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(profile VolumeProfileIdentityIntf, capacity int64) (_model *VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	_model = &VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity{
		Profile:  profile,
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity) isaVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext() bool {
	return true
}

func (*VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot : VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot struct
// This model "extends" VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot struct {
	// The maximum I/O operations per second (IOPS) to use for this volume. Applicable only to volumes using a profile
	// `family` of `custom`.
	Iops *int64 `json:"iops,omitempty"`

	// The name for this volume. The name must not be used by another volume in the region. If unspecified, the name will
	// be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The [profile](https://cloud.ibm.com/docs/vpc?topic=vpc-block-storage-profiles) to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use for this volume. If unspecified, the instance's resource group will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The [user tags](https://cloud.ibm.com/apidocs/tagging#types-of-tags) associated with this volume.
	UserTags []string `json:"user_tags,omitempty"`

	// The capacity to use for the volume (in gigabytes). Must be at least the snapshot's
	// `minimum_capacity`. The maximum value may increase in the future.
	//
	// If unspecified, the capacity will be the source snapshot's `minimum_capacity`.
	Capacity *int64 `json:"capacity,omitempty"`

	// The root key to use to wrap the data encryption key for the volume.
	//
	// If unspecified, the `encryption` type for the volume will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The snapshot from which to clone the volume.
	SourceSnapshot SnapshotIdentityIntf `json:"source_snapshot" validate:"required"`
}

// NewVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot : Instantiate VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot(profile VolumeProfileIdentityIntf, sourceSnapshot SnapshotIdentityIntf) (_model *VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot, err error) {
	_model = &VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot{
		Profile:        profile,
		SourceSnapshot: sourceSnapshot,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot) isaVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContext() bool {
	return true
}

func (*VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot) isaVolumeAttachmentPrototypeVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot unmarshals an instance of VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeBySourceSnapshot)
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_tags", &obj.UserTags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_snapshot", &obj.SourceSnapshot, UnmarshalSnapshotIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup : InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup struct
// This model "extends" InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec
type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroupPrototype `json:"group" validate:"required"`
}

// NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup : Instantiate InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup(group *InstanceGroupManagerScheduledActionGroupPrototype) (_model *InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup, err error) {
	_model = &InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup{
		Group: group,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup) isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByGroup)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroupPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager : InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager struct
// This model "extends" InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec
type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The cron specification for a recurring scheduled action. Actions can be applied a maximum of one time within a 5 min
	// period.
	CronSpec *string `json:"cron_spec,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerPrototypeIntf `json:"manager" validate:"required"`
}

// NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager : Instantiate InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager(manager InstanceGroupManagerScheduledActionManagerPrototypeIntf) (_model *InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager, err error) {
	_model = &InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager{
		Manager: manager,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager) isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpec() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototypeByCronSpecByManager)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cron_spec", &obj.CronSpec)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManagerPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup : InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup struct
// This model "extends" InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt
type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The date and time the scheduled action will run.
	RunAt *strfmt.DateTime `json:"run_at,omitempty"`

	Group *InstanceGroupManagerScheduledActionGroupPrototype `json:"group" validate:"required"`
}

// NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup : Instantiate InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup(group *InstanceGroupManagerScheduledActionGroupPrototype) (_model *InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup, err error) {
	_model = &InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup{
		Group: group,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup) isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByGroup)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "run_at", &obj.RunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalInstanceGroupManagerScheduledActionGroupPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager : InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager struct
// This model "extends" InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt
type InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager struct {
	// The name for this instance group manager action. The name must not be used by another action for the instance group
	// manager. If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The date and time the scheduled action will run.
	RunAt *strfmt.DateTime `json:"run_at,omitempty"`

	Manager InstanceGroupManagerScheduledActionManagerPrototypeIntf `json:"manager" validate:"required"`
}

// NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager : Instantiate InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager(manager InstanceGroupManagerScheduledActionManagerPrototypeIntf) (_model *InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager, err error) {
	_model = &InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager{
		Manager: manager,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager) isaInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAt() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager) isaInstanceGroupManagerActionPrototypeScheduledActionPrototype() bool {
	return true
}

func (*InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager) isaInstanceGroupManagerActionPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager unmarshals an instance of InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager from the specified map of raw messages.
func UnmarshalInstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerActionPrototypeScheduledActionPrototypeByRunAtByManager)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "run_at", &obj.RunAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "manager", &obj.Manager, UnmarshalInstanceGroupManagerScheduledActionManagerPrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcsPager can be used to simplify the use of the "ListVpcs" method.
type VpcsPager struct {
	hasNext     bool
	options     *ListVpcsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVpcsPager returns a new VpcsPager instance.
func (vpc *VpcV1) NewVpcsPager(options *ListVpcsOptions) (pager *VpcsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVpcsOptions = *options
	pager = &VpcsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VpcsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VpcsPager) GetNextWithContext(ctx context.Context) (page []VPC, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVpcsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Vpcs

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VpcsPager) GetAllWithContext(ctx context.Context) (allItems []VPC, err error) {
	for pager.HasNext() {
		var nextPage []VPC
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VpcsPager) GetNext() (page []VPC, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VpcsPager) GetAll() (allItems []VPC, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPCAddressPrefixesPager can be used to simplify the use of the "ListVPCAddressPrefixes" method.
type VPCAddressPrefixesPager struct {
	hasNext     bool
	options     *ListVPCAddressPrefixesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPCAddressPrefixesPager returns a new VPCAddressPrefixesPager instance.
func (vpc *VpcV1) NewVPCAddressPrefixesPager(options *ListVPCAddressPrefixesOptions) (pager *VPCAddressPrefixesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPCAddressPrefixesOptions = *options
	pager = &VPCAddressPrefixesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPCAddressPrefixesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPCAddressPrefixesPager) GetNextWithContext(ctx context.Context) (page []AddressPrefix, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPCAddressPrefixesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.AddressPrefixes

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPCAddressPrefixesPager) GetAllWithContext(ctx context.Context) (allItems []AddressPrefix, err error) {
	for pager.HasNext() {
		var nextPage []AddressPrefix
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPCAddressPrefixesPager) GetNext() (page []AddressPrefix, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPCAddressPrefixesPager) GetAll() (allItems []AddressPrefix, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPCDnsResolutionBindingsPager can be used to simplify the use of the "ListVPCDnsResolutionBindings" method.
type VPCDnsResolutionBindingsPager struct {
	hasNext     bool
	options     *ListVPCDnsResolutionBindingsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPCDnsResolutionBindingsPager returns a new VPCDnsResolutionBindingsPager instance.
func (vpc *VpcV1) NewVPCDnsResolutionBindingsPager(options *ListVPCDnsResolutionBindingsOptions) (pager *VPCDnsResolutionBindingsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPCDnsResolutionBindingsOptions = *options
	pager = &VPCDnsResolutionBindingsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPCDnsResolutionBindingsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPCDnsResolutionBindingsPager) GetNextWithContext(ctx context.Context) (page []VpcdnsResolutionBinding, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPCDnsResolutionBindingsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.DnsResolutionBindings

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPCDnsResolutionBindingsPager) GetAllWithContext(ctx context.Context) (allItems []VpcdnsResolutionBinding, err error) {
	for pager.HasNext() {
		var nextPage []VpcdnsResolutionBinding
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPCDnsResolutionBindingsPager) GetNext() (page []VpcdnsResolutionBinding, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPCDnsResolutionBindingsPager) GetAll() (allItems []VpcdnsResolutionBinding, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPCRoutesPager can be used to simplify the use of the "ListVPCRoutes" method.
type VPCRoutesPager struct {
	hasNext     bool
	options     *ListVPCRoutesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPCRoutesPager returns a new VPCRoutesPager instance.
func (vpc *VpcV1) NewVPCRoutesPager(options *ListVPCRoutesOptions) (pager *VPCRoutesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPCRoutesOptions = *options
	pager = &VPCRoutesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPCRoutesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPCRoutesPager) GetNextWithContext(ctx context.Context) (page []RouteCollectionVPCContextRoutesItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPCRoutesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Routes

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPCRoutesPager) GetAllWithContext(ctx context.Context) (allItems []RouteCollectionVPCContextRoutesItem, err error) {
	for pager.HasNext() {
		var nextPage []RouteCollectionVPCContextRoutesItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPCRoutesPager) GetNext() (page []RouteCollectionVPCContextRoutesItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPCRoutesPager) GetAll() (allItems []RouteCollectionVPCContextRoutesItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPCRoutingTablesPager can be used to simplify the use of the "ListVPCRoutingTables" method.
type VPCRoutingTablesPager struct {
	hasNext     bool
	options     *ListVPCRoutingTablesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPCRoutingTablesPager returns a new VPCRoutingTablesPager instance.
func (vpc *VpcV1) NewVPCRoutingTablesPager(options *ListVPCRoutingTablesOptions) (pager *VPCRoutingTablesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPCRoutingTablesOptions = *options
	pager = &VPCRoutingTablesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPCRoutingTablesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPCRoutingTablesPager) GetNextWithContext(ctx context.Context) (page []RoutingTable, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPCRoutingTablesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.RoutingTables

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPCRoutingTablesPager) GetAllWithContext(ctx context.Context) (allItems []RoutingTable, err error) {
	for pager.HasNext() {
		var nextPage []RoutingTable
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPCRoutingTablesPager) GetNext() (page []RoutingTable, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPCRoutingTablesPager) GetAll() (allItems []RoutingTable, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPCRoutingTableRoutesPager can be used to simplify the use of the "ListVPCRoutingTableRoutes" method.
type VPCRoutingTableRoutesPager struct {
	hasNext     bool
	options     *ListVPCRoutingTableRoutesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPCRoutingTableRoutesPager returns a new VPCRoutingTableRoutesPager instance.
func (vpc *VpcV1) NewVPCRoutingTableRoutesPager(options *ListVPCRoutingTableRoutesOptions) (pager *VPCRoutingTableRoutesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPCRoutingTableRoutesOptions = *options
	pager = &VPCRoutingTableRoutesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPCRoutingTableRoutesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPCRoutingTableRoutesPager) GetNextWithContext(ctx context.Context) (page []Route, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPCRoutingTableRoutesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Routes

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPCRoutingTableRoutesPager) GetAllWithContext(ctx context.Context) (allItems []Route, err error) {
	for pager.HasNext() {
		var nextPage []Route
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPCRoutingTableRoutesPager) GetNext() (page []Route, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPCRoutingTableRoutesPager) GetAll() (allItems []Route, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SubnetsPager can be used to simplify the use of the "ListSubnets" method.
type SubnetsPager struct {
	hasNext     bool
	options     *ListSubnetsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewSubnetsPager returns a new SubnetsPager instance.
func (vpc *VpcV1) NewSubnetsPager(options *ListSubnetsOptions) (pager *SubnetsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListSubnetsOptions = *options
	pager = &SubnetsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SubnetsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SubnetsPager) GetNextWithContext(ctx context.Context) (page []Subnet, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListSubnetsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Subnets

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SubnetsPager) GetAllWithContext(ctx context.Context) (allItems []Subnet, err error) {
	for pager.HasNext() {
		var nextPage []Subnet
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SubnetsPager) GetNext() (page []Subnet, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SubnetsPager) GetAll() (allItems []Subnet, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SubnetReservedIpsPager can be used to simplify the use of the "ListSubnetReservedIps" method.
type SubnetReservedIpsPager struct {
	hasNext     bool
	options     *ListSubnetReservedIpsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewSubnetReservedIpsPager returns a new SubnetReservedIpsPager instance.
func (vpc *VpcV1) NewSubnetReservedIpsPager(options *ListSubnetReservedIpsOptions) (pager *SubnetReservedIpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListSubnetReservedIpsOptions = *options
	pager = &SubnetReservedIpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SubnetReservedIpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SubnetReservedIpsPager) GetNextWithContext(ctx context.Context) (page []ReservedIP, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListSubnetReservedIpsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.ReservedIps

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SubnetReservedIpsPager) GetAllWithContext(ctx context.Context) (allItems []ReservedIP, err error) {
	for pager.HasNext() {
		var nextPage []ReservedIP
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SubnetReservedIpsPager) GetNext() (page []ReservedIP, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SubnetReservedIpsPager) GetAll() (allItems []ReservedIP, err error) {
	return pager.GetAllWithContext(context.Background())
}

// ImagesPager can be used to simplify the use of the "ListImages" method.
type ImagesPager struct {
	hasNext     bool
	options     *ListImagesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewImagesPager returns a new ImagesPager instance.
func (vpc *VpcV1) NewImagesPager(options *ListImagesOptions) (pager *ImagesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListImagesOptions = *options
	pager = &ImagesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ImagesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ImagesPager) GetNextWithContext(ctx context.Context) (page []Image, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListImagesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Images

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ImagesPager) GetAllWithContext(ctx context.Context) (allItems []Image, err error) {
	for pager.HasNext() {
		var nextPage []Image
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ImagesPager) GetNext() (page []Image, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ImagesPager) GetAll() (allItems []Image, err error) {
	return pager.GetAllWithContext(context.Background())
}

// OperatingSystemsPager can be used to simplify the use of the "ListOperatingSystems" method.
type OperatingSystemsPager struct {
	hasNext     bool
	options     *ListOperatingSystemsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewOperatingSystemsPager returns a new OperatingSystemsPager instance.
func (vpc *VpcV1) NewOperatingSystemsPager(options *ListOperatingSystemsOptions) (pager *OperatingSystemsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListOperatingSystemsOptions = *options
	pager = &OperatingSystemsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *OperatingSystemsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *OperatingSystemsPager) GetNextWithContext(ctx context.Context) (page []OperatingSystem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListOperatingSystemsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.OperatingSystems

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *OperatingSystemsPager) GetAllWithContext(ctx context.Context) (allItems []OperatingSystem, err error) {
	for pager.HasNext() {
		var nextPage []OperatingSystem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *OperatingSystemsPager) GetNext() (page []OperatingSystem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *OperatingSystemsPager) GetAll() (allItems []OperatingSystem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// KeysPager can be used to simplify the use of the "ListKeys" method.
type KeysPager struct {
	hasNext     bool
	options     *ListKeysOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewKeysPager returns a new KeysPager instance.
func (vpc *VpcV1) NewKeysPager(options *ListKeysOptions) (pager *KeysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListKeysOptions = *options
	pager = &KeysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *KeysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *KeysPager) GetNextWithContext(ctx context.Context) (page []Key, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListKeysWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Keys

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *KeysPager) GetAllWithContext(ctx context.Context) (allItems []Key, err error) {
	for pager.HasNext() {
		var nextPage []Key
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *KeysPager) GetNext() (page []Key, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *KeysPager) GetAll() (allItems []Key, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstancesPager can be used to simplify the use of the "ListInstances" method.
type InstancesPager struct {
	hasNext     bool
	options     *ListInstancesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstancesPager returns a new InstancesPager instance.
func (vpc *VpcV1) NewInstancesPager(options *ListInstancesOptions) (pager *InstancesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstancesOptions = *options
	pager = &InstancesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstancesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstancesPager) GetNextWithContext(ctx context.Context) (page []Instance, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstancesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Instances

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstancesPager) GetAllWithContext(ctx context.Context) (allItems []Instance, err error) {
	for pager.HasNext() {
		var nextPage []Instance
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstancesPager) GetNext() (page []Instance, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstancesPager) GetAll() (allItems []Instance, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstanceNetworkInterfaceIpsPager can be used to simplify the use of the "ListInstanceNetworkInterfaceIps" method.
type InstanceNetworkInterfaceIpsPager struct {
	hasNext     bool
	options     *ListInstanceNetworkInterfaceIpsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstanceNetworkInterfaceIpsPager returns a new InstanceNetworkInterfaceIpsPager instance.
func (vpc *VpcV1) NewInstanceNetworkInterfaceIpsPager(options *ListInstanceNetworkInterfaceIpsOptions) (pager *InstanceNetworkInterfaceIpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstanceNetworkInterfaceIpsOptions = *options
	pager = &InstanceNetworkInterfaceIpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstanceNetworkInterfaceIpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstanceNetworkInterfaceIpsPager) GetNextWithContext(ctx context.Context) (page []ReservedIP, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstanceNetworkInterfaceIpsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Ips

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstanceNetworkInterfaceIpsPager) GetAllWithContext(ctx context.Context) (allItems []ReservedIP, err error) {
	for pager.HasNext() {
		var nextPage []ReservedIP
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstanceNetworkInterfaceIpsPager) GetNext() (page []ReservedIP, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstanceNetworkInterfaceIpsPager) GetAll() (allItems []ReservedIP, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstanceGroupsPager can be used to simplify the use of the "ListInstanceGroups" method.
type InstanceGroupsPager struct {
	hasNext     bool
	options     *ListInstanceGroupsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstanceGroupsPager returns a new InstanceGroupsPager instance.
func (vpc *VpcV1) NewInstanceGroupsPager(options *ListInstanceGroupsOptions) (pager *InstanceGroupsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstanceGroupsOptions = *options
	pager = &InstanceGroupsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstanceGroupsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstanceGroupsPager) GetNextWithContext(ctx context.Context) (page []InstanceGroup, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstanceGroupsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.InstanceGroups

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstanceGroupsPager) GetAllWithContext(ctx context.Context) (allItems []InstanceGroup, err error) {
	for pager.HasNext() {
		var nextPage []InstanceGroup
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupsPager) GetNext() (page []InstanceGroup, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupsPager) GetAll() (allItems []InstanceGroup, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstanceGroupManagersPager can be used to simplify the use of the "ListInstanceGroupManagers" method.
type InstanceGroupManagersPager struct {
	hasNext     bool
	options     *ListInstanceGroupManagersOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstanceGroupManagersPager returns a new InstanceGroupManagersPager instance.
func (vpc *VpcV1) NewInstanceGroupManagersPager(options *ListInstanceGroupManagersOptions) (pager *InstanceGroupManagersPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstanceGroupManagersOptions = *options
	pager = &InstanceGroupManagersPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstanceGroupManagersPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstanceGroupManagersPager) GetNextWithContext(ctx context.Context) (page []InstanceGroupManagerIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstanceGroupManagersWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Managers

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstanceGroupManagersPager) GetAllWithContext(ctx context.Context) (allItems []InstanceGroupManagerIntf, err error) {
	for pager.HasNext() {
		var nextPage []InstanceGroupManagerIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupManagersPager) GetNext() (page []InstanceGroupManagerIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupManagersPager) GetAll() (allItems []InstanceGroupManagerIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstanceGroupManagerActionsPager can be used to simplify the use of the "ListInstanceGroupManagerActions" method.
type InstanceGroupManagerActionsPager struct {
	hasNext     bool
	options     *ListInstanceGroupManagerActionsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstanceGroupManagerActionsPager returns a new InstanceGroupManagerActionsPager instance.
func (vpc *VpcV1) NewInstanceGroupManagerActionsPager(options *ListInstanceGroupManagerActionsOptions) (pager *InstanceGroupManagerActionsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstanceGroupManagerActionsOptions = *options
	pager = &InstanceGroupManagerActionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstanceGroupManagerActionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstanceGroupManagerActionsPager) GetNextWithContext(ctx context.Context) (page []InstanceGroupManagerActionIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstanceGroupManagerActionsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Actions

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstanceGroupManagerActionsPager) GetAllWithContext(ctx context.Context) (allItems []InstanceGroupManagerActionIntf, err error) {
	for pager.HasNext() {
		var nextPage []InstanceGroupManagerActionIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupManagerActionsPager) GetNext() (page []InstanceGroupManagerActionIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupManagerActionsPager) GetAll() (allItems []InstanceGroupManagerActionIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstanceGroupManagerPoliciesPager can be used to simplify the use of the "ListInstanceGroupManagerPolicies" method.
type InstanceGroupManagerPoliciesPager struct {
	hasNext     bool
	options     *ListInstanceGroupManagerPoliciesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstanceGroupManagerPoliciesPager returns a new InstanceGroupManagerPoliciesPager instance.
func (vpc *VpcV1) NewInstanceGroupManagerPoliciesPager(options *ListInstanceGroupManagerPoliciesOptions) (pager *InstanceGroupManagerPoliciesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstanceGroupManagerPoliciesOptions = *options
	pager = &InstanceGroupManagerPoliciesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstanceGroupManagerPoliciesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstanceGroupManagerPoliciesPager) GetNextWithContext(ctx context.Context) (page []InstanceGroupManagerPolicyIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstanceGroupManagerPoliciesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Policies

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstanceGroupManagerPoliciesPager) GetAllWithContext(ctx context.Context) (allItems []InstanceGroupManagerPolicyIntf, err error) {
	for pager.HasNext() {
		var nextPage []InstanceGroupManagerPolicyIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupManagerPoliciesPager) GetNext() (page []InstanceGroupManagerPolicyIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupManagerPoliciesPager) GetAll() (allItems []InstanceGroupManagerPolicyIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// InstanceGroupMembershipsPager can be used to simplify the use of the "ListInstanceGroupMemberships" method.
type InstanceGroupMembershipsPager struct {
	hasNext     bool
	options     *ListInstanceGroupMembershipsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewInstanceGroupMembershipsPager returns a new InstanceGroupMembershipsPager instance.
func (vpc *VpcV1) NewInstanceGroupMembershipsPager(options *ListInstanceGroupMembershipsOptions) (pager *InstanceGroupMembershipsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListInstanceGroupMembershipsOptions = *options
	pager = &InstanceGroupMembershipsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *InstanceGroupMembershipsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *InstanceGroupMembershipsPager) GetNextWithContext(ctx context.Context) (page []InstanceGroupMembership, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListInstanceGroupMembershipsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Memberships

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *InstanceGroupMembershipsPager) GetAllWithContext(ctx context.Context) (allItems []InstanceGroupMembership, err error) {
	for pager.HasNext() {
		var nextPage []InstanceGroupMembership
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupMembershipsPager) GetNext() (page []InstanceGroupMembership, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *InstanceGroupMembershipsPager) GetAll() (allItems []InstanceGroupMembership, err error) {
	return pager.GetAllWithContext(context.Background())
}

// DedicatedHostGroupsPager can be used to simplify the use of the "ListDedicatedHostGroups" method.
type DedicatedHostGroupsPager struct {
	hasNext     bool
	options     *ListDedicatedHostGroupsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewDedicatedHostGroupsPager returns a new DedicatedHostGroupsPager instance.
func (vpc *VpcV1) NewDedicatedHostGroupsPager(options *ListDedicatedHostGroupsOptions) (pager *DedicatedHostGroupsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListDedicatedHostGroupsOptions = *options
	pager = &DedicatedHostGroupsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *DedicatedHostGroupsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *DedicatedHostGroupsPager) GetNextWithContext(ctx context.Context) (page []DedicatedHostGroup, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListDedicatedHostGroupsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Groups

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *DedicatedHostGroupsPager) GetAllWithContext(ctx context.Context) (allItems []DedicatedHostGroup, err error) {
	for pager.HasNext() {
		var nextPage []DedicatedHostGroup
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *DedicatedHostGroupsPager) GetNext() (page []DedicatedHostGroup, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *DedicatedHostGroupsPager) GetAll() (allItems []DedicatedHostGroup, err error) {
	return pager.GetAllWithContext(context.Background())
}

// DedicatedHostProfilesPager can be used to simplify the use of the "ListDedicatedHostProfiles" method.
type DedicatedHostProfilesPager struct {
	hasNext     bool
	options     *ListDedicatedHostProfilesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewDedicatedHostProfilesPager returns a new DedicatedHostProfilesPager instance.
func (vpc *VpcV1) NewDedicatedHostProfilesPager(options *ListDedicatedHostProfilesOptions) (pager *DedicatedHostProfilesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListDedicatedHostProfilesOptions = *options
	pager = &DedicatedHostProfilesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *DedicatedHostProfilesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *DedicatedHostProfilesPager) GetNextWithContext(ctx context.Context) (page []DedicatedHostProfile, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListDedicatedHostProfilesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Profiles

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *DedicatedHostProfilesPager) GetAllWithContext(ctx context.Context) (allItems []DedicatedHostProfile, err error) {
	for pager.HasNext() {
		var nextPage []DedicatedHostProfile
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *DedicatedHostProfilesPager) GetNext() (page []DedicatedHostProfile, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *DedicatedHostProfilesPager) GetAll() (allItems []DedicatedHostProfile, err error) {
	return pager.GetAllWithContext(context.Background())
}

// DedicatedHostsPager can be used to simplify the use of the "ListDedicatedHosts" method.
type DedicatedHostsPager struct {
	hasNext     bool
	options     *ListDedicatedHostsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewDedicatedHostsPager returns a new DedicatedHostsPager instance.
func (vpc *VpcV1) NewDedicatedHostsPager(options *ListDedicatedHostsOptions) (pager *DedicatedHostsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListDedicatedHostsOptions = *options
	pager = &DedicatedHostsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *DedicatedHostsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *DedicatedHostsPager) GetNextWithContext(ctx context.Context) (page []DedicatedHost, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListDedicatedHostsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.DedicatedHosts

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *DedicatedHostsPager) GetAllWithContext(ctx context.Context) (allItems []DedicatedHost, err error) {
	for pager.HasNext() {
		var nextPage []DedicatedHost
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *DedicatedHostsPager) GetNext() (page []DedicatedHost, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *DedicatedHostsPager) GetAll() (allItems []DedicatedHost, err error) {
	return pager.GetAllWithContext(context.Background())
}

// BackupPoliciesPager can be used to simplify the use of the "ListBackupPolicies" method.
type BackupPoliciesPager struct {
	hasNext     bool
	options     *ListBackupPoliciesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewBackupPoliciesPager returns a new BackupPoliciesPager instance.
func (vpc *VpcV1) NewBackupPoliciesPager(options *ListBackupPoliciesOptions) (pager *BackupPoliciesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListBackupPoliciesOptions = *options
	pager = &BackupPoliciesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *BackupPoliciesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *BackupPoliciesPager) GetNextWithContext(ctx context.Context) (page []BackupPolicy, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListBackupPoliciesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.BackupPolicies

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *BackupPoliciesPager) GetAllWithContext(ctx context.Context) (allItems []BackupPolicy, err error) {
	for pager.HasNext() {
		var nextPage []BackupPolicy
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *BackupPoliciesPager) GetNext() (page []BackupPolicy, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *BackupPoliciesPager) GetAll() (allItems []BackupPolicy, err error) {
	return pager.GetAllWithContext(context.Background())
}

// BackupPolicyJobsPager can be used to simplify the use of the "ListBackupPolicyJobs" method.
type BackupPolicyJobsPager struct {
	hasNext     bool
	options     *ListBackupPolicyJobsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewBackupPolicyJobsPager returns a new BackupPolicyJobsPager instance.
func (vpc *VpcV1) NewBackupPolicyJobsPager(options *ListBackupPolicyJobsOptions) (pager *BackupPolicyJobsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListBackupPolicyJobsOptions = *options
	pager = &BackupPolicyJobsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *BackupPolicyJobsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *BackupPolicyJobsPager) GetNextWithContext(ctx context.Context) (page []BackupPolicyJob, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListBackupPolicyJobsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Jobs

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *BackupPolicyJobsPager) GetAllWithContext(ctx context.Context) (allItems []BackupPolicyJob, err error) {
	for pager.HasNext() {
		var nextPage []BackupPolicyJob
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *BackupPolicyJobsPager) GetNext() (page []BackupPolicyJob, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *BackupPolicyJobsPager) GetAll() (allItems []BackupPolicyJob, err error) {
	return pager.GetAllWithContext(context.Background())
}

// PlacementGroupsPager can be used to simplify the use of the "ListPlacementGroups" method.
type PlacementGroupsPager struct {
	hasNext     bool
	options     *ListPlacementGroupsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewPlacementGroupsPager returns a new PlacementGroupsPager instance.
func (vpc *VpcV1) NewPlacementGroupsPager(options *ListPlacementGroupsOptions) (pager *PlacementGroupsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListPlacementGroupsOptions = *options
	pager = &PlacementGroupsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *PlacementGroupsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *PlacementGroupsPager) GetNextWithContext(ctx context.Context) (page []PlacementGroup, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListPlacementGroupsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.PlacementGroups

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *PlacementGroupsPager) GetAllWithContext(ctx context.Context) (allItems []PlacementGroup, err error) {
	for pager.HasNext() {
		var nextPage []PlacementGroup
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *PlacementGroupsPager) GetNext() (page []PlacementGroup, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *PlacementGroupsPager) GetAll() (allItems []PlacementGroup, err error) {
	return pager.GetAllWithContext(context.Background())
}

// BareMetalServerProfilesPager can be used to simplify the use of the "ListBareMetalServerProfiles" method.
type BareMetalServerProfilesPager struct {
	hasNext     bool
	options     *ListBareMetalServerProfilesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewBareMetalServerProfilesPager returns a new BareMetalServerProfilesPager instance.
func (vpc *VpcV1) NewBareMetalServerProfilesPager(options *ListBareMetalServerProfilesOptions) (pager *BareMetalServerProfilesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListBareMetalServerProfilesOptions = *options
	pager = &BareMetalServerProfilesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *BareMetalServerProfilesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *BareMetalServerProfilesPager) GetNextWithContext(ctx context.Context) (page []BareMetalServerProfile, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListBareMetalServerProfilesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Profiles

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *BareMetalServerProfilesPager) GetAllWithContext(ctx context.Context) (allItems []BareMetalServerProfile, err error) {
	for pager.HasNext() {
		var nextPage []BareMetalServerProfile
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *BareMetalServerProfilesPager) GetNext() (page []BareMetalServerProfile, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *BareMetalServerProfilesPager) GetAll() (allItems []BareMetalServerProfile, err error) {
	return pager.GetAllWithContext(context.Background())
}

// BareMetalServersPager can be used to simplify the use of the "ListBareMetalServers" method.
type BareMetalServersPager struct {
	hasNext     bool
	options     *ListBareMetalServersOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewBareMetalServersPager returns a new BareMetalServersPager instance.
func (vpc *VpcV1) NewBareMetalServersPager(options *ListBareMetalServersOptions) (pager *BareMetalServersPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListBareMetalServersOptions = *options
	pager = &BareMetalServersPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *BareMetalServersPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *BareMetalServersPager) GetNextWithContext(ctx context.Context) (page []BareMetalServer, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListBareMetalServersWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.BareMetalServers

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *BareMetalServersPager) GetAllWithContext(ctx context.Context) (allItems []BareMetalServer, err error) {
	for pager.HasNext() {
		var nextPage []BareMetalServer
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *BareMetalServersPager) GetNext() (page []BareMetalServer, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *BareMetalServersPager) GetAll() (allItems []BareMetalServer, err error) {
	return pager.GetAllWithContext(context.Background())
}

// BareMetalServerNetworkInterfacesPager can be used to simplify the use of the "ListBareMetalServerNetworkInterfaces" method.
type BareMetalServerNetworkInterfacesPager struct {
	hasNext     bool
	options     *ListBareMetalServerNetworkInterfacesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewBareMetalServerNetworkInterfacesPager returns a new BareMetalServerNetworkInterfacesPager instance.
func (vpc *VpcV1) NewBareMetalServerNetworkInterfacesPager(options *ListBareMetalServerNetworkInterfacesOptions) (pager *BareMetalServerNetworkInterfacesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListBareMetalServerNetworkInterfacesOptions = *options
	pager = &BareMetalServerNetworkInterfacesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *BareMetalServerNetworkInterfacesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *BareMetalServerNetworkInterfacesPager) GetNextWithContext(ctx context.Context) (page []BareMetalServerNetworkInterfaceIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListBareMetalServerNetworkInterfacesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.NetworkInterfaces

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *BareMetalServerNetworkInterfacesPager) GetAllWithContext(ctx context.Context) (allItems []BareMetalServerNetworkInterfaceIntf, err error) {
	for pager.HasNext() {
		var nextPage []BareMetalServerNetworkInterfaceIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *BareMetalServerNetworkInterfacesPager) GetNext() (page []BareMetalServerNetworkInterfaceIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *BareMetalServerNetworkInterfacesPager) GetAll() (allItems []BareMetalServerNetworkInterfaceIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VolumeProfilesPager can be used to simplify the use of the "ListVolumeProfiles" method.
type VolumeProfilesPager struct {
	hasNext     bool
	options     *ListVolumeProfilesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVolumeProfilesPager returns a new VolumeProfilesPager instance.
func (vpc *VpcV1) NewVolumeProfilesPager(options *ListVolumeProfilesOptions) (pager *VolumeProfilesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVolumeProfilesOptions = *options
	pager = &VolumeProfilesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VolumeProfilesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VolumeProfilesPager) GetNextWithContext(ctx context.Context) (page []VolumeProfile, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVolumeProfilesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Profiles

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VolumeProfilesPager) GetAllWithContext(ctx context.Context) (allItems []VolumeProfile, err error) {
	for pager.HasNext() {
		var nextPage []VolumeProfile
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VolumeProfilesPager) GetNext() (page []VolumeProfile, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VolumeProfilesPager) GetAll() (allItems []VolumeProfile, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VolumesPager can be used to simplify the use of the "ListVolumes" method.
type VolumesPager struct {
	hasNext     bool
	options     *ListVolumesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVolumesPager returns a new VolumesPager instance.
func (vpc *VpcV1) NewVolumesPager(options *ListVolumesOptions) (pager *VolumesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVolumesOptions = *options
	pager = &VolumesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VolumesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VolumesPager) GetNextWithContext(ctx context.Context) (page []Volume, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVolumesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Volumes

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VolumesPager) GetAllWithContext(ctx context.Context) (allItems []Volume, err error) {
	for pager.HasNext() {
		var nextPage []Volume
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VolumesPager) GetNext() (page []Volume, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VolumesPager) GetAll() (allItems []Volume, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SnapshotsPager can be used to simplify the use of the "ListSnapshots" method.
type SnapshotsPager struct {
	hasNext     bool
	options     *ListSnapshotsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewSnapshotsPager returns a new SnapshotsPager instance.
func (vpc *VpcV1) NewSnapshotsPager(options *ListSnapshotsOptions) (pager *SnapshotsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListSnapshotsOptions = *options
	pager = &SnapshotsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SnapshotsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SnapshotsPager) GetNextWithContext(ctx context.Context) (page []Snapshot, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListSnapshotsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Snapshots

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SnapshotsPager) GetAllWithContext(ctx context.Context) (allItems []Snapshot, err error) {
	for pager.HasNext() {
		var nextPage []Snapshot
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SnapshotsPager) GetNext() (page []Snapshot, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SnapshotsPager) GetAll() (allItems []Snapshot, err error) {
	return pager.GetAllWithContext(context.Background())
}

// ShareProfilesPager can be used to simplify the use of the "ListShareProfiles" method.
type ShareProfilesPager struct {
	hasNext     bool
	options     *ListShareProfilesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewShareProfilesPager returns a new ShareProfilesPager instance.
func (vpc *VpcV1) NewShareProfilesPager(options *ListShareProfilesOptions) (pager *ShareProfilesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListShareProfilesOptions = *options
	pager = &ShareProfilesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ShareProfilesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ShareProfilesPager) GetNextWithContext(ctx context.Context) (page []ShareProfile, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListShareProfilesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Profiles

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ShareProfilesPager) GetAllWithContext(ctx context.Context) (allItems []ShareProfile, err error) {
	for pager.HasNext() {
		var nextPage []ShareProfile
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ShareProfilesPager) GetNext() (page []ShareProfile, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ShareProfilesPager) GetAll() (allItems []ShareProfile, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SharesPager can be used to simplify the use of the "ListShares" method.
type SharesPager struct {
	hasNext     bool
	options     *ListSharesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewSharesPager returns a new SharesPager instance.
func (vpc *VpcV1) NewSharesPager(options *ListSharesOptions) (pager *SharesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListSharesOptions = *options
	pager = &SharesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SharesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SharesPager) GetNextWithContext(ctx context.Context) (page []Share, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListSharesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Shares

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SharesPager) GetAllWithContext(ctx context.Context) (allItems []Share, err error) {
	for pager.HasNext() {
		var nextPage []Share
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SharesPager) GetNext() (page []Share, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SharesPager) GetAll() (allItems []Share, err error) {
	return pager.GetAllWithContext(context.Background())
}

// ShareMountTargetsPager can be used to simplify the use of the "ListShareMountTargets" method.
type ShareMountTargetsPager struct {
	hasNext     bool
	options     *ListShareMountTargetsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewShareMountTargetsPager returns a new ShareMountTargetsPager instance.
func (vpc *VpcV1) NewShareMountTargetsPager(options *ListShareMountTargetsOptions) (pager *ShareMountTargetsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListShareMountTargetsOptions = *options
	pager = &ShareMountTargetsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ShareMountTargetsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ShareMountTargetsPager) GetNextWithContext(ctx context.Context) (page []ShareMountTarget, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListShareMountTargetsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.MountTargets

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ShareMountTargetsPager) GetAllWithContext(ctx context.Context) (allItems []ShareMountTarget, err error) {
	for pager.HasNext() {
		var nextPage []ShareMountTarget
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ShareMountTargetsPager) GetNext() (page []ShareMountTarget, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ShareMountTargetsPager) GetAll() (allItems []ShareMountTarget, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VirtualNetworkInterfacesPager can be used to simplify the use of the "ListVirtualNetworkInterfaces" method.
type VirtualNetworkInterfacesPager struct {
	hasNext     bool
	options     *ListVirtualNetworkInterfacesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVirtualNetworkInterfacesPager returns a new VirtualNetworkInterfacesPager instance.
func (vpc *VpcV1) NewVirtualNetworkInterfacesPager(options *ListVirtualNetworkInterfacesOptions) (pager *VirtualNetworkInterfacesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVirtualNetworkInterfacesOptions = *options
	pager = &VirtualNetworkInterfacesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VirtualNetworkInterfacesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VirtualNetworkInterfacesPager) GetNextWithContext(ctx context.Context) (page []VirtualNetworkInterface, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVirtualNetworkInterfacesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.VirtualNetworkInterfaces

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VirtualNetworkInterfacesPager) GetAllWithContext(ctx context.Context) (allItems []VirtualNetworkInterface, err error) {
	for pager.HasNext() {
		var nextPage []VirtualNetworkInterface
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VirtualNetworkInterfacesPager) GetNext() (page []VirtualNetworkInterface, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VirtualNetworkInterfacesPager) GetAll() (allItems []VirtualNetworkInterface, err error) {
	return pager.GetAllWithContext(context.Background())
}

// PublicGatewaysPager can be used to simplify the use of the "ListPublicGateways" method.
type PublicGatewaysPager struct {
	hasNext     bool
	options     *ListPublicGatewaysOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewPublicGatewaysPager returns a new PublicGatewaysPager instance.
func (vpc *VpcV1) NewPublicGatewaysPager(options *ListPublicGatewaysOptions) (pager *PublicGatewaysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListPublicGatewaysOptions = *options
	pager = &PublicGatewaysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *PublicGatewaysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *PublicGatewaysPager) GetNextWithContext(ctx context.Context) (page []PublicGateway, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListPublicGatewaysWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.PublicGateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *PublicGatewaysPager) GetAllWithContext(ctx context.Context) (allItems []PublicGateway, err error) {
	for pager.HasNext() {
		var nextPage []PublicGateway
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *PublicGatewaysPager) GetNext() (page []PublicGateway, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *PublicGatewaysPager) GetAll() (allItems []PublicGateway, err error) {
	return pager.GetAllWithContext(context.Background())
}

// FloatingIpsPager can be used to simplify the use of the "ListFloatingIps" method.
type FloatingIpsPager struct {
	hasNext     bool
	options     *ListFloatingIpsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewFloatingIpsPager returns a new FloatingIpsPager instance.
func (vpc *VpcV1) NewFloatingIpsPager(options *ListFloatingIpsOptions) (pager *FloatingIpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListFloatingIpsOptions = *options
	pager = &FloatingIpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *FloatingIpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *FloatingIpsPager) GetNextWithContext(ctx context.Context) (page []FloatingIP, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListFloatingIpsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.FloatingIps

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *FloatingIpsPager) GetAllWithContext(ctx context.Context) (allItems []FloatingIP, err error) {
	for pager.HasNext() {
		var nextPage []FloatingIP
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *FloatingIpsPager) GetNext() (page []FloatingIP, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *FloatingIpsPager) GetAll() (allItems []FloatingIP, err error) {
	return pager.GetAllWithContext(context.Background())
}

// NetworkAclsPager can be used to simplify the use of the "ListNetworkAcls" method.
type NetworkAclsPager struct {
	hasNext     bool
	options     *ListNetworkAclsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewNetworkAclsPager returns a new NetworkAclsPager instance.
func (vpc *VpcV1) NewNetworkAclsPager(options *ListNetworkAclsOptions) (pager *NetworkAclsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListNetworkAclsOptions = *options
	pager = &NetworkAclsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *NetworkAclsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *NetworkAclsPager) GetNextWithContext(ctx context.Context) (page []NetworkACL, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListNetworkAclsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.NetworkAcls

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *NetworkAclsPager) GetAllWithContext(ctx context.Context) (allItems []NetworkACL, err error) {
	for pager.HasNext() {
		var nextPage []NetworkACL
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *NetworkAclsPager) GetNext() (page []NetworkACL, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *NetworkAclsPager) GetAll() (allItems []NetworkACL, err error) {
	return pager.GetAllWithContext(context.Background())
}

// NetworkACLRulesPager can be used to simplify the use of the "ListNetworkACLRules" method.
type NetworkACLRulesPager struct {
	hasNext     bool
	options     *ListNetworkACLRulesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewNetworkACLRulesPager returns a new NetworkACLRulesPager instance.
func (vpc *VpcV1) NewNetworkACLRulesPager(options *ListNetworkACLRulesOptions) (pager *NetworkACLRulesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListNetworkACLRulesOptions = *options
	pager = &NetworkACLRulesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *NetworkACLRulesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *NetworkACLRulesPager) GetNextWithContext(ctx context.Context) (page []NetworkACLRuleItemIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListNetworkACLRulesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Rules

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *NetworkACLRulesPager) GetAllWithContext(ctx context.Context) (allItems []NetworkACLRuleItemIntf, err error) {
	for pager.HasNext() {
		var nextPage []NetworkACLRuleItemIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *NetworkACLRulesPager) GetNext() (page []NetworkACLRuleItemIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *NetworkACLRulesPager) GetAll() (allItems []NetworkACLRuleItemIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SecurityGroupsPager can be used to simplify the use of the "ListSecurityGroups" method.
type SecurityGroupsPager struct {
	hasNext     bool
	options     *ListSecurityGroupsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewSecurityGroupsPager returns a new SecurityGroupsPager instance.
func (vpc *VpcV1) NewSecurityGroupsPager(options *ListSecurityGroupsOptions) (pager *SecurityGroupsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListSecurityGroupsOptions = *options
	pager = &SecurityGroupsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SecurityGroupsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SecurityGroupsPager) GetNextWithContext(ctx context.Context) (page []SecurityGroup, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListSecurityGroupsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.SecurityGroups

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SecurityGroupsPager) GetAllWithContext(ctx context.Context) (allItems []SecurityGroup, err error) {
	for pager.HasNext() {
		var nextPage []SecurityGroup
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SecurityGroupsPager) GetNext() (page []SecurityGroup, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SecurityGroupsPager) GetAll() (allItems []SecurityGroup, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SecurityGroupTargetsPager can be used to simplify the use of the "ListSecurityGroupTargets" method.
type SecurityGroupTargetsPager struct {
	hasNext     bool
	options     *ListSecurityGroupTargetsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewSecurityGroupTargetsPager returns a new SecurityGroupTargetsPager instance.
func (vpc *VpcV1) NewSecurityGroupTargetsPager(options *ListSecurityGroupTargetsOptions) (pager *SecurityGroupTargetsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListSecurityGroupTargetsOptions = *options
	pager = &SecurityGroupTargetsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SecurityGroupTargetsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SecurityGroupTargetsPager) GetNextWithContext(ctx context.Context) (page []SecurityGroupTargetReferenceIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListSecurityGroupTargetsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Targets

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SecurityGroupTargetsPager) GetAllWithContext(ctx context.Context) (allItems []SecurityGroupTargetReferenceIntf, err error) {
	for pager.HasNext() {
		var nextPage []SecurityGroupTargetReferenceIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SecurityGroupTargetsPager) GetNext() (page []SecurityGroupTargetReferenceIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SecurityGroupTargetsPager) GetAll() (allItems []SecurityGroupTargetReferenceIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// IkePoliciesPager can be used to simplify the use of the "ListIkePolicies" method.
type IkePoliciesPager struct {
	hasNext     bool
	options     *ListIkePoliciesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewIkePoliciesPager returns a new IkePoliciesPager instance.
func (vpc *VpcV1) NewIkePoliciesPager(options *ListIkePoliciesOptions) (pager *IkePoliciesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListIkePoliciesOptions = *options
	pager = &IkePoliciesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *IkePoliciesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *IkePoliciesPager) GetNextWithContext(ctx context.Context) (page []IkePolicy, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListIkePoliciesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.IkePolicies

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *IkePoliciesPager) GetAllWithContext(ctx context.Context) (allItems []IkePolicy, err error) {
	for pager.HasNext() {
		var nextPage []IkePolicy
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *IkePoliciesPager) GetNext() (page []IkePolicy, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *IkePoliciesPager) GetAll() (allItems []IkePolicy, err error) {
	return pager.GetAllWithContext(context.Background())
}

// IpsecPoliciesPager can be used to simplify the use of the "ListIpsecPolicies" method.
type IpsecPoliciesPager struct {
	hasNext     bool
	options     *ListIpsecPoliciesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewIpsecPoliciesPager returns a new IpsecPoliciesPager instance.
func (vpc *VpcV1) NewIpsecPoliciesPager(options *ListIpsecPoliciesOptions) (pager *IpsecPoliciesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListIpsecPoliciesOptions = *options
	pager = &IpsecPoliciesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *IpsecPoliciesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *IpsecPoliciesPager) GetNextWithContext(ctx context.Context) (page []IPsecPolicy, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListIpsecPoliciesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.IpsecPolicies

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *IpsecPoliciesPager) GetAllWithContext(ctx context.Context) (allItems []IPsecPolicy, err error) {
	for pager.HasNext() {
		var nextPage []IPsecPolicy
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *IpsecPoliciesPager) GetNext() (page []IPsecPolicy, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *IpsecPoliciesPager) GetAll() (allItems []IPsecPolicy, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPNGatewaysPager can be used to simplify the use of the "ListVPNGateways" method.
type VPNGatewaysPager struct {
	hasNext     bool
	options     *ListVPNGatewaysOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPNGatewaysPager returns a new VPNGatewaysPager instance.
func (vpc *VpcV1) NewVPNGatewaysPager(options *ListVPNGatewaysOptions) (pager *VPNGatewaysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPNGatewaysOptions = *options
	pager = &VPNGatewaysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPNGatewaysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPNGatewaysPager) GetNextWithContext(ctx context.Context) (page []VPNGatewayIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPNGatewaysWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.VPNGateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPNGatewaysPager) GetAllWithContext(ctx context.Context) (allItems []VPNGatewayIntf, err error) {
	for pager.HasNext() {
		var nextPage []VPNGatewayIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPNGatewaysPager) GetNext() (page []VPNGatewayIntf, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPNGatewaysPager) GetAll() (allItems []VPNGatewayIntf, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPNServersPager can be used to simplify the use of the "ListVPNServers" method.
type VPNServersPager struct {
	hasNext     bool
	options     *ListVPNServersOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPNServersPager returns a new VPNServersPager instance.
func (vpc *VpcV1) NewVPNServersPager(options *ListVPNServersOptions) (pager *VPNServersPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPNServersOptions = *options
	pager = &VPNServersPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPNServersPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPNServersPager) GetNextWithContext(ctx context.Context) (page []VPNServer, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPNServersWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.VPNServers

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPNServersPager) GetAllWithContext(ctx context.Context) (allItems []VPNServer, err error) {
	for pager.HasNext() {
		var nextPage []VPNServer
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPNServersPager) GetNext() (page []VPNServer, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPNServersPager) GetAll() (allItems []VPNServer, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPNServerClientsPager can be used to simplify the use of the "ListVPNServerClients" method.
type VPNServerClientsPager struct {
	hasNext     bool
	options     *ListVPNServerClientsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPNServerClientsPager returns a new VPNServerClientsPager instance.
func (vpc *VpcV1) NewVPNServerClientsPager(options *ListVPNServerClientsOptions) (pager *VPNServerClientsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPNServerClientsOptions = *options
	pager = &VPNServerClientsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPNServerClientsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPNServerClientsPager) GetNextWithContext(ctx context.Context) (page []VPNServerClient, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPNServerClientsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Clients

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPNServerClientsPager) GetAllWithContext(ctx context.Context) (allItems []VPNServerClient, err error) {
	for pager.HasNext() {
		var nextPage []VPNServerClient
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPNServerClientsPager) GetNext() (page []VPNServerClient, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPNServerClientsPager) GetAll() (allItems []VPNServerClient, err error) {
	return pager.GetAllWithContext(context.Background())
}

// VPNServerRoutesPager can be used to simplify the use of the "ListVPNServerRoutes" method.
type VPNServerRoutesPager struct {
	hasNext     bool
	options     *ListVPNServerRoutesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewVPNServerRoutesPager returns a new VPNServerRoutesPager instance.
func (vpc *VpcV1) NewVPNServerRoutesPager(options *ListVPNServerRoutesOptions) (pager *VPNServerRoutesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListVPNServerRoutesOptions = *options
	pager = &VPNServerRoutesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *VPNServerRoutesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *VPNServerRoutesPager) GetNextWithContext(ctx context.Context) (page []VPNServerRoute, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListVPNServerRoutesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Routes

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *VPNServerRoutesPager) GetAllWithContext(ctx context.Context) (allItems []VPNServerRoute, err error) {
	for pager.HasNext() {
		var nextPage []VPNServerRoute
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *VPNServerRoutesPager) GetNext() (page []VPNServerRoute, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *VPNServerRoutesPager) GetAll() (allItems []VPNServerRoute, err error) {
	return pager.GetAllWithContext(context.Background())
}

// LoadBalancerProfilesPager can be used to simplify the use of the "ListLoadBalancerProfiles" method.
type LoadBalancerProfilesPager struct {
	hasNext     bool
	options     *ListLoadBalancerProfilesOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewLoadBalancerProfilesPager returns a new LoadBalancerProfilesPager instance.
func (vpc *VpcV1) NewLoadBalancerProfilesPager(options *ListLoadBalancerProfilesOptions) (pager *LoadBalancerProfilesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListLoadBalancerProfilesOptions = *options
	pager = &LoadBalancerProfilesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *LoadBalancerProfilesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *LoadBalancerProfilesPager) GetNextWithContext(ctx context.Context) (page []LoadBalancerProfile, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListLoadBalancerProfilesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Profiles

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *LoadBalancerProfilesPager) GetAllWithContext(ctx context.Context) (allItems []LoadBalancerProfile, err error) {
	for pager.HasNext() {
		var nextPage []LoadBalancerProfile
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *LoadBalancerProfilesPager) GetNext() (page []LoadBalancerProfile, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *LoadBalancerProfilesPager) GetAll() (allItems []LoadBalancerProfile, err error) {
	return pager.GetAllWithContext(context.Background())
}

// LoadBalancersPager can be used to simplify the use of the "ListLoadBalancers" method.
type LoadBalancersPager struct {
	hasNext     bool
	options     *ListLoadBalancersOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewLoadBalancersPager returns a new LoadBalancersPager instance.
func (vpc *VpcV1) NewLoadBalancersPager(options *ListLoadBalancersOptions) (pager *LoadBalancersPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListLoadBalancersOptions = *options
	pager = &LoadBalancersPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *LoadBalancersPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *LoadBalancersPager) GetNextWithContext(ctx context.Context) (page []LoadBalancer, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListLoadBalancersWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.LoadBalancers

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *LoadBalancersPager) GetAllWithContext(ctx context.Context) (allItems []LoadBalancer, err error) {
	for pager.HasNext() {
		var nextPage []LoadBalancer
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *LoadBalancersPager) GetNext() (page []LoadBalancer, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *LoadBalancersPager) GetAll() (allItems []LoadBalancer, err error) {
	return pager.GetAllWithContext(context.Background())
}

// EndpointGatewaysPager can be used to simplify the use of the "ListEndpointGateways" method.
type EndpointGatewaysPager struct {
	hasNext     bool
	options     *ListEndpointGatewaysOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewEndpointGatewaysPager returns a new EndpointGatewaysPager instance.
func (vpc *VpcV1) NewEndpointGatewaysPager(options *ListEndpointGatewaysOptions) (pager *EndpointGatewaysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListEndpointGatewaysOptions = *options
	pager = &EndpointGatewaysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *EndpointGatewaysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *EndpointGatewaysPager) GetNextWithContext(ctx context.Context) (page []EndpointGateway, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListEndpointGatewaysWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.EndpointGateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *EndpointGatewaysPager) GetAllWithContext(ctx context.Context) (allItems []EndpointGateway, err error) {
	for pager.HasNext() {
		var nextPage []EndpointGateway
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *EndpointGatewaysPager) GetNext() (page []EndpointGateway, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *EndpointGatewaysPager) GetAll() (allItems []EndpointGateway, err error) {
	return pager.GetAllWithContext(context.Background())
}

// EndpointGatewayIpsPager can be used to simplify the use of the "ListEndpointGatewayIps" method.
type EndpointGatewayIpsPager struct {
	hasNext     bool
	options     *ListEndpointGatewayIpsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewEndpointGatewayIpsPager returns a new EndpointGatewayIpsPager instance.
func (vpc *VpcV1) NewEndpointGatewayIpsPager(options *ListEndpointGatewayIpsOptions) (pager *EndpointGatewayIpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListEndpointGatewayIpsOptions = *options
	pager = &EndpointGatewayIpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *EndpointGatewayIpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *EndpointGatewayIpsPager) GetNextWithContext(ctx context.Context) (page []ReservedIP, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListEndpointGatewayIpsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Ips

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *EndpointGatewayIpsPager) GetAllWithContext(ctx context.Context) (allItems []ReservedIP, err error) {
	for pager.HasNext() {
		var nextPage []ReservedIP
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *EndpointGatewayIpsPager) GetNext() (page []ReservedIP, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *EndpointGatewayIpsPager) GetAll() (allItems []ReservedIP, err error) {
	return pager.GetAllWithContext(context.Background())
}

// FlowLogCollectorsPager can be used to simplify the use of the "ListFlowLogCollectors" method.
type FlowLogCollectorsPager struct {
	hasNext     bool
	options     *ListFlowLogCollectorsOptions
	client      *VpcV1
	pageContext struct {
		next *string
	}
}

// NewFlowLogCollectorsPager returns a new FlowLogCollectorsPager instance.
func (vpc *VpcV1) NewFlowLogCollectorsPager(options *ListFlowLogCollectorsOptions) (pager *FlowLogCollectorsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListFlowLogCollectorsOptions = *options
	pager = &FlowLogCollectorsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  vpc,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *FlowLogCollectorsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *FlowLogCollectorsPager) GetNextWithContext(ctx context.Context) (page []FlowLogCollector, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListFlowLogCollectorsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.FlowLogCollectors

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *FlowLogCollectorsPager) GetAllWithContext(ctx context.Context) (allItems []FlowLogCollector, err error) {
	for pager.HasNext() {
		var nextPage []FlowLogCollector
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *FlowLogCollectorsPager) GetNext() (page []FlowLogCollector, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *FlowLogCollectorsPager) GetAll() (allItems []FlowLogCollector, err error) {
	return pager.GetAllWithContext(context.Background())
}
