/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.90.0-5aad763d-20240506-203857
 */

// Package backuprecoveryv1 : Operations and models for the BackupRecoveryV1 service
package backuprecoveryv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/ibm-backup-recovery-sdk-go/common"
)

// BackupRecoveryV1 : REST API used to configure Backup Recovery Service
//
// API Version: 1.0.0
type BackupRecoveryV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = ""

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "backup_recovery"

// BackupRecoveryV1Options : Service options
type BackupRecoveryV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewBackupRecoveryV1UsingExternalConfig : constructs an instance of BackupRecoveryV1 with passed in options and external configuration.
func NewBackupRecoveryV1UsingExternalConfig(options *BackupRecoveryV1Options) (backupRecovery *BackupRecoveryV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			err = core.SDKErrorf(err, "", "env-auth-error", common.GetComponentInfo())
			return
		}
	}

	backupRecovery, err = NewBackupRecoveryV1(options)
	err = core.RepurposeSDKProblem(err, "new-client-error")
	if err != nil {
		return
	}

	err = backupRecovery.Service.ConfigureService(options.ServiceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "client-config-error", common.GetComponentInfo())
		return
	}

	if options.URL != "" {
		err = backupRecovery.Service.SetServiceURL(options.URL)
		err = core.RepurposeSDKProblem(err, "url-set-error")
	}
	return
}

// NewBackupRecoveryV1 : constructs an instance of BackupRecoveryV1 with passed in options.
func NewBackupRecoveryV1(options *BackupRecoveryV1Options) (service *BackupRecoveryV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		err = core.SDKErrorf(err, "", "new-base-error", common.GetComponentInfo())
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			err = core.SDKErrorf(err, "", "set-url-error", common.GetComponentInfo())
			return
		}
	}

	service = &BackupRecoveryV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", core.SDKErrorf(nil, "service does not support regional URLs", "no-regional-support", common.GetComponentInfo())
}

// Clone makes a copy of "backupRecovery" suitable for processing requests.
func (backupRecovery *BackupRecoveryV1) Clone() *BackupRecoveryV1 {
	if core.IsNil(backupRecovery) {
		return nil
	}
	clone := *backupRecovery
	clone.Service = backupRecovery.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (backupRecovery *BackupRecoveryV1) SetServiceURL(url string) error {
	err := backupRecovery.Service.SetServiceURL(url)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-set-error", common.GetComponentInfo())
	}
	return err
}

// GetServiceURL returns the service URL
func (backupRecovery *BackupRecoveryV1) GetServiceURL() string {
	return backupRecovery.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (backupRecovery *BackupRecoveryV1) SetDefaultHeaders(headers http.Header) {
	backupRecovery.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (backupRecovery *BackupRecoveryV1) SetEnableGzipCompression(enableGzip bool) {
	backupRecovery.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (backupRecovery *BackupRecoveryV1) GetEnableGzipCompression() bool {
	return backupRecovery.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (backupRecovery *BackupRecoveryV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	backupRecovery.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (backupRecovery *BackupRecoveryV1) DisableRetries() {
	backupRecovery.Service.DisableRetries()
}

// DownloadAgent : Download agent
// Download agent for different hosts.
func (backupRecovery *BackupRecoveryV1) DownloadAgent(downloadAgentOptions *DownloadAgentOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.DownloadAgentWithContext(context.Background(), downloadAgentOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DownloadAgentWithContext is an alternate form of the DownloadAgent method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DownloadAgentWithContext(ctx context.Context, downloadAgentOptions *DownloadAgentOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(downloadAgentOptions, "downloadAgentOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(downloadAgentOptions, "downloadAgentOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/agents/download`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range downloadAgentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DownloadAgent")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/octet-stream")
	builder.AddHeader("Content-Type", "application/json")
	if downloadAgentOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*downloadAgentOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if downloadAgentOptions.Platform != nil {
		body["platform"] = downloadAgentOptions.Platform
	}
	if downloadAgentOptions.LinuxParams != nil {
		body["linuxParams"] = downloadAgentOptions.LinuxParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, &result)
	if err != nil {
		core.EnrichHTTPProblem(err, "DownloadAgent", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetUpgradeTasks : Get upgrade tasks
// Get the list of agent upgrade tasks.
func (backupRecovery *BackupRecoveryV1) GetUpgradeTasks(getUpgradeTasksOptions *GetUpgradeTasksOptions) (result *AgentUpgradeTaskStates, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetUpgradeTasksWithContext(context.Background(), getUpgradeTasksOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetUpgradeTasksWithContext is an alternate form of the GetUpgradeTasks method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetUpgradeTasksWithContext(ctx context.Context, getUpgradeTasksOptions *GetUpgradeTasksOptions) (result *AgentUpgradeTaskStates, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getUpgradeTasksOptions, "getUpgradeTasksOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getUpgradeTasksOptions, "getUpgradeTasksOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/agents/upgrade-tasks`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getUpgradeTasksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetUpgradeTasks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getUpgradeTasksOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getUpgradeTasksOptions.XIBMTenantID))
	}

	if getUpgradeTasksOptions.Ids != nil {
		err = builder.AddQuerySlice("ids", getUpgradeTasksOptions.Ids)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetUpgradeTasks", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAgentUpgradeTaskStates)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateUpgradeTask : Create an upgrade task
// Create a schedule-based agent upgrade task.
func (backupRecovery *BackupRecoveryV1) CreateUpgradeTask(createUpgradeTaskOptions *CreateUpgradeTaskOptions) (result *AgentUpgradeTaskState, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateUpgradeTaskWithContext(context.Background(), createUpgradeTaskOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateUpgradeTaskWithContext is an alternate form of the CreateUpgradeTask method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateUpgradeTaskWithContext(ctx context.Context, createUpgradeTaskOptions *CreateUpgradeTaskOptions) (result *AgentUpgradeTaskState, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createUpgradeTaskOptions, "createUpgradeTaskOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createUpgradeTaskOptions, "createUpgradeTaskOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/agents/upgrade-tasks`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createUpgradeTaskOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateUpgradeTask")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createUpgradeTaskOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createUpgradeTaskOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if createUpgradeTaskOptions.AgentIDs != nil {
		body["agentIDs"] = createUpgradeTaskOptions.AgentIDs
	}
	if createUpgradeTaskOptions.Description != nil {
		body["description"] = createUpgradeTaskOptions.Description
	}
	if createUpgradeTaskOptions.Name != nil {
		body["name"] = createUpgradeTaskOptions.Name
	}
	if createUpgradeTaskOptions.RetryTaskID != nil {
		body["retryTaskId"] = createUpgradeTaskOptions.RetryTaskID
	}
	if createUpgradeTaskOptions.ScheduleEndTimeUsecs != nil {
		body["scheduleEndTimeUsecs"] = createUpgradeTaskOptions.ScheduleEndTimeUsecs
	}
	if createUpgradeTaskOptions.ScheduleTimeUsecs != nil {
		body["scheduleTimeUsecs"] = createUpgradeTaskOptions.ScheduleTimeUsecs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateUpgradeTask", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAgentUpgradeTaskState)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListProtectionSources : List Protection Sources
// If no parameters are specified, all Protection Sources that are registered on the Cohesity Cluster are returned. In
// addition, an Object subtree gathered from each Source is returned. For example, the Cohesity Cluster interrogates a
// Source VMware vCenter Server and creates an hierarchical Object subtree that mirrors the Inventory tree on vCenter
// Server. The contents of the Object tree are returned as a "nodes" hierarchy of "protectionSource"s. Specifying
// parameters can alter the results that are returned.
func (backupRecovery *BackupRecoveryV1) ListProtectionSources(listProtectionSourcesOptions *ListProtectionSourcesOptions) (result []ProtectionSourceNodes, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.ListProtectionSourcesWithContext(context.Background(), listProtectionSourcesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListProtectionSourcesWithContext is an alternate form of the ListProtectionSources method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) ListProtectionSourcesWithContext(ctx context.Context, listProtectionSourcesOptions *ListProtectionSourcesOptions) (result []ProtectionSourceNodes, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listProtectionSourcesOptions, "listProtectionSourcesOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listProtectionSourcesOptions, "listProtectionSourcesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	protectionSourcesUrl := strings.TrimSuffix(backupRecovery.Service.Options.URL, "/v2")
	_, err = builder.ResolveRequestURL(protectionSourcesUrl, `/irisservices/api/v1/public/protectionSources`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listProtectionSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "ListProtectionSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listProtectionSourcesOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*listProtectionSourcesOptions.XIBMTenantID))
	}

	if listProtectionSourcesOptions.ExcludeOffice365Types != nil {
		builder.AddQuery("excludeOffice365Types", strings.Join(listProtectionSourcesOptions.ExcludeOffice365Types, ","))
	}
	if listProtectionSourcesOptions.GetTeamsChannels != nil {
		builder.AddQuery("getTeamsChannels", fmt.Sprint(*listProtectionSourcesOptions.GetTeamsChannels))
	}
	if listProtectionSourcesOptions.AfterCursorEntityID != nil {
		builder.AddQuery("afterCursorEntityId", fmt.Sprint(*listProtectionSourcesOptions.AfterCursorEntityID))
	}
	if listProtectionSourcesOptions.BeforeCursorEntityID != nil {
		builder.AddQuery("beforeCursorEntityId", fmt.Sprint(*listProtectionSourcesOptions.BeforeCursorEntityID))
	}
	if listProtectionSourcesOptions.NodeID != nil {
		builder.AddQuery("nodeId", fmt.Sprint(*listProtectionSourcesOptions.NodeID))
	}
	if listProtectionSourcesOptions.PageSize != nil {
		builder.AddQuery("pageSize", fmt.Sprint(*listProtectionSourcesOptions.PageSize))
	}
	if listProtectionSourcesOptions.HasValidMailbox != nil {
		builder.AddQuery("hasValidMailbox", fmt.Sprint(*listProtectionSourcesOptions.HasValidMailbox))
	}
	if listProtectionSourcesOptions.HasValidOnedrive != nil {
		builder.AddQuery("hasValidOnedrive", fmt.Sprint(*listProtectionSourcesOptions.HasValidOnedrive))
	}
	if listProtectionSourcesOptions.IsSecurityGroup != nil {
		builder.AddQuery("isSecurityGroup", fmt.Sprint(*listProtectionSourcesOptions.IsSecurityGroup))
	}
	if listProtectionSourcesOptions.ID != nil {
		builder.AddQuery("id", fmt.Sprint(*listProtectionSourcesOptions.ID))
	}
	if listProtectionSourcesOptions.NumLevels != nil {
		builder.AddQuery("numLevels", fmt.Sprint(*listProtectionSourcesOptions.NumLevels))
	}
	if listProtectionSourcesOptions.ExcludeTypes != nil {
		builder.AddQuery("excludeTypes", strings.Join(listProtectionSourcesOptions.ExcludeTypes, ","))
	}
	if listProtectionSourcesOptions.ExcludeAwsTypes != nil {
		builder.AddQuery("excludeAwsTypes", strings.Join(listProtectionSourcesOptions.ExcludeAwsTypes, ","))
	}
	if listProtectionSourcesOptions.ExcludeKubernetesTypes != nil {
		builder.AddQuery("excludeKubernetesTypes", strings.Join(listProtectionSourcesOptions.ExcludeKubernetesTypes, ","))
	}
	if listProtectionSourcesOptions.IncludeDatastores != nil {
		builder.AddQuery("includeDatastores", fmt.Sprint(*listProtectionSourcesOptions.IncludeDatastores))
	}
	if listProtectionSourcesOptions.IncludeNetworks != nil {
		builder.AddQuery("includeNetworks", fmt.Sprint(*listProtectionSourcesOptions.IncludeNetworks))
	}
	if listProtectionSourcesOptions.IncludeVMFolders != nil {
		builder.AddQuery("includeVMFolders", fmt.Sprint(*listProtectionSourcesOptions.IncludeVMFolders))
	}
	if listProtectionSourcesOptions.IncludeSfdcFields != nil {
		builder.AddQuery("includeSfdcFields", fmt.Sprint(*listProtectionSourcesOptions.IncludeSfdcFields))
	}
	if listProtectionSourcesOptions.IncludeSystemVApps != nil {
		builder.AddQuery("includeSystemVApps", fmt.Sprint(*listProtectionSourcesOptions.IncludeSystemVApps))
	}
	if listProtectionSourcesOptions.Environments != nil {
		builder.AddQuery("environments", strings.Join(listProtectionSourcesOptions.Environments, ","))
	}
	if listProtectionSourcesOptions.Environment != nil {
		builder.AddQuery("environment", fmt.Sprint(*listProtectionSourcesOptions.Environment))
	}
	if listProtectionSourcesOptions.IncludeEntityPermissionInfo != nil {
		builder.AddQuery("includeEntityPermissionInfo", fmt.Sprint(*listProtectionSourcesOptions.IncludeEntityPermissionInfo))
	}
	if listProtectionSourcesOptions.Sids != nil {
		builder.AddQuery("sids", strings.Join(listProtectionSourcesOptions.Sids, ","))
	}
	if listProtectionSourcesOptions.IncludeSourceCredentials != nil {
		builder.AddQuery("includeSourceCredentials", fmt.Sprint(*listProtectionSourcesOptions.IncludeSourceCredentials))
	}
	if listProtectionSourcesOptions.EncryptionKey != nil {
		builder.AddQuery("encryptionKey", fmt.Sprint(*listProtectionSourcesOptions.EncryptionKey))
	}
	if listProtectionSourcesOptions.IncludeObjectProtectionInfo != nil {
		builder.AddQuery("includeObjectProtectionInfo", fmt.Sprint(*listProtectionSourcesOptions.IncludeObjectProtectionInfo))
	}
	if listProtectionSourcesOptions.PruneNonCriticalInfo != nil {
		builder.AddQuery("pruneNonCriticalInfo", fmt.Sprint(*listProtectionSourcesOptions.PruneNonCriticalInfo))
	}
	if listProtectionSourcesOptions.PruneAggregationInfo != nil {
		builder.AddQuery("pruneAggregationInfo", fmt.Sprint(*listProtectionSourcesOptions.PruneAggregationInfo))
	}
	if listProtectionSourcesOptions.RequestInitiatorType != nil {
		builder.AddQuery("requestInitiatorType", fmt.Sprint(*listProtectionSourcesOptions.RequestInitiatorType))
	}
	if listProtectionSourcesOptions.UseCachedData != nil {
		builder.AddQuery("useCachedData", fmt.Sprint(*listProtectionSourcesOptions.UseCachedData))
	}
	if listProtectionSourcesOptions.AllUnderHierarchy != nil {
		builder.AddQuery("allUnderHierarchy", fmt.Sprint(*listProtectionSourcesOptions.AllUnderHierarchy))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse []json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "ListProtectionSources", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionSourceNodes)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetDataSourceConnections : Get data-source connections
// Gets all specified data-source connections.
func (backupRecovery *BackupRecoveryV1) GetDataSourceConnections(getDataSourceConnectionsOptions *GetDataSourceConnectionsOptions) (result *DataSourceConnectionList, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetDataSourceConnectionsWithContext(context.Background(), getDataSourceConnectionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetDataSourceConnectionsWithContext is an alternate form of the GetDataSourceConnections method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetDataSourceConnectionsWithContext(ctx context.Context, getDataSourceConnectionsOptions *GetDataSourceConnectionsOptions) (result *DataSourceConnectionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDataSourceConnectionsOptions, "getDataSourceConnectionsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getDataSourceConnectionsOptions, "getDataSourceConnectionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connections`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getDataSourceConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetDataSourceConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getDataSourceConnectionsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getDataSourceConnectionsOptions.XIBMTenantID))
	}

	if getDataSourceConnectionsOptions.ConnectionIds != nil {
		builder.AddQuery("connectionIds", strings.Join(getDataSourceConnectionsOptions.ConnectionIds, ","))
	}
	if getDataSourceConnectionsOptions.ConnectionNames != nil {
		builder.AddQuery("connectionNames", strings.Join(getDataSourceConnectionsOptions.ConnectionNames, ","))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetDataSourceConnections", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDataSourceConnectionList)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateDataSourceConnection : Create a data-source connection
// Creates a data-source connection which can be used to register and protect sources, to access filer services, etc.
func (backupRecovery *BackupRecoveryV1) CreateDataSourceConnection(createDataSourceConnectionOptions *CreateDataSourceConnectionOptions) (result *DataSourceConnection, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateDataSourceConnectionWithContext(context.Background(), createDataSourceConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateDataSourceConnectionWithContext is an alternate form of the CreateDataSourceConnection method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateDataSourceConnectionWithContext(ctx context.Context, createDataSourceConnectionOptions *CreateDataSourceConnectionOptions) (result *DataSourceConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDataSourceConnectionOptions, "createDataSourceConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createDataSourceConnectionOptions, "createDataSourceConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connections`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createDataSourceConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateDataSourceConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createDataSourceConnectionOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createDataSourceConnectionOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if createDataSourceConnectionOptions.ConnectionName != nil {
		body["connectionName"] = createDataSourceConnectionOptions.ConnectionName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateDataSourceConnection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDataSourceConnection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteDataSourceConnection : Delete the data-source connection specified by the ID in the request path
// Delete a data-source connection using its ID. After deleting a connection, any connectors within it won't be able to
// connect to the cluster. A connection should only be deleted after ensuring that no sources are using it.
func (backupRecovery *BackupRecoveryV1) DeleteDataSourceConnection(deleteDataSourceConnectionOptions *DeleteDataSourceConnectionOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DeleteDataSourceConnectionWithContext(context.Background(), deleteDataSourceConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteDataSourceConnectionWithContext is an alternate form of the DeleteDataSourceConnection method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DeleteDataSourceConnectionWithContext(ctx context.Context, deleteDataSourceConnectionOptions *DeleteDataSourceConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDataSourceConnectionOptions, "deleteDataSourceConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteDataSourceConnectionOptions, "deleteDataSourceConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"connectionId": *deleteDataSourceConnectionOptions.ConnectionID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connections/{connectionId}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteDataSourceConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DeleteDataSourceConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteDataSourceConnectionOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*deleteDataSourceConnectionOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DeleteDataSourceConnection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// PatchDataSourceConnection : Patch a data-source connection using its ID
// Patch the data-source connection specified by the ID in the request path.
func (backupRecovery *BackupRecoveryV1) PatchDataSourceConnection(patchDataSourceConnectionOptions *PatchDataSourceConnectionOptions) (result *DataSourceConnection, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.PatchDataSourceConnectionWithContext(context.Background(), patchDataSourceConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// PatchDataSourceConnectionWithContext is an alternate form of the PatchDataSourceConnection method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) PatchDataSourceConnectionWithContext(ctx context.Context, patchDataSourceConnectionOptions *PatchDataSourceConnectionOptions) (result *DataSourceConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchDataSourceConnectionOptions, "patchDataSourceConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(patchDataSourceConnectionOptions, "patchDataSourceConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"connectionId": *patchDataSourceConnectionOptions.ConnectionID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connections/{connectionId}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range patchDataSourceConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "PatchDataSourceConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if patchDataSourceConnectionOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*patchDataSourceConnectionOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if patchDataSourceConnectionOptions.ConnectionName != nil {
		body["connectionName"] = patchDataSourceConnectionOptions.ConnectionName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "PatchDataSourceConnection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDataSourceConnection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GenerateDataSourceConnectionRegistrationToken : Generate registration token for a data-source connection
// Generate a token to register connectors against the data-source connection specified by the ID in the request path.
// The same token can be used to register multiple connectors as long as the token is valid. Once the token expires,
// typically in a day, this API can be hit again to generate another token.
func (backupRecovery *BackupRecoveryV1) GenerateDataSourceConnectionRegistrationToken(generateDataSourceConnectionRegistrationTokenOptions *GenerateDataSourceConnectionRegistrationTokenOptions) (result *string, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GenerateDataSourceConnectionRegistrationTokenWithContext(context.Background(), generateDataSourceConnectionRegistrationTokenOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GenerateDataSourceConnectionRegistrationTokenWithContext is an alternate form of the GenerateDataSourceConnectionRegistrationToken method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GenerateDataSourceConnectionRegistrationTokenWithContext(ctx context.Context, generateDataSourceConnectionRegistrationTokenOptions *GenerateDataSourceConnectionRegistrationTokenOptions) (result *string, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(generateDataSourceConnectionRegistrationTokenOptions, "generateDataSourceConnectionRegistrationTokenOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(generateDataSourceConnectionRegistrationTokenOptions, "generateDataSourceConnectionRegistrationTokenOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"connectionId": *generateDataSourceConnectionRegistrationTokenOptions.ConnectionID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connections/{connectionId}/registrationToken`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range generateDataSourceConnectionRegistrationTokenOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GenerateDataSourceConnectionRegistrationToken")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if generateDataSourceConnectionRegistrationTokenOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*generateDataSourceConnectionRegistrationTokenOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, &result)
	if err != nil {
		core.EnrichHTTPProblem(err, "GenerateDataSourceConnectionRegistrationToken", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetDataSourceConnectors : Get data-source connectors
// Gets all specified data-source connectors.
func (backupRecovery *BackupRecoveryV1) GetDataSourceConnectors(getDataSourceConnectorsOptions *GetDataSourceConnectorsOptions) (result *DataSourceConnectorList, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetDataSourceConnectorsWithContext(context.Background(), getDataSourceConnectorsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetDataSourceConnectorsWithContext is an alternate form of the GetDataSourceConnectors method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetDataSourceConnectorsWithContext(ctx context.Context, getDataSourceConnectorsOptions *GetDataSourceConnectorsOptions) (result *DataSourceConnectorList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDataSourceConnectorsOptions, "getDataSourceConnectorsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getDataSourceConnectorsOptions, "getDataSourceConnectorsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connectors`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getDataSourceConnectorsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetDataSourceConnectors")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getDataSourceConnectorsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getDataSourceConnectorsOptions.XIBMTenantID))
	}

	if getDataSourceConnectorsOptions.ConnectorIds != nil {
		builder.AddQuery("connectorIds", strings.Join(getDataSourceConnectorsOptions.ConnectorIds, ","))
	}
	if getDataSourceConnectorsOptions.ConnectorNames != nil {
		builder.AddQuery("connectorNames", strings.Join(getDataSourceConnectorsOptions.ConnectorNames, ","))
	}
	if getDataSourceConnectorsOptions.ConnectionID != nil {
		builder.AddQuery("connectionId", fmt.Sprint(*getDataSourceConnectorsOptions.ConnectionID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetDataSourceConnectors", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDataSourceConnectorList)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetConnectorMetadata : Get information about the available connectors
// Get information about the available connectors.
func (backupRecovery *BackupRecoveryV1) GetConnectorMetadata(getConnectorMetadataOptions *GetConnectorMetadataOptions) (result *ConnectorMetadata, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetConnectorMetadataWithContext(context.Background(), getConnectorMetadataOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetConnectorMetadataWithContext is an alternate form of the GetConnectorMetadata method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetConnectorMetadataWithContext(ctx context.Context, getConnectorMetadataOptions *GetConnectorMetadataOptions) (result *ConnectorMetadata, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getConnectorMetadataOptions, "getConnectorMetadataOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getConnectorMetadataOptions, "getConnectorMetadataOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connectors/metadata`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getConnectorMetadataOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetConnectorMetadata")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getConnectorMetadataOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getConnectorMetadataOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetConnectorMetadata", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalConnectorMetadata)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteDataSourceConnector : Delete a data-source connector using its ID
// Delete the data-source connector specified by the ID in the request path.
func (backupRecovery *BackupRecoveryV1) DeleteDataSourceConnector(deleteDataSourceConnectorOptions *DeleteDataSourceConnectorOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DeleteDataSourceConnectorWithContext(context.Background(), deleteDataSourceConnectorOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteDataSourceConnectorWithContext is an alternate form of the DeleteDataSourceConnector method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DeleteDataSourceConnectorWithContext(ctx context.Context, deleteDataSourceConnectorOptions *DeleteDataSourceConnectorOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDataSourceConnectorOptions, "deleteDataSourceConnectorOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteDataSourceConnectorOptions, "deleteDataSourceConnectorOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"connectorId": *deleteDataSourceConnectorOptions.ConnectorID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connectors/{connectorId}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteDataSourceConnectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DeleteDataSourceConnector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteDataSourceConnectorOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*deleteDataSourceConnectorOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DeleteDataSourceConnector", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// PatchDataSourceConnector : Patch a data-source connector using its ID
// Patch the data-source connector specified by the ID in the request path.
func (backupRecovery *BackupRecoveryV1) PatchDataSourceConnector(patchDataSourceConnectorOptions *PatchDataSourceConnectorOptions) (result *DataSourceConnector, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.PatchDataSourceConnectorWithContext(context.Background(), patchDataSourceConnectorOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// PatchDataSourceConnectorWithContext is an alternate form of the PatchDataSourceConnector method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) PatchDataSourceConnectorWithContext(ctx context.Context, patchDataSourceConnectorOptions *PatchDataSourceConnectorOptions) (result *DataSourceConnector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchDataSourceConnectorOptions, "patchDataSourceConnectorOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(patchDataSourceConnectorOptions, "patchDataSourceConnectorOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"connectorId": *patchDataSourceConnectorOptions.ConnectorID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-source-connectors/{connectorId}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range patchDataSourceConnectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "PatchDataSourceConnector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if patchDataSourceConnectorOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*patchDataSourceConnectorOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if patchDataSourceConnectorOptions.ConnectorName != nil {
		body["connectorName"] = patchDataSourceConnectorOptions.ConnectorName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "PatchDataSourceConnector", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDataSourceConnector)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetObjectSnapshots : List the snapshots for a given object
// List the snapshots for a given object.
func (backupRecovery *BackupRecoveryV1) GetObjectSnapshots(getObjectSnapshotsOptions *GetObjectSnapshotsOptions) (result *GetObjectSnapshotsResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetObjectSnapshotsWithContext(context.Background(), getObjectSnapshotsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetObjectSnapshotsWithContext is an alternate form of the GetObjectSnapshots method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetObjectSnapshotsWithContext(ctx context.Context, getObjectSnapshotsOptions *GetObjectSnapshotsOptions) (result *GetObjectSnapshotsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getObjectSnapshotsOptions, "getObjectSnapshotsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getObjectSnapshotsOptions, "getObjectSnapshotsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": fmt.Sprint(*getObjectSnapshotsOptions.ID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/objects/{id}/snapshots`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getObjectSnapshotsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetObjectSnapshots")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getObjectSnapshotsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getObjectSnapshotsOptions.XIBMTenantID))
	}

	if getObjectSnapshotsOptions.FromTimeUsecs != nil {
		builder.AddQuery("fromTimeUsecs", fmt.Sprint(*getObjectSnapshotsOptions.FromTimeUsecs))
	}
	if getObjectSnapshotsOptions.ToTimeUsecs != nil {
		builder.AddQuery("toTimeUsecs", fmt.Sprint(*getObjectSnapshotsOptions.ToTimeUsecs))
	}
	if getObjectSnapshotsOptions.RunStartFromTimeUsecs != nil {
		builder.AddQuery("runStartFromTimeUsecs", fmt.Sprint(*getObjectSnapshotsOptions.RunStartFromTimeUsecs))
	}
	if getObjectSnapshotsOptions.RunStartToTimeUsecs != nil {
		builder.AddQuery("runStartToTimeUsecs", fmt.Sprint(*getObjectSnapshotsOptions.RunStartToTimeUsecs))
	}
	if getObjectSnapshotsOptions.SnapshotActions != nil {
		builder.AddQuery("snapshotActions", strings.Join(getObjectSnapshotsOptions.SnapshotActions, ","))
	}
	if getObjectSnapshotsOptions.RunTypes != nil {
		builder.AddQuery("runTypes", strings.Join(getObjectSnapshotsOptions.RunTypes, ","))
	}
	if getObjectSnapshotsOptions.ProtectionGroupIds != nil {
		builder.AddQuery("protectionGroupIds", strings.Join(getObjectSnapshotsOptions.ProtectionGroupIds, ","))
	}
	if getObjectSnapshotsOptions.RunInstanceIds != nil {
		err = builder.AddQuerySlice("runInstanceIds", getObjectSnapshotsOptions.RunInstanceIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if getObjectSnapshotsOptions.RegionIds != nil {
		builder.AddQuery("regionIds", strings.Join(getObjectSnapshotsOptions.RegionIds, ","))
	}
	if getObjectSnapshotsOptions.ObjectActionKeys != nil {
		builder.AddQuery("objectActionKeys", strings.Join(getObjectSnapshotsOptions.ObjectActionKeys, ","))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetObjectSnapshots", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetObjectSnapshotsResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetProtectionPolicies : List Protection Policies based on provided filtering parameters
// Lists protection policies based on filtering query parameters.
func (backupRecovery *BackupRecoveryV1) GetProtectionPolicies(getProtectionPoliciesOptions *GetProtectionPoliciesOptions) (result *ProtectionPoliciesResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetProtectionPoliciesWithContext(context.Background(), getProtectionPoliciesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProtectionPoliciesWithContext is an alternate form of the GetProtectionPolicies method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetProtectionPoliciesWithContext(ctx context.Context, getProtectionPoliciesOptions *GetProtectionPoliciesOptions) (result *ProtectionPoliciesResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProtectionPoliciesOptions, "getProtectionPoliciesOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProtectionPoliciesOptions, "getProtectionPoliciesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/policies`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProtectionPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetProtectionPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getProtectionPoliciesOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getProtectionPoliciesOptions.XIBMTenantID))
	}
	if getProtectionPoliciesOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*getProtectionPoliciesOptions.RequestInitiatorType))
	}

	if getProtectionPoliciesOptions.Ids != nil {
		builder.AddQuery("ids", strings.Join(getProtectionPoliciesOptions.Ids, ","))
	}
	if getProtectionPoliciesOptions.PolicyNames != nil {
		builder.AddQuery("policyNames", strings.Join(getProtectionPoliciesOptions.PolicyNames, ","))
	}
	if getProtectionPoliciesOptions.Types != nil {
		builder.AddQuery("types", strings.Join(getProtectionPoliciesOptions.Types, ","))
	}
	if getProtectionPoliciesOptions.ExcludeLinkedPolicies != nil {
		builder.AddQuery("excludeLinkedPolicies", fmt.Sprint(*getProtectionPoliciesOptions.ExcludeLinkedPolicies))
	}
	if getProtectionPoliciesOptions.IncludeReplicatedPolicies != nil {
		builder.AddQuery("includeReplicatedPolicies", fmt.Sprint(*getProtectionPoliciesOptions.IncludeReplicatedPolicies))
	}
	if getProtectionPoliciesOptions.IncludeStats != nil {
		builder.AddQuery("includeStats", fmt.Sprint(*getProtectionPoliciesOptions.IncludeStats))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetProtectionPolicies", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionPoliciesResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateProtectionPolicy : Create a Protection Policy
// Create the Protection Policy and returns the newly created policy object.
func (backupRecovery *BackupRecoveryV1) CreateProtectionPolicy(createProtectionPolicyOptions *CreateProtectionPolicyOptions) (result *ProtectionPolicyResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateProtectionPolicyWithContext(context.Background(), createProtectionPolicyOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateProtectionPolicyWithContext is an alternate form of the CreateProtectionPolicy method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateProtectionPolicyWithContext(ctx context.Context, createProtectionPolicyOptions *CreateProtectionPolicyOptions) (result *ProtectionPolicyResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createProtectionPolicyOptions, "createProtectionPolicyOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createProtectionPolicyOptions, "createProtectionPolicyOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/policies`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createProtectionPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateProtectionPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createProtectionPolicyOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createProtectionPolicyOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if createProtectionPolicyOptions.Name != nil {
		body["name"] = createProtectionPolicyOptions.Name
	}
	if createProtectionPolicyOptions.BackupPolicy != nil {
		body["backupPolicy"] = createProtectionPolicyOptions.BackupPolicy
	}
	if createProtectionPolicyOptions.Description != nil {
		body["description"] = createProtectionPolicyOptions.Description
	}
	if createProtectionPolicyOptions.BlackoutWindow != nil {
		body["blackoutWindow"] = createProtectionPolicyOptions.BlackoutWindow
	}
	if createProtectionPolicyOptions.ExtendedRetention != nil {
		body["extendedRetention"] = createProtectionPolicyOptions.ExtendedRetention
	}
	if createProtectionPolicyOptions.RemoteTargetPolicy != nil {
		body["remoteTargetPolicy"] = createProtectionPolicyOptions.RemoteTargetPolicy
	}
	if createProtectionPolicyOptions.CascadedTargetsConfig != nil {
		body["cascadedTargetsConfig"] = createProtectionPolicyOptions.CascadedTargetsConfig
	}
	if createProtectionPolicyOptions.RetryOptions != nil {
		body["retryOptions"] = createProtectionPolicyOptions.RetryOptions
	}
	if createProtectionPolicyOptions.DataLock != nil {
		body["dataLock"] = createProtectionPolicyOptions.DataLock
	}
	if createProtectionPolicyOptions.Version != nil {
		body["version"] = createProtectionPolicyOptions.Version
	}
	if createProtectionPolicyOptions.IsCBSEnabled != nil {
		body["isCBSEnabled"] = createProtectionPolicyOptions.IsCBSEnabled
	}
	if createProtectionPolicyOptions.LastModificationTimeUsecs != nil {
		body["lastModificationTimeUsecs"] = createProtectionPolicyOptions.LastModificationTimeUsecs
	}
	if createProtectionPolicyOptions.TemplateID != nil {
		body["templateId"] = createProtectionPolicyOptions.TemplateID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateProtectionPolicy", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionPolicyResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetProtectionPolicyByID : List details about a single Protection Policy
// Returns the Protection Policy details based on provided Policy Id.
func (backupRecovery *BackupRecoveryV1) GetProtectionPolicyByID(getProtectionPolicyByIdOptions *GetProtectionPolicyByIdOptions) (result *ProtectionPolicyResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetProtectionPolicyByIDWithContext(context.Background(), getProtectionPolicyByIdOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProtectionPolicyByIDWithContext is an alternate form of the GetProtectionPolicyByID method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetProtectionPolicyByIDWithContext(ctx context.Context, getProtectionPolicyByIdOptions *GetProtectionPolicyByIdOptions) (result *ProtectionPolicyResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProtectionPolicyByIdOptions, "getProtectionPolicyByIdOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProtectionPolicyByIdOptions, "getProtectionPolicyByIdOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getProtectionPolicyByIdOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/policies/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProtectionPolicyByIdOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetProtectionPolicyByID")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getProtectionPolicyByIdOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getProtectionPolicyByIdOptions.XIBMTenantID))
	}
	if getProtectionPolicyByIdOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*getProtectionPolicyByIdOptions.RequestInitiatorType))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetProtectionPolicyById", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionPolicyResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateProtectionPolicy : Update a Protection Policy
// Specifies the request to update the existing Protection Policy. On successful update, returns the updated policy
// object.
func (backupRecovery *BackupRecoveryV1) UpdateProtectionPolicy(updateProtectionPolicyOptions *UpdateProtectionPolicyOptions) (result *ProtectionPolicyResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.UpdateProtectionPolicyWithContext(context.Background(), updateProtectionPolicyOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateProtectionPolicyWithContext is an alternate form of the UpdateProtectionPolicy method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) UpdateProtectionPolicyWithContext(ctx context.Context, updateProtectionPolicyOptions *UpdateProtectionPolicyOptions) (result *ProtectionPolicyResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateProtectionPolicyOptions, "updateProtectionPolicyOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateProtectionPolicyOptions, "updateProtectionPolicyOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateProtectionPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/policies/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateProtectionPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "UpdateProtectionPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if updateProtectionPolicyOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*updateProtectionPolicyOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if updateProtectionPolicyOptions.Name != nil {
		body["name"] = updateProtectionPolicyOptions.Name
	}
	if updateProtectionPolicyOptions.BackupPolicy != nil {
		body["backupPolicy"] = updateProtectionPolicyOptions.BackupPolicy
	}
	if updateProtectionPolicyOptions.Description != nil {
		body["description"] = updateProtectionPolicyOptions.Description
	}
	if updateProtectionPolicyOptions.BlackoutWindow != nil {
		body["blackoutWindow"] = updateProtectionPolicyOptions.BlackoutWindow
	}
	if updateProtectionPolicyOptions.ExtendedRetention != nil {
		body["extendedRetention"] = updateProtectionPolicyOptions.ExtendedRetention
	}
	if updateProtectionPolicyOptions.RemoteTargetPolicy != nil {
		body["remoteTargetPolicy"] = updateProtectionPolicyOptions.RemoteTargetPolicy
	}
	if updateProtectionPolicyOptions.CascadedTargetsConfig != nil {
		body["cascadedTargetsConfig"] = updateProtectionPolicyOptions.CascadedTargetsConfig
	}
	if updateProtectionPolicyOptions.RetryOptions != nil {
		body["retryOptions"] = updateProtectionPolicyOptions.RetryOptions
	}
	if updateProtectionPolicyOptions.DataLock != nil {
		body["dataLock"] = updateProtectionPolicyOptions.DataLock
	}
	if updateProtectionPolicyOptions.Version != nil {
		body["version"] = updateProtectionPolicyOptions.Version
	}
	if updateProtectionPolicyOptions.IsCBSEnabled != nil {
		body["isCBSEnabled"] = updateProtectionPolicyOptions.IsCBSEnabled
	}
	if updateProtectionPolicyOptions.LastModificationTimeUsecs != nil {
		body["lastModificationTimeUsecs"] = updateProtectionPolicyOptions.LastModificationTimeUsecs
	}
	if updateProtectionPolicyOptions.TemplateID != nil {
		body["templateId"] = updateProtectionPolicyOptions.TemplateID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "UpdateProtectionPolicy", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionPolicyResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteProtectionPolicy : Delete a Protection Policy
// Deletes a Protection Policy based on given policy id.
func (backupRecovery *BackupRecoveryV1) DeleteProtectionPolicy(deleteProtectionPolicyOptions *DeleteProtectionPolicyOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DeleteProtectionPolicyWithContext(context.Background(), deleteProtectionPolicyOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteProtectionPolicyWithContext is an alternate form of the DeleteProtectionPolicy method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DeleteProtectionPolicyWithContext(ctx context.Context, deleteProtectionPolicyOptions *DeleteProtectionPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteProtectionPolicyOptions, "deleteProtectionPolicyOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteProtectionPolicyOptions, "deleteProtectionPolicyOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteProtectionPolicyOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/policies/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteProtectionPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DeleteProtectionPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteProtectionPolicyOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*deleteProtectionPolicyOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DeleteProtectionPolicy", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetProtectionGroups : Get the list of Protection Groups
// Get the list of Protection Groups.
func (backupRecovery *BackupRecoveryV1) GetProtectionGroups(getProtectionGroupsOptions *GetProtectionGroupsOptions) (result *ProtectionGroupsResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetProtectionGroupsWithContext(context.Background(), getProtectionGroupsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProtectionGroupsWithContext is an alternate form of the GetProtectionGroups method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetProtectionGroupsWithContext(ctx context.Context, getProtectionGroupsOptions *GetProtectionGroupsOptions) (result *ProtectionGroupsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProtectionGroupsOptions, "getProtectionGroupsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProtectionGroupsOptions, "getProtectionGroupsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProtectionGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetProtectionGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getProtectionGroupsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getProtectionGroupsOptions.XIBMTenantID))
	}
	if getProtectionGroupsOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*getProtectionGroupsOptions.RequestInitiatorType))
	}

	if getProtectionGroupsOptions.Ids != nil {
		builder.AddQuery("ids", strings.Join(getProtectionGroupsOptions.Ids, ","))
	}
	if getProtectionGroupsOptions.Names != nil {
		builder.AddQuery("names", strings.Join(getProtectionGroupsOptions.Names, ","))
	}
	if getProtectionGroupsOptions.PolicyIds != nil {
		builder.AddQuery("policyIds", strings.Join(getProtectionGroupsOptions.PolicyIds, ","))
	}
	if getProtectionGroupsOptions.IncludeGroupsWithDatalockOnly != nil {
		builder.AddQuery("includeGroupsWithDatalockOnly", fmt.Sprint(*getProtectionGroupsOptions.IncludeGroupsWithDatalockOnly))
	}
	if getProtectionGroupsOptions.Environments != nil {
		builder.AddQuery("environments", strings.Join(getProtectionGroupsOptions.Environments, ","))
	}
	if getProtectionGroupsOptions.IsActive != nil {
		builder.AddQuery("isActive", fmt.Sprint(*getProtectionGroupsOptions.IsActive))
	}
	if getProtectionGroupsOptions.IsDeleted != nil {
		builder.AddQuery("isDeleted", fmt.Sprint(*getProtectionGroupsOptions.IsDeleted))
	}
	if getProtectionGroupsOptions.IsPaused != nil {
		builder.AddQuery("isPaused", fmt.Sprint(*getProtectionGroupsOptions.IsPaused))
	}
	if getProtectionGroupsOptions.LastRunLocalBackupStatus != nil {
		builder.AddQuery("lastRunLocalBackupStatus", strings.Join(getProtectionGroupsOptions.LastRunLocalBackupStatus, ","))
	}
	if getProtectionGroupsOptions.LastRunReplicationStatus != nil {
		builder.AddQuery("lastRunReplicationStatus", strings.Join(getProtectionGroupsOptions.LastRunReplicationStatus, ","))
	}
	if getProtectionGroupsOptions.LastRunArchivalStatus != nil {
		builder.AddQuery("lastRunArchivalStatus", strings.Join(getProtectionGroupsOptions.LastRunArchivalStatus, ","))
	}
	if getProtectionGroupsOptions.LastRunCloudSpinStatus != nil {
		builder.AddQuery("lastRunCloudSpinStatus", strings.Join(getProtectionGroupsOptions.LastRunCloudSpinStatus, ","))
	}
	if getProtectionGroupsOptions.LastRunAnyStatus != nil {
		builder.AddQuery("lastRunAnyStatus", strings.Join(getProtectionGroupsOptions.LastRunAnyStatus, ","))
	}
	if getProtectionGroupsOptions.IsLastRunSlaViolated != nil {
		builder.AddQuery("isLastRunSlaViolated", fmt.Sprint(*getProtectionGroupsOptions.IsLastRunSlaViolated))
	}
	if getProtectionGroupsOptions.IncludeLastRunInfo != nil {
		builder.AddQuery("includeLastRunInfo", fmt.Sprint(*getProtectionGroupsOptions.IncludeLastRunInfo))
	}
	if getProtectionGroupsOptions.PruneExcludedSourceIds != nil {
		builder.AddQuery("pruneExcludedSourceIds", fmt.Sprint(*getProtectionGroupsOptions.PruneExcludedSourceIds))
	}
	if getProtectionGroupsOptions.PruneSourceIds != nil {
		builder.AddQuery("pruneSourceIds", fmt.Sprint(*getProtectionGroupsOptions.PruneSourceIds))
	}
	if getProtectionGroupsOptions.UseCachedData != nil {
		builder.AddQuery("useCachedData", fmt.Sprint(*getProtectionGroupsOptions.UseCachedData))
	}
	if getProtectionGroupsOptions.SourceIds != nil {
		err = builder.AddQuerySlice("sourceIds", getProtectionGroupsOptions.SourceIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetProtectionGroups", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionGroupsResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateProtectionGroup : Create a Protection Group
// Create a Protection Group.
func (backupRecovery *BackupRecoveryV1) CreateProtectionGroup(createProtectionGroupOptions *CreateProtectionGroupOptions) (result *ProtectionGroupResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateProtectionGroupWithContext(context.Background(), createProtectionGroupOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateProtectionGroupWithContext is an alternate form of the CreateProtectionGroup method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateProtectionGroupWithContext(ctx context.Context, createProtectionGroupOptions *CreateProtectionGroupOptions) (result *ProtectionGroupResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createProtectionGroupOptions, "createProtectionGroupOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createProtectionGroupOptions, "createProtectionGroupOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createProtectionGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateProtectionGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createProtectionGroupOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createProtectionGroupOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if createProtectionGroupOptions.Name != nil {
		body["name"] = createProtectionGroupOptions.Name
	}
	if createProtectionGroupOptions.PolicyID != nil {
		body["policyId"] = createProtectionGroupOptions.PolicyID
	}
	if createProtectionGroupOptions.Environment != nil {
		body["environment"] = createProtectionGroupOptions.Environment
	}
	if createProtectionGroupOptions.Priority != nil {
		body["priority"] = createProtectionGroupOptions.Priority
	}
	if createProtectionGroupOptions.Description != nil {
		body["description"] = createProtectionGroupOptions.Description
	}
	if createProtectionGroupOptions.StartTime != nil {
		body["startTime"] = createProtectionGroupOptions.StartTime
	}
	if createProtectionGroupOptions.EndTimeUsecs != nil {
		body["endTimeUsecs"] = createProtectionGroupOptions.EndTimeUsecs
	}
	if createProtectionGroupOptions.LastModifiedTimestampUsecs != nil {
		body["lastModifiedTimestampUsecs"] = createProtectionGroupOptions.LastModifiedTimestampUsecs
	}
	if createProtectionGroupOptions.AlertPolicy != nil {
		body["alertPolicy"] = createProtectionGroupOptions.AlertPolicy
	}
	if createProtectionGroupOptions.Sla != nil {
		body["sla"] = createProtectionGroupOptions.Sla
	}
	if createProtectionGroupOptions.QosPolicy != nil {
		body["qosPolicy"] = createProtectionGroupOptions.QosPolicy
	}
	if createProtectionGroupOptions.AbortInBlackouts != nil {
		body["abortInBlackouts"] = createProtectionGroupOptions.AbortInBlackouts
	}
	if createProtectionGroupOptions.PauseInBlackouts != nil {
		body["pauseInBlackouts"] = createProtectionGroupOptions.PauseInBlackouts
	}
	if createProtectionGroupOptions.IsPaused != nil {
		body["isPaused"] = createProtectionGroupOptions.IsPaused
	}
	if createProtectionGroupOptions.AdvancedConfigs != nil {
		body["advancedConfigs"] = createProtectionGroupOptions.AdvancedConfigs
	}
	if createProtectionGroupOptions.PhysicalParams != nil {
		body["physicalParams"] = createProtectionGroupOptions.PhysicalParams
	}
	if createProtectionGroupOptions.MssqlParams != nil {
		body["mssqlParams"] = createProtectionGroupOptions.MssqlParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateProtectionGroup", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionGroupResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetProtectionGroupByID : List details about single Protection Group
// Returns the Protection Group corresponding to the specified Group id.
func (backupRecovery *BackupRecoveryV1) GetProtectionGroupByID(getProtectionGroupByIdOptions *GetProtectionGroupByIdOptions) (result *ProtectionGroupResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetProtectionGroupByIDWithContext(context.Background(), getProtectionGroupByIdOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProtectionGroupByIDWithContext is an alternate form of the GetProtectionGroupByID method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetProtectionGroupByIDWithContext(ctx context.Context, getProtectionGroupByIdOptions *GetProtectionGroupByIdOptions) (result *ProtectionGroupResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProtectionGroupByIdOptions, "getProtectionGroupByIdOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProtectionGroupByIdOptions, "getProtectionGroupByIdOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getProtectionGroupByIdOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProtectionGroupByIdOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetProtectionGroupByID")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getProtectionGroupByIdOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getProtectionGroupByIdOptions.XIBMTenantID))
	}
	if getProtectionGroupByIdOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*getProtectionGroupByIdOptions.RequestInitiatorType))
	}

	if getProtectionGroupByIdOptions.IncludeLastRunInfo != nil {
		builder.AddQuery("includeLastRunInfo", fmt.Sprint(*getProtectionGroupByIdOptions.IncludeLastRunInfo))
	}
	if getProtectionGroupByIdOptions.PruneExcludedSourceIds != nil {
		builder.AddQuery("pruneExcludedSourceIds", fmt.Sprint(*getProtectionGroupByIdOptions.PruneExcludedSourceIds))
	}
	if getProtectionGroupByIdOptions.PruneSourceIds != nil {
		builder.AddQuery("pruneSourceIds", fmt.Sprint(*getProtectionGroupByIdOptions.PruneSourceIds))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetProtectionGroupById", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionGroupResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateProtectionGroup : Update a Protection Group
// Update the specified Protection Group.
func (backupRecovery *BackupRecoveryV1) UpdateProtectionGroup(updateProtectionGroupOptions *UpdateProtectionGroupOptions) (result *ProtectionGroupResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.UpdateProtectionGroupWithContext(context.Background(), updateProtectionGroupOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateProtectionGroupWithContext is an alternate form of the UpdateProtectionGroup method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) UpdateProtectionGroupWithContext(ctx context.Context, updateProtectionGroupOptions *UpdateProtectionGroupOptions) (result *ProtectionGroupResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateProtectionGroupOptions, "updateProtectionGroupOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateProtectionGroupOptions, "updateProtectionGroupOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateProtectionGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateProtectionGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "UpdateProtectionGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if updateProtectionGroupOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*updateProtectionGroupOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if updateProtectionGroupOptions.Name != nil {
		body["name"] = updateProtectionGroupOptions.Name
	}
	if updateProtectionGroupOptions.PolicyID != nil {
		body["policyId"] = updateProtectionGroupOptions.PolicyID
	}
	if updateProtectionGroupOptions.Environment != nil {
		body["environment"] = updateProtectionGroupOptions.Environment
	}
	if updateProtectionGroupOptions.Priority != nil {
		body["priority"] = updateProtectionGroupOptions.Priority
	}
	if updateProtectionGroupOptions.Description != nil {
		body["description"] = updateProtectionGroupOptions.Description
	}
	if updateProtectionGroupOptions.StartTime != nil {
		body["startTime"] = updateProtectionGroupOptions.StartTime
	}
	if updateProtectionGroupOptions.EndTimeUsecs != nil {
		body["endTimeUsecs"] = updateProtectionGroupOptions.EndTimeUsecs
	}
	if updateProtectionGroupOptions.LastModifiedTimestampUsecs != nil {
		body["lastModifiedTimestampUsecs"] = updateProtectionGroupOptions.LastModifiedTimestampUsecs
	}
	if updateProtectionGroupOptions.AlertPolicy != nil {
		body["alertPolicy"] = updateProtectionGroupOptions.AlertPolicy
	}
	if updateProtectionGroupOptions.Sla != nil {
		body["sla"] = updateProtectionGroupOptions.Sla
	}
	if updateProtectionGroupOptions.QosPolicy != nil {
		body["qosPolicy"] = updateProtectionGroupOptions.QosPolicy
	}
	if updateProtectionGroupOptions.AbortInBlackouts != nil {
		body["abortInBlackouts"] = updateProtectionGroupOptions.AbortInBlackouts
	}
	if updateProtectionGroupOptions.PauseInBlackouts != nil {
		body["pauseInBlackouts"] = updateProtectionGroupOptions.PauseInBlackouts
	}
	if updateProtectionGroupOptions.IsPaused != nil {
		body["isPaused"] = updateProtectionGroupOptions.IsPaused
	}
	if updateProtectionGroupOptions.AdvancedConfigs != nil {
		body["advancedConfigs"] = updateProtectionGroupOptions.AdvancedConfigs
	}
	if updateProtectionGroupOptions.PhysicalParams != nil {
		body["physicalParams"] = updateProtectionGroupOptions.PhysicalParams
	}
	if updateProtectionGroupOptions.MssqlParams != nil {
		body["mssqlParams"] = updateProtectionGroupOptions.MssqlParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "UpdateProtectionGroup", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionGroupResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteProtectionGroup : Delete a Protection Group
// Returns Success if the Protection Group is deleted.
func (backupRecovery *BackupRecoveryV1) DeleteProtectionGroup(deleteProtectionGroupOptions *DeleteProtectionGroupOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DeleteProtectionGroupWithContext(context.Background(), deleteProtectionGroupOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteProtectionGroupWithContext is an alternate form of the DeleteProtectionGroup method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DeleteProtectionGroupWithContext(ctx context.Context, deleteProtectionGroupOptions *DeleteProtectionGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteProtectionGroupOptions, "deleteProtectionGroupOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteProtectionGroupOptions, "deleteProtectionGroupOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteProtectionGroupOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteProtectionGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DeleteProtectionGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteProtectionGroupOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*deleteProtectionGroupOptions.XIBMTenantID))
	}

	if deleteProtectionGroupOptions.DeleteSnapshots != nil {
		builder.AddQuery("deleteSnapshots", fmt.Sprint(*deleteProtectionGroupOptions.DeleteSnapshots))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DeleteProtectionGroup", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetProtectionGroupRuns : Get the list of runs for a Protection Group
// Get the runs for a particular Protection Group.
func (backupRecovery *BackupRecoveryV1) GetProtectionGroupRuns(getProtectionGroupRunsOptions *GetProtectionGroupRunsOptions) (result *ProtectionGroupRunsResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetProtectionGroupRunsWithContext(context.Background(), getProtectionGroupRunsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProtectionGroupRunsWithContext is an alternate form of the GetProtectionGroupRuns method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetProtectionGroupRunsWithContext(ctx context.Context, getProtectionGroupRunsOptions *GetProtectionGroupRunsOptions) (result *ProtectionGroupRunsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProtectionGroupRunsOptions, "getProtectionGroupRunsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProtectionGroupRunsOptions, "getProtectionGroupRunsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getProtectionGroupRunsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}/runs`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProtectionGroupRunsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetProtectionGroupRuns")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getProtectionGroupRunsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getProtectionGroupRunsOptions.XIBMTenantID))
	}
	if getProtectionGroupRunsOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*getProtectionGroupRunsOptions.RequestInitiatorType))
	}

	if getProtectionGroupRunsOptions.RunID != nil {
		builder.AddQuery("runId", fmt.Sprint(*getProtectionGroupRunsOptions.RunID))
	}
	if getProtectionGroupRunsOptions.StartTimeUsecs != nil {
		builder.AddQuery("startTimeUsecs", fmt.Sprint(*getProtectionGroupRunsOptions.StartTimeUsecs))
	}
	if getProtectionGroupRunsOptions.EndTimeUsecs != nil {
		builder.AddQuery("endTimeUsecs", fmt.Sprint(*getProtectionGroupRunsOptions.EndTimeUsecs))
	}
	if getProtectionGroupRunsOptions.RunTypes != nil {
		builder.AddQuery("runTypes", strings.Join(getProtectionGroupRunsOptions.RunTypes, ","))
	}
	if getProtectionGroupRunsOptions.IncludeObjectDetails != nil {
		builder.AddQuery("includeObjectDetails", fmt.Sprint(*getProtectionGroupRunsOptions.IncludeObjectDetails))
	}
	if getProtectionGroupRunsOptions.LocalBackupRunStatus != nil {
		builder.AddQuery("localBackupRunStatus", strings.Join(getProtectionGroupRunsOptions.LocalBackupRunStatus, ","))
	}
	if getProtectionGroupRunsOptions.ReplicationRunStatus != nil {
		builder.AddQuery("replicationRunStatus", strings.Join(getProtectionGroupRunsOptions.ReplicationRunStatus, ","))
	}
	if getProtectionGroupRunsOptions.ArchivalRunStatus != nil {
		builder.AddQuery("archivalRunStatus", strings.Join(getProtectionGroupRunsOptions.ArchivalRunStatus, ","))
	}
	if getProtectionGroupRunsOptions.CloudSpinRunStatus != nil {
		builder.AddQuery("cloudSpinRunStatus", strings.Join(getProtectionGroupRunsOptions.CloudSpinRunStatus, ","))
	}
	if getProtectionGroupRunsOptions.NumRuns != nil {
		builder.AddQuery("numRuns", fmt.Sprint(*getProtectionGroupRunsOptions.NumRuns))
	}
	if getProtectionGroupRunsOptions.ExcludeNonRestorableRuns != nil {
		builder.AddQuery("excludeNonRestorableRuns", fmt.Sprint(*getProtectionGroupRunsOptions.ExcludeNonRestorableRuns))
	}
	if getProtectionGroupRunsOptions.RunTags != nil {
		builder.AddQuery("runTags", strings.Join(getProtectionGroupRunsOptions.RunTags, ","))
	}
	if getProtectionGroupRunsOptions.UseCachedData != nil {
		builder.AddQuery("useCachedData", fmt.Sprint(*getProtectionGroupRunsOptions.UseCachedData))
	}
	if getProtectionGroupRunsOptions.FilterByEndTime != nil {
		builder.AddQuery("filterByEndTime", fmt.Sprint(*getProtectionGroupRunsOptions.FilterByEndTime))
	}
	if getProtectionGroupRunsOptions.SnapshotTargetTypes != nil {
		builder.AddQuery("snapshotTargetTypes", strings.Join(getProtectionGroupRunsOptions.SnapshotTargetTypes, ","))
	}
	if getProtectionGroupRunsOptions.OnlyReturnSuccessfulCopyRun != nil {
		builder.AddQuery("onlyReturnSuccessfulCopyRun", fmt.Sprint(*getProtectionGroupRunsOptions.OnlyReturnSuccessfulCopyRun))
	}
	if getProtectionGroupRunsOptions.FilterByCopyTaskEndTime != nil {
		builder.AddQuery("filterByCopyTaskEndTime", fmt.Sprint(*getProtectionGroupRunsOptions.FilterByCopyTaskEndTime))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetProtectionGroupRuns", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectionGroupRunsResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateProtectionGroupRun : Update runs for a particular Protection Group
// Update runs for a particular Protection Group. A user can perform the following actions: 1. Extend or reduce
// retention of a local, replication and archival snapshots. 2. Can perform resync operation on failed copy snapshots
// attempts in this Run. 3. Add new replication and archival snapshot targets to the Run. 4. Add or remove legal hold on
// the snapshots. Only a user with DSO role can perform this operation. 5. Delete the snapshots that were created as a
// part of this Run. 6. Apply datalock on existing snapshots where a user cannot manually delete snapshots before the
// expiry time.
func (backupRecovery *BackupRecoveryV1) UpdateProtectionGroupRun(updateProtectionGroupRunOptions *UpdateProtectionGroupRunOptions) (result *UpdateProtectionGroupRunResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.UpdateProtectionGroupRunWithContext(context.Background(), updateProtectionGroupRunOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateProtectionGroupRunWithContext is an alternate form of the UpdateProtectionGroupRun method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) UpdateProtectionGroupRunWithContext(ctx context.Context, updateProtectionGroupRunOptions *UpdateProtectionGroupRunOptions) (result *UpdateProtectionGroupRunResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateProtectionGroupRunOptions, "updateProtectionGroupRunOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateProtectionGroupRunOptions, "updateProtectionGroupRunOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateProtectionGroupRunOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}/runs`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateProtectionGroupRunOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "UpdateProtectionGroupRun")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if updateProtectionGroupRunOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*updateProtectionGroupRunOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if updateProtectionGroupRunOptions.UpdateProtectionGroupRunParams != nil {
		body["updateProtectionGroupRunParams"] = updateProtectionGroupRunOptions.UpdateProtectionGroupRunParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "UpdateProtectionGroupRun", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUpdateProtectionGroupRunResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateProtectionGroupRun : Create a new protection run
// Create a new protection run. This can be used to start a run for a Protection Group on demand, ignoring the schedule
// and retention specified in the protection policy.
func (backupRecovery *BackupRecoveryV1) CreateProtectionGroupRun(createProtectionGroupRunOptions *CreateProtectionGroupRunOptions) (result *CreateProtectionGroupRunResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateProtectionGroupRunWithContext(context.Background(), createProtectionGroupRunOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateProtectionGroupRunWithContext is an alternate form of the CreateProtectionGroupRun method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateProtectionGroupRunWithContext(ctx context.Context, createProtectionGroupRunOptions *CreateProtectionGroupRunOptions) (result *CreateProtectionGroupRunResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createProtectionGroupRunOptions, "createProtectionGroupRunOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createProtectionGroupRunOptions, "createProtectionGroupRunOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createProtectionGroupRunOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}/runs`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createProtectionGroupRunOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateProtectionGroupRun")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createProtectionGroupRunOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createProtectionGroupRunOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if createProtectionGroupRunOptions.RunType != nil {
		body["runType"] = createProtectionGroupRunOptions.RunType
	}
	if createProtectionGroupRunOptions.Objects != nil {
		body["objects"] = createProtectionGroupRunOptions.Objects
	}
	if createProtectionGroupRunOptions.TargetsConfig != nil {
		body["targetsConfig"] = createProtectionGroupRunOptions.TargetsConfig
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateProtectionGroupRun", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateProtectionGroupRunResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// PerformActionOnProtectionGroupRun : Actions on protection group run
// Perform various actions on a Protection Group run.
func (backupRecovery *BackupRecoveryV1) PerformActionOnProtectionGroupRun(performActionOnProtectionGroupRunOptions *PerformActionOnProtectionGroupRunOptions) (result *PerformRunActionResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.PerformActionOnProtectionGroupRunWithContext(context.Background(), performActionOnProtectionGroupRunOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// PerformActionOnProtectionGroupRunWithContext is an alternate form of the PerformActionOnProtectionGroupRun method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) PerformActionOnProtectionGroupRunWithContext(ctx context.Context, performActionOnProtectionGroupRunOptions *PerformActionOnProtectionGroupRunOptions) (result *PerformRunActionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(performActionOnProtectionGroupRunOptions, "performActionOnProtectionGroupRunOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(performActionOnProtectionGroupRunOptions, "performActionOnProtectionGroupRunOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *performActionOnProtectionGroupRunOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/protection-groups/{id}/runs/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range performActionOnProtectionGroupRunOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "PerformActionOnProtectionGroupRun")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if performActionOnProtectionGroupRunOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*performActionOnProtectionGroupRunOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if performActionOnProtectionGroupRunOptions.Action != nil {
		body["action"] = performActionOnProtectionGroupRunOptions.Action
	}
	if performActionOnProtectionGroupRunOptions.PauseParams != nil {
		body["pauseParams"] = performActionOnProtectionGroupRunOptions.PauseParams
	}
	if performActionOnProtectionGroupRunOptions.ResumeParams != nil {
		body["resumeParams"] = performActionOnProtectionGroupRunOptions.ResumeParams
	}
	if performActionOnProtectionGroupRunOptions.CancelParams != nil {
		body["cancelParams"] = performActionOnProtectionGroupRunOptions.CancelParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "PerformActionOnProtectionGroupRun", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPerformRunActionResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetRecoveries : Lists the Recoveries
// Lists the Recoveries.
func (backupRecovery *BackupRecoveryV1) GetRecoveries(getRecoveriesOptions *GetRecoveriesOptions) (result *RecoveriesResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetRecoveriesWithContext(context.Background(), getRecoveriesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetRecoveriesWithContext is an alternate form of the GetRecoveries method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetRecoveriesWithContext(ctx context.Context, getRecoveriesOptions *GetRecoveriesOptions) (result *RecoveriesResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRecoveriesOptions, "getRecoveriesOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getRecoveriesOptions, "getRecoveriesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/recoveries`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getRecoveriesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetRecoveries")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getRecoveriesOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getRecoveriesOptions.XIBMTenantID))
	}

	if getRecoveriesOptions.Ids != nil {
		builder.AddQuery("ids", strings.Join(getRecoveriesOptions.Ids, ","))
	}
	if getRecoveriesOptions.ReturnOnlyChildRecoveries != nil {
		builder.AddQuery("returnOnlyChildRecoveries", fmt.Sprint(*getRecoveriesOptions.ReturnOnlyChildRecoveries))
	}
	if getRecoveriesOptions.StartTimeUsecs != nil {
		builder.AddQuery("startTimeUsecs", fmt.Sprint(*getRecoveriesOptions.StartTimeUsecs))
	}
	if getRecoveriesOptions.EndTimeUsecs != nil {
		builder.AddQuery("endTimeUsecs", fmt.Sprint(*getRecoveriesOptions.EndTimeUsecs))
	}
	if getRecoveriesOptions.SnapshotTargetType != nil {
		builder.AddQuery("snapshotTargetType", strings.Join(getRecoveriesOptions.SnapshotTargetType, ","))
	}
	if getRecoveriesOptions.ArchivalTargetType != nil {
		builder.AddQuery("archivalTargetType", strings.Join(getRecoveriesOptions.ArchivalTargetType, ","))
	}
	if getRecoveriesOptions.SnapshotEnvironments != nil {
		builder.AddQuery("snapshotEnvironments", strings.Join(getRecoveriesOptions.SnapshotEnvironments, ","))
	}
	if getRecoveriesOptions.Status != nil {
		builder.AddQuery("status", strings.Join(getRecoveriesOptions.Status, ","))
	}
	if getRecoveriesOptions.RecoveryActions != nil {
		builder.AddQuery("recoveryActions", strings.Join(getRecoveriesOptions.RecoveryActions, ","))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetRecoveries", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRecoveriesResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateRecovery : Performs a Recovery
// Performs a Recovery.
func (backupRecovery *BackupRecoveryV1) CreateRecovery(createRecoveryOptions *CreateRecoveryOptions) (result *Recovery, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateRecoveryWithContext(context.Background(), createRecoveryOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateRecoveryWithContext is an alternate form of the CreateRecovery method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateRecoveryWithContext(ctx context.Context, createRecoveryOptions *CreateRecoveryOptions) (result *Recovery, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createRecoveryOptions, "createRecoveryOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createRecoveryOptions, "createRecoveryOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/recoveries`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createRecoveryOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateRecovery")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createRecoveryOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createRecoveryOptions.XIBMTenantID))
	}
	if createRecoveryOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*createRecoveryOptions.RequestInitiatorType))
	}

	body := make(map[string]interface{})
	if createRecoveryOptions.Name != nil {
		body["name"] = createRecoveryOptions.Name
	}
	if createRecoveryOptions.SnapshotEnvironment != nil {
		body["snapshotEnvironment"] = createRecoveryOptions.SnapshotEnvironment
	}
	if createRecoveryOptions.PhysicalParams != nil {
		body["physicalParams"] = createRecoveryOptions.PhysicalParams
	}
	if createRecoveryOptions.MssqlParams != nil {
		body["mssqlParams"] = createRecoveryOptions.MssqlParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateRecovery", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRecovery)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateDownloadFilesAndFoldersRecovery : Create a download files and folders recovery
// Creates a download files and folders recovery.
func (backupRecovery *BackupRecoveryV1) CreateDownloadFilesAndFoldersRecovery(createDownloadFilesAndFoldersRecoveryOptions *CreateDownloadFilesAndFoldersRecoveryOptions) (result *Recovery, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.CreateDownloadFilesAndFoldersRecoveryWithContext(context.Background(), createDownloadFilesAndFoldersRecoveryOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateDownloadFilesAndFoldersRecoveryWithContext is an alternate form of the CreateDownloadFilesAndFoldersRecovery method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) CreateDownloadFilesAndFoldersRecoveryWithContext(ctx context.Context, createDownloadFilesAndFoldersRecoveryOptions *CreateDownloadFilesAndFoldersRecoveryOptions) (result *Recovery, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDownloadFilesAndFoldersRecoveryOptions, "createDownloadFilesAndFoldersRecoveryOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createDownloadFilesAndFoldersRecoveryOptions, "createDownloadFilesAndFoldersRecoveryOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/recoveries/download-files-folders`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createDownloadFilesAndFoldersRecoveryOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "CreateDownloadFilesAndFoldersRecovery")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createDownloadFilesAndFoldersRecoveryOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*createDownloadFilesAndFoldersRecoveryOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if createDownloadFilesAndFoldersRecoveryOptions.Name != nil {
		body["name"] = createDownloadFilesAndFoldersRecoveryOptions.Name
	}
	if createDownloadFilesAndFoldersRecoveryOptions.Object != nil {
		body["object"] = createDownloadFilesAndFoldersRecoveryOptions.Object
	}
	if createDownloadFilesAndFoldersRecoveryOptions.FilesAndFolders != nil {
		body["filesAndFolders"] = createDownloadFilesAndFoldersRecoveryOptions.FilesAndFolders
	}
	if createDownloadFilesAndFoldersRecoveryOptions.Documents != nil {
		body["documents"] = createDownloadFilesAndFoldersRecoveryOptions.Documents
	}
	if createDownloadFilesAndFoldersRecoveryOptions.ParentRecoveryID != nil {
		body["parentRecoveryId"] = createDownloadFilesAndFoldersRecoveryOptions.ParentRecoveryID
	}
	if createDownloadFilesAndFoldersRecoveryOptions.GlacierRetrievalType != nil {
		body["glacierRetrievalType"] = createDownloadFilesAndFoldersRecoveryOptions.GlacierRetrievalType
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "CreateDownloadFilesAndFoldersRecovery", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRecovery)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetRecoveryByID : Get Recovery for a given id
// Get Recovery for a given id.
func (backupRecovery *BackupRecoveryV1) GetRecoveryByID(getRecoveryByIdOptions *GetRecoveryByIdOptions) (result *Recovery, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetRecoveryByIDWithContext(context.Background(), getRecoveryByIdOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetRecoveryByIDWithContext is an alternate form of the GetRecoveryByID method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetRecoveryByIDWithContext(ctx context.Context, getRecoveryByIdOptions *GetRecoveryByIdOptions) (result *Recovery, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRecoveryByIdOptions, "getRecoveryByIdOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getRecoveryByIdOptions, "getRecoveryByIdOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getRecoveryByIdOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/recoveries/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getRecoveryByIdOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetRecoveryByID")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getRecoveryByIdOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getRecoveryByIdOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetRecoveryById", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRecovery)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DownloadFilesFromRecovery : Download files from the given download file recovery
// Download files from the given download file recovery.
func (backupRecovery *BackupRecoveryV1) DownloadFilesFromRecovery(downloadFilesFromRecoveryOptions *DownloadFilesFromRecoveryOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DownloadFilesFromRecoveryWithContext(context.Background(), downloadFilesFromRecoveryOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DownloadFilesFromRecoveryWithContext is an alternate form of the DownloadFilesFromRecovery method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DownloadFilesFromRecoveryWithContext(ctx context.Context, downloadFilesFromRecoveryOptions *DownloadFilesFromRecoveryOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(downloadFilesFromRecoveryOptions, "downloadFilesFromRecoveryOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(downloadFilesFromRecoveryOptions, "downloadFilesFromRecoveryOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *downloadFilesFromRecoveryOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/recoveries/{id}/download-files`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range downloadFilesFromRecoveryOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DownloadFilesFromRecovery")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if downloadFilesFromRecoveryOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*downloadFilesFromRecoveryOptions.XIBMTenantID))
	}

	if downloadFilesFromRecoveryOptions.StartOffset != nil {
		builder.AddQuery("startOffset", fmt.Sprint(*downloadFilesFromRecoveryOptions.StartOffset))
	}
	if downloadFilesFromRecoveryOptions.Length != nil {
		builder.AddQuery("length", fmt.Sprint(*downloadFilesFromRecoveryOptions.Length))
	}
	if downloadFilesFromRecoveryOptions.FileType != nil {
		builder.AddQuery("fileType", fmt.Sprint(*downloadFilesFromRecoveryOptions.FileType))
	}
	if downloadFilesFromRecoveryOptions.SourceName != nil {
		builder.AddQuery("sourceName", fmt.Sprint(*downloadFilesFromRecoveryOptions.SourceName))
	}
	if downloadFilesFromRecoveryOptions.StartTime != nil {
		builder.AddQuery("startTime", fmt.Sprint(*downloadFilesFromRecoveryOptions.StartTime))
	}
	if downloadFilesFromRecoveryOptions.IncludeTenants != nil {
		builder.AddQuery("includeTenants", fmt.Sprint(*downloadFilesFromRecoveryOptions.IncludeTenants))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DownloadFilesFromRecovery", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetRestorePointsInTimeRange : List Restore Points in a given time range
// List Restore Points i.e. returns the snapshots in in a given time range.
func (backupRecovery *BackupRecoveryV1) GetRestorePointsInTimeRange(getRestorePointsInTimeRangeOptions *GetRestorePointsInTimeRangeOptions) (result *GetRestorePointsInTimeRangeResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetRestorePointsInTimeRangeWithContext(context.Background(), getRestorePointsInTimeRangeOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetRestorePointsInTimeRangeWithContext is an alternate form of the GetRestorePointsInTimeRange method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetRestorePointsInTimeRangeWithContext(ctx context.Context, getRestorePointsInTimeRangeOptions *GetRestorePointsInTimeRangeOptions) (result *GetRestorePointsInTimeRangeResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRestorePointsInTimeRangeOptions, "getRestorePointsInTimeRangeOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getRestorePointsInTimeRangeOptions, "getRestorePointsInTimeRangeOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/snapshots/restore-points`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getRestorePointsInTimeRangeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetRestorePointsInTimeRange")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if getRestorePointsInTimeRangeOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getRestorePointsInTimeRangeOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if getRestorePointsInTimeRangeOptions.EndTimeUsecs != nil {
		body["endTimeUsecs"] = getRestorePointsInTimeRangeOptions.EndTimeUsecs
	}
	if getRestorePointsInTimeRangeOptions.Environment != nil {
		body["environment"] = getRestorePointsInTimeRangeOptions.Environment
	}
	if getRestorePointsInTimeRangeOptions.ProtectionGroupIds != nil {
		body["protectionGroupIds"] = getRestorePointsInTimeRangeOptions.ProtectionGroupIds
	}
	if getRestorePointsInTimeRangeOptions.StartTimeUsecs != nil {
		body["startTimeUsecs"] = getRestorePointsInTimeRangeOptions.StartTimeUsecs
	}
	if getRestorePointsInTimeRangeOptions.SourceID != nil {
		body["sourceId"] = getRestorePointsInTimeRangeOptions.SourceID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetRestorePointsInTimeRange", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetRestorePointsInTimeRangeResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DownloadIndexedFile : Download an indexed file
// Download an indexed file from a snapshot.
func (backupRecovery *BackupRecoveryV1) DownloadIndexedFile(downloadIndexedFileOptions *DownloadIndexedFileOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DownloadIndexedFileWithContext(context.Background(), downloadIndexedFileOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DownloadIndexedFileWithContext is an alternate form of the DownloadIndexedFile method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DownloadIndexedFileWithContext(ctx context.Context, downloadIndexedFileOptions *DownloadIndexedFileOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(downloadIndexedFileOptions, "downloadIndexedFileOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(downloadIndexedFileOptions, "downloadIndexedFileOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"snapshotsId": *downloadIndexedFileOptions.SnapshotsID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/snapshots/{snapshotsId}/download-file`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range downloadIndexedFileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DownloadIndexedFile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if downloadIndexedFileOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*downloadIndexedFileOptions.XIBMTenantID))
	}

	if downloadIndexedFileOptions.FilePath != nil {
		builder.AddQuery("filePath", fmt.Sprint(*downloadIndexedFileOptions.FilePath))
	}
	if downloadIndexedFileOptions.NvramFile != nil {
		builder.AddQuery("nvramFile", fmt.Sprint(*downloadIndexedFileOptions.NvramFile))
	}
	if downloadIndexedFileOptions.RetryAttempt != nil {
		builder.AddQuery("retryAttempt", fmt.Sprint(*downloadIndexedFileOptions.RetryAttempt))
	}
	if downloadIndexedFileOptions.StartOffset != nil {
		builder.AddQuery("startOffset", fmt.Sprint(*downloadIndexedFileOptions.StartOffset))
	}
	if downloadIndexedFileOptions.Length != nil {
		builder.AddQuery("length", fmt.Sprint(*downloadIndexedFileOptions.Length))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DownloadIndexedFile", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// SearchIndexedObjects : List indexed objects
// List all the indexed objects like files and folders, emails, mailboxes etc., that match the specified search and
// filter criteria from protected objects.
func (backupRecovery *BackupRecoveryV1) SearchIndexedObjects(searchIndexedObjectsOptions *SearchIndexedObjectsOptions) (result *SearchIndexedObjectsResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.SearchIndexedObjectsWithContext(context.Background(), searchIndexedObjectsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// SearchIndexedObjectsWithContext is an alternate form of the SearchIndexedObjects method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) SearchIndexedObjectsWithContext(ctx context.Context, searchIndexedObjectsOptions *SearchIndexedObjectsOptions) (result *SearchIndexedObjectsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(searchIndexedObjectsOptions, "searchIndexedObjectsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(searchIndexedObjectsOptions, "searchIndexedObjectsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/search/indexed-objects`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range searchIndexedObjectsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "SearchIndexedObjects")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if searchIndexedObjectsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*searchIndexedObjectsOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if searchIndexedObjectsOptions.ObjectType != nil {
		body["objectType"] = searchIndexedObjectsOptions.ObjectType
	}
	if searchIndexedObjectsOptions.ProtectionGroupIds != nil {
		body["protectionGroupIds"] = searchIndexedObjectsOptions.ProtectionGroupIds
	}
	if searchIndexedObjectsOptions.StorageDomainIds != nil {
		body["storageDomainIds"] = searchIndexedObjectsOptions.StorageDomainIds
	}
	if searchIndexedObjectsOptions.TenantID != nil {
		body["tenantId"] = searchIndexedObjectsOptions.TenantID
	}
	if searchIndexedObjectsOptions.IncludeTenants != nil {
		body["includeTenants"] = searchIndexedObjectsOptions.IncludeTenants
	}
	if searchIndexedObjectsOptions.Tags != nil {
		body["tags"] = searchIndexedObjectsOptions.Tags
	}
	if searchIndexedObjectsOptions.SnapshotTags != nil {
		body["snapshotTags"] = searchIndexedObjectsOptions.SnapshotTags
	}
	if searchIndexedObjectsOptions.MustHaveTagIds != nil {
		body["mustHaveTagIds"] = searchIndexedObjectsOptions.MustHaveTagIds
	}
	if searchIndexedObjectsOptions.MightHaveTagIds != nil {
		body["mightHaveTagIds"] = searchIndexedObjectsOptions.MightHaveTagIds
	}
	if searchIndexedObjectsOptions.MustHaveSnapshotTagIds != nil {
		body["mustHaveSnapshotTagIds"] = searchIndexedObjectsOptions.MustHaveSnapshotTagIds
	}
	if searchIndexedObjectsOptions.MightHaveSnapshotTagIds != nil {
		body["mightHaveSnapshotTagIds"] = searchIndexedObjectsOptions.MightHaveSnapshotTagIds
	}
	if searchIndexedObjectsOptions.PaginationCookie != nil {
		body["paginationCookie"] = searchIndexedObjectsOptions.PaginationCookie
	}
	if searchIndexedObjectsOptions.Count != nil {
		body["count"] = searchIndexedObjectsOptions.Count
	}
	if searchIndexedObjectsOptions.UseCachedData != nil {
		body["useCachedData"] = searchIndexedObjectsOptions.UseCachedData
	}
	if searchIndexedObjectsOptions.CassandraParams != nil {
		body["cassandraParams"] = searchIndexedObjectsOptions.CassandraParams
	}
	if searchIndexedObjectsOptions.CouchbaseParams != nil {
		body["couchbaseParams"] = searchIndexedObjectsOptions.CouchbaseParams
	}
	if searchIndexedObjectsOptions.EmailParams != nil {
		body["emailParams"] = searchIndexedObjectsOptions.EmailParams
	}
	if searchIndexedObjectsOptions.ExchangeParams != nil {
		body["exchangeParams"] = searchIndexedObjectsOptions.ExchangeParams
	}
	if searchIndexedObjectsOptions.FileParams != nil {
		body["fileParams"] = searchIndexedObjectsOptions.FileParams
	}
	if searchIndexedObjectsOptions.HbaseParams != nil {
		body["hbaseParams"] = searchIndexedObjectsOptions.HbaseParams
	}
	if searchIndexedObjectsOptions.HdfsParams != nil {
		body["hdfsParams"] = searchIndexedObjectsOptions.HdfsParams
	}
	if searchIndexedObjectsOptions.HiveParams != nil {
		body["hiveParams"] = searchIndexedObjectsOptions.HiveParams
	}
	if searchIndexedObjectsOptions.MongodbParams != nil {
		body["mongodbParams"] = searchIndexedObjectsOptions.MongodbParams
	}
	if searchIndexedObjectsOptions.MsGroupsParams != nil {
		body["msGroupsParams"] = searchIndexedObjectsOptions.MsGroupsParams
	}
	if searchIndexedObjectsOptions.MsTeamsParams != nil {
		body["msTeamsParams"] = searchIndexedObjectsOptions.MsTeamsParams
	}
	if searchIndexedObjectsOptions.OneDriveParams != nil {
		body["oneDriveParams"] = searchIndexedObjectsOptions.OneDriveParams
	}
	if searchIndexedObjectsOptions.PublicFolderParams != nil {
		body["publicFolderParams"] = searchIndexedObjectsOptions.PublicFolderParams
	}
	if searchIndexedObjectsOptions.SfdcParams != nil {
		body["sfdcParams"] = searchIndexedObjectsOptions.SfdcParams
	}
	if searchIndexedObjectsOptions.SharepointParams != nil {
		body["sharepointParams"] = searchIndexedObjectsOptions.SharepointParams
	}
	if searchIndexedObjectsOptions.UdaParams != nil {
		body["udaParams"] = searchIndexedObjectsOptions.UdaParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "SearchIndexedObjects", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSearchIndexedObjectsResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// SearchObjects : List Objects
// List objects.
func (backupRecovery *BackupRecoveryV1) SearchObjects(searchObjectsOptions *SearchObjectsOptions) (result *ObjectsSearchResponseBody, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.SearchObjectsWithContext(context.Background(), searchObjectsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// SearchObjectsWithContext is an alternate form of the SearchObjects method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) SearchObjectsWithContext(ctx context.Context, searchObjectsOptions *SearchObjectsOptions) (result *ObjectsSearchResponseBody, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(searchObjectsOptions, "searchObjectsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(searchObjectsOptions, "searchObjectsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/search/objects`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range searchObjectsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "SearchObjects")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if searchObjectsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*searchObjectsOptions.XIBMTenantID))
	}
	if searchObjectsOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*searchObjectsOptions.RequestInitiatorType))
	}

	if searchObjectsOptions.SearchString != nil {
		builder.AddQuery("searchString", fmt.Sprint(*searchObjectsOptions.SearchString))
	}
	if searchObjectsOptions.Environments != nil {
		builder.AddQuery("environments", strings.Join(searchObjectsOptions.Environments, ","))
	}
	if searchObjectsOptions.ProtectionTypes != nil {
		builder.AddQuery("protectionTypes", strings.Join(searchObjectsOptions.ProtectionTypes, ","))
	}
	if searchObjectsOptions.ProtectionGroupIds != nil {
		builder.AddQuery("protectionGroupIds", strings.Join(searchObjectsOptions.ProtectionGroupIds, ","))
	}
	if searchObjectsOptions.ObjectIds != nil {
		err = builder.AddQuerySlice("objectIds", searchObjectsOptions.ObjectIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if searchObjectsOptions.OsTypes != nil {
		builder.AddQuery("osTypes", strings.Join(searchObjectsOptions.OsTypes, ","))
	}
	if searchObjectsOptions.SourceIds != nil {
		err = builder.AddQuerySlice("sourceIds", searchObjectsOptions.SourceIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if searchObjectsOptions.SourceUUIDs != nil {
		builder.AddQuery("sourceUuids", strings.Join(searchObjectsOptions.SourceUUIDs, ","))
	}
	if searchObjectsOptions.IsProtected != nil {
		builder.AddQuery("isProtected", fmt.Sprint(*searchObjectsOptions.IsProtected))
	}
	if searchObjectsOptions.IsDeleted != nil {
		builder.AddQuery("isDeleted", fmt.Sprint(*searchObjectsOptions.IsDeleted))
	}
	if searchObjectsOptions.LastRunStatusList != nil {
		builder.AddQuery("lastRunStatusList", strings.Join(searchObjectsOptions.LastRunStatusList, ","))
	}
	if searchObjectsOptions.ClusterIdentifiers != nil {
		builder.AddQuery("clusterIdentifiers", strings.Join(searchObjectsOptions.ClusterIdentifiers, ","))
	}
	if searchObjectsOptions.IncludeDeletedObjects != nil {
		builder.AddQuery("includeDeletedObjects", fmt.Sprint(*searchObjectsOptions.IncludeDeletedObjects))
	}
	if searchObjectsOptions.PaginationCookie != nil {
		builder.AddQuery("paginationCookie", fmt.Sprint(*searchObjectsOptions.PaginationCookie))
	}
	if searchObjectsOptions.Count != nil {
		builder.AddQuery("count", fmt.Sprint(*searchObjectsOptions.Count))
	}
	if searchObjectsOptions.MustHaveTagIds != nil {
		builder.AddQuery("mustHaveTagIds", strings.Join(searchObjectsOptions.MustHaveTagIds, ","))
	}
	if searchObjectsOptions.MightHaveTagIds != nil {
		builder.AddQuery("mightHaveTagIds", strings.Join(searchObjectsOptions.MightHaveTagIds, ","))
	}
	if searchObjectsOptions.MustHaveSnapshotTagIds != nil {
		builder.AddQuery("mustHaveSnapshotTagIds", strings.Join(searchObjectsOptions.MustHaveSnapshotTagIds, ","))
	}
	if searchObjectsOptions.MightHaveSnapshotTagIds != nil {
		builder.AddQuery("mightHaveSnapshotTagIds", strings.Join(searchObjectsOptions.MightHaveSnapshotTagIds, ","))
	}
	if searchObjectsOptions.TagSearchName != nil {
		builder.AddQuery("tagSearchName", fmt.Sprint(*searchObjectsOptions.TagSearchName))
	}
	if searchObjectsOptions.TagNames != nil {
		builder.AddQuery("tagNames", strings.Join(searchObjectsOptions.TagNames, ","))
	}
	if searchObjectsOptions.TagTypes != nil {
		builder.AddQuery("tagTypes", strings.Join(searchObjectsOptions.TagTypes, ","))
	}
	if searchObjectsOptions.TagCategories != nil {
		builder.AddQuery("tagCategories", strings.Join(searchObjectsOptions.TagCategories, ","))
	}
	if searchObjectsOptions.TagSubCategories != nil {
		builder.AddQuery("tagSubCategories", strings.Join(searchObjectsOptions.TagSubCategories, ","))
	}
	if searchObjectsOptions.IncludeHeliosTagInfoForObjects != nil {
		builder.AddQuery("includeHeliosTagInfoForObjects", fmt.Sprint(*searchObjectsOptions.IncludeHeliosTagInfoForObjects))
	}
	if searchObjectsOptions.ExternalFilters != nil {
		builder.AddQuery("externalFilters", strings.Join(searchObjectsOptions.ExternalFilters, ","))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "SearchObjects", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObjectsSearchResponseBody)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// SearchProtectedObjects : List Protected Objects
// List protected objects and corresponding detail information from registered sources filtered by specified query
// parameters. If no search pattern or filter parameters are specified, all protected objects currently found are
// returned.
func (backupRecovery *BackupRecoveryV1) SearchProtectedObjects(searchProtectedObjectsOptions *SearchProtectedObjectsOptions) (result *ProtectedObjectsSearchResponse, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.SearchProtectedObjectsWithContext(context.Background(), searchProtectedObjectsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// SearchProtectedObjectsWithContext is an alternate form of the SearchProtectedObjects method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) SearchProtectedObjectsWithContext(ctx context.Context, searchProtectedObjectsOptions *SearchProtectedObjectsOptions) (result *ProtectedObjectsSearchResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(searchProtectedObjectsOptions, "searchProtectedObjectsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(searchProtectedObjectsOptions, "searchProtectedObjectsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/search/protected-objects`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range searchProtectedObjectsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "SearchProtectedObjects")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if searchProtectedObjectsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*searchProtectedObjectsOptions.XIBMTenantID))
	}
	if searchProtectedObjectsOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*searchProtectedObjectsOptions.RequestInitiatorType))
	}

	if searchProtectedObjectsOptions.SearchString != nil {
		builder.AddQuery("searchString", fmt.Sprint(*searchProtectedObjectsOptions.SearchString))
	}
	if searchProtectedObjectsOptions.Environments != nil {
		builder.AddQuery("environments", strings.Join(searchProtectedObjectsOptions.Environments, ","))
	}
	if searchProtectedObjectsOptions.SnapshotActions != nil {
		builder.AddQuery("snapshotActions", strings.Join(searchProtectedObjectsOptions.SnapshotActions, ","))
	}
	if searchProtectedObjectsOptions.ObjectActionKey != nil {
		builder.AddQuery("objectActionKey", fmt.Sprint(*searchProtectedObjectsOptions.ObjectActionKey))
	}
	if searchProtectedObjectsOptions.ProtectionGroupIds != nil {
		builder.AddQuery("protectionGroupIds", strings.Join(searchProtectedObjectsOptions.ProtectionGroupIds, ","))
	}
	if searchProtectedObjectsOptions.ObjectIds != nil {
		err = builder.AddQuerySlice("objectIds", searchProtectedObjectsOptions.ObjectIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if searchProtectedObjectsOptions.SubResultSize != nil {
		builder.AddQuery("subResultSize", fmt.Sprint(*searchProtectedObjectsOptions.SubResultSize))
	}
	if searchProtectedObjectsOptions.FilterSnapshotFromUsecs != nil {
		builder.AddQuery("filterSnapshotFromUsecs", fmt.Sprint(*searchProtectedObjectsOptions.FilterSnapshotFromUsecs))
	}
	if searchProtectedObjectsOptions.FilterSnapshotToUsecs != nil {
		builder.AddQuery("filterSnapshotToUsecs", fmt.Sprint(*searchProtectedObjectsOptions.FilterSnapshotToUsecs))
	}
	if searchProtectedObjectsOptions.OsTypes != nil {
		builder.AddQuery("osTypes", strings.Join(searchProtectedObjectsOptions.OsTypes, ","))
	}
	if searchProtectedObjectsOptions.SourceIds != nil {
		err = builder.AddQuerySlice("sourceIds", searchProtectedObjectsOptions.SourceIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if searchProtectedObjectsOptions.RunInstanceIds != nil {
		err = builder.AddQuerySlice("runInstanceIds", searchProtectedObjectsOptions.RunInstanceIds)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if searchProtectedObjectsOptions.CdpProtectedOnly != nil {
		builder.AddQuery("cdpProtectedOnly", fmt.Sprint(*searchProtectedObjectsOptions.CdpProtectedOnly))
	}
	if searchProtectedObjectsOptions.UseCachedData != nil {
		builder.AddQuery("useCachedData", fmt.Sprint(*searchProtectedObjectsOptions.UseCachedData))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "SearchProtectedObjects", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProtectedObjectsSearchResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetSourceRegistrations : Get the list of Protection Source registrations
// Get the list of Protection Source registrations.
func (backupRecovery *BackupRecoveryV1) GetSourceRegistrations(getSourceRegistrationsOptions *GetSourceRegistrationsOptions) (result *SourceRegistrations, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetSourceRegistrationsWithContext(context.Background(), getSourceRegistrationsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetSourceRegistrationsWithContext is an alternate form of the GetSourceRegistrations method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetSourceRegistrationsWithContext(ctx context.Context, getSourceRegistrationsOptions *GetSourceRegistrationsOptions) (result *SourceRegistrations, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSourceRegistrationsOptions, "getSourceRegistrationsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getSourceRegistrationsOptions, "getSourceRegistrationsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/registrations`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getSourceRegistrationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetSourceRegistrations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getSourceRegistrationsOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getSourceRegistrationsOptions.XIBMTenantID))
	}

	if getSourceRegistrationsOptions.Ids != nil {
		err = builder.AddQuerySlice("ids", getSourceRegistrationsOptions.Ids)
		if err != nil {
			err = core.SDKErrorf(err, "", "add-query-slice-error", common.GetComponentInfo())
			return
		}
	}
	if getSourceRegistrationsOptions.IncludeSourceCredentials != nil {
		builder.AddQuery("includeSourceCredentials", fmt.Sprint(*getSourceRegistrationsOptions.IncludeSourceCredentials))
	}
	if getSourceRegistrationsOptions.EncryptionKey != nil {
		builder.AddQuery("encryptionKey", fmt.Sprint(*getSourceRegistrationsOptions.EncryptionKey))
	}
	if getSourceRegistrationsOptions.UseCachedData != nil {
		builder.AddQuery("useCachedData", fmt.Sprint(*getSourceRegistrationsOptions.UseCachedData))
	}
	if getSourceRegistrationsOptions.IncludeExternalMetadata != nil {
		builder.AddQuery("includeExternalMetadata", fmt.Sprint(*getSourceRegistrationsOptions.IncludeExternalMetadata))
	}
	if getSourceRegistrationsOptions.IgnoreTenantMigrationInProgressCheck != nil {
		builder.AddQuery("ignoreTenantMigrationInProgressCheck", fmt.Sprint(*getSourceRegistrationsOptions.IgnoreTenantMigrationInProgressCheck))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetSourceRegistrations", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceRegistrations)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// RegisterProtectionSource : Register a Protection Source
// Register a Protection Source.
func (backupRecovery *BackupRecoveryV1) RegisterProtectionSource(registerProtectionSourceOptions *RegisterProtectionSourceOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.RegisterProtectionSourceWithContext(context.Background(), registerProtectionSourceOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// RegisterProtectionSourceWithContext is an alternate form of the RegisterProtectionSource method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) RegisterProtectionSourceWithContext(ctx context.Context, registerProtectionSourceOptions *RegisterProtectionSourceOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(registerProtectionSourceOptions, "registerProtectionSourceOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(registerProtectionSourceOptions, "registerProtectionSourceOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/registrations`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range registerProtectionSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "RegisterProtectionSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if registerProtectionSourceOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*registerProtectionSourceOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if registerProtectionSourceOptions.Environment != nil {
		body["environment"] = registerProtectionSourceOptions.Environment
	}
	if registerProtectionSourceOptions.Name != nil {
		body["name"] = registerProtectionSourceOptions.Name
	}
	if registerProtectionSourceOptions.IsInternalEncrypted != nil {
		body["isInternalEncrypted"] = registerProtectionSourceOptions.IsInternalEncrypted
	}
	if registerProtectionSourceOptions.EncryptionKey != nil {
		body["encryptionKey"] = registerProtectionSourceOptions.EncryptionKey
	}
	if registerProtectionSourceOptions.ConnectionID != nil {
		body["connectionId"] = registerProtectionSourceOptions.ConnectionID
	}
	if registerProtectionSourceOptions.Connections != nil {
		body["connections"] = registerProtectionSourceOptions.Connections
	}
	if registerProtectionSourceOptions.ConnectorGroupID != nil {
		body["connectorGroupId"] = registerProtectionSourceOptions.ConnectorGroupID
	}
	if registerProtectionSourceOptions.AdvancedConfigs != nil {
		body["advancedConfigs"] = registerProtectionSourceOptions.AdvancedConfigs
	}
	if registerProtectionSourceOptions.DataSourceConnectionID != nil {
		body["dataSourceConnectionId"] = registerProtectionSourceOptions.DataSourceConnectionID
	}
	if registerProtectionSourceOptions.PhysicalParams != nil {
		body["physicalParams"] = registerProtectionSourceOptions.PhysicalParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "RegisterProtectionSource", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceRegistrationReponseParams)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetProtectionSourceRegistration : Get a Protection Source registration
// Get a Protection Source registration.
func (backupRecovery *BackupRecoveryV1) GetProtectionSourceRegistration(getProtectionSourceRegistrationOptions *GetProtectionSourceRegistrationOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.GetProtectionSourceRegistrationWithContext(context.Background(), getProtectionSourceRegistrationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProtectionSourceRegistrationWithContext is an alternate form of the GetProtectionSourceRegistration method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) GetProtectionSourceRegistrationWithContext(ctx context.Context, getProtectionSourceRegistrationOptions *GetProtectionSourceRegistrationOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProtectionSourceRegistrationOptions, "getProtectionSourceRegistrationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProtectionSourceRegistrationOptions, "getProtectionSourceRegistrationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": fmt.Sprint(*getProtectionSourceRegistrationOptions.ID),
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/registrations/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProtectionSourceRegistrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "GetProtectionSourceRegistration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getProtectionSourceRegistrationOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*getProtectionSourceRegistrationOptions.XIBMTenantID))
	}
	if getProtectionSourceRegistrationOptions.RequestInitiatorType != nil {
		builder.AddHeader("requestInitiatorType", fmt.Sprint(*getProtectionSourceRegistrationOptions.RequestInitiatorType))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "GetProtectionSourceRegistration", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceRegistrationReponseParams)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateProtectionSourceRegistration : Update Protection Source registration
// Update Protection Source registration.
func (backupRecovery *BackupRecoveryV1) UpdateProtectionSourceRegistration(updateProtectionSourceRegistrationOptions *UpdateProtectionSourceRegistrationOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.UpdateProtectionSourceRegistrationWithContext(context.Background(), updateProtectionSourceRegistrationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateProtectionSourceRegistrationWithContext is an alternate form of the UpdateProtectionSourceRegistration method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) UpdateProtectionSourceRegistrationWithContext(ctx context.Context, updateProtectionSourceRegistrationOptions *UpdateProtectionSourceRegistrationOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateProtectionSourceRegistrationOptions, "updateProtectionSourceRegistrationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateProtectionSourceRegistrationOptions, "updateProtectionSourceRegistrationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": fmt.Sprint(*updateProtectionSourceRegistrationOptions.ID),
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/registrations/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateProtectionSourceRegistrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "UpdateProtectionSourceRegistration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if updateProtectionSourceRegistrationOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*updateProtectionSourceRegistrationOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if updateProtectionSourceRegistrationOptions.Environment != nil {
		body["environment"] = updateProtectionSourceRegistrationOptions.Environment
	}
	if updateProtectionSourceRegistrationOptions.Name != nil {
		body["name"] = updateProtectionSourceRegistrationOptions.Name
	}
	if updateProtectionSourceRegistrationOptions.IsInternalEncrypted != nil {
		body["isInternalEncrypted"] = updateProtectionSourceRegistrationOptions.IsInternalEncrypted
	}
	if updateProtectionSourceRegistrationOptions.EncryptionKey != nil {
		body["encryptionKey"] = updateProtectionSourceRegistrationOptions.EncryptionKey
	}
	if updateProtectionSourceRegistrationOptions.ConnectionID != nil {
		body["connectionId"] = updateProtectionSourceRegistrationOptions.ConnectionID
	}
	if updateProtectionSourceRegistrationOptions.Connections != nil {
		body["connections"] = updateProtectionSourceRegistrationOptions.Connections
	}
	if updateProtectionSourceRegistrationOptions.ConnectorGroupID != nil {
		body["connectorGroupId"] = updateProtectionSourceRegistrationOptions.ConnectorGroupID
	}
	if updateProtectionSourceRegistrationOptions.AdvancedConfigs != nil {
		body["advancedConfigs"] = updateProtectionSourceRegistrationOptions.AdvancedConfigs
	}
	if updateProtectionSourceRegistrationOptions.DataSourceConnectionID != nil {
		body["dataSourceConnectionId"] = updateProtectionSourceRegistrationOptions.DataSourceConnectionID
	}
	if updateProtectionSourceRegistrationOptions.LastModifiedTimestampUsecs != nil {
		body["lastModifiedTimestampUsecs"] = updateProtectionSourceRegistrationOptions.LastModifiedTimestampUsecs
	}
	if updateProtectionSourceRegistrationOptions.PhysicalParams != nil {
		body["physicalParams"] = updateProtectionSourceRegistrationOptions.PhysicalParams
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "UpdateProtectionSourceRegistration", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceRegistrationReponseParams)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// PatchProtectionSourceRegistration : Patches a Protection Source
// Patches a Protection Source.
func (backupRecovery *BackupRecoveryV1) PatchProtectionSourceRegistration(patchProtectionSourceRegistrationOptions *PatchProtectionSourceRegistrationOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	result, response, err = backupRecovery.PatchProtectionSourceRegistrationWithContext(context.Background(), patchProtectionSourceRegistrationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// PatchProtectionSourceRegistrationWithContext is an alternate form of the PatchProtectionSourceRegistration method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) PatchProtectionSourceRegistrationWithContext(ctx context.Context, patchProtectionSourceRegistrationOptions *PatchProtectionSourceRegistrationOptions) (result *SourceRegistrationReponseParams, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchProtectionSourceRegistrationOptions, "patchProtectionSourceRegistrationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(patchProtectionSourceRegistrationOptions, "patchProtectionSourceRegistrationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": fmt.Sprint(*patchProtectionSourceRegistrationOptions.ID),
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/registrations/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range patchProtectionSourceRegistrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "PatchProtectionSourceRegistration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if patchProtectionSourceRegistrationOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*patchProtectionSourceRegistrationOptions.XIBMTenantID))
	}

	body := make(map[string]interface{})
	if patchProtectionSourceRegistrationOptions.Environment != nil {
		body["environment"] = patchProtectionSourceRegistrationOptions.Environment
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = backupRecovery.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "PatchProtectionSourceRegistration", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceRegistrationReponseParams)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteProtectionSourceRegistration : Delete Protection Source Registration
// Delete Protection Source Registration.
func (backupRecovery *BackupRecoveryV1) DeleteProtectionSourceRegistration(deleteProtectionSourceRegistrationOptions *DeleteProtectionSourceRegistrationOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.DeleteProtectionSourceRegistrationWithContext(context.Background(), deleteProtectionSourceRegistrationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteProtectionSourceRegistrationWithContext is an alternate form of the DeleteProtectionSourceRegistration method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) DeleteProtectionSourceRegistrationWithContext(ctx context.Context, deleteProtectionSourceRegistrationOptions *DeleteProtectionSourceRegistrationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteProtectionSourceRegistrationOptions, "deleteProtectionSourceRegistrationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteProtectionSourceRegistrationOptions, "deleteProtectionSourceRegistrationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": fmt.Sprint(*deleteProtectionSourceRegistrationOptions.ID),
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/registrations/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteProtectionSourceRegistrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "DeleteProtectionSourceRegistration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteProtectionSourceRegistrationOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*deleteProtectionSourceRegistrationOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "DeleteProtectionSourceRegistration", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// RefreshProtectionSourceByID : Refresh a Protection Source
// Refresh a Protection Source.
func (backupRecovery *BackupRecoveryV1) RefreshProtectionSourceByID(refreshProtectionSourceByIdOptions *RefreshProtectionSourceByIdOptions) (response *core.DetailedResponse, err error) {
	response, err = backupRecovery.RefreshProtectionSourceByIDWithContext(context.Background(), refreshProtectionSourceByIdOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// RefreshProtectionSourceByIDWithContext is an alternate form of the RefreshProtectionSourceByID method which supports a Context parameter
func (backupRecovery *BackupRecoveryV1) RefreshProtectionSourceByIDWithContext(ctx context.Context, refreshProtectionSourceByIdOptions *RefreshProtectionSourceByIdOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(refreshProtectionSourceByIdOptions, "refreshProtectionSourceByIdOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(refreshProtectionSourceByIdOptions, "refreshProtectionSourceByIdOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": fmt.Sprint(*refreshProtectionSourceByIdOptions.ID),
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = backupRecovery.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(backupRecovery.Service.Options.URL, `/data-protect/sources/{id}/refresh`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range refreshProtectionSourceByIdOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("backup_recovery", "V1", "RefreshProtectionSourceByID")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if refreshProtectionSourceByIdOptions.XIBMTenantID != nil {
		builder.AddHeader("X-IBM-Tenant-Id", fmt.Sprint(*refreshProtectionSourceByIdOptions.XIBMTenantID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = backupRecovery.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "RefreshProtectionSourceById", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}
func getServiceComponentInfo() *core.ProblemComponent {
	return core.NewProblemComponent(DefaultServiceName, "1.0.0")
}

// AAGInfo : Object details for Mssql.
type AAGInfo struct {
	// Specifies the AAG name.
	Name *string `json:"name,omitempty"`

	// Specifies the AAG object Id.
	ObjectID *int64 `json:"objectId,omitempty"`
}

// UnmarshalAAGInfo unmarshals an instance of AAGInfo from the specified map of raw messages.
func UnmarshalAAGInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AAGInfo)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectId", &obj.ObjectID)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AWSTargetConfig : Specifies the configuration for adding AWS as repilcation target.
type AWSTargetConfig struct {
	// Specifies the name of the AWS Replication target. This parameter is read-only and
	// is included only in the response. It should not be included in any requests, as doing
	// so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies id of the AWS region in which to replicate the Snapshot to. Applicable if replication target is AWS
	// target.
	Region *int64 `json:"region" validate:"required"`

	// Specifies name of the AWS region in which to replicate the Snapshot to. Applicable if replication target is AWS
	// target. This parameter is read-only and is included only in the response. It should not be included in any requests,
	// as doing so will result in an error.
	RegionName *string `json:"regionName,omitempty"`

	// Specifies the source id of the AWS protection source registered on IBM cluster.
	SourceID *int64 `json:"sourceId" validate:"required"`
}

// NewAWSTargetConfig : Instantiate AWSTargetConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewAWSTargetConfig(region int64, sourceID int64) (_model *AWSTargetConfig, err error) {
	_model = &AWSTargetConfig{
		Region:   core.Int64Ptr(region),
		SourceID: core.Int64Ptr(sourceID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAWSTargetConfig unmarshals an instance of AWSTargetConfig from the specified map of raw messages.
func UnmarshalAWSTargetConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AWSTargetConfig)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		err = core.SDKErrorf(err, "", "region-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "regionName", &obj.RegionName)
	if err != nil {
		err = core.SDKErrorf(err, "", "regionName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AWSTier : Specifies the settings for a aws tier.
type AWSTier struct {
	// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
	// 'moveAfter' field specified below.
	MoveAfterUnit *string `json:"moveAfterUnit,omitempty"`

	// Specifies the time period after which the backup will be moved from current tier to next tier.
	MoveAfter *int64 `json:"moveAfter,omitempty"`

	// Specifies the AWS tier types.
	TierType *string `json:"tierType" validate:"required"`
}

// Constants associated with the AWSTier.MoveAfterUnit property.
// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
// 'moveAfter' field specified below.
const (
	AWSTier_MoveAfterUnit_Days   = "Days"
	AWSTier_MoveAfterUnit_Months = "Months"
	AWSTier_MoveAfterUnit_Weeks  = "Weeks"
	AWSTier_MoveAfterUnit_Years  = "Years"
)

// Constants associated with the AWSTier.TierType property.
// Specifies the AWS tier types.
const (
	AWSTier_TierType_Kamazons3glacier            = "kAmazonS3Glacier"
	AWSTier_TierType_Kamazons3glacierdeeparchive = "kAmazonS3GlacierDeepArchive"
	AWSTier_TierType_Kamazons3intelligenttiering = "kAmazonS3IntelligentTiering"
	AWSTier_TierType_Kamazons3onezoneia          = "kAmazonS3OneZoneIA"
	AWSTier_TierType_Kamazons3standard           = "kAmazonS3Standard"
	AWSTier_TierType_Kamazons3standardia         = "kAmazonS3StandardIA"
)

// NewAWSTier : Instantiate AWSTier (Generic Model Constructor)
func (*BackupRecoveryV1) NewAWSTier(tierType string) (_model *AWSTier, err error) {
	_model = &AWSTier{
		TierType: core.StringPtr(tierType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAWSTier unmarshals an instance of AWSTier from the specified map of raw messages.
func UnmarshalAWSTier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AWSTier)
	err = core.UnmarshalPrimitive(m, "moveAfterUnit", &obj.MoveAfterUnit)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfterUnit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "moveAfter", &obj.MoveAfter)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tierType", &obj.TierType)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AWSTiers : Specifies aws tiers.
type AWSTiers struct {
	// Specifies the tiers that are used to move the archived backup from current tier to next tier. The order of the tiers
	// determines which tier will be used next for moving the archived backup. The first tier input should always be
	// default tier where backup will be acrhived. Each tier specifies how much time after the backup will be moved to next
	// tier from the current tier.
	Tiers []AWSTier `json:"tiers" validate:"required"`
}

// NewAWSTiers : Instantiate AWSTiers (Generic Model Constructor)
func (*BackupRecoveryV1) NewAWSTiers(tiers []AWSTier) (_model *AWSTiers, err error) {
	_model = &AWSTiers{
		Tiers: tiers,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAWSTiers unmarshals an instance of AWSTiers from the specified map of raw messages.
func UnmarshalAWSTiers(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AWSTiers)
	err = core.UnmarshalModel(m, "tiers", &obj.Tiers, UnmarshalAWSTier)
	if err != nil {
		err = core.SDKErrorf(err, "", "tiers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AdvancedSettings : This is used to regulate certain gflag values from the UI. The values passed by the user from the UI will be used for
// the respective gflags.
type AdvancedSettings struct {
	// Whether to report error if SQL database is cloned.
	ClonedDbBackupStatus *string `json:"clonedDbBackupStatus,omitempty"`

	// Whether to report error if SQL database is not online.
	DbBackupIfNotOnlineStatus *string `json:"dbBackupIfNotOnlineStatus,omitempty"`

	// Fail the backup job when the database is missing. The database may be missing if it is deleted or corrupted.
	MissingDbBackupStatus *string `json:"missingDbBackupStatus,omitempty"`

	// Fail the backup job when database is offline or restoring.
	OfflineRestoringDbBackupStatus *string `json:"offlineRestoringDbBackupStatus,omitempty"`

	// Whether to skip backup for read-only SQL databases.
	ReadOnlyDbBackupStatus *string `json:"readOnlyDbBackupStatus,omitempty"`

	// Whether to report error for all dbs in non-autoprotect jobs.
	ReportAllNonAutoprotectDbErrors *string `json:"reportAllNonAutoprotectDbErrors,omitempty"`
}

// Constants associated with the AdvancedSettings.ClonedDbBackupStatus property.
// Whether to report error if SQL database is cloned.
const (
	AdvancedSettings_ClonedDbBackupStatus_Kerror  = "kError"
	AdvancedSettings_ClonedDbBackupStatus_Kignore = "kIgnore"
	AdvancedSettings_ClonedDbBackupStatus_Kwarn   = "kWarn"
)

// Constants associated with the AdvancedSettings.DbBackupIfNotOnlineStatus property.
// Whether to report error if SQL database is not online.
const (
	AdvancedSettings_DbBackupIfNotOnlineStatus_Kerror  = "kError"
	AdvancedSettings_DbBackupIfNotOnlineStatus_Kignore = "kIgnore"
	AdvancedSettings_DbBackupIfNotOnlineStatus_Kwarn   = "kWarn"
)

// Constants associated with the AdvancedSettings.MissingDbBackupStatus property.
// Fail the backup job when the database is missing. The database may be missing if it is deleted or corrupted.
const (
	AdvancedSettings_MissingDbBackupStatus_Kerror  = "kError"
	AdvancedSettings_MissingDbBackupStatus_Kignore = "kIgnore"
	AdvancedSettings_MissingDbBackupStatus_Kwarn   = "kWarn"
)

// Constants associated with the AdvancedSettings.OfflineRestoringDbBackupStatus property.
// Fail the backup job when database is offline or restoring.
const (
	AdvancedSettings_OfflineRestoringDbBackupStatus_Kerror  = "kError"
	AdvancedSettings_OfflineRestoringDbBackupStatus_Kignore = "kIgnore"
	AdvancedSettings_OfflineRestoringDbBackupStatus_Kwarn   = "kWarn"
)

// Constants associated with the AdvancedSettings.ReadOnlyDbBackupStatus property.
// Whether to skip backup for read-only SQL databases.
const (
	AdvancedSettings_ReadOnlyDbBackupStatus_Kerror  = "kError"
	AdvancedSettings_ReadOnlyDbBackupStatus_Kignore = "kIgnore"
	AdvancedSettings_ReadOnlyDbBackupStatus_Kwarn   = "kWarn"
)

// Constants associated with the AdvancedSettings.ReportAllNonAutoprotectDbErrors property.
// Whether to report error for all dbs in non-autoprotect jobs.
const (
	AdvancedSettings_ReportAllNonAutoprotectDbErrors_Kerror  = "kError"
	AdvancedSettings_ReportAllNonAutoprotectDbErrors_Kignore = "kIgnore"
	AdvancedSettings_ReportAllNonAutoprotectDbErrors_Kwarn   = "kWarn"
)

// UnmarshalAdvancedSettings unmarshals an instance of AdvancedSettings from the specified map of raw messages.
func UnmarshalAdvancedSettings(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AdvancedSettings)
	err = core.UnmarshalPrimitive(m, "clonedDbBackupStatus", &obj.ClonedDbBackupStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "clonedDbBackupStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dbBackupIfNotOnlineStatus", &obj.DbBackupIfNotOnlineStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbBackupIfNotOnlineStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missingDbBackupStatus", &obj.MissingDbBackupStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "missingDbBackupStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "offlineRestoringDbBackupStatus", &obj.OfflineRestoringDbBackupStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "offlineRestoringDbBackupStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "readOnlyDbBackupStatus", &obj.ReadOnlyDbBackupStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "readOnlyDbBackupStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "reportAllNonAutoprotectDbErrors", &obj.ReportAllNonAutoprotectDbErrors)
	if err != nil {
		err = core.SDKErrorf(err, "", "reportAllNonAutoprotectDbErrors-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentAccessInfo : Specifies the parameters required to establish a connection with a particular environment.
type AgentAccessInfo struct {
	// ID of the Bifrost (HyX or Rigel) network realm (i.e. a connection) associated with the source.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// Specifies the Id of the connector group. Each connector group is collection of Rigel/hyx. Each entity will be tagged
	// with connector group id.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Specify an IP address or URL of the environment. (such as the IP address of the vCenter Server for a VMware
	// environment).
	Endpoint *string `json:"endpoint,omitempty"`

	// Specifies the environment like VMware, SQL, where the Protection Source exists. Supported environment types such as
	// 'kView', 'kSQL', 'kVMware', etc.
	Environment *string `json:"environment,omitempty"`

	// Specifies a Unique id that is generated when the Source is registered. This is a convenience field that is used to
	// maintain an index to different connection params.
	ID *int64 `json:"id,omitempty"`

	// Version is updated each time the connector parameters are updated. This is used to discard older connector
	// parameters.
	Version *int64 `json:"version,omitempty"`
}

// Constants associated with the AgentAccessInfo.Environment property.
// Specifies the environment like VMware, SQL, where the Protection Source exists. Supported environment types such as
// 'kView', 'kSQL', 'kVMware', etc.
const (
	AgentAccessInfo_Environment_Kagent         = "kAgent"
	AgentAccessInfo_Environment_Kphysical      = "kPhysical"
	AgentAccessInfo_Environment_Kphysicalfiles = "kPhysicalFiles"
	AgentAccessInfo_Environment_Ksql           = "kSQL"
)

// UnmarshalAgentAccessInfo unmarshals an instance of AgentAccessInfo from the specified map of raw messages.
func UnmarshalAgentAccessInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentAccessInfo)
	err = core.UnmarshalPrimitive(m, "connectionId", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorGroupId", &obj.ConnectorGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		err = core.SDKErrorf(err, "", "endpoint-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		err = core.SDKErrorf(err, "", "version-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentInfoObject : Specifies the upgrade state of the agent.
type AgentInfoObject struct {
	// Specifies the time when the upgrade for an agent completed as a Unix epoch Timestamp (in microseconds).
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Object that holds the error object.
	Error *Error `json:"error,omitempty"`

	// Specifies the name of the source where the agent is installed.
	Name *string `json:"name,omitempty"`

	// Specifies the software version of the agent before upgrade.
	PreviousSoftwareVersion *string `json:"previousSoftwareVersion,omitempty"`

	// Specifies the time when the upgrade for an agent started as a Unix epoch Timestamp (in microseconds).
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the upgrade status of the agent.<br> 'Scheduled' indicates that upgrade for the agent is yet to start.<br>
	// 'Started' indicates that upgrade for the agent is started.<br> 'Succeeded' indicates that agent was upgraded
	// successfully.<br> 'Failed' indicates that upgrade for the agent has failed.<br> 'Skipped' indicates that upgrade for
	// the agent was skipped.
	Status *string `json:"status,omitempty"`
}

// Constants associated with the AgentInfoObject.Status property.
// Specifies the upgrade status of the agent.<br> 'Scheduled' indicates that upgrade for the agent is yet to start.<br>
// 'Started' indicates that upgrade for the agent is started.<br> 'Succeeded' indicates that agent was upgraded
// successfully.<br> 'Failed' indicates that upgrade for the agent has failed.<br> 'Skipped' indicates that upgrade for
// the agent was skipped.
const (
	AgentInfoObject_Status_Failed    = "Failed"
	AgentInfoObject_Status_Scheduled = "Scheduled"
	AgentInfoObject_Status_Skipped   = "Skipped"
	AgentInfoObject_Status_Started   = "Started"
	AgentInfoObject_Status_Succeeded = "Succeeded"
)

// UnmarshalAgentInfoObject unmarshals an instance of AgentInfoObject from the specified map of raw messages.
func UnmarshalAgentInfoObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentInfoObject)
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "error", &obj.Error, UnmarshalError)
	if err != nil {
		err = core.SDKErrorf(err, "", "error-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "previousSoftwareVersion", &obj.PreviousSoftwareVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "previousSoftwareVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentInformation : Specifies information about the Agent software running on the server or the Virtual Machine.
type AgentInformation struct {
	// Specifies the version if Cristie BMR product is installed on the host.
	CbmrVersion *string `json:"cbmrVersion,omitempty"`

	// CBT version and service state info.
	FileCbtInfo *CbtInfo `json:"fileCbtInfo,omitempty"`

	// Specifies the host type where the agent is running. This is only set for persistent agents.
	HostType *string `json:"hostType,omitempty"`

	// Specifies the agent's id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the agent's name.
	Name *string `json:"name,omitempty"`

	// Specifies whether oracle multi node multi channel is supported or not.
	OracleMultiNodeChannelSupported *bool `json:"oracleMultiNodeChannelSupported,omitempty"`

	// Specifies information about a registered Source.
	RegistrationInfo *AgentRegistrationInfo `json:"registrationInfo,omitempty"`

	// Specifies whether source side dedup is enabled or not.
	SourceSideDedupEnabled *bool `json:"sourceSideDedupEnabled,omitempty"`

	// Specifies the agent status. Specifies the status of the agent running on a physical source.
	Status *string `json:"status,omitempty"`

	// Specifies additional details about the agent status.
	StatusMessage *string `json:"statusMessage,omitempty"`

	// Specifies the upgradability of the agent running on the physical server. Specifies the upgradability of the agent
	// running on the physical server.
	Upgradability *string `json:"upgradability,omitempty"`

	// Specifies the status of the upgrade of the agent on a physical server. Specifies the status of the upgrade of the
	// agent on a physical server.
	UpgradeStatus *string `json:"upgradeStatus,omitempty"`

	// Specifies detailed message about the agent upgrade failure. This field is not set for successful upgrade.
	UpgradeStatusMessage *string `json:"upgradeStatusMessage,omitempty"`

	// Specifies the version of the Agent software.
	Version *string `json:"version,omitempty"`

	// CBT version and service state info.
	VolCbtInfo *CbtInfo `json:"volCbtInfo,omitempty"`
}

// Constants associated with the AgentInformation.HostType property.
// Specifies the host type where the agent is running. This is only set for persistent agents.
const (
	AgentInformation_HostType_Kaix         = "kAix"
	AgentInformation_HostType_Kcockroachdb = "kCockroachDB"
	AgentInformation_HostType_Kdb2         = "kDB2"
	AgentInformation_HostType_Khpux        = "kHPUX"
	AgentInformation_HostType_Klinux       = "kLinux"
	AgentInformation_HostType_Kmariadb     = "kMariaDB"
	AgentInformation_HostType_Kmysql       = "kMySQL"
	AgentInformation_HostType_Kother       = "kOther"
	AgentInformation_HostType_Kpostgresql  = "kPostgreSQL"
	AgentInformation_HostType_Ksapase      = "kSapASE"
	AgentInformation_HostType_Ksaphana     = "kSapHana"
	AgentInformation_HostType_Ksapmaxdb    = "kSapMaxDB"
	AgentInformation_HostType_Ksaporacle   = "kSapOracle"
	AgentInformation_HostType_Ksapsybase   = "kSapSybase"
	AgentInformation_HostType_Ksapsybaseiq = "kSapSybaseIQ"
	AgentInformation_HostType_Ksolaris     = "kSolaris"
	AgentInformation_HostType_Kvos         = "kVOS"
	AgentInformation_HostType_Kwindows     = "kWindows"
)

// Constants associated with the AgentInformation.Status property.
// Specifies the agent status. Specifies the status of the agent running on a physical source.
const (
	AgentInformation_Status_Kdegraded    = "kDegraded"
	AgentInformation_Status_Khealthy     = "kHealthy"
	AgentInformation_Status_Kunknown     = "kUnknown"
	AgentInformation_Status_Kunreachable = "kUnreachable"
)

// Constants associated with the AgentInformation.Upgradability property.
// Specifies the upgradability of the agent running on the physical server. Specifies the upgradability of the agent
// running on the physical server.
const (
	AgentInformation_Upgradability_Kcurrent                     = "kCurrent"
	AgentInformation_Upgradability_Knonupgradableagentisnewer   = "kNonUpgradableAgentIsNewer"
	AgentInformation_Upgradability_Knonupgradableagentisold     = "kNonUpgradableAgentIsOld"
	AgentInformation_Upgradability_Knonupgradableinvalidversion = "kNonUpgradableInvalidVersion"
	AgentInformation_Upgradability_Kunknown                     = "kUnknown"
	AgentInformation_Upgradability_Kupgradable                  = "kUpgradable"
)

// Constants associated with the AgentInformation.UpgradeStatus property.
// Specifies the status of the upgrade of the agent on a physical server. Specifies the status of the upgrade of the
// agent on a physical server.
const (
	AgentInformation_UpgradeStatus_Kaccepted  = "kAccepted"
	AgentInformation_UpgradeStatus_Kfinished  = "kFinished"
	AgentInformation_UpgradeStatus_Kidle      = "kIdle"
	AgentInformation_UpgradeStatus_Kscheduled = "kScheduled"
	AgentInformation_UpgradeStatus_Kstarted   = "kStarted"
)

// UnmarshalAgentInformation unmarshals an instance of AgentInformation from the specified map of raw messages.
func UnmarshalAgentInformation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentInformation)
	err = core.UnmarshalPrimitive(m, "cbmrVersion", &obj.CbmrVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "cbmrVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "fileCbtInfo", &obj.FileCbtInfo, UnmarshalCbtInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileCbtInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostType", &obj.HostType)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "oracleMultiNodeChannelSupported", &obj.OracleMultiNodeChannelSupported)
	if err != nil {
		err = core.SDKErrorf(err, "", "oracleMultiNodeChannelSupported-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "registrationInfo", &obj.RegistrationInfo, UnmarshalAgentRegistrationInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "registrationInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceSideDedupEnabled", &obj.SourceSideDedupEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceSideDedupEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "statusMessage", &obj.StatusMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "statusMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "upgradability", &obj.Upgradability)
	if err != nil {
		err = core.SDKErrorf(err, "", "upgradability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "upgradeStatus", &obj.UpgradeStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "upgradeStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "upgradeStatusMessage", &obj.UpgradeStatusMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "upgradeStatusMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		err = core.SDKErrorf(err, "", "version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "volCbtInfo", &obj.VolCbtInfo, UnmarshalCbtInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "volCbtInfo-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentPhysicalParams : Specifies the parameters required to register Application Servers running in a Protection Source specific to a
// physical adapter.
type AgentPhysicalParams struct {
	// Specifies the types of applications such as 'kSQL', 'kExchange', 'kAD' running on the Protection Source. Supported
	// environment types such as 'kView', 'kSQL', 'kVMware', etc.
	Applications []string `json:"applications,omitempty"`

	// Specifies password of the username to access the target source.
	Password *string `json:"password,omitempty"`

	// Specifies the source side throttling configuration.
	ThrottlingConfig *ThrottlingConfig `json:"throttlingConfig,omitempty"`

	// Specifies username to access the target source.
	Username *string `json:"username,omitempty"`
}

// Constants associated with the AgentPhysicalParams.Applications property.
const (
	AgentPhysicalParams_Applications_Koracle = "kOracle"
	AgentPhysicalParams_Applications_Ksql    = "kSQL"
)

// UnmarshalAgentPhysicalParams unmarshals an instance of AgentPhysicalParams from the specified map of raw messages.
func UnmarshalAgentPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentPhysicalParams)
	err = core.UnmarshalPrimitive(m, "applications", &obj.Applications)
	if err != nil {
		err = core.SDKErrorf(err, "", "applications-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		err = core.SDKErrorf(err, "", "password-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "throttlingConfig", &obj.ThrottlingConfig, UnmarshalThrottlingConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "throttlingConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		err = core.SDKErrorf(err, "", "username-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentRegistrationInfo : Specifies information about a registered Source.
type AgentRegistrationInfo struct {
	// Specifies the parameters required to establish a connection with a particular environment.
	AccessInfo *AgentAccessInfo `json:"accessInfo,omitempty"`

	// Specifies the list of IP Addresses on the registered source to be exclusively allowed for doing any type of IO
	// operations.
	AllowedIpAddresses []string `json:"allowedIpAddresses,omitempty"`

	// Specifies an authentication error message. This indicates the given credentials are rejected and the registration of
	// the source is not successful.
	AuthenticationErrorMessage *string `json:"authenticationErrorMessage,omitempty"`

	// Specifies the status of the authenticating to the Protection Source when registering it with Cohesity Cluster.
	AuthenticationStatus *string `json:"authenticationStatus,omitempty"`

	// This field is deprecated. Use DeniedIpAddresses instead.
	BlacklistedIpAddresses []string `json:"blacklistedIpAddresses,omitempty"`

	// Specifies the list of IP Addresses on the registered source to be denied for doing any type of IO operations.
	DeniedIpAddresses []string `json:"deniedIpAddresses,omitempty"`

	// Specifies a list of applications environment that are registered with this Protection Source such as 'kSQL'.
	// Supported environment types such as 'kView', 'kSQL', 'kVMware', etc.
	Environments []string `json:"environments,omitempty"`

	// Specifies if application entity dbAuthenticated or not.
	IsDbAuthenticated *bool `json:"isDbAuthenticated,omitempty"`

	// Specifies if this source entity has enabled storage array snapshot or not.
	IsStorageArraySnapshotEnabled *bool `json:"isStorageArraySnapshotEnabled,omitempty"`

	// Specifies if the VM linking feature is enabled for this VCenter This means that VMs present in this VCenter which
	// earlier belonged to some other VCenter(also registerd on same cluster) and were migrated, will be linked during EH
	// refresh. This will enable preserving snapshot chains for migrated VMs.
	LinkVmsAcrossVcenter *bool `json:"linkVmsAcrossVcenter,omitempty"`

	// Specifies the minimum free space in GiB of the space expected to be available on the datastore where the virtual
	// disks of the VM being backed up. If the amount of free space(in GiB) is lower than the value given by this field,
	// backup will be aborted. Note that this field is applicable only to 'kVMware' type of environments.
	MinimumFreeSpaceGB *int64 `json:"minimumFreeSpaceGB,omitempty"`

	// Specifies the minimum free space in percentage of the space expected to be available on the datastore where the
	// virtual disks of the VM being backed up. If the amount of free space(in percentage) is lower than the value given by
	// this field, backup will be aborted. Note that this field is applicable only to 'kVMware' type of environments.
	MinimumFreeSpacePercent *int64 `json:"minimumFreeSpacePercent,omitempty"`

	// Specifies password of the username to access the target source.
	Password *string `json:"password,omitempty"`

	// Specifies the parameters required to register Application Servers running in a Protection Source specific to a
	// physical adapter.
	PhysicalParams *AgentPhysicalParams `json:"physicalParams,omitempty"`

	// Captures the current progress and pulse details w.r.t to either the registration or refresh.
	ProgressMonitorPath *string `json:"progressMonitorPath,omitempty"`

	// Specifies a message if there was any error encountered during the last rebuild of the Protection Source tree. If
	// there was no error during the last rebuild, this field is reset.
	RefreshErrorMessage *string `json:"refreshErrorMessage,omitempty"`

	// Specifies the Unix epoch time (in microseconds) when the Protection Source tree was most recently fetched and built.
	RefreshTimeUsecs *int64 `json:"refreshTimeUsecs,omitempty"`

	// Specifies information of the applications registered on this protection source.
	RegisteredAppsInfo []RegisteredAppInfo `json:"registeredAppsInfo,omitempty"`

	// Specifies the Unix epoch time (in microseconds) when the Protection Source was registered.
	RegistrationTimeUsecs *int64 `json:"registrationTimeUsecs,omitempty"`

	// Specifies the list of subnets added during creation or updation of vmare source. Currently, this field will only be
	// populated in case of VMware registration.
	Subnets []Subnet `json:"subnets,omitempty"`

	// Specifies the throttling policy for a registered Protection Source.
	ThrottlingPolicy *ThrottlingPolicy `json:"throttlingPolicy,omitempty"`

	ThrottlingPolicyOverrides []ThrottlingPolicyOverrides `json:"throttlingPolicyOverrides,omitempty"`

	// Specifies whether OAuth should be used for authentication in case of Exchange Online.
	UseOAuthForExchangeOnline *bool `json:"useOAuthForExchangeOnline,omitempty"`

	// Specifies if registered vCenter is using BIOS UUID to track virtual machines.
	UseVmBiosUUID *bool `json:"useVmBiosUuid,omitempty"`

	// Specifies the additional details encountered during registration. Though the registration may succeed, user messages
	// imply the host environment requires some cleanup or fixing.
	UserMessages []string `json:"userMessages,omitempty"`

	// Specifies username to access the target source.
	Username *string `json:"username,omitempty"`

	// Specifies the VLAN configuration for Recovery.
	VlanParams *RegisteredSourceVlanConfig `json:"vlanParams,omitempty"`

	// Specifies a list of warnings encountered during registration. Though the registration may succeed, warning messages
	// imply the host environment requires some cleanup or fixing.
	WarningMessages []string `json:"warningMessages,omitempty"`
}

// Constants associated with the AgentRegistrationInfo.AuthenticationStatus property.
// Specifies the status of the authenticating to the Protection Source when registering it with Cohesity Cluster.
const (
	AgentRegistrationInfo_AuthenticationStatus_Kfinished          = "kFinished"
	AgentRegistrationInfo_AuthenticationStatus_Kpending           = "kPending"
	AgentRegistrationInfo_AuthenticationStatus_Krefreshinprogress = "kRefreshInProgress"
	AgentRegistrationInfo_AuthenticationStatus_Kscheduled         = "kScheduled"
)

// Constants associated with the AgentRegistrationInfo.Environments property.
const (
	AgentRegistrationInfo_Environments_Kagent         = "kAgent"
	AgentRegistrationInfo_Environments_Kphysical      = "kPhysical"
	AgentRegistrationInfo_Environments_Kphysicalfiles = "kPhysicalFiles"
	AgentRegistrationInfo_Environments_Ksql           = "kSQL"
)

// UnmarshalAgentRegistrationInfo unmarshals an instance of AgentRegistrationInfo from the specified map of raw messages.
func UnmarshalAgentRegistrationInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentRegistrationInfo)
	err = core.UnmarshalModel(m, "accessInfo", &obj.AccessInfo, UnmarshalAgentAccessInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "accessInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "allowedIpAddresses", &obj.AllowedIpAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "allowedIpAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "authenticationErrorMessage", &obj.AuthenticationErrorMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "authenticationErrorMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "authenticationStatus", &obj.AuthenticationStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "authenticationStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "blacklistedIpAddresses", &obj.BlacklistedIpAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "blacklistedIpAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "deniedIpAddresses", &obj.DeniedIpAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "deniedIpAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environments", &obj.Environments)
	if err != nil {
		err = core.SDKErrorf(err, "", "environments-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isDbAuthenticated", &obj.IsDbAuthenticated)
	if err != nil {
		err = core.SDKErrorf(err, "", "isDbAuthenticated-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isStorageArraySnapshotEnabled", &obj.IsStorageArraySnapshotEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isStorageArraySnapshotEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "linkVmsAcrossVcenter", &obj.LinkVmsAcrossVcenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "linkVmsAcrossVcenter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "minimumFreeSpaceGB", &obj.MinimumFreeSpaceGB)
	if err != nil {
		err = core.SDKErrorf(err, "", "minimumFreeSpaceGB-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "minimumFreeSpacePercent", &obj.MinimumFreeSpacePercent)
	if err != nil {
		err = core.SDKErrorf(err, "", "minimumFreeSpacePercent-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		err = core.SDKErrorf(err, "", "password-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalAgentPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressMonitorPath", &obj.ProgressMonitorPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressMonitorPath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "refreshErrorMessage", &obj.RefreshErrorMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "refreshErrorMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "refreshTimeUsecs", &obj.RefreshTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "refreshTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "registeredAppsInfo", &obj.RegisteredAppsInfo, UnmarshalRegisteredAppInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "registeredAppsInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "registrationTimeUsecs", &obj.RegistrationTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "registrationTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnet)
	if err != nil {
		err = core.SDKErrorf(err, "", "subnets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "throttlingPolicy", &obj.ThrottlingPolicy, UnmarshalThrottlingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "throttlingPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "throttlingPolicyOverrides", &obj.ThrottlingPolicyOverrides, UnmarshalThrottlingPolicyOverrides)
	if err != nil {
		err = core.SDKErrorf(err, "", "throttlingPolicyOverrides-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "useOAuthForExchangeOnline", &obj.UseOAuthForExchangeOnline)
	if err != nil {
		err = core.SDKErrorf(err, "", "useOAuthForExchangeOnline-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "useVmBiosUuid", &obj.UseVmBiosUUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "useVmBiosUuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userMessages", &obj.UserMessages)
	if err != nil {
		err = core.SDKErrorf(err, "", "userMessages-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		err = core.SDKErrorf(err, "", "username-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vlanParams", &obj.VlanParams, UnmarshalRegisteredSourceVlanConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlanParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "warningMessages", &obj.WarningMessages)
	if err != nil {
		err = core.SDKErrorf(err, "", "warningMessages-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentUpgradeInfoObject : Specifies the agent upgrade state.
type AgentUpgradeInfoObject struct {
	// Specifies the ID of the agent.
	ID *int64 `json:"id,omitempty"`

	// Specifies the upgrade state of the agent.
	Info *AgentInfoObject `json:"info,omitempty"`
}

// UnmarshalAgentUpgradeInfoObject unmarshals an instance of AgentUpgradeInfoObject from the specified map of raw messages.
func UnmarshalAgentUpgradeInfoObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentUpgradeInfoObject)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "info", &obj.Info, UnmarshalAgentInfoObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "info-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentUpgradeTaskState : Specifies the state of an agent upgrade task.
type AgentUpgradeTaskState struct {
	// Specifies the agents upgraded in the task.
	AgentIDs []int64 `json:"agentIDs,omitempty"`

	// Specifies the upgrade information for each agent.
	Agents []AgentUpgradeInfoObject `json:"agents,omitempty"`

	// Specifies the version to which agents are upgraded.
	ClusterVersion *string `json:"clusterVersion,omitempty"`

	// Specifies the description of the task.
	Description *string `json:"description,omitempty"`

	// Specifies the time when the upgrade task completed execution as a Unix epoch Timestamp (in microseconds).
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Object that holds the error object.
	Error *Error `json:"error,omitempty"`

	// Specifies the ID of the task.
	ID *int64 `json:"id,omitempty"`

	// Specifies if a task can be retried.
	IsRetryable *bool `json:"isRetryable,omitempty"`

	// Specifies the name of the task.
	Name *string `json:"name,omitempty"`

	// Specifies ID of a task which was retried if type is 'Retry'.
	RetriedTaskID *int64 `json:"retriedTaskID,omitempty"`

	// Specifies the time before which the upgrade task should start execution as a Unix epoch Timestamp (in microseconds).
	// If this is not specified the task will start anytime after scheduleTimeUsecs.
	ScheduleEndTimeUsecs *int64 `json:"scheduleEndTimeUsecs,omitempty"`

	// Specifies the time when the task should start execution as a Unix epoch Timestamp (in microseconds). If no schedule
	// is specified, the task will start immediately.
	ScheduleTimeUsecs *int64 `json:"scheduleTimeUsecs,omitempty"`

	// Specifies the time, as a Unix epoch timestamp in microseconds, when the task started execution.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the status of the task.<br> 'Scheduled' indicates that the upgrade task is yet to start.<br> 'Running'
	// indicates that the upgrade task has started execution.<br> 'Succeeded' indicates that the upgrade task completed
	// without an error.<br> 'Failed' indicates that upgrade has failed for all agents. 'PartiallyFailed' indicates that
	// upgrade has failed for some agents.
	Status *string `json:"status,omitempty"`

	// Specifes the type of task.<br> 'Auto' indicates an auto agent upgrade task which is started after a cluster
	// upgrade.<br> 'Manual' indicates a schedule based agent upgrade task.<br> 'Retry' indicates an agent upgrade task
	// which was retried.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the AgentUpgradeTaskState.Status property.
// Specifies the status of the task.<br> 'Scheduled' indicates that the upgrade task is yet to start.<br> 'Running'
// indicates that the upgrade task has started execution.<br> 'Succeeded' indicates that the upgrade task completed
// without an error.<br> 'Failed' indicates that upgrade has failed for all agents. 'PartiallyFailed' indicates that
// upgrade has failed for some agents.
const (
	AgentUpgradeTaskState_Status_Canceled        = "Canceled"
	AgentUpgradeTaskState_Status_Failed          = "Failed"
	AgentUpgradeTaskState_Status_Partiallyfailed = "PartiallyFailed"
	AgentUpgradeTaskState_Status_Running         = "Running"
	AgentUpgradeTaskState_Status_Scheduled       = "Scheduled"
	AgentUpgradeTaskState_Status_Succeeded       = "Succeeded"
)

// Constants associated with the AgentUpgradeTaskState.Type property.
// Specifes the type of task.<br> 'Auto' indicates an auto agent upgrade task which is started after a cluster
// upgrade.<br> 'Manual' indicates a schedule based agent upgrade task.<br> 'Retry' indicates an agent upgrade task
// which was retried.
const (
	AgentUpgradeTaskState_Type_Auto   = "Auto"
	AgentUpgradeTaskState_Type_Manual = "Manual"
	AgentUpgradeTaskState_Type_Retry  = "Retry"
)

// UnmarshalAgentUpgradeTaskState unmarshals an instance of AgentUpgradeTaskState from the specified map of raw messages.
func UnmarshalAgentUpgradeTaskState(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentUpgradeTaskState)
	err = core.UnmarshalPrimitive(m, "agentIDs", &obj.AgentIDs)
	if err != nil {
		err = core.SDKErrorf(err, "", "agentIDs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "agents", &obj.Agents, UnmarshalAgentUpgradeInfoObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "agents-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterVersion", &obj.ClusterVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		err = core.SDKErrorf(err, "", "description-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "error", &obj.Error, UnmarshalError)
	if err != nil {
		err = core.SDKErrorf(err, "", "error-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isRetryable", &obj.IsRetryable)
	if err != nil {
		err = core.SDKErrorf(err, "", "isRetryable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "retriedTaskID", &obj.RetriedTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "retriedTaskID-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "scheduleEndTimeUsecs", &obj.ScheduleEndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "scheduleEndTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "scheduleTimeUsecs", &obj.ScheduleTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "scheduleTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AgentUpgradeTaskStates : List of agent upgrade tasks.
type AgentUpgradeTaskStates struct {
	// Specifies the list of agent upgrade tasks.
	Tasks []AgentUpgradeTaskState `json:"tasks,omitempty"`
}

// UnmarshalAgentUpgradeTaskStates unmarshals an instance of AgentUpgradeTaskStates from the specified map of raw messages.
func UnmarshalAgentUpgradeTaskStates(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AgentUpgradeTaskStates)
	err = core.UnmarshalModel(m, "tasks", &obj.Tasks, UnmarshalAgentUpgradeTaskState)
	if err != nil {
		err = core.SDKErrorf(err, "", "tasks-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AlertTarget : Specifies an alert target to receive an alert.
type AlertTarget struct {
	// Specifies an email address to receive an alert.
	EmailAddress *string `json:"emailAddress" validate:"required"`

	// Specifies the language of the delivery target. Default value is 'en-us'.
	Language *string `json:"language,omitempty"`

	// Specifies the recipient type of email recipient. Default value is 'kTo'.
	RecipientType *string `json:"recipientType,omitempty"`
}

// Constants associated with the AlertTarget.Language property.
// Specifies the language of the delivery target. Default value is 'en-us'.
const (
	AlertTarget_Language_EnUs = "en-us"
	AlertTarget_Language_JaJp = "ja-jp"
	AlertTarget_Language_ZhCn = "zh-cn"
)

// Constants associated with the AlertTarget.RecipientType property.
// Specifies the recipient type of email recipient. Default value is 'kTo'.
const (
	AlertTarget_RecipientType_Kcc = "kCc"
	AlertTarget_RecipientType_Kto = "kTo"
)

// NewAlertTarget : Instantiate AlertTarget (Generic Model Constructor)
func (*BackupRecoveryV1) NewAlertTarget(emailAddress string) (_model *AlertTarget, err error) {
	_model = &AlertTarget{
		EmailAddress: core.StringPtr(emailAddress),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAlertTarget unmarshals an instance of AlertTarget from the specified map of raw messages.
func UnmarshalAlertTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AlertTarget)
	err = core.UnmarshalPrimitive(m, "emailAddress", &obj.EmailAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "language", &obj.Language)
	if err != nil {
		err = core.SDKErrorf(err, "", "language-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recipientType", &obj.RecipientType)
	if err != nil {
		err = core.SDKErrorf(err, "", "recipientType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalDataStats : Specifies statistics about archival data.
type ArchivalDataStats struct {
	// Specifies the logicalSizeBytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies total logical bytes read for creating the snapshot.
	BytesRead *int64 `json:"bytesRead,omitempty"`

	// Specifies the logical bytes transferred.
	LogicalBytesTransferred *int64 `json:"logicalBytesTransferred,omitempty"`

	// Specifies the physical bytes transferred.
	PhysicalBytesTransferred *int64 `json:"physicalBytesTransferred,omitempty"`

	// Specifies the average rate of transfer in bytes per second.
	AvgLogicalTransferRateBps *int64 `json:"avgLogicalTransferRateBps,omitempty"`

	// Specifies whether the file system walk is done. Only applicable to file based backups.
	FileWalkDone *bool `json:"fileWalkDone,omitempty"`

	// Specifies the total number of file and directory entities visited in this backup. Only applicable to file based
	// backups.
	TotalFileCount *int64 `json:"totalFileCount,omitempty"`

	// Specifies the total number of file and directory entities that are backed up in this run. Only applicable to file
	// based backups.
	BackupFileCount *int64 `json:"backupFileCount,omitempty"`
}

// UnmarshalArchivalDataStats unmarshals an instance of ArchivalDataStats from the specified map of raw messages.
func UnmarshalArchivalDataStats(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalDataStats)
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bytesRead", &obj.BytesRead)
	if err != nil {
		err = core.SDKErrorf(err, "", "bytesRead-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalBytesTransferred", &obj.LogicalBytesTransferred)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalBytesTransferred-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "physicalBytesTransferred", &obj.PhysicalBytesTransferred)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalBytesTransferred-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "avgLogicalTransferRateBps", &obj.AvgLogicalTransferRateBps)
	if err != nil {
		err = core.SDKErrorf(err, "", "avgLogicalTransferRateBps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fileWalkDone", &obj.FileWalkDone)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileWalkDone-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "totalFileCount", &obj.TotalFileCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "totalFileCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupFileCount", &obj.BackupFileCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupFileCount-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalRun : Specifies information about archival run for an object.
type ArchivalRun struct {
	// Archival result for an archival target.
	ArchivalTargetResults []ArchivalTargetResult `json:"archivalTargetResults,omitempty"`
}

// UnmarshalArchivalRun unmarshals an instance of ArchivalRun from the specified map of raw messages.
func UnmarshalArchivalRun(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalRun)
	err = core.UnmarshalModel(m, "archivalTargetResults", &obj.ArchivalTargetResults, UnmarshalArchivalTargetResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalRunSummary : Specifies summary information about archival run.
type ArchivalRunSummary struct {
	// Archival results for each archival target.
	ArchivalTargetResults []ArchivalTargetResult `json:"archivalTargetResults,omitempty"`
}

// UnmarshalArchivalRunSummary unmarshals an instance of ArchivalRunSummary from the specified map of raw messages.
func UnmarshalArchivalRunSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalRunSummary)
	err = core.UnmarshalModel(m, "archivalTargetResults", &obj.ArchivalTargetResults, UnmarshalArchivalTargetResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalTargetConfiguration : Specifies settings for copying Snapshots External Targets (such as AWS or Tape). This also specifies the retention
// policy that should be applied to Snapshots after they have been copied to the specified target.
type ArchivalTargetConfiguration struct {
	// Specifies a schedule fregquency and schedule unit for copying Snapshots to backup targets.
	Schedule *TargetSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`

	// Specifies if Snapshots are copied from the first completely successful Protection Group Run or the first partially
	// successful Protection Group Run occurring at the start of the replication schedule. <br> If true, Snapshots are
	// copied from the first Protection Group Run occurring at the start of the replication schedule that was completely
	// successful i.e. Snapshots for all the Objects in the Protection Group were successfully captured. <br> If false,
	// Snapshots are copied from the first Protection Group Run occurring at the start of the replication schedule, even if
	// first Protection Group Run was not completely successful i.e. Snapshots were not captured for all Objects in the
	// Protection Group.
	CopyOnRunSuccess *bool `json:"copyOnRunSuccess,omitempty"`

	// Specifies the unique identifier for the target getting added. This field need to be passed only when policies are
	// being updated.
	ConfigID *string `json:"configId,omitempty"`

	// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
	// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
	// be set to Full.
	BackupRunType *string `json:"backupRunType,omitempty"`

	// Specifies the replication/archival timeouts for different type of runs(kFull, kRegular etc.).
	RunTimeouts []CancellationTimeoutParams `json:"runTimeouts,omitempty"`

	// Specifies the retention of a backup.
	LogRetention *LogRetention `json:"logRetention,omitempty"`

	// Specifies the Archival target to copy the Snapshots to.
	TargetID *int64 `json:"targetId" validate:"required"`

	// Specifies the Archival target name where Snapshots are copied.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the Archival target type where Snapshots are copied.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the settings tier levels configured with each archival target. The tier settings need to be applied in
	// specific order and default tier should always be passed as first entry in tiers array. The following example
	// illustrates how to configure tiering input for AWS tiering. Same type of input structure applied to other cloud
	// platforms also. <br>If user wants to achieve following tiering for backup, <br>User Desired Tiering-
	// <br><t>1.Archive Full back up for 12 Months <br><t>2.Tier Levels <br><t><t>[1,12] [ <br><t><t><t>s3 (1 to 2 months),
	// (default tier) <br><t><t><t>s3 Intelligent tiering (3 to 6 months), <br><t><t><t>s3 One Zone (7 to 9 months)
	// <br><t><t><t>Glacier (10 to 12 months)] <br><t>API Input <br><t><t>1.tiers-[ <br><t><t><t>{'tierType':
	// 'S3','moveAfterUnit':'months', <br><t><t><t>'moveAfter':2 - move from s3 to s3Inte after 2 months},
	// <br><t><t><t>{'tierType': 'S3Inte','moveAfterUnit':'months', <br><t><t><t>'moveAfter':4 - move from S3Inte to
	// Glacier after 4 months}, <br><t><t><t>{'tierType': 'Glacier', 'moveAfterUnit':'months', <br><t><t><t>'moveAfter': 3
	// - move from Glacier to S3 One Zone after 3 months }, <br><t><t><t>{'tierType': 'S3 One Zone', 'moveAfterUnit': nil,
	// <br><t><t><t>'moveAfter': nil - For the last record, 'moveAfter' and 'moveAfterUnit' <br><t><t><t>will be ignored
	// since there are no further tier for data movement } <br><t><t><t>}].
	TierSettings *TierLevelSettings `json:"tierSettings,omitempty"`

	// Specifies additional retention policies that should be applied to the archived backup. Archived backup snapshot will
	// be retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []ExtendedRetentionPolicy `json:"extendedRetention,omitempty"`
}

// Constants associated with the ArchivalTargetConfiguration.BackupRunType property.
// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
// be set to Full.
const (
	ArchivalTargetConfiguration_BackupRunType_Full                 = "Full"
	ArchivalTargetConfiguration_BackupRunType_Log                  = "Log"
	ArchivalTargetConfiguration_BackupRunType_Regular              = "Regular"
	ArchivalTargetConfiguration_BackupRunType_Storagearraysnapshot = "StorageArraySnapshot"
	ArchivalTargetConfiguration_BackupRunType_System               = "System"
)

// Constants associated with the ArchivalTargetConfiguration.TargetType property.
// Specifies the Archival target type where Snapshots are copied.
const (
	ArchivalTargetConfiguration_TargetType_Cloud = "Cloud"
	ArchivalTargetConfiguration_TargetType_Nas   = "Nas"
	ArchivalTargetConfiguration_TargetType_Tape  = "Tape"
)

// NewArchivalTargetConfiguration : Instantiate ArchivalTargetConfiguration (Generic Model Constructor)
func (*BackupRecoveryV1) NewArchivalTargetConfiguration(schedule *TargetSchedule, retention *Retention, targetID int64) (_model *ArchivalTargetConfiguration, err error) {
	_model = &ArchivalTargetConfiguration{
		Schedule:  schedule,
		Retention: retention,
		TargetID:  core.Int64Ptr(targetID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalArchivalTargetConfiguration unmarshals an instance of ArchivalTargetConfiguration from the specified map of raw messages.
func UnmarshalArchivalTargetConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalTargetConfiguration)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalTargetSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "copyOnRunSuccess", &obj.CopyOnRunSuccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "copyOnRunSuccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupRunType", &obj.BackupRunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "runTimeouts", &obj.RunTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "runTimeouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "logRetention", &obj.LogRetention, UnmarshalLogRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "logRetention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tierSettings", &obj.TierSettings, UnmarshalTierLevelSettings)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "extendedRetention", &obj.ExtendedRetention, UnmarshalExtendedRetentionPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "extendedRetention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalTargetResult : Archival result for an archival target.
type ArchivalTargetResult struct {
	// Specifies the archival target ID.
	TargetID *int64 `json:"targetId,omitempty"`

	// Specifies the archival task id. This is a protection group UID which only applies when archival type is 'Tape'.
	ArchivalTaskID *string `json:"archivalTaskId,omitempty"`

	// Specifies the archival target name.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the archival target type.
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the usage type for the target.
	UsageType *string `json:"usageType,omitempty"`

	// Specifies the ownership context for the target.
	OwnershipContext *string `json:"ownershipContext,omitempty"`

	// Specifies the tier info for archival.
	TierSettings *ArchivalTargetTierInfo `json:"tierSettings,omitempty"`

	// Type of Protection Group run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT
	// (if supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the
	// blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects
	// are always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture
	// the database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume
	// backup. It produces an image for bare metal recovery.
	RunType *string `json:"runType,omitempty"`

	// Indicated if SLA has been violated for this run.
	IsSlaViolated *bool `json:"isSlaViolated,omitempty"`

	// Snapshot id for a successful snapshot. This field will not be set if the archival Run fails to take the snapshot.
	SnapshotID *string `json:"snapshotId,omitempty"`

	// Specifies the start time of replication run in Unix epoch Timestamp(in microseconds) for an archival target.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of replication run in Unix epoch Timestamp(in microseconds) for an archival target.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the time when the archival is queued for schedule in Unix epoch Timestamp(in microseconds) for a target.
	QueuedTimeUsecs *int64 `json:"queuedTimeUsecs,omitempty"`

	// Whether this is an incremental archive. If set to true, this is an incremental archive, otherwise this is a full
	// archive.
	IsIncremental *bool `json:"isIncremental,omitempty"`

	// Whether this is forever incremental or not.
	IsForeverIncremental *bool `json:"isForeverIncremental,omitempty"`

	// Whether this is CAD archive or not.
	IsCadArchive *bool `json:"isCadArchive,omitempty"`

	// Status of the replication run for an archival target. 'Running' indicates that the run is still running. 'Canceled'
	// indicates that the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled.
	// 'Paused' indicates that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed'
	// indicates that the run was unable to take place at the scheduled time because the previous run was still happening.
	// 'Succeeded' indicates that the run has finished successfully. 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages. 'Skipped' indicates that the run was skipped.
	Status *string `json:"status,omitempty"`

	// Message about the archival run.
	Message *string `json:"message,omitempty"`

	// Progress monitor task id for archival.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Run Stats task id for archival.
	StatsTaskID *string `json:"statsTaskId,omitempty"`

	// Progress monitor task for indexing.
	IndexingTaskID *string `json:"indexingTaskId,omitempty"`

	// Specifies the count of objects for which backup was successful.
	SuccessfulObjectsCount *int64 `json:"successfulObjectsCount,omitempty"`

	// Specifies the count of objects for which backup failed.
	FailedObjectsCount *int64 `json:"failedObjectsCount,omitempty"`

	// Specifies the count of objects for which backup was cancelled.
	CancelledObjectsCount *int64 `json:"cancelledObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup was successful.
	SuccessfulAppObjectsCount *int64 `json:"successfulAppObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup failed.
	FailedAppObjectsCount *int64 `json:"failedAppObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup was cancelled.
	CancelledAppObjectsCount *int64 `json:"cancelledAppObjectsCount,omitempty"`

	// Specifies statistics about archival data.
	Stats *ArchivalDataStats `json:"stats,omitempty"`

	// Specifies whether the snapshot is deleted manually.
	IsManuallyDeleted *bool `json:"isManuallyDeleted,omitempty"`

	// Specifies the expiry time of attempt in Unix epoch Timestamp (in microseconds).
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// Specifies the dataLock constraints for local or target snapshot.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`

	// Specifies the legal hold status for a archival target.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`

	// Specifies the WORM related properties for this archive.
	WormProperties *WormProperties `json:"wormProperties,omitempty"`
}

// Constants associated with the ArchivalTargetResult.TargetType property.
// Specifies the archival target type.
const (
	ArchivalTargetResult_TargetType_Cloud = "Cloud"
	ArchivalTargetResult_TargetType_Nas   = "Nas"
	ArchivalTargetResult_TargetType_Tape  = "Tape"
)

// Constants associated with the ArchivalTargetResult.UsageType property.
// Specifies the usage type for the target.
const (
	ArchivalTargetResult_UsageType_Archival = "Archival"
	ArchivalTargetResult_UsageType_Rpaas    = "Rpaas"
	ArchivalTargetResult_UsageType_Tiering  = "Tiering"
)

// Constants associated with the ArchivalTargetResult.OwnershipContext property.
// Specifies the ownership context for the target.
const (
	ArchivalTargetResult_OwnershipContext_Fortknox = "FortKnox"
	ArchivalTargetResult_OwnershipContext_Local    = "Local"
)

// Constants associated with the ArchivalTargetResult.RunType property.
// Type of Protection Group run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT (if
// supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the
// blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are
// always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture the
// database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume
// backup. It produces an image for bare metal recovery.
const (
	ArchivalTargetResult_RunType_Kfull                 = "kFull"
	ArchivalTargetResult_RunType_Khydratecdp           = "kHydrateCDP"
	ArchivalTargetResult_RunType_Klog                  = "kLog"
	ArchivalTargetResult_RunType_Kregular              = "kRegular"
	ArchivalTargetResult_RunType_Kstoragearraysnapshot = "kStorageArraySnapshot"
	ArchivalTargetResult_RunType_Ksystem               = "kSystem"
)

// Constants associated with the ArchivalTargetResult.Status property.
// Status of the replication run for an archival target. 'Running' indicates that the run is still running. 'Canceled'
// indicates that the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled.
// 'Paused' indicates that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed'
// indicates that the run was unable to take place at the scheduled time because the previous run was still happening.
// 'Succeeded' indicates that the run has finished successfully. 'SucceededWithWarning' indicates that the run finished
// successfully, but there were some warning messages. 'Skipped' indicates that the run was skipped.
const (
	ArchivalTargetResult_Status_Accepted             = "Accepted"
	ArchivalTargetResult_Status_Canceled             = "Canceled"
	ArchivalTargetResult_Status_Canceling            = "Canceling"
	ArchivalTargetResult_Status_Failed               = "Failed"
	ArchivalTargetResult_Status_Finalizing           = "Finalizing"
	ArchivalTargetResult_Status_Missed               = "Missed"
	ArchivalTargetResult_Status_Onhold               = "OnHold"
	ArchivalTargetResult_Status_Paused               = "Paused"
	ArchivalTargetResult_Status_Running              = "Running"
	ArchivalTargetResult_Status_Skipped              = "Skipped"
	ArchivalTargetResult_Status_Succeeded            = "Succeeded"
	ArchivalTargetResult_Status_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalArchivalTargetResult unmarshals an instance of ArchivalTargetResult from the specified map of raw messages.
func UnmarshalArchivalTargetResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalTargetResult)
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTaskId", &obj.ArchivalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "usageType", &obj.UsageType)
	if err != nil {
		err = core.SDKErrorf(err, "", "usageType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownershipContext", &obj.OwnershipContext)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownershipContext-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tierSettings", &obj.TierSettings, UnmarshalArchivalTargetTierInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runType", &obj.RunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "runType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isSlaViolated", &obj.IsSlaViolated)
	if err != nil {
		err = core.SDKErrorf(err, "", "isSlaViolated-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "queuedTimeUsecs", &obj.QueuedTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "queuedTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isIncremental", &obj.IsIncremental)
	if err != nil {
		err = core.SDKErrorf(err, "", "isIncremental-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isForeverIncremental", &obj.IsForeverIncremental)
	if err != nil {
		err = core.SDKErrorf(err, "", "isForeverIncremental-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isCadArchive", &obj.IsCadArchive)
	if err != nil {
		err = core.SDKErrorf(err, "", "isCadArchive-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "statsTaskId", &obj.StatsTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "statsTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "indexingTaskId", &obj.IndexingTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "successfulObjectsCount", &obj.SuccessfulObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "successfulObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "failedObjectsCount", &obj.FailedObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "failedObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cancelledObjectsCount", &obj.CancelledObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cancelledObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "successfulAppObjectsCount", &obj.SuccessfulAppObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "successfulAppObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "failedAppObjectsCount", &obj.FailedAppObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "failedAppObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cancelledAppObjectsCount", &obj.CancelledAppObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cancelledAppObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "stats", &obj.Stats, UnmarshalArchivalDataStats)
	if err != nil {
		err = core.SDKErrorf(err, "", "stats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isManuallyDeleted", &obj.IsManuallyDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isManuallyDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConstraints", &obj.DataLockConstraints, UnmarshalDataLockConstraints)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConstraints-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "onLegalHold", &obj.OnLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "onLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "wormProperties", &obj.WormProperties, UnmarshalWormProperties)
	if err != nil {
		err = core.SDKErrorf(err, "", "wormProperties-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalTargetSummaryInfo : Specifies archival target summary information.
type ArchivalTargetSummaryInfo struct {
	// Specifies the archival target ID.
	TargetID *int64 `json:"targetId,omitempty"`

	// Specifies the archival task id. This is a protection group UID which only applies when archival type is 'Tape'.
	ArchivalTaskID *string `json:"archivalTaskId,omitempty"`

	// Specifies the archival target name.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the archival target type.
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the usage type for the target.
	UsageType *string `json:"usageType,omitempty"`

	// Specifies the ownership context for the target.
	OwnershipContext *string `json:"ownershipContext,omitempty"`

	// Specifies the tier info for archival.
	TierSettings *ArchivalTargetTierInfo `json:"tierSettings,omitempty"`
}

// Constants associated with the ArchivalTargetSummaryInfo.TargetType property.
// Specifies the archival target type.
const (
	ArchivalTargetSummaryInfo_TargetType_Cloud = "Cloud"
	ArchivalTargetSummaryInfo_TargetType_Nas   = "Nas"
	ArchivalTargetSummaryInfo_TargetType_Tape  = "Tape"
)

// Constants associated with the ArchivalTargetSummaryInfo.UsageType property.
// Specifies the usage type for the target.
const (
	ArchivalTargetSummaryInfo_UsageType_Archival = "Archival"
	ArchivalTargetSummaryInfo_UsageType_Rpaas    = "Rpaas"
	ArchivalTargetSummaryInfo_UsageType_Tiering  = "Tiering"
)

// Constants associated with the ArchivalTargetSummaryInfo.OwnershipContext property.
// Specifies the ownership context for the target.
const (
	ArchivalTargetSummaryInfo_OwnershipContext_Fortknox = "FortKnox"
	ArchivalTargetSummaryInfo_OwnershipContext_Local    = "Local"
)

// UnmarshalArchivalTargetSummaryInfo unmarshals an instance of ArchivalTargetSummaryInfo from the specified map of raw messages.
func UnmarshalArchivalTargetSummaryInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalTargetSummaryInfo)
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTaskId", &obj.ArchivalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "usageType", &obj.UsageType)
	if err != nil {
		err = core.SDKErrorf(err, "", "usageType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownershipContext", &obj.OwnershipContext)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownershipContext-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tierSettings", &obj.TierSettings, UnmarshalArchivalTargetTierInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierSettings-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ArchivalTargetTierInfo : Specifies the tier info for archival.
type ArchivalTargetTierInfo struct {
	// Specifies aws tiers.
	AwsTiering *AWSTiers `json:"awsTiering,omitempty"`

	// Specifies Azure tiers.
	AzureTiering *AzureTiers `json:"azureTiering,omitempty"`

	// Specifies the cloud platform to enable tiering.
	CloudPlatform *string `json:"cloudPlatform,omitempty"`

	// Specifies Google tiers.
	GoogleTiering *GoogleTiers `json:"googleTiering,omitempty"`

	// Specifies Oracle tiers.
	OracleTiering *OracleTiers `json:"oracleTiering,omitempty"`

	// Specifies the type of the current tier where the snapshot resides. This will be specified if the run is a CAD run.
	CurrentTierType *string `json:"currentTierType,omitempty"`
}

// Constants associated with the ArchivalTargetTierInfo.CloudPlatform property.
// Specifies the cloud platform to enable tiering.
const (
	ArchivalTargetTierInfo_CloudPlatform_Aws    = "AWS"
	ArchivalTargetTierInfo_CloudPlatform_Azure  = "Azure"
	ArchivalTargetTierInfo_CloudPlatform_Google = "Google"
	ArchivalTargetTierInfo_CloudPlatform_Oracle = "Oracle"
)

// Constants associated with the ArchivalTargetTierInfo.CurrentTierType property.
// Specifies the type of the current tier where the snapshot resides. This will be specified if the run is a CAD run.
const (
	ArchivalTargetTierInfo_CurrentTierType_Kamazons3glacier            = "kAmazonS3Glacier"
	ArchivalTargetTierInfo_CurrentTierType_Kamazons3glacierdeeparchive = "kAmazonS3GlacierDeepArchive"
	ArchivalTargetTierInfo_CurrentTierType_Kamazons3intelligenttiering = "kAmazonS3IntelligentTiering"
	ArchivalTargetTierInfo_CurrentTierType_Kamazons3onezoneia          = "kAmazonS3OneZoneIA"
	ArchivalTargetTierInfo_CurrentTierType_Kamazons3standard           = "kAmazonS3Standard"
	ArchivalTargetTierInfo_CurrentTierType_Kamazons3standardia         = "kAmazonS3StandardIA"
	ArchivalTargetTierInfo_CurrentTierType_Kazuretierarchive           = "kAzureTierArchive"
	ArchivalTargetTierInfo_CurrentTierType_Kazuretiercool              = "kAzureTierCool"
	ArchivalTargetTierInfo_CurrentTierType_Kazuretierhot               = "kAzureTierHot"
	ArchivalTargetTierInfo_CurrentTierType_Kgooglecoldline             = "kGoogleColdline"
	ArchivalTargetTierInfo_CurrentTierType_Kgooglemultiregional        = "kGoogleMultiRegional"
	ArchivalTargetTierInfo_CurrentTierType_Kgooglenearline             = "kGoogleNearline"
	ArchivalTargetTierInfo_CurrentTierType_Kgoogleregional             = "kGoogleRegional"
	ArchivalTargetTierInfo_CurrentTierType_Kgooglestandard             = "kGoogleStandard"
	ArchivalTargetTierInfo_CurrentTierType_Koracletierarchive          = "kOracleTierArchive"
	ArchivalTargetTierInfo_CurrentTierType_Koracletierstandard         = "kOracleTierStandard"
)

// UnmarshalArchivalTargetTierInfo unmarshals an instance of ArchivalTargetTierInfo from the specified map of raw messages.
func UnmarshalArchivalTargetTierInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ArchivalTargetTierInfo)
	err = core.UnmarshalModel(m, "awsTiering", &obj.AwsTiering, UnmarshalAWSTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureTiering", &obj.AzureTiering, UnmarshalAzureTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudPlatform", &obj.CloudPlatform)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudPlatform-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "googleTiering", &obj.GoogleTiering, UnmarshalGoogleTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "googleTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "oracleTiering", &obj.OracleTiering, UnmarshalOracleTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "oracleTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "currentTierType", &obj.CurrentTierType)
	if err != nil {
		err = core.SDKErrorf(err, "", "currentTierType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AwsCloudSpinParams : Specifies various resources when converting and deploying a VM to AWS.
type AwsCloudSpinParams struct {
	// Specifies tags of various resources when converting and deploying a VM to AWS.
	CustomTagList []CustomTagParams `json:"customTagList,omitempty"`

	// Specifies id of the AWS region in which to deploy the VM.
	Region *int64 `json:"region" validate:"required"`

	// Specifies id of the subnet within above VPC.
	SubnetID *int64 `json:"subnetId,omitempty"`

	// Specifies id of the Virtual Private Cloud to chose for the instance type.
	VpcID *int64 `json:"vpcId,omitempty"`
}

// NewAwsCloudSpinParams : Instantiate AwsCloudSpinParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewAwsCloudSpinParams(region int64) (_model *AwsCloudSpinParams, err error) {
	_model = &AwsCloudSpinParams{
		Region: core.Int64Ptr(region),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAwsCloudSpinParams unmarshals an instance of AwsCloudSpinParams from the specified map of raw messages.
func UnmarshalAwsCloudSpinParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AwsCloudSpinParams)
	err = core.UnmarshalModel(m, "customTagList", &obj.CustomTagList, UnmarshalCustomTagParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "customTagList-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		err = core.SDKErrorf(err, "", "region-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "subnetId", &obj.SubnetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "subnetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcId", &obj.VpcID)
	if err != nil {
		err = core.SDKErrorf(err, "", "vpcId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AwsSnapshotParams : Specifies parameters of AWS type snapshots.
type AwsSnapshotParams struct {
	// Specifies the protection type of AWS snapshots.
	ProtectionType *string `json:"protectionType,omitempty"`
}

// Constants associated with the AwsSnapshotParams.ProtectionType property.
// Specifies the protection type of AWS snapshots.
const (
	AwsSnapshotParams_ProtectionType_Kagent                 = "kAgent"
	AwsSnapshotParams_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	AwsSnapshotParams_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	AwsSnapshotParams_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	AwsSnapshotParams_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	AwsSnapshotParams_ProtectionType_Kawss3                 = "kAwsS3"
	AwsSnapshotParams_ProtectionType_Knative                = "kNative"
	AwsSnapshotParams_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	AwsSnapshotParams_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
)

// UnmarshalAwsSnapshotParams unmarshals an instance of AwsSnapshotParams from the specified map of raw messages.
func UnmarshalAwsSnapshotParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AwsSnapshotParams)
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AzureCloudSpinParams : Specifies various resources when converting and deploying a VM to Azure.
type AzureCloudSpinParams struct {
	// Specifies the availability set.
	AvailabilitySetID *int64 `json:"availabilitySetId,omitempty"`

	// Specifies id of the resource group for the selected virtual network.
	NetworkResourceGroupID *int64 `json:"networkResourceGroupId,omitempty"`

	// Specifies id of the Azure resource group. Its value is globally unique within Azure.
	ResourceGroupID *int64 `json:"resourceGroupId,omitempty"`

	// Specifies id of the storage account that will contain the storage container within which we will create the blob
	// that will become the VHD disk for the cloned VM.
	StorageAccountID *int64 `json:"storageAccountId,omitempty"`

	// Specifies id of the storage container within the above storage account.
	StorageContainerID *int64 `json:"storageContainerId,omitempty"`

	// Specifies id of the resource group for the selected storage account.
	StorageResourceGroupID *int64 `json:"storageResourceGroupId,omitempty"`

	// Specifies id of the temporary Azure resource group.
	TempVmResourceGroupID *int64 `json:"tempVmResourceGroupId,omitempty"`

	// Specifies id of the temporary VM storage account that will contain the storage container within which we will create
	// the blob that will become the VHD disk for the cloned VM.
	TempVmStorageAccountID *int64 `json:"tempVmStorageAccountId,omitempty"`

	// Specifies id of the temporary VM storage container within the above storage account.
	TempVmStorageContainerID *int64 `json:"tempVmStorageContainerId,omitempty"`

	// Specifies Id of the temporary VM subnet within the above virtual network.
	TempVmSubnetID *int64 `json:"tempVmSubnetId,omitempty"`

	// Specifies Id of the temporary VM Virtual Network.
	TempVmVirtualNetworkID *int64 `json:"tempVmVirtualNetworkId,omitempty"`
}

// UnmarshalAzureCloudSpinParams unmarshals an instance of AzureCloudSpinParams from the specified map of raw messages.
func UnmarshalAzureCloudSpinParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AzureCloudSpinParams)
	err = core.UnmarshalPrimitive(m, "availabilitySetId", &obj.AvailabilitySetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "availabilitySetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "networkResourceGroupId", &obj.NetworkResourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "networkResourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupId", &obj.ResourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageAccountId", &obj.StorageAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageAccountId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageContainerId", &obj.StorageContainerID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageContainerId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageResourceGroupId", &obj.StorageResourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageResourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tempVmResourceGroupId", &obj.TempVmResourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tempVmResourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tempVmStorageAccountId", &obj.TempVmStorageAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tempVmStorageAccountId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tempVmStorageContainerId", &obj.TempVmStorageContainerID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tempVmStorageContainerId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tempVmSubnetId", &obj.TempVmSubnetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tempVmSubnetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tempVmVirtualNetworkId", &obj.TempVmVirtualNetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tempVmVirtualNetworkId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AzureSnapshotParams : Specifies parameters of Azure type snapshots.
type AzureSnapshotParams struct {
	// Specifies the protection type of Azure snapshots.
	ProtectionType *string `json:"protectionType,omitempty"`
}

// Constants associated with the AzureSnapshotParams.ProtectionType property.
// Specifies the protection type of Azure snapshots.
const (
	AzureSnapshotParams_ProtectionType_Kagent           = "kAgent"
	AzureSnapshotParams_ProtectionType_Kazuresql        = "kAzureSQL"
	AzureSnapshotParams_ProtectionType_Knative          = "kNative"
	AzureSnapshotParams_ProtectionType_Ksnapshotmanager = "kSnapshotManager"
)

// UnmarshalAzureSnapshotParams unmarshals an instance of AzureSnapshotParams from the specified map of raw messages.
func UnmarshalAzureSnapshotParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AzureSnapshotParams)
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AzureTargetConfig : Specifies the configuration for adding Azure as replication target.
type AzureTargetConfig struct {
	// Specifies the name of the Azure Replication target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies id of the Azure resource group used to filter regions in UI.
	ResourceGroup *int64 `json:"resourceGroup,omitempty"`

	// Specifies name of the Azure resource group used to filter regions in UI.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// Specifies the source id of the Azure protection source registered on IBM cluster.
	SourceID *int64 `json:"sourceId" validate:"required"`

	// Specifies id of the storage account of Azure replication target which will contain storage container.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StorageAccount *int64 `json:"storageAccount,omitempty"`

	// Specifies name of the storage account of Azure replication target which will contain storage container.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// Specifies id of the storage container of Azure Replication target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StorageContainer *int64 `json:"storageContainer,omitempty"`

	// Specifies name of the storage container of Azure Replication target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StorageContainerName *string `json:"storageContainerName,omitempty"`

	// Specifies id of the storage resource group of Azure Replication target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StorageResourceGroup *int64 `json:"storageResourceGroup,omitempty"`

	// Specifies name of the storage resource group of Azure Replication target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StorageResourceGroupName *string `json:"storageResourceGroupName,omitempty"`
}

// NewAzureTargetConfig : Instantiate AzureTargetConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewAzureTargetConfig(sourceID int64) (_model *AzureTargetConfig, err error) {
	_model = &AzureTargetConfig{
		SourceID: core.Int64Ptr(sourceID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAzureTargetConfig unmarshals an instance of AzureTargetConfig from the specified map of raw messages.
func UnmarshalAzureTargetConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AzureTargetConfig)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceGroup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupName", &obj.ResourceGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageAccount", &obj.StorageAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageAccount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageAccountName", &obj.StorageAccountName)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageAccountName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageContainer", &obj.StorageContainer)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageContainer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageContainerName", &obj.StorageContainerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageContainerName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageResourceGroup", &obj.StorageResourceGroup)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageResourceGroup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageResourceGroupName", &obj.StorageResourceGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageResourceGroupName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AzureTier : Specifies the settings for a Azure tier.
type AzureTier struct {
	// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
	// 'moveAfter' field specified below.
	MoveAfterUnit *string `json:"moveAfterUnit,omitempty"`

	// Specifies the time period after which the backup will be moved from current tier to next tier.
	MoveAfter *int64 `json:"moveAfter,omitempty"`

	// Specifies the Azure tier types.
	TierType *string `json:"tierType" validate:"required"`
}

// Constants associated with the AzureTier.MoveAfterUnit property.
// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
// 'moveAfter' field specified below.
const (
	AzureTier_MoveAfterUnit_Days   = "Days"
	AzureTier_MoveAfterUnit_Months = "Months"
	AzureTier_MoveAfterUnit_Weeks  = "Weeks"
	AzureTier_MoveAfterUnit_Years  = "Years"
)

// Constants associated with the AzureTier.TierType property.
// Specifies the Azure tier types.
const (
	AzureTier_TierType_Kazuretierarchive = "kAzureTierArchive"
	AzureTier_TierType_Kazuretiercool    = "kAzureTierCool"
	AzureTier_TierType_Kazuretierhot     = "kAzureTierHot"
)

// NewAzureTier : Instantiate AzureTier (Generic Model Constructor)
func (*BackupRecoveryV1) NewAzureTier(tierType string) (_model *AzureTier, err error) {
	_model = &AzureTier{
		TierType: core.StringPtr(tierType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAzureTier unmarshals an instance of AzureTier from the specified map of raw messages.
func UnmarshalAzureTier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AzureTier)
	err = core.UnmarshalPrimitive(m, "moveAfterUnit", &obj.MoveAfterUnit)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfterUnit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "moveAfter", &obj.MoveAfter)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tierType", &obj.TierType)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AzureTiers : Specifies Azure tiers.
type AzureTiers struct {
	// Specifies the tiers that are used to move the archived backup from current tier to next tier. The order of the tiers
	// determines which tier will be used next for moving the archived backup. The first tier input should always be
	// default tier where backup will be acrhived. Each tier specifies how much time after the backup will be moved to next
	// tier from the current tier.
	Tiers []AzureTier `json:"tiers,omitempty"`
}

// UnmarshalAzureTiers unmarshals an instance of AzureTiers from the specified map of raw messages.
func UnmarshalAzureTiers(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AzureTiers)
	err = core.UnmarshalModel(m, "tiers", &obj.Tiers, UnmarshalAzureTier)
	if err != nil {
		err = core.SDKErrorf(err, "", "tiers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupAttempt : Specifies a backup attempt for an object.
type BackupAttempt struct {
	// Specifies the start time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the time at which the backup task was admitted to run in Unix epoch Timestamp(in microseconds) for an
	// object.
	AdmittedTimeUsecs *int64 `json:"admittedTimeUsecs,omitempty"`

	// Specifies the time when gatekeeper permit is granted to the backup task. If the backup task is rescheduled due to
	// errors, the field is updated to the time when permit is granted again.
	PermitGrantTimeUsecs *int64 `json:"permitGrantTimeUsecs,omitempty"`

	// Specifies the duration between the startTime and when gatekeeper permit is granted to the backup task. If the backup
	// task is rescheduled due to errors, the field is updated considering the time when permit is granted again. Queue
	// duration = PermitGrantTimeUsecs - StartTimeUsecs.
	QueueDurationUsecs *int64 `json:"queueDurationUsecs,omitempty"`

	// Specifies the time at which the source snapshot was taken in Unix epoch Timestamp(in microseconds) for an object.
	SnapshotCreationTimeUsecs *int64 `json:"snapshotCreationTimeUsecs,omitempty"`

	// Status of the attempt for an object. 'Running' indicates that the run is still running. 'Canceled' indicates that
	// the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused'
	// indicates that the ongoing run has been paused. 'Pausing' indicates that the ongoing run is in the process of being
	// paused. 'Resuming' indicates that the already paused run is in the process of being running again. 'Failed'
	// indicates that the run has failed. 'Missed' indicates that the run was unable to take place at the scheduled time
	// because the previous run was still happening. 'Succeeded' indicates that the run has finished successfully.
	// 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages. 'Skipped'
	// indicates that the run was skipped.
	Status *string `json:"status,omitempty"`

	// Specifies statistics about local snapshot.
	Stats *BackupDataStats `json:"stats,omitempty"`

	// Progress monitor task for an object.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// A message about the error if encountered while performing backup.
	Message *string `json:"message,omitempty"`
}

// Constants associated with the BackupAttempt.Status property.
// Status of the attempt for an object. 'Running' indicates that the run is still running. 'Canceled' indicates that the
// run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates
// that the ongoing run has been paused. 'Pausing' indicates that the ongoing run is in the process of being paused.
// 'Resuming' indicates that the already paused run is in the process of being running again. 'Failed' indicates that
// the run has failed. 'Missed' indicates that the run was unable to take place at the scheduled time because the
// previous run was still happening. 'Succeeded' indicates that the run has finished successfully.
// 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages. 'Skipped'
// indicates that the run was skipped.
const (
	BackupAttempt_Status_Accepted             = "Accepted"
	BackupAttempt_Status_Canceled             = "Canceled"
	BackupAttempt_Status_Canceling            = "Canceling"
	BackupAttempt_Status_Failed               = "Failed"
	BackupAttempt_Status_Finalizing           = "Finalizing"
	BackupAttempt_Status_Missed               = "Missed"
	BackupAttempt_Status_Onhold               = "OnHold"
	BackupAttempt_Status_Paused               = "Paused"
	BackupAttempt_Status_Running              = "Running"
	BackupAttempt_Status_Skipped              = "Skipped"
	BackupAttempt_Status_Succeeded            = "Succeeded"
	BackupAttempt_Status_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalBackupAttempt unmarshals an instance of BackupAttempt from the specified map of raw messages.
func UnmarshalBackupAttempt(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupAttempt)
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "admittedTimeUsecs", &obj.AdmittedTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "admittedTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "permitGrantTimeUsecs", &obj.PermitGrantTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "permitGrantTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "queueDurationUsecs", &obj.QueueDurationUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "queueDurationUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotCreationTimeUsecs", &obj.SnapshotCreationTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotCreationTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "stats", &obj.Stats, UnmarshalBackupDataStats)
	if err != nil {
		err = core.SDKErrorf(err, "", "stats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupDataStats : Specifies statistics about local snapshot.
type BackupDataStats struct {
	// Specifies total logical size of object(s) in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies total size of data in bytes written after taking backup.
	BytesWritten *int64 `json:"bytesWritten,omitempty"`

	// Specifies total logical bytes read for creating the snapshot.
	BytesRead *int64 `json:"bytesRead,omitempty"`
}

// UnmarshalBackupDataStats unmarshals an instance of BackupDataStats from the specified map of raw messages.
func UnmarshalBackupDataStats(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupDataStats)
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bytesWritten", &obj.BytesWritten)
	if err != nil {
		err = core.SDKErrorf(err, "", "bytesWritten-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bytesRead", &obj.BytesRead)
	if err != nil {
		err = core.SDKErrorf(err, "", "bytesRead-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupPolicy : Specifies the backup schedule and retentions of a Protection Policy.
type BackupPolicy struct {
	// Specifies the Incremental and Full policy settings and also the common Retention policy settings.".
	Regular *RegularBackupPolicy `json:"regular" validate:"required"`

	// Specifies log backup settings for a Protection Group.
	Log *LogBackupPolicy `json:"log,omitempty"`

	// Specifies the BMR schedule in case of physical source protection.
	Bmr *BmrBackupPolicy `json:"bmr,omitempty"`

	// Specifies CDP (Continious Data Protection) backup settings for a Protection Group.
	Cdp *CdpBackupPolicy `json:"cdp,omitempty"`

	// Specifies storage snapshot managment backup settings for a Protection Group.
	StorageArraySnapshot *StorageArraySnapshotBackupPolicy `json:"storageArraySnapshot,omitempty"`

	// Specifies the backup timeouts for different type of runs(kFull, kRegular etc.).
	RunTimeouts []CancellationTimeoutParams `json:"runTimeouts,omitempty"`
}

// NewBackupPolicy : Instantiate BackupPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewBackupPolicy(regular *RegularBackupPolicy) (_model *BackupPolicy, err error) {
	_model = &BackupPolicy{
		Regular: regular,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalBackupPolicy unmarshals an instance of BackupPolicy from the specified map of raw messages.
func UnmarshalBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupPolicy)
	err = core.UnmarshalModel(m, "regular", &obj.Regular, UnmarshalRegularBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "regular-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "log", &obj.Log, UnmarshalLogBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "log-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bmr", &obj.Bmr, UnmarshalBmrBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "bmr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cdp", &obj.Cdp, UnmarshalCdpBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "cdp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "storageArraySnapshot", &obj.StorageArraySnapshot, UnmarshalStorageArraySnapshotBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageArraySnapshot-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "runTimeouts", &obj.RunTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "runTimeouts-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupRun : Specifies information about backup run for an object.
type BackupRun struct {
	// Snapshot info for an object.
	SnapshotInfo *SnapshotInfo `json:"snapshotInfo,omitempty"`

	// Failed backup attempts for an object.
	FailedAttempts []BackupAttempt `json:"failedAttempts,omitempty"`
}

// UnmarshalBackupRun unmarshals an instance of BackupRun from the specified map of raw messages.
func UnmarshalBackupRun(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupRun)
	err = core.UnmarshalModel(m, "snapshotInfo", &obj.SnapshotInfo, UnmarshalSnapshotInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "failedAttempts", &obj.FailedAttempts, UnmarshalBackupAttempt)
	if err != nil {
		err = core.SDKErrorf(err, "", "failedAttempts-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BackupRunSummary : Specifies summary information about local snapshot run across all objects.
type BackupRunSummary struct {
	// Type of Protection Group run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT
	// (if supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the
	// blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects
	// are always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture
	// the database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume
	// backup. It produces an image for bare metal recovery. 'kStorageArraySnapshot' indicates storage array snapshot
	// backup.
	RunType *string `json:"runType,omitempty"`

	// Indicated if SLA has been violated for this run.
	IsSlaViolated *bool `json:"isSlaViolated,omitempty"`

	// Specifies the start time of backup run in Unix epoch Timestamp(in microseconds).
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of backup run in Unix epoch Timestamp(in microseconds).
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Status of the backup run. 'Running' indicates that the run is still running. 'Canceled' indicates that the run has
	// been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates that the
	// ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that the run was unable
	// to take place at the scheduled time because the previous run was still happening. 'Succeeded' indicates that the run
	// has finished successfully. 'SucceededWithWarning' indicates that the run finished successfully, but there were some
	// warning messages. 'Skipped' indicates that the run was skipped.
	Status *string `json:"status,omitempty"`

	// Message about the backup run.
	Messages []string `json:"messages,omitempty"`

	// Specifies the count of objects for which backup was successful.
	SuccessfulObjectsCount *int64 `json:"successfulObjectsCount,omitempty"`

	// Specifies the count of objects for which backup was skipped.
	SkippedObjectsCount *int64 `json:"skippedObjectsCount,omitempty"`

	// Specifies the count of objects for which backup failed.
	FailedObjectsCount *int64 `json:"failedObjectsCount,omitempty"`

	// Specifies the count of objects for which backup was cancelled.
	CancelledObjectsCount *int64 `json:"cancelledObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup was successful.
	SuccessfulAppObjectsCount *int64 `json:"successfulAppObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup failed.
	FailedAppObjectsCount *int64 `json:"failedAppObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup was cancelled.
	CancelledAppObjectsCount *int64 `json:"cancelledAppObjectsCount,omitempty"`

	// Specifies statistics about local snapshot.
	LocalSnapshotStats *BackupDataStats `json:"localSnapshotStats,omitempty"`

	// Progress monitor task for indexing.
	IndexingTaskID *string `json:"indexingTaskId,omitempty"`

	// Progress monitor task id for local backup run.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Stats task id for local backup run.
	StatsTaskID *string `json:"statsTaskId,omitempty"`

	// This field is deprecated. Use DataLockConstraints field instead.
	DataLock *string `json:"dataLock,omitempty"`

	// Task ID for a local protection run.
	LocalTaskID *string `json:"localTaskId,omitempty"`

	// Specifies the dataLock constraints for local or target snapshot.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`
}

// Constants associated with the BackupRunSummary.RunType property.
// Type of Protection Group run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT (if
// supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the
// blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are
// always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture the
// database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume
// backup. It produces an image for bare metal recovery. 'kStorageArraySnapshot' indicates storage array snapshot
// backup.
const (
	BackupRunSummary_RunType_Kfull                 = "kFull"
	BackupRunSummary_RunType_Khydratecdp           = "kHydrateCDP"
	BackupRunSummary_RunType_Klog                  = "kLog"
	BackupRunSummary_RunType_Kregular              = "kRegular"
	BackupRunSummary_RunType_Kstoragearraysnapshot = "kStorageArraySnapshot"
	BackupRunSummary_RunType_Ksystem               = "kSystem"
)

// Constants associated with the BackupRunSummary.Status property.
// Status of the backup run. 'Running' indicates that the run is still running. 'Canceled' indicates that the run has
// been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates that the
// ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that the run was unable
// to take place at the scheduled time because the previous run was still happening. 'Succeeded' indicates that the run
// has finished successfully. 'SucceededWithWarning' indicates that the run finished successfully, but there were some
// warning messages. 'Skipped' indicates that the run was skipped.
const (
	BackupRunSummary_Status_Accepted             = "Accepted"
	BackupRunSummary_Status_Canceled             = "Canceled"
	BackupRunSummary_Status_Canceling            = "Canceling"
	BackupRunSummary_Status_Failed               = "Failed"
	BackupRunSummary_Status_Finalizing           = "Finalizing"
	BackupRunSummary_Status_Missed               = "Missed"
	BackupRunSummary_Status_Onhold               = "OnHold"
	BackupRunSummary_Status_Paused               = "Paused"
	BackupRunSummary_Status_Running              = "Running"
	BackupRunSummary_Status_Skipped              = "Skipped"
	BackupRunSummary_Status_Succeeded            = "Succeeded"
	BackupRunSummary_Status_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the BackupRunSummary.DataLock property.
// This field is deprecated. Use DataLockConstraints field instead.
const (
	BackupRunSummary_DataLock_Administrative = "Administrative"
	BackupRunSummary_DataLock_Compliance     = "Compliance"
)

// UnmarshalBackupRunSummary unmarshals an instance of BackupRunSummary from the specified map of raw messages.
func UnmarshalBackupRunSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BackupRunSummary)
	err = core.UnmarshalPrimitive(m, "runType", &obj.RunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "runType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isSlaViolated", &obj.IsSlaViolated)
	if err != nil {
		err = core.SDKErrorf(err, "", "isSlaViolated-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		err = core.SDKErrorf(err, "", "messages-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "successfulObjectsCount", &obj.SuccessfulObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "successfulObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "skippedObjectsCount", &obj.SkippedObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "skippedObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "failedObjectsCount", &obj.FailedObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "failedObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cancelledObjectsCount", &obj.CancelledObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cancelledObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "successfulAppObjectsCount", &obj.SuccessfulAppObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "successfulAppObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "failedAppObjectsCount", &obj.FailedAppObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "failedAppObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cancelledAppObjectsCount", &obj.CancelledAppObjectsCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cancelledAppObjectsCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "localSnapshotStats", &obj.LocalSnapshotStats, UnmarshalBackupDataStats)
	if err != nil {
		err = core.SDKErrorf(err, "", "localSnapshotStats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "indexingTaskId", &obj.IndexingTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "statsTaskId", &obj.StatsTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "statsTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataLock", &obj.DataLock)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLock-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "localTaskId", &obj.LocalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "localTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConstraints", &obj.DataLockConstraints, UnmarshalDataLockConstraints)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConstraints-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BlackoutWindow : Specifies a time range in a single day when new Protection Group Runs of Protection Groups cannot be started. For
// example, a Protection Group with a daily schedule could define a blackout period for Sunday.
type BlackoutWindow struct {
	// Specifies a day in the week when no new Protection Group Runs should be started such as 'Sunday'. Specifies a day in
	// a week such as 'Sunday', 'Monday', etc.
	Day *string `json:"day" validate:"required"`

	// Specifies the time of day. Used for scheduling purposes.
	StartTime *TimeOfDay `json:"startTime" validate:"required"`

	// Specifies the time of day. Used for scheduling purposes.
	EndTime *TimeOfDay `json:"endTime" validate:"required"`

	// Specifies the unique identifier for the target getting added. This field need to be passed olny when policies are
	// updated.
	ConfigID *string `json:"configId,omitempty"`
}

// Constants associated with the BlackoutWindow.Day property.
// Specifies a day in the week when no new Protection Group Runs should be started such as 'Sunday'. Specifies a day in
// a week such as 'Sunday', 'Monday', etc.
const (
	BlackoutWindow_Day_Friday    = "Friday"
	BlackoutWindow_Day_Monday    = "Monday"
	BlackoutWindow_Day_Saturday  = "Saturday"
	BlackoutWindow_Day_Sunday    = "Sunday"
	BlackoutWindow_Day_Thursday  = "Thursday"
	BlackoutWindow_Day_Tuesday   = "Tuesday"
	BlackoutWindow_Day_Wednesday = "Wednesday"
)

// NewBlackoutWindow : Instantiate BlackoutWindow (Generic Model Constructor)
func (*BackupRecoveryV1) NewBlackoutWindow(day string, startTime *TimeOfDay, endTime *TimeOfDay) (_model *BlackoutWindow, err error) {
	_model = &BlackoutWindow{
		Day:       core.StringPtr(day),
		StartTime: startTime,
		EndTime:   endTime,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalBlackoutWindow unmarshals an instance of BlackoutWindow from the specified map of raw messages.
func UnmarshalBlackoutWindow(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BlackoutWindow)
	err = core.UnmarshalPrimitive(m, "day", &obj.Day)
	if err != nil {
		err = core.SDKErrorf(err, "", "day-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "startTime", &obj.StartTime, UnmarshalTimeOfDay)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTime-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "endTime", &obj.EndTime, UnmarshalTimeOfDay)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTime-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BmrBackupPolicy : Specifies the BMR schedule in case of physical source protection.
type BmrBackupPolicy struct {
	// Specifies settings that defines how frequent bmr backup will be performed for a Protection Group.
	Schedule *BmrSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`
}

// NewBmrBackupPolicy : Instantiate BmrBackupPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewBmrBackupPolicy(schedule *BmrSchedule, retention *Retention) (_model *BmrBackupPolicy, err error) {
	_model = &BmrBackupPolicy{
		Schedule:  schedule,
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalBmrBackupPolicy unmarshals an instance of BmrBackupPolicy from the specified map of raw messages.
func UnmarshalBmrBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BmrBackupPolicy)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalBmrSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BmrSchedule : Specifies settings that defines how frequent bmr backup will be performed for a Protection Group.
type BmrSchedule struct {
	// Specifies how often to start new runs of a Protection Group. <br>'Weeks' specifies that new Protection Group runs
	// start weekly on certain days specified using 'dayOfWeek' field. <br>'Months' specifies that new Protection Group
	// runs start monthly on certain day of specific week.
	Unit *string `json:"unit" validate:"required"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of days.
	DaySchedule *DaySchedule `json:"daySchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start on certain days of week.
	WeekSchedule *WeekSchedule `json:"weekSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to on specific week and specific days of that
	// week.
	MonthSchedule *MonthSchedule `json:"monthSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group to run on specific year and specific day of that
	// year.
	YearSchedule *YearSchedule `json:"yearSchedule,omitempty"`
}

// Constants associated with the BmrSchedule.Unit property.
// Specifies how often to start new runs of a Protection Group. <br>'Weeks' specifies that new Protection Group runs
// start weekly on certain days specified using 'dayOfWeek' field. <br>'Months' specifies that new Protection Group runs
// start monthly on certain day of specific week.
const (
	BmrSchedule_Unit_Days   = "Days"
	BmrSchedule_Unit_Months = "Months"
	BmrSchedule_Unit_Weeks  = "Weeks"
	BmrSchedule_Unit_Years  = "Years"
)

// NewBmrSchedule : Instantiate BmrSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewBmrSchedule(unit string) (_model *BmrSchedule, err error) {
	_model = &BmrSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalBmrSchedule unmarshals an instance of BmrSchedule from the specified map of raw messages.
func UnmarshalBmrSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BmrSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "daySchedule", &obj.DaySchedule, UnmarshalDaySchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "daySchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "weekSchedule", &obj.WeekSchedule, UnmarshalWeekSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "weekSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "monthSchedule", &obj.MonthSchedule, UnmarshalMonthSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "monthSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "yearSchedule", &obj.YearSchedule, UnmarshalYearSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "yearSchedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CancelProtectionGroupRunRequest : Specifies the request to cancel a protection run.
type CancelProtectionGroupRunRequest struct {
	// Specifies a unique run id of the Protection Group run.
	RunID *string `json:"runId" validate:"required"`

	// Specifies the task id of the local run.
	LocalTaskID *string `json:"localTaskId,omitempty"`

	// List of entity ids for which we need to cancel the backup tasks. If this is provided it will not cancel the complete
	// run but will cancel only subset of backup tasks (if backup tasks are cancelled correspoding copy task will also get
	// cancelled). If the backup tasks are completed successfully it will not cancel those backup tasks.
	ObjectIds []int64 `json:"objectIds,omitempty"`

	// Specifies the task id of the replication run.
	ReplicationTaskID []string `json:"replicationTaskId,omitempty"`

	// Specifies the task id of the archival run.
	ArchivalTaskID []string `json:"archivalTaskId,omitempty"`

	// Specifies the task id of the cloudSpin run.
	CloudSpinTaskID []string `json:"cloudSpinTaskId,omitempty"`
}

// NewCancelProtectionGroupRunRequest : Instantiate CancelProtectionGroupRunRequest (Generic Model Constructor)
func (*BackupRecoveryV1) NewCancelProtectionGroupRunRequest(runID string) (_model *CancelProtectionGroupRunRequest, err error) {
	_model = &CancelProtectionGroupRunRequest{
		RunID: core.StringPtr(runID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCancelProtectionGroupRunRequest unmarshals an instance of CancelProtectionGroupRunRequest from the specified map of raw messages.
func UnmarshalCancelProtectionGroupRunRequest(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CancelProtectionGroupRunRequest)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "localTaskId", &obj.LocalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "localTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectIds", &obj.ObjectIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationTaskId", &obj.ReplicationTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTaskId", &obj.ArchivalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudSpinTaskId", &obj.CloudSpinTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudSpinTaskId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CancelProtectionGroupRunResponseParams : Specifies the response of a cancel action on protection runs.
type CancelProtectionGroupRunResponseParams struct {
	// Specifies a unique run id of the Protection Group run.
	RunID *string `json:"runId,omitempty"`
}

// UnmarshalCancelProtectionGroupRunResponseParams unmarshals an instance of CancelProtectionGroupRunResponseParams from the specified map of raw messages.
func UnmarshalCancelProtectionGroupRunResponseParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CancelProtectionGroupRunResponseParams)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CancellationTimeoutParams : Specifies timeouts for different backup types (kFull, kRegular etc.).
type CancellationTimeoutParams struct {
	// Specifies the timeout in mins.
	TimeoutMins *int64 `json:"timeoutMins,omitempty"`

	// The scheduled backup type(kFull, kRegular etc.).
	BackupType *string `json:"backupType,omitempty"`
}

// Constants associated with the CancellationTimeoutParams.BackupType property.
// The scheduled backup type(kFull, kRegular etc.).
const (
	CancellationTimeoutParams_BackupType_Kfull                 = "kFull"
	CancellationTimeoutParams_BackupType_Khydratecdp           = "kHydrateCDP"
	CancellationTimeoutParams_BackupType_Klog                  = "kLog"
	CancellationTimeoutParams_BackupType_Kregular              = "kRegular"
	CancellationTimeoutParams_BackupType_Kstoragearraysnapshot = "kStorageArraySnapshot"
	CancellationTimeoutParams_BackupType_Ksystem               = "kSystem"
)

// UnmarshalCancellationTimeoutParams unmarshals an instance of CancellationTimeoutParams from the specified map of raw messages.
func UnmarshalCancellationTimeoutParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CancellationTimeoutParams)
	err = core.UnmarshalPrimitive(m, "timeoutMins", &obj.TimeoutMins)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeoutMins-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupType", &obj.BackupType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CascadedTargetConfiguration : Specifies the source of the cascadded replication and list of all remote targets that needs to added. Each source
// cluster and remote targets are considered as nodes and immediate connections between them are considered as edges.
type CascadedTargetConfiguration struct {
	// Specifies the source cluster id from where the remote operations will be performed to the next set of remote
	// targets.
	SourceClusterID *int64 `json:"sourceClusterId" validate:"required"`

	// Specifies the replication, archival and cloud spin targets of Protection Policy.
	RemoteTargets *TargetsConfiguration `json:"remoteTargets" validate:"required"`
}

// NewCascadedTargetConfiguration : Instantiate CascadedTargetConfiguration (Generic Model Constructor)
func (*BackupRecoveryV1) NewCascadedTargetConfiguration(sourceClusterID int64, remoteTargets *TargetsConfiguration) (_model *CascadedTargetConfiguration, err error) {
	_model = &CascadedTargetConfiguration{
		SourceClusterID: core.Int64Ptr(sourceClusterID),
		RemoteTargets:   remoteTargets,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCascadedTargetConfiguration unmarshals an instance of CascadedTargetConfiguration from the specified map of raw messages.
func UnmarshalCascadedTargetConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CascadedTargetConfiguration)
	err = core.UnmarshalPrimitive(m, "sourceClusterId", &obj.SourceClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceClusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "remoteTargets", &obj.RemoteTargets, UnmarshalTargetsConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "remoteTargets-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CassandraIndexedObject : Specifies a Cassandra indexed object.
type CassandraIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies type of Keyspace.
	KeyspaceType *string `json:"keyspaceType,omitempty"`

	// Specifies the Cassandra Object type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the CassandraIndexedObject.KeyspaceType property.
// Specifies type of Keyspace.
const (
	CassandraIndexedObject_KeyspaceType_Kgraph   = "kGraph"
	CassandraIndexedObject_KeyspaceType_Kregular = "kRegular"
	CassandraIndexedObject_KeyspaceType_Ksystem  = "kSystem"
)

// Constants associated with the CassandraIndexedObject.Type property.
// Specifies the Cassandra Object type.
const (
	CassandraIndexedObject_Type_Cassandrakeyspaces = "CassandraKeyspaces"
	CassandraIndexedObject_Type_Cassandratables    = "CassandraTables"
)

// UnmarshalCassandraIndexedObject unmarshals an instance of CassandraIndexedObject from the specified map of raw messages.
func UnmarshalCassandraIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CassandraIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "keyspaceType", &obj.KeyspaceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "keyspaceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CassandraOnPremSearchParams : Parameters required to search Cassandra on a cluster.
type CassandraOnPremSearchParams struct {
	// Specifies one or more Cassandra object types to be searched.
	CassandraObjectTypes []string `json:"cassandraObjectTypes" validate:"required"`

	// Specifies the search string to search the Cassandra Objects.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// Constants associated with the CassandraOnPremSearchParams.CassandraObjectTypes property.
const (
	CassandraOnPremSearchParams_CassandraObjectTypes_Cassandrakeyspaces = "CassandraKeyspaces"
	CassandraOnPremSearchParams_CassandraObjectTypes_Cassandratables    = "CassandraTables"
)

// NewCassandraOnPremSearchParams : Instantiate CassandraOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewCassandraOnPremSearchParams(cassandraObjectTypes []string, searchString string) (_model *CassandraOnPremSearchParams, err error) {
	_model = &CassandraOnPremSearchParams{
		CassandraObjectTypes: cassandraObjectTypes,
		SearchString:         core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCassandraOnPremSearchParams unmarshals an instance of CassandraOnPremSearchParams from the specified map of raw messages.
func UnmarshalCassandraOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CassandraOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "cassandraObjectTypes", &obj.CassandraObjectTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "cassandraObjectTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CbtFileVersion : Subcomponent version. The interpretation of the version is based on operating system.
type CbtFileVersion struct {
	BuildVer *float64 `json:"buildVer,omitempty"`

	MajorVer *float64 `json:"majorVer,omitempty"`

	MinorVer *float64 `json:"minorVer,omitempty"`

	RevisionNum *float64 `json:"revisionNum,omitempty"`
}

// UnmarshalCbtFileVersion unmarshals an instance of CbtFileVersion from the specified map of raw messages.
func UnmarshalCbtFileVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CbtFileVersion)
	err = core.UnmarshalPrimitive(m, "buildVer", &obj.BuildVer)
	if err != nil {
		err = core.SDKErrorf(err, "", "buildVer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "majorVer", &obj.MajorVer)
	if err != nil {
		err = core.SDKErrorf(err, "", "majorVer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "minorVer", &obj.MinorVer)
	if err != nil {
		err = core.SDKErrorf(err, "", "minorVer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "revisionNum", &obj.RevisionNum)
	if err != nil {
		err = core.SDKErrorf(err, "", "revisionNum-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CbtInfo : CBT version and service state info.
type CbtInfo struct {
	// Subcomponent version. The interpretation of the version is based on operating system.
	FileVersion *CbtFileVersion `json:"fileVersion,omitempty"`

	// Indicates whether the cbt driver is installed.
	IsInstalled *bool `json:"isInstalled,omitempty"`

	// Indicates whether host is rebooted post VolCBT installation.
	RebootStatus *string `json:"rebootStatus,omitempty"`

	// Structure to Hold Service Status.
	ServiceState *CbtServiceState `json:"serviceState,omitempty"`
}

// Constants associated with the CbtInfo.RebootStatus property.
// Indicates whether host is rebooted post VolCBT installation.
const (
	CbtInfo_RebootStatus_Kinternalerror = "kInternalError"
	CbtInfo_RebootStatus_Kneedsreboot   = "kNeedsReboot"
	CbtInfo_RebootStatus_Krebooted      = "kRebooted"
)

// UnmarshalCbtInfo unmarshals an instance of CbtInfo from the specified map of raw messages.
func UnmarshalCbtInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CbtInfo)
	err = core.UnmarshalModel(m, "fileVersion", &obj.FileVersion, UnmarshalCbtFileVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isInstalled", &obj.IsInstalled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isInstalled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "rebootStatus", &obj.RebootStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "rebootStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "serviceState", &obj.ServiceState, UnmarshalCbtServiceState)
	if err != nil {
		err = core.SDKErrorf(err, "", "serviceState-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CbtServiceState : Structure to Hold Service Status.
type CbtServiceState struct {
	Name *string `json:"name" validate:"required"`

	State *string `json:"state" validate:"required"`
}

// UnmarshalCbtServiceState unmarshals an instance of CbtServiceState from the specified map of raw messages.
func UnmarshalCbtServiceState(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CbtServiceState)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		err = core.SDKErrorf(err, "", "state-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CdpBackupPolicy : Specifies CDP (Continious Data Protection) backup settings for a Protection Group.
type CdpBackupPolicy struct {
	// Specifies the retention of a CDP backup.
	Retention *CdpRetention `json:"retention" validate:"required"`
}

// NewCdpBackupPolicy : Instantiate CdpBackupPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewCdpBackupPolicy(retention *CdpRetention) (_model *CdpBackupPolicy, err error) {
	_model = &CdpBackupPolicy{
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCdpBackupPolicy unmarshals an instance of CdpBackupPolicy from the specified map of raw messages.
func UnmarshalCdpBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CdpBackupPolicy)
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalCdpRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CdpLocalBackupInfo : Specifies the last local backup information for a given CDP object.
type CdpLocalBackupInfo struct {
	// Specifies the end time of the last local backup taken.
	EndTimeInUsecs *int64 `json:"endTimeInUsecs,omitempty"`

	// Specifies the start time of the last local backup taken.
	StartTimeInUsecs *int64 `json:"startTimeInUsecs,omitempty"`
}

// UnmarshalCdpLocalBackupInfo unmarshals an instance of CdpLocalBackupInfo from the specified map of raw messages.
func UnmarshalCdpLocalBackupInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CdpLocalBackupInfo)
	err = core.UnmarshalPrimitive(m, "endTimeInUsecs", &obj.EndTimeInUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeInUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeInUsecs", &obj.StartTimeInUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeInUsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CdpObjectInfo : Specifies the CDP related information for a given object. This field will only be populated when protection group is
// configured with policy having CDP retention settings.
type CdpObjectInfo struct {
	// Specifies if re-enabling CDP is allowed or not through UI without any job or policy update through API.
	AllowReEnableCdp *bool `json:"allowReEnableCdp,omitempty"`

	// Specifies whether CDP is currently active or not. CDP might have been active on this object before, but it might not
	// be anymore.
	CdpEnabled *bool `json:"cdpEnabled,omitempty"`

	// Specifies the last backup information for a given CDP object.
	LastRunInfo *CdpObjectLastRunInfo `json:"lastRunInfo,omitempty"`

	// Specifies the protection group id to which this CDP object belongs.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`
}

// UnmarshalCdpObjectInfo unmarshals an instance of CdpObjectInfo from the specified map of raw messages.
func UnmarshalCdpObjectInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CdpObjectInfo)
	err = core.UnmarshalPrimitive(m, "allowReEnableCdp", &obj.AllowReEnableCdp)
	if err != nil {
		err = core.SDKErrorf(err, "", "allowReEnableCdp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cdpEnabled", &obj.CdpEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "cdpEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "lastRunInfo", &obj.LastRunInfo, UnmarshalCdpObjectLastRunInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastRunInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CdpObjectLastRunInfo : Specifies the last backup information for a given CDP object.
type CdpObjectLastRunInfo struct {
	// Specifies the last local backup information for a given CDP object.
	LocalBackupInfo *CdpLocalBackupInfo `json:"localBackupInfo,omitempty"`
}

// UnmarshalCdpObjectLastRunInfo unmarshals an instance of CdpObjectLastRunInfo from the specified map of raw messages.
func UnmarshalCdpObjectLastRunInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CdpObjectLastRunInfo)
	err = core.UnmarshalModel(m, "localBackupInfo", &obj.LocalBackupInfo, UnmarshalCdpLocalBackupInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "localBackupInfo-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CdpRetention : Specifies the retention of a CDP backup.
type CdpRetention struct {
	// Specificies the Retention Unit of a CDP backup measured in minutes or hours.
	Unit *string `json:"unit" validate:"required"`

	// Specifies the duration for a cdp backup retention.
	Duration *int64 `json:"duration" validate:"required"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
	// Protection Groups using this policy will be kept for the last N days as specified in the duration of the datalock.
	// During that time, the snapshots cannot be deleted.
	DataLockConfig *DataLockConfig `json:"dataLockConfig,omitempty"`
}

// Constants associated with the CdpRetention.Unit property.
// Specificies the Retention Unit of a CDP backup measured in minutes or hours.
const (
	CdpRetention_Unit_Hours   = "Hours"
	CdpRetention_Unit_Minutes = "Minutes"
)

// NewCdpRetention : Instantiate CdpRetention (Generic Model Constructor)
func (*BackupRecoveryV1) NewCdpRetention(unit string, duration int64) (_model *CdpRetention, err error) {
	_model = &CdpRetention{
		Unit:     core.StringPtr(unit),
		Duration: core.Int64Ptr(duration),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCdpRetention unmarshals an instance of CdpRetention from the specified map of raw messages.
func UnmarshalCdpRetention(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CdpRetention)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "duration", &obj.Duration)
	if err != nil {
		err = core.SDKErrorf(err, "", "duration-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConfig", &obj.DataLockConfig, UnmarshalDataLockConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ChannelItem : Specifies a M365 Teams channel item.
type ChannelItem struct {
	// Specifies the email of this channel.
	ChannelEmail *string `json:"channelEmail,omitempty"`

	// Specifies the id of this channel.
	ChannelID *string `json:"channelId,omitempty"`

	// Specifies the channel name.
	ChannelName *string `json:"channelName,omitempty"`

	// Specifies the channel type.
	ChannelType *string `json:"channelType,omitempty"`

	// Specifies the Unix timestamp epoch in seconds at which this channel is created.
	CreationTimeSecs *int64 `json:"creationTimeSecs,omitempty"`

	// Specifies the names of owners of this channel.
	OwnerNames []string `json:"ownerNames,omitempty"`
}

// Constants associated with the ChannelItem.ChannelType property.
// Specifies the channel type.
const (
	ChannelItem_ChannelType_Private = "Private"
	ChannelItem_ChannelType_Public  = "Public"
)

// UnmarshalChannelItem unmarshals an instance of ChannelItem from the specified map of raw messages.
func UnmarshalChannelItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ChannelItem)
	err = core.UnmarshalPrimitive(m, "channelEmail", &obj.ChannelEmail)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelEmail-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "channelId", &obj.ChannelID)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "channelName", &obj.ChannelName)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "channelType", &obj.ChannelType)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "creationTimeSecs", &obj.CreationTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownerNames", &obj.OwnerNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownerNames-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudSpinDataStats : Specifies statistics about Cloud Spin data.
type CloudSpinDataStats struct {
	// Specifies the physical bytes transferred.
	PhysicalBytesTransferred *int64 `json:"physicalBytesTransferred,omitempty"`
}

// UnmarshalCloudSpinDataStats unmarshals an instance of CloudSpinDataStats from the specified map of raw messages.
func UnmarshalCloudSpinDataStats(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudSpinDataStats)
	err = core.UnmarshalPrimitive(m, "physicalBytesTransferred", &obj.PhysicalBytesTransferred)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalBytesTransferred-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudSpinRun : Specifies information about Cloud Spin run for an object.
type CloudSpinRun struct {
	// Cloud Spin result for a target.
	CloudSpinTargetResults []CloudSpinTargetResult `json:"cloudSpinTargetResults,omitempty"`
}

// UnmarshalCloudSpinRun unmarshals an instance of CloudSpinRun from the specified map of raw messages.
func UnmarshalCloudSpinRun(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudSpinRun)
	err = core.UnmarshalModel(m, "cloudSpinTargetResults", &obj.CloudSpinTargetResults, UnmarshalCloudSpinTargetResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudSpinTargetResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudSpinRunSummary : Specifies summary information about cloud spin run.
type CloudSpinRunSummary struct {
	// Cloud Spin results for each Cloud Spin target.
	CloudSpinTargetResults []CloudSpinTargetResult `json:"cloudSpinTargetResults,omitempty"`
}

// UnmarshalCloudSpinRunSummary unmarshals an instance of CloudSpinRunSummary from the specified map of raw messages.
func UnmarshalCloudSpinRunSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudSpinRunSummary)
	err = core.UnmarshalModel(m, "cloudSpinTargetResults", &obj.CloudSpinTargetResults, UnmarshalCloudSpinTargetResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudSpinTargetResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudSpinTarget : Specifies the details about Cloud Spin target where backup snapshots may be converted and stored.
type CloudSpinTarget struct {
	// Specifies various resources when converting and deploying a VM to AWS.
	AwsParams *AwsCloudSpinParams `json:"awsParams,omitempty"`

	// Specifies various resources when converting and deploying a VM to Azure.
	AzureParams *AzureCloudSpinParams `json:"azureParams,omitempty"`

	// Specifies the unique id of the cloud spin entity.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the already added cloud spin target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`
}

// UnmarshalCloudSpinTarget unmarshals an instance of CloudSpinTarget from the specified map of raw messages.
func UnmarshalCloudSpinTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudSpinTarget)
	err = core.UnmarshalModel(m, "awsParams", &obj.AwsParams, UnmarshalAwsCloudSpinParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureParams", &obj.AzureParams, UnmarshalAzureCloudSpinParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudSpinTargetConfiguration : Specifies settings for copying Snapshots to Cloud. This also specifies the retention policy that should be applied to
// Snapshots after they have been copied to Cloud.
type CloudSpinTargetConfiguration struct {
	// Specifies a schedule fregquency and schedule unit for copying Snapshots to backup targets.
	Schedule *TargetSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`

	// Specifies if Snapshots are copied from the first completely successful Protection Group Run or the first partially
	// successful Protection Group Run occurring at the start of the replication schedule. <br> If true, Snapshots are
	// copied from the first Protection Group Run occurring at the start of the replication schedule that was completely
	// successful i.e. Snapshots for all the Objects in the Protection Group were successfully captured. <br> If false,
	// Snapshots are copied from the first Protection Group Run occurring at the start of the replication schedule, even if
	// first Protection Group Run was not completely successful i.e. Snapshots were not captured for all Objects in the
	// Protection Group.
	CopyOnRunSuccess *bool `json:"copyOnRunSuccess,omitempty"`

	// Specifies the unique identifier for the target getting added. This field need to be passed only when policies are
	// being updated.
	ConfigID *string `json:"configId,omitempty"`

	// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
	// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
	// be set to Full.
	BackupRunType *string `json:"backupRunType,omitempty"`

	// Specifies the replication/archival timeouts for different type of runs(kFull, kRegular etc.).
	RunTimeouts []CancellationTimeoutParams `json:"runTimeouts,omitempty"`

	// Specifies the retention of a backup.
	LogRetention *LogRetention `json:"logRetention,omitempty"`

	// Specifies the details about Cloud Spin target where backup snapshots may be converted and stored.
	Target *CloudSpinTarget `json:"target" validate:"required"`
}

// Constants associated with the CloudSpinTargetConfiguration.BackupRunType property.
// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
// be set to Full.
const (
	CloudSpinTargetConfiguration_BackupRunType_Full                 = "Full"
	CloudSpinTargetConfiguration_BackupRunType_Log                  = "Log"
	CloudSpinTargetConfiguration_BackupRunType_Regular              = "Regular"
	CloudSpinTargetConfiguration_BackupRunType_Storagearraysnapshot = "StorageArraySnapshot"
	CloudSpinTargetConfiguration_BackupRunType_System               = "System"
)

// NewCloudSpinTargetConfiguration : Instantiate CloudSpinTargetConfiguration (Generic Model Constructor)
func (*BackupRecoveryV1) NewCloudSpinTargetConfiguration(schedule *TargetSchedule, retention *Retention, target *CloudSpinTarget) (_model *CloudSpinTargetConfiguration, err error) {
	_model = &CloudSpinTargetConfiguration{
		Schedule:  schedule,
		Retention: retention,
		Target:    target,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCloudSpinTargetConfiguration unmarshals an instance of CloudSpinTargetConfiguration from the specified map of raw messages.
func UnmarshalCloudSpinTargetConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudSpinTargetConfiguration)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalTargetSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "copyOnRunSuccess", &obj.CopyOnRunSuccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "copyOnRunSuccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupRunType", &obj.BackupRunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "runTimeouts", &obj.RunTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "runTimeouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "logRetention", &obj.LogRetention, UnmarshalLogRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "logRetention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalCloudSpinTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "target-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudSpinTargetResult : Cloud Spin result for a target.
type CloudSpinTargetResult struct {
	// Specifies various resources when converting and deploying a VM to AWS.
	AwsParams *AwsCloudSpinParams `json:"awsParams,omitempty"`

	// Specifies various resources when converting and deploying a VM to Azure.
	AzureParams *AzureCloudSpinParams `json:"azureParams,omitempty"`

	// Specifies the unique id of the cloud spin entity.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the already added cloud spin target.
	Name *string `json:"name,omitempty"`

	// Specifies the start time of Cloud Spin in Unix epoch Timestamp(in microseconds) for a target.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of Cloud Spin in Unix epoch Timestamp(in microseconds) for a target.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Status of the Cloud Spin for a target. 'Running' indicates that the run is still running. 'Canceled' indicates that
	// the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused'
	// indicates that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that
	// the run was unable to take place at the scheduled time because the previous run was still happening. 'Succeeded'
	// indicates that the run has finished successfully. 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages. 'Skipped' indicates that the run was skipped.
	Status *string `json:"status,omitempty"`

	// Message about the Cloud Spin run.
	Message *string `json:"message,omitempty"`

	// Specifies statistics about Cloud Spin data.
	Stats *CloudSpinDataStats `json:"stats,omitempty"`

	// Specifies whether the snapshot is deleted manually.
	IsManuallyDeleted *bool `json:"isManuallyDeleted,omitempty"`

	// Specifies the expiry time of attempt in Unix epoch Timestamp (in microseconds) for an object.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// Task ID for a CloudSpin protection run.
	CloudspinTaskID *string `json:"cloudspinTaskId,omitempty"`

	// Progress monitor task id for Cloud Spin run.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Specifies the dataLock constraints for local or target snapshot.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`

	// Specifies the legal hold status for a cloud spin target.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`
}

// Constants associated with the CloudSpinTargetResult.Status property.
// Status of the Cloud Spin for a target. 'Running' indicates that the run is still running. 'Canceled' indicates that
// the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates
// that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that the run was
// unable to take place at the scheduled time because the previous run was still happening. 'Succeeded' indicates that
// the run has finished successfully. 'SucceededWithWarning' indicates that the run finished successfully, but there
// were some warning messages. 'Skipped' indicates that the run was skipped.
const (
	CloudSpinTargetResult_Status_Accepted             = "Accepted"
	CloudSpinTargetResult_Status_Canceled             = "Canceled"
	CloudSpinTargetResult_Status_Canceling            = "Canceling"
	CloudSpinTargetResult_Status_Failed               = "Failed"
	CloudSpinTargetResult_Status_Finalizing           = "Finalizing"
	CloudSpinTargetResult_Status_Missed               = "Missed"
	CloudSpinTargetResult_Status_Onhold               = "OnHold"
	CloudSpinTargetResult_Status_Paused               = "Paused"
	CloudSpinTargetResult_Status_Running              = "Running"
	CloudSpinTargetResult_Status_Skipped              = "Skipped"
	CloudSpinTargetResult_Status_Succeeded            = "Succeeded"
	CloudSpinTargetResult_Status_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalCloudSpinTargetResult unmarshals an instance of CloudSpinTargetResult from the specified map of raw messages.
func UnmarshalCloudSpinTargetResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudSpinTargetResult)
	err = core.UnmarshalModel(m, "awsParams", &obj.AwsParams, UnmarshalAwsCloudSpinParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureParams", &obj.AzureParams, UnmarshalAzureCloudSpinParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "stats", &obj.Stats, UnmarshalCloudSpinDataStats)
	if err != nil {
		err = core.SDKErrorf(err, "", "stats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isManuallyDeleted", &obj.IsManuallyDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isManuallyDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudspinTaskId", &obj.CloudspinTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudspinTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConstraints", &obj.DataLockConstraints, UnmarshalDataLockConstraints)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConstraints-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "onLegalHold", &obj.OnLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "onLegalHold-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterIdentifier : Specifies the information about a cluster.
type ClusterIdentifier struct {
	// Specifies the id of the cluster.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the incarnation id of the cluster.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the name of the cluster.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ClusterName *string `json:"clusterName,omitempty"`
}

// UnmarshalClusterIdentifier unmarshals an instance of ClusterIdentifier from the specified map of raw messages.
func UnmarshalClusterIdentifier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterIdentifier)
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIncarnationId", &obj.ClusterIncarnationID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIncarnationId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterName", &obj.ClusterName)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterNetworkResourceInformation : Cluster Networking Resource Information.
type ClusterNetworkResourceInformation struct {
	// The endpoints by which the resource is accessible.
	Endpoints []ClusterNetworkingEndpoint `json:"endpoints,omitempty"`

	// The type of the resource.
	Type *string `json:"type,omitempty"`
}

// UnmarshalClusterNetworkResourceInformation unmarshals an instance of ClusterNetworkResourceInformation from the specified map of raw messages.
func UnmarshalClusterNetworkResourceInformation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterNetworkResourceInformation)
	err = core.UnmarshalModel(m, "endpoints", &obj.Endpoints, UnmarshalClusterNetworkingEndpoint)
	if err != nil {
		err = core.SDKErrorf(err, "", "endpoints-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterNetworkingEndpoint : Specifies information about end point.
type ClusterNetworkingEndpoint struct {
	// The Fully Qualified Domain Name.
	Fqdn *string `json:"fqdn,omitempty"`

	// The IPv4 address.
	Ipv4Addr *string `json:"ipv4Addr,omitempty"`

	// The IPv6 address.
	Ipv6Addr *string `json:"ipv6Addr,omitempty"`
}

// UnmarshalClusterNetworkingEndpoint unmarshals an instance of ClusterNetworkingEndpoint from the specified map of raw messages.
func UnmarshalClusterNetworkingEndpoint(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterNetworkingEndpoint)
	err = core.UnmarshalPrimitive(m, "fqdn", &obj.Fqdn)
	if err != nil {
		err = core.SDKErrorf(err, "", "fqdn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4Addr", &obj.Ipv4Addr)
	if err != nil {
		err = core.SDKErrorf(err, "", "ipv4Addr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv6Addr", &obj.Ipv6Addr)
	if err != nil {
		err = core.SDKErrorf(err, "", "ipv6Addr-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonIndexedObjectParamsSourceInfo : Specifies the Source Object information.
type CommonIndexedObjectParamsSourceInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`
}

// Constants associated with the CommonIndexedObjectParamsSourceInfo.Environment property.
// Specifies the environment of the object.
const (
	CommonIndexedObjectParamsSourceInfo_Environment_Kphysical = "kPhysical"
	CommonIndexedObjectParamsSourceInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the CommonIndexedObjectParamsSourceInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kagent                 = "kAgent"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kawss3                 = "kAwsS3"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kfile                  = "kFile"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Knative                = "kNative"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	CommonIndexedObjectParamsSourceInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the CommonIndexedObjectParamsSourceInfo.OsType property.
// Specifies the operating system type of the object.
const (
	CommonIndexedObjectParamsSourceInfo_OsType_Klinux   = "kLinux"
	CommonIndexedObjectParamsSourceInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalCommonIndexedObjectParamsSourceInfo unmarshals an instance of CommonIndexedObjectParamsSourceInfo from the specified map of raw messages.
func UnmarshalCommonIndexedObjectParamsSourceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonIndexedObjectParamsSourceInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonNasObjectParams : Specifies the common parameters for NAS objects.
type CommonNasObjectParams struct {
	// Specifies a list of NAS mount protocols supported by this object.
	SupportedNasMountProtocols []string `json:"supportedNasMountProtocols,omitempty"`
}

// Constants associated with the CommonNasObjectParams.SupportedNasMountProtocols property.
const (
	CommonNasObjectParams_SupportedNasMountProtocols_Kcifs1      = "kCifs1"
	CommonNasObjectParams_SupportedNasMountProtocols_Kcifs2      = "kCifs2"
	CommonNasObjectParams_SupportedNasMountProtocols_Kcifs3      = "kCifs3"
	CommonNasObjectParams_SupportedNasMountProtocols_Knfs3       = "kNfs3"
	CommonNasObjectParams_SupportedNasMountProtocols_Knfs41      = "kNfs4_1"
	CommonNasObjectParams_SupportedNasMountProtocols_Knoprotocol = "kNoProtocol"
)

// UnmarshalCommonNasObjectParams unmarshals an instance of CommonNasObjectParams from the specified map of raw messages.
func UnmarshalCommonNasObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonNasObjectParams)
	err = core.UnmarshalPrimitive(m, "supportedNasMountProtocols", &obj.SupportedNasMountProtocols)
	if err != nil {
		err = core.SDKErrorf(err, "", "supportedNasMountProtocols-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonPostBackupScriptParams : Specifies the common params for PostBackup scripts.
type CommonPostBackupScriptParams struct {
	// Specifies the absolute path to the script on the remote host.
	Path *string `json:"path" validate:"required"`

	// Specifies the arguments or parameters and values to pass into the remote script. For example if the script expects
	// values for the 'database' and 'user' parameters, specify the parameters and values using the following string:
	// "database=myDatabase user=me".
	Params *string `json:"params,omitempty"`

	// Specifies the timeout of the script in seconds. The script will be killed if it exceeds this value. By default, no
	// timeout will occur if left empty.
	TimeoutSecs *int64 `json:"timeoutSecs,omitempty"`

	// Specifies whether the script should be enabled, default value set to true.
	IsActive *bool `json:"isActive,omitempty"`
}

// NewCommonPostBackupScriptParams : Instantiate CommonPostBackupScriptParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewCommonPostBackupScriptParams(path string) (_model *CommonPostBackupScriptParams, err error) {
	_model = &CommonPostBackupScriptParams{
		Path: core.StringPtr(path),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCommonPostBackupScriptParams unmarshals an instance of CommonPostBackupScriptParams from the specified map of raw messages.
func UnmarshalCommonPostBackupScriptParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonPostBackupScriptParams)
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "params", &obj.Params)
	if err != nil {
		err = core.SDKErrorf(err, "", "params-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "timeoutSecs", &obj.TimeoutSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeoutSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isActive", &obj.IsActive)
	if err != nil {
		err = core.SDKErrorf(err, "", "isActive-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonPreBackupScriptParams : Specifies the common params for PreBackup scripts.
type CommonPreBackupScriptParams struct {
	// Specifies the absolute path to the script on the remote host.
	Path *string `json:"path" validate:"required"`

	// Specifies the arguments or parameters and values to pass into the remote script. For example if the script expects
	// values for the 'database' and 'user' parameters, specify the parameters and values using the following string:
	// "database=myDatabase user=me".
	Params *string `json:"params,omitempty"`

	// Specifies the timeout of the script in seconds. The script will be killed if it exceeds this value. By default, no
	// timeout will occur if left empty.
	TimeoutSecs *int64 `json:"timeoutSecs,omitempty"`

	// Specifies whether the script should be enabled, default value set to true.
	IsActive *bool `json:"isActive,omitempty"`

	// Specifies if the script needs to continue even if there is an occurence of an error. If this flag is set to true,
	// then Backup Run will start even if the pre backup script fails. If not specified or false, then backup run will not
	// start when script fails.
	ContinueOnError *bool `json:"continueOnError,omitempty"`
}

// NewCommonPreBackupScriptParams : Instantiate CommonPreBackupScriptParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewCommonPreBackupScriptParams(path string) (_model *CommonPreBackupScriptParams, err error) {
	_model = &CommonPreBackupScriptParams{
		Path: core.StringPtr(path),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCommonPreBackupScriptParams unmarshals an instance of CommonPreBackupScriptParams from the specified map of raw messages.
func UnmarshalCommonPreBackupScriptParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonPreBackupScriptParams)
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "params", &obj.Params)
	if err != nil {
		err = core.SDKErrorf(err, "", "params-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "timeoutSecs", &obj.TimeoutSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeoutSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isActive", &obj.IsActive)
	if err != nil {
		err = core.SDKErrorf(err, "", "isActive-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "continueOnError", &obj.ContinueOnError)
	if err != nil {
		err = core.SDKErrorf(err, "", "continueOnError-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonRecoverFileAndFolderInfo : Specifies the information about the specific file or folder to recover.
type CommonRecoverFileAndFolderInfo struct {
	// Specifies the absolute path to the file or folder.
	AbsolutePath *string `json:"absolutePath" validate:"required"`

	// Specifies the destination directory where the file/directory was copied.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	DestinationDir *string `json:"destinationDir,omitempty"`

	// Specifies whether this is a directory or not.
	IsDirectory *bool `json:"isDirectory,omitempty"`

	// Specifies the recovery status for this file or folder.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Status *string `json:"status,omitempty"`

	// Specify error messages about the file during recovery.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Messages []string `json:"messages,omitempty"`

	// Specify if the recovery is of type view file/folder.
	IsViewFileRecovery *bool `json:"isViewFileRecovery,omitempty"`
}

// Constants associated with the CommonRecoverFileAndFolderInfo.Status property.
// Specifies the recovery status for this file or folder.
const (
	CommonRecoverFileAndFolderInfo_Status_Copyinprogress       = "CopyInProgress"
	CommonRecoverFileAndFolderInfo_Status_Estimationdone       = "EstimationDone"
	CommonRecoverFileAndFolderInfo_Status_Estimationinprogress = "EstimationInProgress"
	CommonRecoverFileAndFolderInfo_Status_Finished             = "Finished"
	CommonRecoverFileAndFolderInfo_Status_Notstarted           = "NotStarted"
)

// NewCommonRecoverFileAndFolderInfo : Instantiate CommonRecoverFileAndFolderInfo (Generic Model Constructor)
func (*BackupRecoveryV1) NewCommonRecoverFileAndFolderInfo(absolutePath string) (_model *CommonRecoverFileAndFolderInfo, err error) {
	_model = &CommonRecoverFileAndFolderInfo{
		AbsolutePath: core.StringPtr(absolutePath),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCommonRecoverFileAndFolderInfo unmarshals an instance of CommonRecoverFileAndFolderInfo from the specified map of raw messages.
func UnmarshalCommonRecoverFileAndFolderInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonRecoverFileAndFolderInfo)
	err = core.UnmarshalPrimitive(m, "absolutePath", &obj.AbsolutePath)
	if err != nil {
		err = core.SDKErrorf(err, "", "absolutePath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "destinationDir", &obj.DestinationDir)
	if err != nil {
		err = core.SDKErrorf(err, "", "destinationDir-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isDirectory", &obj.IsDirectory)
	if err != nil {
		err = core.SDKErrorf(err, "", "isDirectory-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		err = core.SDKErrorf(err, "", "messages-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isViewFileRecovery", &obj.IsViewFileRecovery)
	if err != nil {
		err = core.SDKErrorf(err, "", "isViewFileRecovery-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonRecoverObjectSnapshotParams : Specifies the common snapshot parameters for a protected object.
type CommonRecoverObjectSnapshotParams struct {
	// Specifies the snapshot id.
	SnapshotID *string `json:"snapshotId" validate:"required"`

	// Specifies the timestamp (in microseconds. from epoch) for recovering to a point-in-time in the past.
	PointInTimeUsecs *int64 `json:"pointInTimeUsecs,omitempty"`

	// Specifies the protection group id of the object snapshot.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies the protection group name of the object snapshot.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the time when the snapshot is created in Unix timestamp epoch in microseconds.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SnapshotCreationTimeUsecs *int64 `json:"snapshotCreationTimeUsecs,omitempty"`

	// Specifies the information about the object for which the snapshot is taken.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ObjectInfo *CommonRecoverObjectSnapshotParamsObjectInfo `json:"objectInfo,omitempty"`

	// Specifies the snapshot target type.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SnapshotTargetType *string `json:"snapshotTargetType,omitempty"`

	// Specifies the archival target information if the snapshot is an archival snapshot.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ArchivalTargetInfo *CommonRecoverObjectSnapshotParamsArchivalTargetInfo `json:"archivalTargetInfo,omitempty"`

	// Progress monitor task id for Recovery of VM.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Specifies that user wants to perform standby restore if it is enabled for this object.
	RecoverFromStandby *bool `json:"recoverFromStandby,omitempty"`

	// Status of the Recovery. 'Running' indicates that the Recovery is still running. 'Canceled' indicates that the
	// Recovery has been cancelled. 'Canceling' indicates that the Recovery is in the process of being cancelled. 'Failed'
	// indicates that the Recovery has failed. 'Succeeded' indicates that the Recovery has finished successfully.
	// 'SucceededWithWarning' indicates that the Recovery finished successfully, but there were some warning messages.
	// 'Skipped' indicates that the Recovery task was skipped.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Status *string `json:"status,omitempty"`

	// Specifies the start time of the Recovery in Unix timestamp epoch in microseconds.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of the Recovery in Unix timestamp epoch in microseconds. This field will be populated only
	// after Recovery is finished.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specify error messages about the object.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Messages []string `json:"messages,omitempty"`

	// Specify the total bytes restored.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	BytesRestored *int64 `json:"bytesRestored,omitempty"`
}

// Constants associated with the CommonRecoverObjectSnapshotParams.SnapshotTargetType property.
// Specifies the snapshot target type.
const (
	CommonRecoverObjectSnapshotParams_SnapshotTargetType_Archival             = "Archival"
	CommonRecoverObjectSnapshotParams_SnapshotTargetType_Local                = "Local"
	CommonRecoverObjectSnapshotParams_SnapshotTargetType_Remote               = "Remote"
	CommonRecoverObjectSnapshotParams_SnapshotTargetType_Rpaasarchival        = "RpaasArchival"
	CommonRecoverObjectSnapshotParams_SnapshotTargetType_Storagearraysnapshot = "StorageArraySnapshot"
)

// Constants associated with the CommonRecoverObjectSnapshotParams.Status property.
// Status of the Recovery. 'Running' indicates that the Recovery is still running. 'Canceled' indicates that the
// Recovery has been cancelled. 'Canceling' indicates that the Recovery is in the process of being cancelled. 'Failed'
// indicates that the Recovery has failed. 'Succeeded' indicates that the Recovery has finished successfully.
// 'SucceededWithWarning' indicates that the Recovery finished successfully, but there were some warning messages.
// 'Skipped' indicates that the Recovery task was skipped.
const (
	CommonRecoverObjectSnapshotParams_Status_Accepted             = "Accepted"
	CommonRecoverObjectSnapshotParams_Status_Canceled             = "Canceled"
	CommonRecoverObjectSnapshotParams_Status_Canceling            = "Canceling"
	CommonRecoverObjectSnapshotParams_Status_Failed               = "Failed"
	CommonRecoverObjectSnapshotParams_Status_Finalizing           = "Finalizing"
	CommonRecoverObjectSnapshotParams_Status_Legalhold            = "LegalHold"
	CommonRecoverObjectSnapshotParams_Status_Missed               = "Missed"
	CommonRecoverObjectSnapshotParams_Status_Onhold               = "OnHold"
	CommonRecoverObjectSnapshotParams_Status_Running              = "Running"
	CommonRecoverObjectSnapshotParams_Status_Skipped              = "Skipped"
	CommonRecoverObjectSnapshotParams_Status_Succeeded            = "Succeeded"
	CommonRecoverObjectSnapshotParams_Status_Succeededwithwarning = "SucceededWithWarning"
)

// NewCommonRecoverObjectSnapshotParams : Instantiate CommonRecoverObjectSnapshotParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewCommonRecoverObjectSnapshotParams(snapshotID string) (_model *CommonRecoverObjectSnapshotParams, err error) {
	_model = &CommonRecoverObjectSnapshotParams{
		SnapshotID: core.StringPtr(snapshotID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCommonRecoverObjectSnapshotParams unmarshals an instance of CommonRecoverObjectSnapshotParams from the specified map of raw messages.
func UnmarshalCommonRecoverObjectSnapshotParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonRecoverObjectSnapshotParams)
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "pointInTimeUsecs", &obj.PointInTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "pointInTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotCreationTimeUsecs", &obj.SnapshotCreationTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotCreationTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objectInfo", &obj.ObjectInfo, UnmarshalCommonRecoverObjectSnapshotParamsObjectInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotTargetType", &obj.SnapshotTargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTargetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalTargetInfo", &obj.ArchivalTargetInfo, UnmarshalCommonRecoverObjectSnapshotParamsArchivalTargetInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoverFromStandby", &obj.RecoverFromStandby)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverFromStandby-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		err = core.SDKErrorf(err, "", "messages-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bytesRestored", &obj.BytesRestored)
	if err != nil {
		err = core.SDKErrorf(err, "", "bytesRestored-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonRecoverObjectSnapshotParamsArchivalTargetInfo : Specifies the archival target information if the snapshot is an archival snapshot.
type CommonRecoverObjectSnapshotParamsArchivalTargetInfo struct {
	// Specifies the archival target ID.
	TargetID *int64 `json:"targetId,omitempty"`

	// Specifies the archival task id. This is a protection group UID which only applies when archival type is 'Tape'.
	ArchivalTaskID *string `json:"archivalTaskId,omitempty"`

	// Specifies the archival target name.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the archival target type.
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the usage type for the target.
	UsageType *string `json:"usageType,omitempty"`

	// Specifies the ownership context for the target.
	OwnershipContext *string `json:"ownershipContext,omitempty"`

	// Specifies the tier info for archival.
	TierSettings *ArchivalTargetTierInfo `json:"tierSettings,omitempty"`
}

// Constants associated with the CommonRecoverObjectSnapshotParamsArchivalTargetInfo.TargetType property.
// Specifies the archival target type.
const (
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_TargetType_Cloud = "Cloud"
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_TargetType_Nas   = "Nas"
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_TargetType_Tape  = "Tape"
)

// Constants associated with the CommonRecoverObjectSnapshotParamsArchivalTargetInfo.UsageType property.
// Specifies the usage type for the target.
const (
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_UsageType_Archival = "Archival"
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_UsageType_Rpaas    = "Rpaas"
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_UsageType_Tiering  = "Tiering"
)

// Constants associated with the CommonRecoverObjectSnapshotParamsArchivalTargetInfo.OwnershipContext property.
// Specifies the ownership context for the target.
const (
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_OwnershipContext_Fortknox = "FortKnox"
	CommonRecoverObjectSnapshotParamsArchivalTargetInfo_OwnershipContext_Local    = "Local"
)

// UnmarshalCommonRecoverObjectSnapshotParamsArchivalTargetInfo unmarshals an instance of CommonRecoverObjectSnapshotParamsArchivalTargetInfo from the specified map of raw messages.
func UnmarshalCommonRecoverObjectSnapshotParamsArchivalTargetInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonRecoverObjectSnapshotParamsArchivalTargetInfo)
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTaskId", &obj.ArchivalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "usageType", &obj.UsageType)
	if err != nil {
		err = core.SDKErrorf(err, "", "usageType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownershipContext", &obj.OwnershipContext)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownershipContext-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tierSettings", &obj.TierSettings, UnmarshalArchivalTargetTierInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierSettings-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonRecoverObjectSnapshotParamsObjectInfo : Specifies the information about the object for which the snapshot is taken.
type CommonRecoverObjectSnapshotParamsObjectInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`
}

// Constants associated with the CommonRecoverObjectSnapshotParamsObjectInfo.Environment property.
// Specifies the environment of the object.
const (
	CommonRecoverObjectSnapshotParamsObjectInfo_Environment_Kphysical = "kPhysical"
	CommonRecoverObjectSnapshotParamsObjectInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the CommonRecoverObjectSnapshotParamsObjectInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kagent                 = "kAgent"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kawss3                 = "kAwsS3"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kfile                  = "kFile"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Knative                = "kNative"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	CommonRecoverObjectSnapshotParamsObjectInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the CommonRecoverObjectSnapshotParamsObjectInfo.OsType property.
// Specifies the operating system type of the object.
const (
	CommonRecoverObjectSnapshotParamsObjectInfo_OsType_Klinux   = "kLinux"
	CommonRecoverObjectSnapshotParamsObjectInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalCommonRecoverObjectSnapshotParamsObjectInfo unmarshals an instance of CommonRecoverObjectSnapshotParamsObjectInfo from the specified map of raw messages.
func UnmarshalCommonRecoverObjectSnapshotParamsObjectInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonRecoverObjectSnapshotParamsObjectInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionConfig : Specifies a connection associated with the source.
type ConnectionConfig struct {
	// Specifies the id of the connection.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// Specifies the entity id of the source. The source can a non-root entity.
	EntityID *int64 `json:"entityId,omitempty"`

	// Specifies the connector group id of connector groups.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Specifies the id of the connection in string format.
	DataSourceConnectionID *string `json:"dataSourceConnectionId,omitempty"`
}

// UnmarshalConnectionConfig unmarshals an instance of ConnectionConfig from the specified map of raw messages.
func UnmarshalConnectionConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionConfig)
	err = core.UnmarshalPrimitive(m, "connectionId", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "entityId", &obj.EntityID)
	if err != nil {
		err = core.SDKErrorf(err, "", "entityId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorGroupId", &obj.ConnectorGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataSourceConnectionId", &obj.DataSourceConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataSourceConnectionId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectorImageFile : Specifies the URL to access the connector image file and the platform on which the image can be deployed. The
// software version of the connector is assumed to be derivable from the name of the image file.
type ConnectorImageFile struct {
	// Specifies the platform on which the image can be deployed.
	ImageType *string `json:"imageType" validate:"required"`

	// Specifies the URL to access the file.
	URL *string `json:"url" validate:"required"`
}

// Constants associated with the ConnectorImageFile.ImageType property.
// Specifies the platform on which the image can be deployed.
const (
	ConnectorImageFile_ImageType_Vmware = "VMware"
	ConnectorImageFile_ImageType_Vsi    = "VSI"
)

// UnmarshalConnectorImageFile unmarshals an instance of ConnectorImageFile from the specified map of raw messages.
func UnmarshalConnectorImageFile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectorImageFile)
	err = core.UnmarshalPrimitive(m, "imageType", &obj.ImageType)
	if err != nil {
		err = core.SDKErrorf(err, "", "imageType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectorImageMetadata : Specifies information about the connector images for various platforms.
type ConnectorImageMetadata struct {
	// Specifies info about connector images for the supported platforms.
	ConnectorImageFileList []ConnectorImageFile `json:"connectorImageFileList" validate:"required"`
}

// UnmarshalConnectorImageMetadata unmarshals an instance of ConnectorImageMetadata from the specified map of raw messages.
func UnmarshalConnectorImageMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectorImageMetadata)
	err = core.UnmarshalModel(m, "connectorImageFileList", &obj.ConnectorImageFileList, UnmarshalConnectorImageFile)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorImageFileList-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectorMetadata : Specifies information about the connector.
type ConnectorMetadata struct {
	// Specifies information about the connector images for various platforms.
	ConnectorImageMetadata *ConnectorImageMetadata `json:"connectorImageMetadata,omitempty"`
}

// UnmarshalConnectorMetadata unmarshals an instance of ConnectorMetadata from the specified map of raw messages.
func UnmarshalConnectorMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectorMetadata)
	err = core.UnmarshalModel(m, "connectorImageMetadata", &obj.ConnectorImageMetadata, UnmarshalConnectorImageMetadata)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorImageMetadata-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CouchBaseOnPremSearchParams : Parameters required to search CouchBase on a cluster.
type CouchBaseOnPremSearchParams struct {
	// Specifies Couchbase object types be searched. For Couchbase it can only be set to 'CouchbaseBuckets'.
	CouchbaseObjectTypes []string `json:"couchbaseObjectTypes" validate:"required"`

	// Specifies the search string to search the Couchbase Objects.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// Constants associated with the CouchBaseOnPremSearchParams.CouchbaseObjectTypes property.
const (
	CouchBaseOnPremSearchParams_CouchbaseObjectTypes_Couchbasebuckets = "CouchbaseBuckets"
)

// NewCouchBaseOnPremSearchParams : Instantiate CouchBaseOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewCouchBaseOnPremSearchParams(couchbaseObjectTypes []string, searchString string) (_model *CouchBaseOnPremSearchParams, err error) {
	_model = &CouchBaseOnPremSearchParams{
		CouchbaseObjectTypes: couchbaseObjectTypes,
		SearchString:         core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCouchBaseOnPremSearchParams unmarshals an instance of CouchBaseOnPremSearchParams from the specified map of raw messages.
func UnmarshalCouchBaseOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CouchBaseOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "couchbaseObjectTypes", &obj.CouchbaseObjectTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "couchbaseObjectTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CouchbaseIndexedObject : Specifies a Couchbase indexed object.
type CouchbaseIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CouchbaseIndexedObjectSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies the Couchbase Object Type. For Couchbase this is alywas set to Bucket.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the CouchbaseIndexedObject.Type property.
// Specifies the Couchbase Object Type. For Couchbase this is alywas set to Bucket.
const (
	CouchbaseIndexedObject_Type_Couchbasebuckets = "CouchbaseBuckets"
)

// UnmarshalCouchbaseIndexedObject unmarshals an instance of CouchbaseIndexedObject from the specified map of raw messages.
func UnmarshalCouchbaseIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CouchbaseIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCouchbaseIndexedObjectSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CouchbaseIndexedObjectSourceInfo : Specifies the Source Object information.
type CouchbaseIndexedObjectSourceInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`
}

// Constants associated with the CouchbaseIndexedObjectSourceInfo.Environment property.
// Specifies the environment of the object.
const (
	CouchbaseIndexedObjectSourceInfo_Environment_Kphysical = "kPhysical"
	CouchbaseIndexedObjectSourceInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the CouchbaseIndexedObjectSourceInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kagent                 = "kAgent"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kawss3                 = "kAwsS3"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kfile                  = "kFile"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Knative                = "kNative"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	CouchbaseIndexedObjectSourceInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the CouchbaseIndexedObjectSourceInfo.OsType property.
// Specifies the operating system type of the object.
const (
	CouchbaseIndexedObjectSourceInfo_OsType_Klinux   = "kLinux"
	CouchbaseIndexedObjectSourceInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalCouchbaseIndexedObjectSourceInfo unmarshals an instance of CouchbaseIndexedObjectSourceInfo from the specified map of raw messages.
func UnmarshalCouchbaseIndexedObjectSourceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CouchbaseIndexedObjectSourceInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateDataSourceConnectionOptions : The CreateDataSourceConnection options.
type CreateDataSourceConnectionOptions struct {
	// Specifies the name of the connection being created. For a given tenant, different connections can't have the same
	// name. However, two (or more) different tenants can each have a connection with the same name.
	ConnectionName *string `json:"connectionName" validate:"required"`

	// Id of the tenant accessing the cluster.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateDataSourceConnectionOptions : Instantiate CreateDataSourceConnectionOptions
func (*BackupRecoveryV1) NewCreateDataSourceConnectionOptions(connectionName string) *CreateDataSourceConnectionOptions {
	return &CreateDataSourceConnectionOptions{
		ConnectionName: core.StringPtr(connectionName),
	}
}

// SetConnectionName : Allow user to set ConnectionName
func (_options *CreateDataSourceConnectionOptions) SetConnectionName(connectionName string) *CreateDataSourceConnectionOptions {
	_options.ConnectionName = core.StringPtr(connectionName)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateDataSourceConnectionOptions) SetXIBMTenantID(xIBMTenantID string) *CreateDataSourceConnectionOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDataSourceConnectionOptions) SetHeaders(param map[string]string) *CreateDataSourceConnectionOptions {
	options.Headers = param
	return options
}

// CreateDownloadFilesAndFoldersRecoveryOptions : The CreateDownloadFilesAndFoldersRecovery options.
type CreateDownloadFilesAndFoldersRecoveryOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the name of the recovery task. This field must be set and must be a unique name.
	Name *string `json:"name" validate:"required"`

	// Specifies the common snapshot parameters for a protected object.
	Object *CommonRecoverObjectSnapshotParams `json:"object" validate:"required"`

	// Specifies the list of files and folders to download.
	FilesAndFolders []FilesAndFoldersObject `json:"filesAndFolders" validate:"required"`

	// Specifies the list of documents to download using item ids. Only one of filesAndFolders or documents should be used.
	// Currently only files are supported by documents.
	Documents []DocumentObject `json:"documents,omitempty"`

	// If current recovery is child task triggered through another parent recovery operation, then this field will specify
	// the id of the parent recovery.
	ParentRecoveryID *string `json:"parentRecoveryId,omitempty"`

	// Specifies the glacier retrieval type when restoring or downloding files or folders from a Glacier-based cloud
	// snapshot.
	GlacierRetrievalType *string `json:"glacierRetrievalType,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDownloadFilesAndFoldersRecoveryOptions.GlacierRetrievalType property.
// Specifies the glacier retrieval type when restoring or downloding files or folders from a Glacier-based cloud
// snapshot.
const (
	CreateDownloadFilesAndFoldersRecoveryOptions_GlacierRetrievalType_Kexpeditednopcu   = "kExpeditedNoPCU"
	CreateDownloadFilesAndFoldersRecoveryOptions_GlacierRetrievalType_Kexpeditedwithpcu = "kExpeditedWithPCU"
	CreateDownloadFilesAndFoldersRecoveryOptions_GlacierRetrievalType_Kstandard         = "kStandard"
)

// NewCreateDownloadFilesAndFoldersRecoveryOptions : Instantiate CreateDownloadFilesAndFoldersRecoveryOptions
func (*BackupRecoveryV1) NewCreateDownloadFilesAndFoldersRecoveryOptions(xIBMTenantID string, name string, object *CommonRecoverObjectSnapshotParams, filesAndFolders []FilesAndFoldersObject) *CreateDownloadFilesAndFoldersRecoveryOptions {
	return &CreateDownloadFilesAndFoldersRecoveryOptions{
		XIBMTenantID:    core.StringPtr(xIBMTenantID),
		Name:            core.StringPtr(name),
		Object:          object,
		FilesAndFolders: filesAndFolders,
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetXIBMTenantID(xIBMTenantID string) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetName(name string) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetObject : Allow user to set Object
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetObject(object *CommonRecoverObjectSnapshotParams) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.Object = object
	return _options
}

// SetFilesAndFolders : Allow user to set FilesAndFolders
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetFilesAndFolders(filesAndFolders []FilesAndFoldersObject) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.FilesAndFolders = filesAndFolders
	return _options
}

// SetDocuments : Allow user to set Documents
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetDocuments(documents []DocumentObject) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.Documents = documents
	return _options
}

// SetParentRecoveryID : Allow user to set ParentRecoveryID
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetParentRecoveryID(parentRecoveryID string) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.ParentRecoveryID = core.StringPtr(parentRecoveryID)
	return _options
}

// SetGlacierRetrievalType : Allow user to set GlacierRetrievalType
func (_options *CreateDownloadFilesAndFoldersRecoveryOptions) SetGlacierRetrievalType(glacierRetrievalType string) *CreateDownloadFilesAndFoldersRecoveryOptions {
	_options.GlacierRetrievalType = core.StringPtr(glacierRetrievalType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDownloadFilesAndFoldersRecoveryOptions) SetHeaders(param map[string]string) *CreateDownloadFilesAndFoldersRecoveryOptions {
	options.Headers = param
	return options
}

// CreateProtectionGroupOptions : The CreateProtectionGroup options.
type CreateProtectionGroupOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the name of the Protection Group.
	Name *string `json:"name" validate:"required"`

	// Specifies the unique id of the Protection Policy associated with the Protection Group. The Policy provides retry
	// settings Protection Schedules, Priority, SLA, etc.
	PolicyID *string `json:"policyId" validate:"required"`

	// Specifies the environment type of the Protection Group.
	Environment *string `json:"environment" validate:"required"`

	// Specifies the priority of the Protection Group.
	Priority *string `json:"priority,omitempty"`

	// Specifies a description of the Protection Group.
	Description *string `json:"description,omitempty"`

	// Specifies the time of day. Used for scheduling purposes.
	StartTime *TimeOfDay `json:"startTime,omitempty"`

	// Specifies the end time in micro seconds for this Protection Group. If this is not specified, the Protection Group
	// won't be ended.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the last time this protection group was updated. If this is passed into a PUT request, then the backend
	// will validate that the timestamp passed in matches the time that the protection group was actually last modified. If
	// the two timestamps do not match, then the request will be rejected with a stale error.
	LastModifiedTimestampUsecs *int64 `json:"lastModifiedTimestampUsecs,omitempty"`

	// Specifies a policy for alerting users of the status of a Protection Group.
	AlertPolicy *ProtectionGroupAlertingPolicy `json:"alertPolicy,omitempty"`

	// Specifies the SLA parameters for this Protection Group.
	Sla []SlaRule `json:"sla,omitempty"`

	// Specifies whether the Protection Group will be written to HDD or SSD.
	QosPolicy *string `json:"qosPolicy,omitempty"`

	// Specifies whether currently executing jobs should abort if a blackout period specified by a policy starts. Available
	// only if the selected policy has at least one blackout period. Default value is false. This field should not be set
	// to true if 'pauseInBlackouts' is set to true.
	AbortInBlackouts *bool `json:"abortInBlackouts,omitempty"`

	// Specifies whether currently executing jobs should be paused if a blackout period specified by a policy starts.
	// Available only if the selected policy has at least one blackout period. Default value is false. This field should
	// not be set to true if 'abortInBlackouts' is sent as true.
	PauseInBlackouts *bool `json:"pauseInBlackouts,omitempty"`

	// Specifies if the the Protection Group is paused. New runs are not scheduled for the paused Protection Groups. Active
	// run if any is not impacted.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Specifies the advanced configuration for a protection job.
	AdvancedConfigs []KeyValuePair `json:"advancedConfigs,omitempty"`

	PhysicalParams *PhysicalProtectionGroupParams `json:"physicalParams,omitempty"`

	// Specifies the parameters specific to MSSQL Protection Group.
	MssqlParams *MSSQLProtectionGroupParams `json:"mssqlParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateProtectionGroupOptions.Environment property.
// Specifies the environment type of the Protection Group.
const (
	CreateProtectionGroupOptions_Environment_Kphysical = "kPhysical"
	CreateProtectionGroupOptions_Environment_Ksql      = "kSQL"
)

// Constants associated with the CreateProtectionGroupOptions.Priority property.
// Specifies the priority of the Protection Group.
const (
	CreateProtectionGroupOptions_Priority_Khigh   = "kHigh"
	CreateProtectionGroupOptions_Priority_Klow    = "kLow"
	CreateProtectionGroupOptions_Priority_Kmedium = "kMedium"
)

// Constants associated with the CreateProtectionGroupOptions.QosPolicy property.
// Specifies whether the Protection Group will be written to HDD or SSD.
const (
	CreateProtectionGroupOptions_QosPolicy_Kbackupall      = "kBackupAll"
	CreateProtectionGroupOptions_QosPolicy_Kbackuphdd      = "kBackupHDD"
	CreateProtectionGroupOptions_QosPolicy_Kbackupssd      = "kBackupSSD"
	CreateProtectionGroupOptions_QosPolicy_Ktestanddevhigh = "kTestAndDevHigh"
)

// NewCreateProtectionGroupOptions : Instantiate CreateProtectionGroupOptions
func (*BackupRecoveryV1) NewCreateProtectionGroupOptions(xIBMTenantID string, name string, policyID string, environment string) *CreateProtectionGroupOptions {
	return &CreateProtectionGroupOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Name:         core.StringPtr(name),
		PolicyID:     core.StringPtr(policyID),
		Environment:  core.StringPtr(environment),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateProtectionGroupOptions) SetXIBMTenantID(xIBMTenantID string) *CreateProtectionGroupOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateProtectionGroupOptions) SetName(name string) *CreateProtectionGroupOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *CreateProtectionGroupOptions) SetPolicyID(policyID string) *CreateProtectionGroupOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetEnvironment : Allow user to set Environment
func (_options *CreateProtectionGroupOptions) SetEnvironment(environment string) *CreateProtectionGroupOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetPriority : Allow user to set Priority
func (_options *CreateProtectionGroupOptions) SetPriority(priority string) *CreateProtectionGroupOptions {
	_options.Priority = core.StringPtr(priority)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateProtectionGroupOptions) SetDescription(description string) *CreateProtectionGroupOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetStartTime : Allow user to set StartTime
func (_options *CreateProtectionGroupOptions) SetStartTime(startTime *TimeOfDay) *CreateProtectionGroupOptions {
	_options.StartTime = startTime
	return _options
}

// SetEndTimeUsecs : Allow user to set EndTimeUsecs
func (_options *CreateProtectionGroupOptions) SetEndTimeUsecs(endTimeUsecs int64) *CreateProtectionGroupOptions {
	_options.EndTimeUsecs = core.Int64Ptr(endTimeUsecs)
	return _options
}

// SetLastModifiedTimestampUsecs : Allow user to set LastModifiedTimestampUsecs
func (_options *CreateProtectionGroupOptions) SetLastModifiedTimestampUsecs(lastModifiedTimestampUsecs int64) *CreateProtectionGroupOptions {
	_options.LastModifiedTimestampUsecs = core.Int64Ptr(lastModifiedTimestampUsecs)
	return _options
}

// SetAlertPolicy : Allow user to set AlertPolicy
func (_options *CreateProtectionGroupOptions) SetAlertPolicy(alertPolicy *ProtectionGroupAlertingPolicy) *CreateProtectionGroupOptions {
	_options.AlertPolicy = alertPolicy
	return _options
}

// SetSla : Allow user to set Sla
func (_options *CreateProtectionGroupOptions) SetSla(sla []SlaRule) *CreateProtectionGroupOptions {
	_options.Sla = sla
	return _options
}

// SetQosPolicy : Allow user to set QosPolicy
func (_options *CreateProtectionGroupOptions) SetQosPolicy(qosPolicy string) *CreateProtectionGroupOptions {
	_options.QosPolicy = core.StringPtr(qosPolicy)
	return _options
}

// SetAbortInBlackouts : Allow user to set AbortInBlackouts
func (_options *CreateProtectionGroupOptions) SetAbortInBlackouts(abortInBlackouts bool) *CreateProtectionGroupOptions {
	_options.AbortInBlackouts = core.BoolPtr(abortInBlackouts)
	return _options
}

// SetPauseInBlackouts : Allow user to set PauseInBlackouts
func (_options *CreateProtectionGroupOptions) SetPauseInBlackouts(pauseInBlackouts bool) *CreateProtectionGroupOptions {
	_options.PauseInBlackouts = core.BoolPtr(pauseInBlackouts)
	return _options
}

// SetIsPaused : Allow user to set IsPaused
func (_options *CreateProtectionGroupOptions) SetIsPaused(isPaused bool) *CreateProtectionGroupOptions {
	_options.IsPaused = core.BoolPtr(isPaused)
	return _options
}

// SetAdvancedConfigs : Allow user to set AdvancedConfigs
func (_options *CreateProtectionGroupOptions) SetAdvancedConfigs(advancedConfigs []KeyValuePair) *CreateProtectionGroupOptions {
	_options.AdvancedConfigs = advancedConfigs
	return _options
}

// SetPhysicalParams : Allow user to set PhysicalParams
func (_options *CreateProtectionGroupOptions) SetPhysicalParams(physicalParams *PhysicalProtectionGroupParams) *CreateProtectionGroupOptions {
	_options.PhysicalParams = physicalParams
	return _options
}

// SetMssqlParams : Allow user to set MssqlParams
func (_options *CreateProtectionGroupOptions) SetMssqlParams(mssqlParams *MSSQLProtectionGroupParams) *CreateProtectionGroupOptions {
	_options.MssqlParams = mssqlParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateProtectionGroupOptions) SetHeaders(param map[string]string) *CreateProtectionGroupOptions {
	options.Headers = param
	return options
}

// CreateProtectionGroupRunOptions : The CreateProtectionGroupRun options.
type CreateProtectionGroupRunOptions struct {
	// Specifies a unique id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Type of protection run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT (if
	// supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the
	// blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects
	// are always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture
	// the database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume
	// backup. It produces an image for bare metal recovery.
	RunType *string `json:"runType" validate:"required"`

	// Specifies the list of objects to be protected by this Protection Group run. These can be leaf objects or non-leaf
	// objects in the protection hierarchy. This must be specified only if a subset of objects from the Protection Groups
	// needs to be protected.
	Objects []RunObject `json:"objects,omitempty"`

	// Specifies the replication and archival targets.
	TargetsConfig *RunTargetsConfiguration `json:"targetsConfig,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateProtectionGroupRunOptions.RunType property.
// Type of protection run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT (if
// supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the
// blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are
// always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture the
// database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume
// backup. It produces an image for bare metal recovery.
const (
	CreateProtectionGroupRunOptions_RunType_Kfull                 = "kFull"
	CreateProtectionGroupRunOptions_RunType_Khydratecdp           = "kHydrateCDP"
	CreateProtectionGroupRunOptions_RunType_Klog                  = "kLog"
	CreateProtectionGroupRunOptions_RunType_Kregular              = "kRegular"
	CreateProtectionGroupRunOptions_RunType_Kstoragearraysnapshot = "kStorageArraySnapshot"
	CreateProtectionGroupRunOptions_RunType_Ksystem               = "kSystem"
)

// NewCreateProtectionGroupRunOptions : Instantiate CreateProtectionGroupRunOptions
func (*BackupRecoveryV1) NewCreateProtectionGroupRunOptions(id string, xIBMTenantID string, runType string) *CreateProtectionGroupRunOptions {
	return &CreateProtectionGroupRunOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		RunType:      core.StringPtr(runType),
	}
}

// SetID : Allow user to set ID
func (_options *CreateProtectionGroupRunOptions) SetID(id string) *CreateProtectionGroupRunOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateProtectionGroupRunOptions) SetXIBMTenantID(xIBMTenantID string) *CreateProtectionGroupRunOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRunType : Allow user to set RunType
func (_options *CreateProtectionGroupRunOptions) SetRunType(runType string) *CreateProtectionGroupRunOptions {
	_options.RunType = core.StringPtr(runType)
	return _options
}

// SetObjects : Allow user to set Objects
func (_options *CreateProtectionGroupRunOptions) SetObjects(objects []RunObject) *CreateProtectionGroupRunOptions {
	_options.Objects = objects
	return _options
}

// SetTargetsConfig : Allow user to set TargetsConfig
func (_options *CreateProtectionGroupRunOptions) SetTargetsConfig(targetsConfig *RunTargetsConfiguration) *CreateProtectionGroupRunOptions {
	_options.TargetsConfig = targetsConfig
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateProtectionGroupRunOptions) SetHeaders(param map[string]string) *CreateProtectionGroupRunOptions {
	options.Headers = param
	return options
}

// CreateProtectionGroupRunResponse : Specifies the response for create a protection run. On success, the system will accept the request and return the
// Protection Group id for which the run is supposed to start. The actual run may start at a later time if the system is
// busy. Consumers must query the Protection Group to see the run.
type CreateProtectionGroupRunResponse struct {
	// Specifies id of the Protection Group which must be polled for seeing the new run.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`
}

// UnmarshalCreateProtectionGroupRunResponse unmarshals an instance of CreateProtectionGroupRunResponse from the specified map of raw messages.
func UnmarshalCreateProtectionGroupRunResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateProtectionGroupRunResponse)
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateProtectionPolicyOptions : The CreateProtectionPolicy options.
type CreateProtectionPolicyOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the name of the Protection Policy.
	Name *string `json:"name" validate:"required"`

	// Specifies the backup schedule and retentions of a Protection Policy.
	BackupPolicy *BackupPolicy `json:"backupPolicy" validate:"required"`

	// Specifies the description of the Protection Policy.
	Description *string `json:"description,omitempty"`

	// List of Blackout Windows. If specified, this field defines blackout periods when new Group Runs are not started. If
	// a Group Run has been scheduled but not yet executed and the blackout period starts, the behavior depends on the
	// policy field AbortInBlackoutPeriod.
	BlackoutWindow []BlackoutWindow `json:"blackoutWindow,omitempty"`

	// Specifies additional retention policies that should be applied to the backup snapshots. A backup snapshot will be
	// retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []ExtendedRetentionPolicy `json:"extendedRetention,omitempty"`

	// Specifies the replication, archival and cloud spin targets of Protection Policy.
	RemoteTargetPolicy *TargetsConfiguration `json:"remoteTargetPolicy,omitempty"`

	// Specifies the configuration for cascaded replications. Using cascaded replication, replication cluster(Rx) can
	// further replicate and archive the snapshot copies to further targets. Its recommended to create cascaded
	// configuration where protection group will be created.
	CascadedTargetsConfig []CascadedTargetConfiguration `json:"cascadedTargetsConfig,omitempty"`

	// Retry Options of a Protection Policy when a Protection Group run fails.
	RetryOptions *RetryOptions `json:"retryOptions,omitempty"`

	// This field is now deprecated. Please use the DataLockConfig in the backup retention.
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies the current policy verison. Policy version is incremented for optionally supporting new features and
	// differentialting across releases.
	Version *int64 `json:"version,omitempty"`

	// Specifies true if Calender Based Schedule is supported by client. Default value is assumed as false for this
	// feature.
	IsCBSEnabled *bool `json:"isCBSEnabled,omitempty"`

	// Specifies the last time this Policy was updated. If this is passed into a PUT request, then the backend will
	// validate that the timestamp passed in matches the time that the policy was actually last modified. If the two
	// timestamps do not match, then the request will be rejected with a stale error.
	LastModificationTimeUsecs *int64 `json:"lastModificationTimeUsecs,omitempty"`

	// Specifies the parent policy template id to which the policy is linked to.
	TemplateID *string `json:"templateId,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateProtectionPolicyOptions.DataLock property.
// This field is now deprecated. Please use the DataLockConfig in the backup retention.
const (
	CreateProtectionPolicyOptions_DataLock_Administrative = "Administrative"
	CreateProtectionPolicyOptions_DataLock_Compliance     = "Compliance"
)

// NewCreateProtectionPolicyOptions : Instantiate CreateProtectionPolicyOptions
func (*BackupRecoveryV1) NewCreateProtectionPolicyOptions(xIBMTenantID string, name string, backupPolicy *BackupPolicy) *CreateProtectionPolicyOptions {
	return &CreateProtectionPolicyOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Name:         core.StringPtr(name),
		BackupPolicy: backupPolicy,
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateProtectionPolicyOptions) SetXIBMTenantID(xIBMTenantID string) *CreateProtectionPolicyOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateProtectionPolicyOptions) SetName(name string) *CreateProtectionPolicyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetBackupPolicy : Allow user to set BackupPolicy
func (_options *CreateProtectionPolicyOptions) SetBackupPolicy(backupPolicy *BackupPolicy) *CreateProtectionPolicyOptions {
	_options.BackupPolicy = backupPolicy
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateProtectionPolicyOptions) SetDescription(description string) *CreateProtectionPolicyOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetBlackoutWindow : Allow user to set BlackoutWindow
func (_options *CreateProtectionPolicyOptions) SetBlackoutWindow(blackoutWindow []BlackoutWindow) *CreateProtectionPolicyOptions {
	_options.BlackoutWindow = blackoutWindow
	return _options
}

// SetExtendedRetention : Allow user to set ExtendedRetention
func (_options *CreateProtectionPolicyOptions) SetExtendedRetention(extendedRetention []ExtendedRetentionPolicy) *CreateProtectionPolicyOptions {
	_options.ExtendedRetention = extendedRetention
	return _options
}

// SetRemoteTargetPolicy : Allow user to set RemoteTargetPolicy
func (_options *CreateProtectionPolicyOptions) SetRemoteTargetPolicy(remoteTargetPolicy *TargetsConfiguration) *CreateProtectionPolicyOptions {
	_options.RemoteTargetPolicy = remoteTargetPolicy
	return _options
}

// SetCascadedTargetsConfig : Allow user to set CascadedTargetsConfig
func (_options *CreateProtectionPolicyOptions) SetCascadedTargetsConfig(cascadedTargetsConfig []CascadedTargetConfiguration) *CreateProtectionPolicyOptions {
	_options.CascadedTargetsConfig = cascadedTargetsConfig
	return _options
}

// SetRetryOptions : Allow user to set RetryOptions
func (_options *CreateProtectionPolicyOptions) SetRetryOptions(retryOptions *RetryOptions) *CreateProtectionPolicyOptions {
	_options.RetryOptions = retryOptions
	return _options
}

// SetDataLock : Allow user to set DataLock
func (_options *CreateProtectionPolicyOptions) SetDataLock(dataLock string) *CreateProtectionPolicyOptions {
	_options.DataLock = core.StringPtr(dataLock)
	return _options
}

// SetVersion : Allow user to set Version
func (_options *CreateProtectionPolicyOptions) SetVersion(version int64) *CreateProtectionPolicyOptions {
	_options.Version = core.Int64Ptr(version)
	return _options
}

// SetIsCBSEnabled : Allow user to set IsCBSEnabled
func (_options *CreateProtectionPolicyOptions) SetIsCBSEnabled(isCBSEnabled bool) *CreateProtectionPolicyOptions {
	_options.IsCBSEnabled = core.BoolPtr(isCBSEnabled)
	return _options
}

// SetLastModificationTimeUsecs : Allow user to set LastModificationTimeUsecs
func (_options *CreateProtectionPolicyOptions) SetLastModificationTimeUsecs(lastModificationTimeUsecs int64) *CreateProtectionPolicyOptions {
	_options.LastModificationTimeUsecs = core.Int64Ptr(lastModificationTimeUsecs)
	return _options
}

// SetTemplateID : Allow user to set TemplateID
func (_options *CreateProtectionPolicyOptions) SetTemplateID(templateID string) *CreateProtectionPolicyOptions {
	_options.TemplateID = core.StringPtr(templateID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateProtectionPolicyOptions) SetHeaders(param map[string]string) *CreateProtectionPolicyOptions {
	options.Headers = param
	return options
}

// CreateRecoveryOptions : The CreateRecovery options.
type CreateRecoveryOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the name of the Recovery.
	Name *string `json:"name" validate:"required"`

	// Specifies the type of environment of snapshots for which the Recovery has to be performed.
	SnapshotEnvironment *string `json:"snapshotEnvironment" validate:"required"`

	// Specifies the recovery options specific to Physical environment.
	PhysicalParams *RecoverPhysicalParams `json:"physicalParams,omitempty"`

	// Specifies the recovery options specific to Sql environment.
	MssqlParams *RecoverSqlParams `json:"mssqlParams,omitempty"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateRecoveryOptions.SnapshotEnvironment property.
// Specifies the type of environment of snapshots for which the Recovery has to be performed.
const (
	CreateRecoveryOptions_SnapshotEnvironment_Kphysical = "kPhysical"
	CreateRecoveryOptions_SnapshotEnvironment_Ksql      = "kSQL"
)

// Constants associated with the CreateRecoveryOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	CreateRecoveryOptions_RequestInitiatorType_Helios = "Helios"
	CreateRecoveryOptions_RequestInitiatorType_Uiauto = "UIAuto"
	CreateRecoveryOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// NewCreateRecoveryOptions : Instantiate CreateRecoveryOptions
func (*BackupRecoveryV1) NewCreateRecoveryOptions(xIBMTenantID string, name string, snapshotEnvironment string) *CreateRecoveryOptions {
	return &CreateRecoveryOptions{
		XIBMTenantID:        core.StringPtr(xIBMTenantID),
		Name:                core.StringPtr(name),
		SnapshotEnvironment: core.StringPtr(snapshotEnvironment),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateRecoveryOptions) SetXIBMTenantID(xIBMTenantID string) *CreateRecoveryOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateRecoveryOptions) SetName(name string) *CreateRecoveryOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSnapshotEnvironment : Allow user to set SnapshotEnvironment
func (_options *CreateRecoveryOptions) SetSnapshotEnvironment(snapshotEnvironment string) *CreateRecoveryOptions {
	_options.SnapshotEnvironment = core.StringPtr(snapshotEnvironment)
	return _options
}

// SetPhysicalParams : Allow user to set PhysicalParams
func (_options *CreateRecoveryOptions) SetPhysicalParams(physicalParams *RecoverPhysicalParams) *CreateRecoveryOptions {
	_options.PhysicalParams = physicalParams
	return _options
}

// SetMssqlParams : Allow user to set MssqlParams
func (_options *CreateRecoveryOptions) SetMssqlParams(mssqlParams *RecoverSqlParams) *CreateRecoveryOptions {
	_options.MssqlParams = mssqlParams
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *CreateRecoveryOptions) SetRequestInitiatorType(requestInitiatorType string) *CreateRecoveryOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateRecoveryOptions) SetHeaders(param map[string]string) *CreateRecoveryOptions {
	options.Headers = param
	return options
}

// CreateUpgradeTaskOptions : The CreateUpgradeTask options.
type CreateUpgradeTaskOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies agent IDs to be upgraded in the task.
	AgentIDs []int64 `json:"agentIDs,omitempty"`

	// Specifies the description of the task.
	Description *string `json:"description,omitempty"`

	// Specifies the name of the task.
	Name *string `json:"name,omitempty"`

	// Specifies the task that needs to be retried.
	RetryTaskID *int64 `json:"retryTaskId,omitempty"`

	// Specifies the time before which the upgrade task should start execution as a Unix epoch Timestamp (in microseconds).
	// If this is not specified the task will start anytime after scheduleTimeUsecs.
	ScheduleEndTimeUsecs *int64 `json:"scheduleEndTimeUsecs,omitempty"`

	// Specifies the start time of the task specified by the user as a Unix epoch Timestamp (in microseconds). If no
	// schedule is specified, the agents will be upgraded immediately.
	ScheduleTimeUsecs *int64 `json:"scheduleTimeUsecs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateUpgradeTaskOptions : Instantiate CreateUpgradeTaskOptions
func (*BackupRecoveryV1) NewCreateUpgradeTaskOptions(xIBMTenantID string) *CreateUpgradeTaskOptions {
	return &CreateUpgradeTaskOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *CreateUpgradeTaskOptions) SetXIBMTenantID(xIBMTenantID string) *CreateUpgradeTaskOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetAgentIDs : Allow user to set AgentIDs
func (_options *CreateUpgradeTaskOptions) SetAgentIDs(agentIDs []int64) *CreateUpgradeTaskOptions {
	_options.AgentIDs = agentIDs
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateUpgradeTaskOptions) SetDescription(description string) *CreateUpgradeTaskOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateUpgradeTaskOptions) SetName(name string) *CreateUpgradeTaskOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRetryTaskID : Allow user to set RetryTaskID
func (_options *CreateUpgradeTaskOptions) SetRetryTaskID(retryTaskID int64) *CreateUpgradeTaskOptions {
	_options.RetryTaskID = core.Int64Ptr(retryTaskID)
	return _options
}

// SetScheduleEndTimeUsecs : Allow user to set ScheduleEndTimeUsecs
func (_options *CreateUpgradeTaskOptions) SetScheduleEndTimeUsecs(scheduleEndTimeUsecs int64) *CreateUpgradeTaskOptions {
	_options.ScheduleEndTimeUsecs = core.Int64Ptr(scheduleEndTimeUsecs)
	return _options
}

// SetScheduleTimeUsecs : Allow user to set ScheduleTimeUsecs
func (_options *CreateUpgradeTaskOptions) SetScheduleTimeUsecs(scheduleTimeUsecs int64) *CreateUpgradeTaskOptions {
	_options.ScheduleTimeUsecs = core.Int64Ptr(scheduleTimeUsecs)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateUpgradeTaskOptions) SetHeaders(param map[string]string) *CreateUpgradeTaskOptions {
	options.Headers = param
	return options
}

// CreationInfo : Specifies the information about the creation of the protection group or recovery.
type CreationInfo struct {
	// Specifies the name of the user who created the protection group or recovery.
	UserName *string `json:"userName,omitempty"`
}

// UnmarshalCreationInfo unmarshals an instance of CreationInfo from the specified map of raw messages.
func UnmarshalCreationInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreationInfo)
	err = core.UnmarshalPrimitive(m, "userName", &obj.UserName)
	if err != nil {
		err = core.SDKErrorf(err, "", "userName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CustomTagParams : Specifies tag information of custom tags to be applied to various resources when converting and deploying a VM to
// AWS.
type CustomTagParams struct {
	// Specifies key of the custom tag.
	Key *string `json:"key" validate:"required"`

	// Specifies value of the custom tag.
	Value *string `json:"value" validate:"required"`
}

// NewCustomTagParams : Instantiate CustomTagParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewCustomTagParams(key string, value string) (_model *CustomTagParams, err error) {
	_model = &CustomTagParams{
		Key:   core.StringPtr(key),
		Value: core.StringPtr(value),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalCustomTagParams unmarshals an instance of CustomTagParams from the specified map of raw messages.
func UnmarshalCustomTagParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CustomTagParams)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataLockConfig : Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
// Protection Groups using this policy will be kept for the last N days as specified in the duration of the datalock.
// During that time, the snapshots cannot be deleted.
type DataLockConfig struct {
	// Specifies the type of WORM retention type.
	// 'Compliance' implies WORM retention is set for compliance reason.
	// 'Administrative' implies WORM retention is set for administrative purposes.
	Mode *string `json:"mode" validate:"required"`

	// Specificies the Retention Unit of a dataLock measured in days, months or years. <br> If unit is 'Months', then
	// number specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of
	// retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied
	// to 365. <br> If duration is 2 and unit is 'Months' then number of retention days will be 365 * 2 = 730 days.
	Unit *string `json:"unit" validate:"required"`

	// Specifies the duration for a dataLock. <br> Example. If duration is 7 and unit is Months, the dataLock is enabled
	// for last 7 * 30 = 210 days of the backup.
	Duration *int64 `json:"duration" validate:"required"`

	// Specifies whether objects in the external target associated with this policy need to be made immutable.
	EnableWormOnExternalTarget *bool `json:"enableWormOnExternalTarget,omitempty"`
}

// Constants associated with the DataLockConfig.Mode property.
// Specifies the type of WORM retention type.
// 'Compliance' implies WORM retention is set for compliance reason.
// 'Administrative' implies WORM retention is set for administrative purposes.
const (
	DataLockConfig_Mode_Administrative = "Administrative"
	DataLockConfig_Mode_Compliance     = "Compliance"
)

// Constants associated with the DataLockConfig.Unit property.
// Specificies the Retention Unit of a dataLock measured in days, months or years. <br> If unit is 'Months', then number
// specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of
// retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied to
// 365. <br> If duration is 2 and unit is 'Months' then number of retention days will be 365 * 2 = 730 days.
const (
	DataLockConfig_Unit_Days   = "Days"
	DataLockConfig_Unit_Months = "Months"
	DataLockConfig_Unit_Weeks  = "Weeks"
	DataLockConfig_Unit_Years  = "Years"
)

// NewDataLockConfig : Instantiate DataLockConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewDataLockConfig(mode string, unit string, duration int64) (_model *DataLockConfig, err error) {
	_model = &DataLockConfig{
		Mode:     core.StringPtr(mode),
		Unit:     core.StringPtr(unit),
		Duration: core.Int64Ptr(duration),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalDataLockConfig unmarshals an instance of DataLockConfig from the specified map of raw messages.
func UnmarshalDataLockConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataLockConfig)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "duration", &obj.Duration)
	if err != nil {
		err = core.SDKErrorf(err, "", "duration-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "enableWormOnExternalTarget", &obj.EnableWormOnExternalTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableWormOnExternalTarget-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataLockConstraints : Specifies the dataLock constraints for local or target snapshot.
type DataLockConstraints struct {
	// Specifies the type of WORM retention type. <br>'Compliance' implies WORM retention is set for compliance reason.
	// <br>'Administrative' implies WORM retention is set for administrative purposes.
	Mode *string `json:"mode,omitempty"`

	// Specifies the expiry time of attempt in Unix epoch Timestamp (in microseconds).
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`
}

// Constants associated with the DataLockConstraints.Mode property.
// Specifies the type of WORM retention type. <br>'Compliance' implies WORM retention is set for compliance reason.
// <br>'Administrative' implies WORM retention is set for administrative purposes.
const (
	DataLockConstraints_Mode_Administrative = "Administrative"
	DataLockConstraints_Mode_Compliance     = "Compliance"
)

// UnmarshalDataLockConstraints unmarshals an instance of DataLockConstraints from the specified map of raw messages.
func UnmarshalDataLockConstraints(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataLockConstraints)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataSourceConnection : Specifies all the properties of the data-source connection. A connection is specified by an ID that's guaranteed to
// be unique. A connection is associated with exactly one tenant. A connection can be thought of as a subset of its
// tenant's connectors and can contain 0 or more connectors within it. A connector can only be associated with one
// connection at max at a given time.
type DataSourceConnection struct {
	// Specifies the unique ID of the connection.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ConnectionID *string `json:"connectionId,omitempty"`

	// Specifies the name of the connection. For a given tenant, different connections can't have the same name. However,
	// two (or more) different tenants can each have a connection with the same name.
	ConnectionName *string `json:"connectionName" validate:"required"`

	// Specifies the IDs of the connectors in this connection.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ConnectorIds []string `json:"connectorIds,omitempty"`

	// Specifies a token that can be used to register a connector against this connection.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	RegistrationToken *string `json:"registrationToken,omitempty"`

	// Specifies the tenant ID of the connection.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies the connector ID that is currently in upgrade.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	UpgradingConnectorID *string `json:"upgradingConnectorId,omitempty"`
}

// UnmarshalDataSourceConnection unmarshals an instance of DataSourceConnection from the specified map of raw messages.
func UnmarshalDataSourceConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataSourceConnection)
	err = core.UnmarshalPrimitive(m, "connectionId", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectionName", &obj.ConnectionName)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorIds", &obj.ConnectorIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "registrationToken", &obj.RegistrationToken)
	if err != nil {
		err = core.SDKErrorf(err, "", "registrationToken-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantId", &obj.TenantID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "upgradingConnectorId", &obj.UpgradingConnectorID)
	if err != nil {
		err = core.SDKErrorf(err, "", "upgradingConnectorId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataSourceConnectionList : Specifies a list of data-source connections.
type DataSourceConnectionList struct {
	Connections []DataSourceConnection `json:"connections,omitempty"`
}

// UnmarshalDataSourceConnectionList unmarshals an instance of DataSourceConnectionList from the specified map of raw messages.
func UnmarshalDataSourceConnectionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataSourceConnectionList)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalDataSourceConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataSourceConnector : Specifies all the properties of the data-source connector. A connector is uniquely identified by a 'connectorId' for
// a given tenant. A connector resource is created internally by the system when a connector is registered with the
// cluster and thus, a POST API doesn't exist and isn't needed for creating a connector resource. An active connector is
// always associated with a data-source connection belonging to its tenant. A connector can never be associated with
// more than one connection/tenant/cluster at a given time. A connector also has a name which can be updated by the
// user. Names of connectors for a tenant or across tenants needn't be unique. Also, a connector constituent can
// optionally have two actively used NICs (dual-homed connectors).
type DataSourceConnector struct {
	// Specifies the IP of the connector's NIC facing the cluster.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ClusterSideIp *string `json:"clusterSideIp,omitempty"`

	// Specifies the ID of the connection to which this connector belongs.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ConnectionID *string `json:"connectionId,omitempty"`

	// Specifies the unique ID of the connector.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ConnectorID *string `json:"connectorId,omitempty"`

	// Specifies the name of the connector. The name of a connector need not be unique within a tenant or across tenants.
	// The name of the connector can be updated as needed.
	ConnectorName *string `json:"connectorName,omitempty"`

	// Specifies status information for the data-source connector. For example if it's currently connected to the cluster,
	// when it last connected to the cluster successfully, etc.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ConnectivityStatus *DataSourceConnectorConnectivityStatus `json:"connectivityStatus,omitempty"`

	// Specifies the connector's software version.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SoftwareVersion *string `json:"softwareVersion,omitempty"`

	// Specifies the IP of the connector's NIC facing the sources of the tenant to which the connector belongs.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	TenantSideIp *string `json:"tenantSideIp,omitempty"`

	// Specifies upgrade status for the data-source connector. For example when the upgrade started, current status of the
	// upgrade, errors for upgrade failure etc.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	UpgradeStatus *DataSourceConnectorUpgradeStatus `json:"upgradeStatus,omitempty"`
}

// UnmarshalDataSourceConnector unmarshals an instance of DataSourceConnector from the specified map of raw messages.
func UnmarshalDataSourceConnector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataSourceConnector)
	err = core.UnmarshalPrimitive(m, "clusterSideIp", &obj.ClusterSideIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterSideIp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectionId", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorId", &obj.ConnectorID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorName", &obj.ConnectorName)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connectivityStatus", &obj.ConnectivityStatus, UnmarshalDataSourceConnectorConnectivityStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectivityStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "softwareVersion", &obj.SoftwareVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "softwareVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantSideIp", &obj.TenantSideIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantSideIp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "upgradeStatus", &obj.UpgradeStatus, UnmarshalDataSourceConnectorUpgradeStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "upgradeStatus-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataSourceConnectorConnectivityStatus : Specifies status information for the data-source connector. For example if it's currently connected to the cluster,
// when it last connected to the cluster successfully, etc.
type DataSourceConnectorConnectivityStatus struct {
	// Specifies whether the connector is currently connected to the cluster.
	IsConnected *bool `json:"isConnected" validate:"required"`

	// Specifies the last timestamp in UNIX time (seconds) when the connector had successfully connected to the cluster.
	// This property can be present even if the connector is currently disconnected.
	LastConnectedTimestampSecs *int64 `json:"lastConnectedTimestampSecs,omitempty"`

	// Specifies error message when the connector is unable to connect to the cluster.
	Message *string `json:"message,omitempty"`
}

// UnmarshalDataSourceConnectorConnectivityStatus unmarshals an instance of DataSourceConnectorConnectivityStatus from the specified map of raw messages.
func UnmarshalDataSourceConnectorConnectivityStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataSourceConnectorConnectivityStatus)
	err = core.UnmarshalPrimitive(m, "isConnected", &obj.IsConnected)
	if err != nil {
		err = core.SDKErrorf(err, "", "isConnected-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastConnectedTimestampSecs", &obj.LastConnectedTimestampSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastConnectedTimestampSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataSourceConnectorList : Specifies a list of data-source connectors.
type DataSourceConnectorList struct {
	Connectors []DataSourceConnector `json:"connectors,omitempty"`
}

// UnmarshalDataSourceConnectorList unmarshals an instance of DataSourceConnectorList from the specified map of raw messages.
func UnmarshalDataSourceConnectorList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataSourceConnectorList)
	err = core.UnmarshalModel(m, "connectors", &obj.Connectors, UnmarshalDataSourceConnector)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectors-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DataSourceConnectorUpgradeStatus : Specifies upgrade status for the data-source connector. For example when the upgrade started, current status of the
// upgrade, errors for upgrade failure etc.
type DataSourceConnectorUpgradeStatus struct {
	// Specifies the last timestamp in UNIX time (milliseconds) when the connector upgrade status was fetched.
	LastStatusFetchedTimestampMsecs *int64 `json:"lastStatusFetchedTimestampMsecs,omitempty"`

	// Specifies error message for upgrade failure.
	Message *string `json:"message,omitempty"`

	// Specifies the last timestamp in UNIX time (milliseconds) when the connector upgrade was triggered.
	StartTimestampMSecs *int64 `json:"startTimestampMSecs,omitempty"`

	// Specifies the last fetched upgrade status of the connector.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the DataSourceConnectorUpgradeStatus.Status property.
// Specifies the last fetched upgrade status of the connector.
const (
	DataSourceConnectorUpgradeStatus_Status_Failed     = "Failed"
	DataSourceConnectorUpgradeStatus_Status_Inprogress = "InProgress"
	DataSourceConnectorUpgradeStatus_Status_Notstarted = "NotStarted"
	DataSourceConnectorUpgradeStatus_Status_Succeeded  = "Succeeded"
)

// UnmarshalDataSourceConnectorUpgradeStatus unmarshals an instance of DataSourceConnectorUpgradeStatus from the specified map of raw messages.
func UnmarshalDataSourceConnectorUpgradeStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataSourceConnectorUpgradeStatus)
	err = core.UnmarshalPrimitive(m, "lastStatusFetchedTimestampMsecs", &obj.LastStatusFetchedTimestampMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastStatusFetchedTimestampMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimestampMSecs", &obj.StartTimestampMSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimestampMSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DatabaseFileInformation : Specifies information about a database file.
type DatabaseFileInformation struct {
	// Specifies the format type of the file that SQL database stores the data. Specifies the format type of the file that
	// SQL database stores the data. 'kRows' refers to a data file 'kLog' refers to a log file 'kFileStream' refers to a
	// directory containing FILESTREAM data 'kNotSupportedType' is for information purposes only. Not supported.
	// 'kFullText' refers to a full-text catalog.
	FileType *string `json:"fileType,omitempty"`

	// Specifies the full path of the database file on the SQL host machine.
	FullPath *string `json:"fullPath,omitempty"`

	// Specifies the last known size of the database file.
	SizeBytes *int64 `json:"sizeBytes,omitempty"`
}

// Constants associated with the DatabaseFileInformation.FileType property.
// Specifies the format type of the file that SQL database stores the data. Specifies the format type of the file that
// SQL database stores the data. 'kRows' refers to a data file 'kLog' refers to a log file 'kFileStream' refers to a
// directory containing FILESTREAM data 'kNotSupportedType' is for information purposes only. Not supported. 'kFullText'
// refers to a full-text catalog.
const (
	DatabaseFileInformation_FileType_Kfilestream       = "kFileStream"
	DatabaseFileInformation_FileType_Kfulltext         = "kFullText"
	DatabaseFileInformation_FileType_Klog              = "kLog"
	DatabaseFileInformation_FileType_Knotsupportedtype = "kNotSupportedType"
	DatabaseFileInformation_FileType_Krows             = "kRows"
)

// UnmarshalDatabaseFileInformation unmarshals an instance of DatabaseFileInformation from the specified map of raw messages.
func UnmarshalDatabaseFileInformation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DatabaseFileInformation)
	err = core.UnmarshalPrimitive(m, "fileType", &obj.FileType)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fullPath", &obj.FullPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullPath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sizeBytes", &obj.SizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "sizeBytes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DaySchedule : Specifies settings that define a schedule for a Protection Group runs to start after certain number of days.
type DaySchedule struct {
	// Specifies a factor to multiply the unit by, to determine the backup schedule. <br> Example: If 'frequency' set to 2
	// and the unit is 'Hours', then Snapshots are backed up every 2 hours. <br> This field is only applicable if unit is
	// 'Minutes', 'Hours' or 'Days'.
	Frequency *int64 `json:"frequency" validate:"required"`
}

// NewDaySchedule : Instantiate DaySchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewDaySchedule(frequency int64) (_model *DaySchedule, err error) {
	_model = &DaySchedule{
		Frequency: core.Int64Ptr(frequency),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalDaySchedule unmarshals an instance of DaySchedule from the specified map of raw messages.
func UnmarshalDaySchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DaySchedule)
	err = core.UnmarshalPrimitive(m, "frequency", &obj.Frequency)
	if err != nil {
		err = core.SDKErrorf(err, "", "frequency-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DayTimeParams : Specifies the Day Time Parameters.
type DayTimeParams struct {
	// Specifies the day of the week (such as 'kMonday') for scheduling throttling. Specifies a day in a week such as
	// 'kSunday', 'kMonday', etc.
	Day *string `json:"day,omitempty"`

	// Specifies the time in hours and minutes.
	Time *Time `json:"time,omitempty"`
}

// Constants associated with the DayTimeParams.Day property.
// Specifies the day of the week (such as 'kMonday') for scheduling throttling. Specifies a day in a week such as
// 'kSunday', 'kMonday', etc.
const (
	DayTimeParams_Day_Kfriday    = "kFriday"
	DayTimeParams_Day_Kmonday    = "kMonday"
	DayTimeParams_Day_Ksaturday  = "kSaturday"
	DayTimeParams_Day_Ksunday    = "kSunday"
	DayTimeParams_Day_Kthursday  = "kThursday"
	DayTimeParams_Day_Ktuesday   = "kTuesday"
	DayTimeParams_Day_Kwednesday = "kWednesday"
)

// UnmarshalDayTimeParams unmarshals an instance of DayTimeParams from the specified map of raw messages.
func UnmarshalDayTimeParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DayTimeParams)
	err = core.UnmarshalPrimitive(m, "day", &obj.Day)
	if err != nil {
		err = core.SDKErrorf(err, "", "day-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "time", &obj.Time, UnmarshalTime)
	if err != nil {
		err = core.SDKErrorf(err, "", "time-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DayTimeWindow : Specifies the Day Time Window Parameters.
type DayTimeWindow struct {
	// Specifies the Day Time Parameters.
	EndTime *DayTimeParams `json:"endTime,omitempty"`

	// Specifies the Day Time Parameters.
	StartTime *DayTimeParams `json:"startTime,omitempty"`
}

// UnmarshalDayTimeWindow unmarshals an instance of DayTimeWindow from the specified map of raw messages.
func UnmarshalDayTimeWindow(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DayTimeWindow)
	err = core.UnmarshalModel(m, "endTime", &obj.EndTime, UnmarshalDayTimeParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTime-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "startTime", &obj.StartTime, UnmarshalDayTimeParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTime-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteDataSourceConnectionOptions : The DeleteDataSourceConnection options.
type DeleteDataSourceConnectionOptions struct {
	// Specifies the ID of the connection, connectors belonging to which are to be fetched.
	ConnectionID *string `json:"connectionId" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDataSourceConnectionOptions : Instantiate DeleteDataSourceConnectionOptions
func (*BackupRecoveryV1) NewDeleteDataSourceConnectionOptions(connectionID string, xIBMTenantID string) *DeleteDataSourceConnectionOptions {
	return &DeleteDataSourceConnectionOptions{
		ConnectionID: core.StringPtr(connectionID),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *DeleteDataSourceConnectionOptions) SetConnectionID(connectionID string) *DeleteDataSourceConnectionOptions {
	_options.ConnectionID = core.StringPtr(connectionID)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DeleteDataSourceConnectionOptions) SetXIBMTenantID(xIBMTenantID string) *DeleteDataSourceConnectionOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDataSourceConnectionOptions) SetHeaders(param map[string]string) *DeleteDataSourceConnectionOptions {
	options.Headers = param
	return options
}

// DeleteDataSourceConnectorOptions : The DeleteDataSourceConnector options.
type DeleteDataSourceConnectorOptions struct {
	// Specifies the unique ID of the connector which is to be deleted.
	ConnectorID *string `json:"connectorId" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDataSourceConnectorOptions : Instantiate DeleteDataSourceConnectorOptions
func (*BackupRecoveryV1) NewDeleteDataSourceConnectorOptions(connectorID string, xIBMTenantID string) *DeleteDataSourceConnectorOptions {
	return &DeleteDataSourceConnectorOptions{
		ConnectorID:  core.StringPtr(connectorID),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetConnectorID : Allow user to set ConnectorID
func (_options *DeleteDataSourceConnectorOptions) SetConnectorID(connectorID string) *DeleteDataSourceConnectorOptions {
	_options.ConnectorID = core.StringPtr(connectorID)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DeleteDataSourceConnectorOptions) SetXIBMTenantID(xIBMTenantID string) *DeleteDataSourceConnectorOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDataSourceConnectorOptions) SetHeaders(param map[string]string) *DeleteDataSourceConnectorOptions {
	options.Headers = param
	return options
}

// DeleteProtectionGroupOptions : The DeleteProtectionGroup options.
type DeleteProtectionGroupOptions struct {
	// Specifies a unique id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is
	// deleted.
	DeleteSnapshots *bool `json:"deleteSnapshots,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteProtectionGroupOptions : Instantiate DeleteProtectionGroupOptions
func (*BackupRecoveryV1) NewDeleteProtectionGroupOptions(id string, xIBMTenantID string) *DeleteProtectionGroupOptions {
	return &DeleteProtectionGroupOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteProtectionGroupOptions) SetID(id string) *DeleteProtectionGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DeleteProtectionGroupOptions) SetXIBMTenantID(xIBMTenantID string) *DeleteProtectionGroupOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetDeleteSnapshots : Allow user to set DeleteSnapshots
func (_options *DeleteProtectionGroupOptions) SetDeleteSnapshots(deleteSnapshots bool) *DeleteProtectionGroupOptions {
	_options.DeleteSnapshots = core.BoolPtr(deleteSnapshots)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteProtectionGroupOptions) SetHeaders(param map[string]string) *DeleteProtectionGroupOptions {
	options.Headers = param
	return options
}

// DeleteProtectionPolicyOptions : The DeleteProtectionPolicy options.
type DeleteProtectionPolicyOptions struct {
	// Specifies a unique id of the Protection Policy to delete.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteProtectionPolicyOptions : Instantiate DeleteProtectionPolicyOptions
func (*BackupRecoveryV1) NewDeleteProtectionPolicyOptions(id string, xIBMTenantID string) *DeleteProtectionPolicyOptions {
	return &DeleteProtectionPolicyOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteProtectionPolicyOptions) SetID(id string) *DeleteProtectionPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DeleteProtectionPolicyOptions) SetXIBMTenantID(xIBMTenantID string) *DeleteProtectionPolicyOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteProtectionPolicyOptions) SetHeaders(param map[string]string) *DeleteProtectionPolicyOptions {
	options.Headers = param
	return options
}

// DeleteProtectionSourceRegistrationOptions : The DeleteProtectionSourceRegistration options.
type DeleteProtectionSourceRegistrationOptions struct {
	// Specifies the ID of the Protection Source Registration.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteProtectionSourceRegistrationOptions : Instantiate DeleteProtectionSourceRegistrationOptions
func (*BackupRecoveryV1) NewDeleteProtectionSourceRegistrationOptions(id int64, xIBMTenantID string) *DeleteProtectionSourceRegistrationOptions {
	return &DeleteProtectionSourceRegistrationOptions{
		ID:           core.Int64Ptr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteProtectionSourceRegistrationOptions) SetID(id int64) *DeleteProtectionSourceRegistrationOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DeleteProtectionSourceRegistrationOptions) SetXIBMTenantID(xIBMTenantID string) *DeleteProtectionSourceRegistrationOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteProtectionSourceRegistrationOptions) SetHeaders(param map[string]string) *DeleteProtectionSourceRegistrationOptions {
	options.Headers = param
	return options
}

// DocumentLibraryItem : Specifies a Document Library indexed item.
type DocumentLibraryItem struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the Unix timestamp epoch in seconds at which this item is created.
	CreationTimeSecs *int64 `json:"creationTimeSecs,omitempty"`

	// Specifies the file type.
	FileType *string `json:"fileType,omitempty"`

	// Specifies the id of the document library item.
	ItemID *string `json:"itemId,omitempty"`

	// Specifies the size in bytes for the indexed item.
	ItemSize *int64 `json:"itemSize,omitempty"`

	// Specifies the email of the owner of the document library item.
	OwnerEmail *string `json:"ownerEmail,omitempty"`

	// Specifies the name of the owner of the document library item.
	OwnerName *string `json:"ownerName,omitempty"`
}

// Constants associated with the DocumentLibraryItem.FileType property.
// Specifies the file type.
const (
	DocumentLibraryItem_FileType_Directory = "Directory"
	DocumentLibraryItem_FileType_File      = "File"
	DocumentLibraryItem_FileType_Symlink   = "Symlink"
)

// UnmarshalDocumentLibraryItem unmarshals an instance of DocumentLibraryItem from the specified map of raw messages.
func UnmarshalDocumentLibraryItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DocumentLibraryItem)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "creationTimeSecs", &obj.CreationTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fileType", &obj.FileType)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "itemId", &obj.ItemID)
	if err != nil {
		err = core.SDKErrorf(err, "", "itemId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "itemSize", &obj.ItemSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "itemSize-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownerEmail", &obj.OwnerEmail)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownerEmail-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownerName", &obj.OwnerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownerName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DocumentObject : Specifies a document to download using item id.
type DocumentObject struct {
	// Specifies whether the document is a directory. Since currently only files are supported this should always be false.
	IsDirectory *bool `json:"isDirectory,omitempty"`

	// Specifies the item id of the document.
	ItemID *string `json:"itemId" validate:"required"`
}

// NewDocumentObject : Instantiate DocumentObject (Generic Model Constructor)
func (*BackupRecoveryV1) NewDocumentObject(itemID string) (_model *DocumentObject, err error) {
	_model = &DocumentObject{
		ItemID: core.StringPtr(itemID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalDocumentObject unmarshals an instance of DocumentObject from the specified map of raw messages.
func UnmarshalDocumentObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DocumentObject)
	err = core.UnmarshalPrimitive(m, "isDirectory", &obj.IsDirectory)
	if err != nil {
		err = core.SDKErrorf(err, "", "isDirectory-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "itemId", &obj.ItemID)
	if err != nil {
		err = core.SDKErrorf(err, "", "itemId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DownloadAgentOptions : The DownloadAgent options.
type DownloadAgentOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the platform for which agent needs to be downloaded.
	Platform *string `json:"platform" validate:"required"`

	// Linux agent parameters.
	LinuxParams *LinuxAgentParams `json:"linuxParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the DownloadAgentOptions.Platform property.
// Specifies the platform for which agent needs to be downloaded.
const (
	DownloadAgentOptions_Platform_Klinux   = "kLinux"
	DownloadAgentOptions_Platform_Kwindows = "kWindows"
)

// NewDownloadAgentOptions : Instantiate DownloadAgentOptions
func (*BackupRecoveryV1) NewDownloadAgentOptions(xIBMTenantID string, platform string) *DownloadAgentOptions {
	return &DownloadAgentOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Platform:     core.StringPtr(platform),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DownloadAgentOptions) SetXIBMTenantID(xIBMTenantID string) *DownloadAgentOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetPlatform : Allow user to set Platform
func (_options *DownloadAgentOptions) SetPlatform(platform string) *DownloadAgentOptions {
	_options.Platform = core.StringPtr(platform)
	return _options
}

// SetLinuxParams : Allow user to set LinuxParams
func (_options *DownloadAgentOptions) SetLinuxParams(linuxParams *LinuxAgentParams) *DownloadAgentOptions {
	_options.LinuxParams = linuxParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DownloadAgentOptions) SetHeaders(param map[string]string) *DownloadAgentOptions {
	options.Headers = param
	return options
}

// DownloadFilesFromRecoveryOptions : The DownloadFilesFromRecovery options.
type DownloadFilesFromRecoveryOptions struct {
	// Specifies the id of a Recovery.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the start offset of file chunk to be downloaded.
	StartOffset *int64 `json:"startOffset,omitempty"`

	// Specifies the length of bytes to download. This can not be greater than 8MB (8388608 byets).
	Length *int64 `json:"length,omitempty"`

	// Specifies the downloaded type, i.e: error, success_files_list.
	FileType *string `json:"fileType,omitempty"`

	// Specifies the name of the source on which restore is done.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the start time of restore task.
	StartTime *string `json:"startTime,omitempty"`

	// Specifies if objects of all the organizations under the hierarchy of the logged in user's organization should be
	// returned.
	IncludeTenants *bool `json:"includeTenants,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDownloadFilesFromRecoveryOptions : Instantiate DownloadFilesFromRecoveryOptions
func (*BackupRecoveryV1) NewDownloadFilesFromRecoveryOptions(id string, xIBMTenantID string) *DownloadFilesFromRecoveryOptions {
	return &DownloadFilesFromRecoveryOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *DownloadFilesFromRecoveryOptions) SetID(id string) *DownloadFilesFromRecoveryOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DownloadFilesFromRecoveryOptions) SetXIBMTenantID(xIBMTenantID string) *DownloadFilesFromRecoveryOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetStartOffset : Allow user to set StartOffset
func (_options *DownloadFilesFromRecoveryOptions) SetStartOffset(startOffset int64) *DownloadFilesFromRecoveryOptions {
	_options.StartOffset = core.Int64Ptr(startOffset)
	return _options
}

// SetLength : Allow user to set Length
func (_options *DownloadFilesFromRecoveryOptions) SetLength(length int64) *DownloadFilesFromRecoveryOptions {
	_options.Length = core.Int64Ptr(length)
	return _options
}

// SetFileType : Allow user to set FileType
func (_options *DownloadFilesFromRecoveryOptions) SetFileType(fileType string) *DownloadFilesFromRecoveryOptions {
	_options.FileType = core.StringPtr(fileType)
	return _options
}

// SetSourceName : Allow user to set SourceName
func (_options *DownloadFilesFromRecoveryOptions) SetSourceName(sourceName string) *DownloadFilesFromRecoveryOptions {
	_options.SourceName = core.StringPtr(sourceName)
	return _options
}

// SetStartTime : Allow user to set StartTime
func (_options *DownloadFilesFromRecoveryOptions) SetStartTime(startTime string) *DownloadFilesFromRecoveryOptions {
	_options.StartTime = core.StringPtr(startTime)
	return _options
}

// SetIncludeTenants : Allow user to set IncludeTenants
func (_options *DownloadFilesFromRecoveryOptions) SetIncludeTenants(includeTenants bool) *DownloadFilesFromRecoveryOptions {
	_options.IncludeTenants = core.BoolPtr(includeTenants)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DownloadFilesFromRecoveryOptions) SetHeaders(param map[string]string) *DownloadFilesFromRecoveryOptions {
	options.Headers = param
	return options
}

// DownloadIndexedFileOptions : The DownloadIndexedFile options.
type DownloadIndexedFileOptions struct {
	// Specifies the snapshot id to download from.
	SnapshotsID *string `json:"snapshotsId" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the path to the file to download. If no path is specified and snapshot environment is kVMWare, VMX file
	// for VMware will be downloaded. For other snapshot environments, this field must be specified.
	FilePath *string `json:"filePath,omitempty"`

	// Specifies if NVRAM file for VMware should be downloaded.
	NvramFile *bool `json:"nvramFile,omitempty"`

	// Specifies the number of attempts the protection run took to create this file.
	RetryAttempt *int64 `json:"retryAttempt,omitempty"`

	// Specifies the start offset of file chunk to be downloaded.
	StartOffset *int64 `json:"startOffset,omitempty"`

	// Specifies the length of bytes to download. This can not be greater than 8MB (8388608 byets).
	Length *int64 `json:"length,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDownloadIndexedFileOptions : Instantiate DownloadIndexedFileOptions
func (*BackupRecoveryV1) NewDownloadIndexedFileOptions(snapshotsID string, xIBMTenantID string) *DownloadIndexedFileOptions {
	return &DownloadIndexedFileOptions{
		SnapshotsID:  core.StringPtr(snapshotsID),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetSnapshotsID : Allow user to set SnapshotsID
func (_options *DownloadIndexedFileOptions) SetSnapshotsID(snapshotsID string) *DownloadIndexedFileOptions {
	_options.SnapshotsID = core.StringPtr(snapshotsID)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *DownloadIndexedFileOptions) SetXIBMTenantID(xIBMTenantID string) *DownloadIndexedFileOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetFilePath : Allow user to set FilePath
func (_options *DownloadIndexedFileOptions) SetFilePath(filePath string) *DownloadIndexedFileOptions {
	_options.FilePath = core.StringPtr(filePath)
	return _options
}

// SetNvramFile : Allow user to set NvramFile
func (_options *DownloadIndexedFileOptions) SetNvramFile(nvramFile bool) *DownloadIndexedFileOptions {
	_options.NvramFile = core.BoolPtr(nvramFile)
	return _options
}

// SetRetryAttempt : Allow user to set RetryAttempt
func (_options *DownloadIndexedFileOptions) SetRetryAttempt(retryAttempt int64) *DownloadIndexedFileOptions {
	_options.RetryAttempt = core.Int64Ptr(retryAttempt)
	return _options
}

// SetStartOffset : Allow user to set StartOffset
func (_options *DownloadIndexedFileOptions) SetStartOffset(startOffset int64) *DownloadIndexedFileOptions {
	_options.StartOffset = core.Int64Ptr(startOffset)
	return _options
}

// SetLength : Allow user to set Length
func (_options *DownloadIndexedFileOptions) SetLength(length int64) *DownloadIndexedFileOptions {
	_options.Length = core.Int64Ptr(length)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DownloadIndexedFileOptions) SetHeaders(param map[string]string) *DownloadIndexedFileOptions {
	options.Headers = param
	return options
}

// Email : Specifies an email or an email folder.
type Email struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// "Specifies the email addresses of all the BCC receipients of this email.".
	BccRecipientAddresses []string `json:"bccRecipientAddresses,omitempty"`

	// "Specifies the email addresses of all the CC receipients of this email.".
	CcRecipientAddresses []string `json:"ccRecipientAddresses,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this item is created.".
	CreatedTimeSecs *int64 `json:"createdTimeSecs,omitempty"`

	// Specifies the directory path to this mailbox item.
	DirectoryPath *string `json:"directoryPath,omitempty"`

	// Specifies the email addresses of a contact.
	EmailAddresses []string `json:"emailAddresses,omitempty"`

	// Specifies the subject of this email.
	EmailSubject *string `json:"emailSubject,omitempty"`

	// Specifies the contact's first name.
	FirstName *string `json:"firstName,omitempty"`

	// Specify the name of the email folder.
	FolderName *string `json:"folderName,omitempty"`

	// Specifies whether email has an attachment.
	HasAttachment *bool `json:"hasAttachment,omitempty"`

	// Specifies the id of the email object.
	ID *string `json:"id,omitempty"`

	// "Specifies the name of the person who modified this item.".
	LastModificationName *string `json:"lastModificationName,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this item was modified.".
	LastModificationTimeSecs *int64 `json:"lastModificationTimeSecs,omitempty"`

	// Specifies the contact's last name.
	LastName *string `json:"lastName,omitempty"`

	// "Specifies the email addresses of all the optional attendees of this calendar item.".
	OptionalAttendeesAddresses []string `json:"optionalAttendeesAddresses,omitempty"`

	// "Specifies the calendar item organizer's email address.".
	OrganizerAddress *string `json:"organizerAddress,omitempty"`

	// Specifies the id of parent folder the mailbox item.
	ParentFolderID *int64 `json:"parentFolderId,omitempty"`

	// Specifies the path to this mailbox item.
	Path *string `json:"path,omitempty"`

	// "Specifies the Protection Group id protecting the mailbox.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the Protection Group name protecting the mailbox item.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this email is received.".
	ReceivedTimeSecs *int64 `json:"receivedTimeSecs,omitempty"`

	// "Specifies the email addresses of all receipients of this email.".
	RecipientAddresses []string `json:"recipientAddresses,omitempty"`

	// "Specifies the email addresses of all required attendees of this calendar item.".
	RequiredAttendeesAddresses []string `json:"requiredAttendeesAddresses,omitempty"`

	// Specifies the sender's email address.
	SenderAddress *string `json:"senderAddress,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this email is sent.".
	SentTimeSecs *int64 `json:"sentTimeSecs,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this task item was completed.".
	TaskCompletionDateTimeSecs *int64 `json:"taskCompletionDateTimeSecs,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this task item is due.".
	TaskDueDateTimeSecs *int64 `json:"taskDueDateTimeSecs,omitempty"`

	// Specifies the task item status type.
	TaskStatus *string `json:"taskStatus,omitempty"`

	// "Specify the tenant id to which this email belongs to.".
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies the Mailbox item type.
	Type *string `json:"type,omitempty"`

	// Specifies the Object Summary.
	UserObjectInfo *ObjectSummary `json:"userObjectInfo,omitempty"`
}

// Constants associated with the Email.TaskStatus property.
// Specifies the task item status type.
const (
	Email_TaskStatus_Completed       = "Completed"
	Email_TaskStatus_Deferred        = "Deferred"
	Email_TaskStatus_Inprogress      = "InProgress"
	Email_TaskStatus_Notstarted      = "NotStarted"
	Email_TaskStatus_Waitingonothers = "WaitingOnOthers"
)

// Constants associated with the Email.Type property.
// Specifies the Mailbox item type.
const (
	Email_Type_Calendar = "Calendar"
	Email_Type_Contact  = "Contact"
	Email_Type_Email    = "Email"
	Email_Type_Folder   = "Folder"
	Email_Type_Note     = "Note"
	Email_Type_Task     = "Task"
)

// UnmarshalEmail unmarshals an instance of Email from the specified map of raw messages.
func UnmarshalEmail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Email)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bccRecipientAddresses", &obj.BccRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "bccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ccRecipientAddresses", &obj.CcRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "ccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "createdTimeSecs", &obj.CreatedTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "directoryPath", &obj.DirectoryPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "directoryPath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "emailAddresses", &obj.EmailAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "emailSubject", &obj.EmailSubject)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailSubject-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "firstName", &obj.FirstName)
	if err != nil {
		err = core.SDKErrorf(err, "", "firstName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "folderName", &obj.FolderName)
	if err != nil {
		err = core.SDKErrorf(err, "", "folderName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasAttachment", &obj.HasAttachment)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasAttachment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModificationName", &obj.LastModificationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModificationName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModificationTimeSecs", &obj.LastModificationTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModificationTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastName", &obj.LastName)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "optionalAttendeesAddresses", &obj.OptionalAttendeesAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "optionalAttendeesAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "organizerAddress", &obj.OrganizerAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "organizerAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentFolderId", &obj.ParentFolderID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentFolderId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedTimeSecs", &obj.ReceivedTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recipientAddresses", &obj.RecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "recipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "requiredAttendeesAddresses", &obj.RequiredAttendeesAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "requiredAttendeesAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "senderAddress", &obj.SenderAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "senderAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sentTimeSecs", &obj.SentTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "sentTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "taskCompletionDateTimeSecs", &obj.TaskCompletionDateTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskCompletionDateTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "taskDueDateTimeSecs", &obj.TaskDueDateTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskDueDateTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "taskStatus", &obj.TaskStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantId", &obj.TenantID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "userObjectInfo", &obj.UserObjectInfo, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "userObjectInfo-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EntityExternalMetadata : Specifies the External metadata of an entity.
type EntityExternalMetadata struct {
	// Specifies the entity metadata for maintenance mode.
	MaintenanceModeConfig *MaintenanceModeConfig `json:"maintenanceModeConfig,omitempty"`
}

// UnmarshalEntityExternalMetadata unmarshals an instance of EntityExternalMetadata from the specified map of raw messages.
func UnmarshalEntityExternalMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EntityExternalMetadata)
	err = core.UnmarshalModel(m, "maintenanceModeConfig", &obj.MaintenanceModeConfig, UnmarshalMaintenanceModeConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "maintenanceModeConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EntityGroupParams : Specifies struct with basic group details.
type EntityGroupParams struct {
	// Specifies domain name of the user.
	Domain *string `json:"domain,omitempty"`

	// Specifies group name of the group.
	GroupName *string `json:"groupName,omitempty"`

	// Specifies unique Security ID (SID) of the user.
	Sid *string `json:"sid,omitempty"`

	// Specifies the tenants to which the group belongs to.
	TenantIds []string `json:"tenantIds,omitempty"`
}

// UnmarshalEntityGroupParams unmarshals an instance of EntityGroupParams from the specified map of raw messages.
func UnmarshalEntityGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EntityGroupParams)
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		err = core.SDKErrorf(err, "", "domain-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "groupName", &obj.GroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "groupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sid", &obj.Sid)
	if err != nil {
		err = core.SDKErrorf(err, "", "sid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantIds", &obj.TenantIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EntityPermissionInfo : Specifies the permission information of entities.
type EntityPermissionInfo struct {
	// Specifies the entity id.
	EntityID *int64 `json:"entityId,omitempty"`

	Groups []EntityGroupParams `json:"groups,omitempty"`

	// Specifies whether the Entity Permission Information is inferred or not. For example, SQL application hosted over
	// vCenter will have inferred entity permission information.
	IsInferred *bool `json:"isInferred,omitempty"`

	// Specifies whether this entity is registered by the SP or not. This will be populated only if the entity is a root
	// entity. Refer to magneto/base/permissions.proto for details.
	IsRegisteredBySp *bool `json:"isRegisteredBySp,omitempty"`

	// Specifies the tenant id that registered this entity. This will be populated only if the entity is a root entity.
	RegisteringTenantID *string `json:"registeringTenantId,omitempty"`

	// Specifies struct with basic tenant details.
	Tenant *EntityTenantInfo `json:"tenant,omitempty"`

	Users []EntityUserInfo `json:"users,omitempty"`
}

// UnmarshalEntityPermissionInfo unmarshals an instance of EntityPermissionInfo from the specified map of raw messages.
func UnmarshalEntityPermissionInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EntityPermissionInfo)
	err = core.UnmarshalPrimitive(m, "entityId", &obj.EntityID)
	if err != nil {
		err = core.SDKErrorf(err, "", "entityId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "groups", &obj.Groups, UnmarshalEntityGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "groups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isInferred", &obj.IsInferred)
	if err != nil {
		err = core.SDKErrorf(err, "", "isInferred-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isRegisteredBySp", &obj.IsRegisteredBySp)
	if err != nil {
		err = core.SDKErrorf(err, "", "isRegisteredBySp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "registeringTenantId", &obj.RegisteringTenantID)
	if err != nil {
		err = core.SDKErrorf(err, "", "registeringTenantId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tenant", &obj.Tenant, UnmarshalEntityTenantInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenant-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "users", &obj.Users, UnmarshalEntityUserInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "users-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EntityTenantInfo : Specifies struct with basic tenant details.
type EntityTenantInfo struct {
	// Specifies if this tenant is bifrost enabled or not.
	BifrostEnabled *bool `json:"bifrostEnabled,omitempty"`

	// Specifies whether this tenant is manged on helios.
	IsManagedOnHelios *bool `json:"isManagedOnHelios,omitempty"`

	// Specifies name of the tenant.
	Name *bool `json:"name,omitempty"`

	// Specifies the unique id of the tenant.
	TenantID *bool `json:"tenantId,omitempty"`
}

// UnmarshalEntityTenantInfo unmarshals an instance of EntityTenantInfo from the specified map of raw messages.
func UnmarshalEntityTenantInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EntityTenantInfo)
	err = core.UnmarshalPrimitive(m, "bifrostEnabled", &obj.BifrostEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "bifrostEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isManagedOnHelios", &obj.IsManagedOnHelios)
	if err != nil {
		err = core.SDKErrorf(err, "", "isManagedOnHelios-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantId", &obj.TenantID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EntityUserInfo : Specifies struct with basic user details.
type EntityUserInfo struct {
	// Specifies domain name of the user.
	Domain *string `json:"domain,omitempty"`

	// Specifies unique Security ID (SID) of the user.
	Sid *string `json:"sid,omitempty"`

	// Specifies the tenant to which the user belongs to.
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies user name of the user.
	UserName *string `json:"userName,omitempty"`
}

// UnmarshalEntityUserInfo unmarshals an instance of EntityUserInfo from the specified map of raw messages.
func UnmarshalEntityUserInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EntityUserInfo)
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		err = core.SDKErrorf(err, "", "domain-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sid", &obj.Sid)
	if err != nil {
		err = core.SDKErrorf(err, "", "sid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantId", &obj.TenantID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userName", &obj.UserName)
	if err != nil {
		err = core.SDKErrorf(err, "", "userName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Error : Object that holds the error object.
type Error struct {
	// Specifies the error code.
	ErrorCode *string `json:"errorCode,omitempty"`

	// Specifies the error message.
	Message *string `json:"message,omitempty"`

	// Specifies the TaskLogId of the failed task.
	TaskLogID *string `json:"taskLogId,omitempty"`
}

// UnmarshalError unmarshals an instance of Error from the specified map of raw messages.
func UnmarshalError(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Error)
	err = core.UnmarshalPrimitive(m, "errorCode", &obj.ErrorCode)
	if err != nil {
		err = core.SDKErrorf(err, "", "errorCode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "taskLogId", &obj.TaskLogID)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskLogId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExchangeIndexedObject : Specifies the Exchange Indexed object.
type ExchangeIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the name of the Exchange database corresponding to the mailbox.
	DatabaseName *string `json:"databaseName,omitempty"`

	// Specifies the email corresponding to the mailbox.
	Email *string `json:"email,omitempty"`

	// Specifies the name of the Exchange mailbox.
	ObjectName *string `json:"objectName,omitempty"`
}

// UnmarshalExchangeIndexedObject unmarshals an instance of ExchangeIndexedObject from the specified map of raw messages.
func UnmarshalExchangeIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExchangeIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "databaseName", &obj.DatabaseName)
	if err != nil {
		err = core.SDKErrorf(err, "", "databaseName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		err = core.SDKErrorf(err, "", "email-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectName", &obj.ObjectName)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExtendedRetentionPolicy : Specifies additional retention policies to apply to backup snapshots.
type ExtendedRetentionPolicy struct {
	// Specifies a schedule frequency and schedule unit for Extended Retentions.
	Schedule *ExtendedRetentionSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`

	// The backup run type to which this extended retention applies to. If this is not set, the extended retention will be
	// applicable to all non-log backup types. Currently, the only value that can be set here is Full.
	// 'Regular' indicates a incremental (CBT) backup. Incremental backups utilizing CBT (if supported) are captured of the
	// target protection objects. The first run of a Regular schedule captures all the blocks.
	// 'Full' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are always
	// captured and Change Block Tracking (CBT) is not utilized.
	// 'Log' indicates a Database Log backup. Capture the database transaction logs to allow rolling back to a specific
	// point in time.
	// 'System' indicates a system backup. System backups are used to do bare metal recovery of the system to a specific
	// point in time.
	RunType *string `json:"runType,omitempty"`

	// Specifies the unique identifier for the target getting added. This field need to be passed olny when policies are
	// updated.
	ConfigID *string `json:"configId,omitempty"`
}

// Constants associated with the ExtendedRetentionPolicy.RunType property.
// The backup run type to which this extended retention applies to. If this is not set, the extended retention will be
// applicable to all non-log backup types. Currently, the only value that can be set here is Full.
// 'Regular' indicates a incremental (CBT) backup. Incremental backups utilizing CBT (if supported) are captured of the
// target protection objects. The first run of a Regular schedule captures all the blocks.
// 'Full' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are always
// captured and Change Block Tracking (CBT) is not utilized.
// 'Log' indicates a Database Log backup. Capture the database transaction logs to allow rolling back to a specific
// point in time.
// 'System' indicates a system backup. System backups are used to do bare metal recovery of the system to a specific
// point in time.
const (
	ExtendedRetentionPolicy_RunType_Full                 = "Full"
	ExtendedRetentionPolicy_RunType_Log                  = "Log"
	ExtendedRetentionPolicy_RunType_Regular              = "Regular"
	ExtendedRetentionPolicy_RunType_Storagearraysnapshot = "StorageArraySnapshot"
	ExtendedRetentionPolicy_RunType_System               = "System"
)

// NewExtendedRetentionPolicy : Instantiate ExtendedRetentionPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewExtendedRetentionPolicy(schedule *ExtendedRetentionSchedule, retention *Retention) (_model *ExtendedRetentionPolicy, err error) {
	_model = &ExtendedRetentionPolicy{
		Schedule:  schedule,
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalExtendedRetentionPolicy unmarshals an instance of ExtendedRetentionPolicy from the specified map of raw messages.
func UnmarshalExtendedRetentionPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExtendedRetentionPolicy)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalExtendedRetentionSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runType", &obj.RunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "runType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExtendedRetentionSchedule : Specifies a schedule frequency and schedule unit for Extended Retentions.
type ExtendedRetentionSchedule struct {
	// Specifies the unit interval for retention of Snapshots. <br>'Runs' means that the Snapshot copy retained after the
	// number of Protection Group Runs equals the number specified in the frequency. <br>'Hours' means that the Snapshot
	// copy retained hourly at the frequency set in the frequency, for example if scheduleFrequency is 2, the copy occurs
	// every 2 hours. <br>'Days' means that the Snapshot copy gets retained daily at the frequency set in the frequency.
	// <br>'Weeks' means that the Snapshot copy is retained weekly at the frequency set in the frequency. <br>'Months'
	// means that the Snapshot copy is retained monthly at the frequency set in the Frequency. <br>'Years' means that the
	// Snapshot copy is retained yearly at the frequency set in the Frequency.
	Unit *string `json:"unit" validate:"required"`

	// Specifies a factor to multiply the unit by, to determine the retention schedule. For example if set to 2 and the
	// unit is hourly, then Snapshots from the first eligible Job Run for every 2 hour period is retained.
	Frequency *int64 `json:"frequency,omitempty"`
}

// Constants associated with the ExtendedRetentionSchedule.Unit property.
// Specifies the unit interval for retention of Snapshots. <br>'Runs' means that the Snapshot copy retained after the
// number of Protection Group Runs equals the number specified in the frequency. <br>'Hours' means that the Snapshot
// copy retained hourly at the frequency set in the frequency, for example if scheduleFrequency is 2, the copy occurs
// every 2 hours. <br>'Days' means that the Snapshot copy gets retained daily at the frequency set in the frequency.
// <br>'Weeks' means that the Snapshot copy is retained weekly at the frequency set in the frequency. <br>'Months' means
// that the Snapshot copy is retained monthly at the frequency set in the Frequency. <br>'Years' means that the Snapshot
// copy is retained yearly at the frequency set in the Frequency.
const (
	ExtendedRetentionSchedule_Unit_Days   = "Days"
	ExtendedRetentionSchedule_Unit_Hours  = "Hours"
	ExtendedRetentionSchedule_Unit_Months = "Months"
	ExtendedRetentionSchedule_Unit_Runs   = "Runs"
	ExtendedRetentionSchedule_Unit_Weeks  = "Weeks"
	ExtendedRetentionSchedule_Unit_Years  = "Years"
)

// NewExtendedRetentionSchedule : Instantiate ExtendedRetentionSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewExtendedRetentionSchedule(unit string) (_model *ExtendedRetentionSchedule, err error) {
	_model = &ExtendedRetentionSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalExtendedRetentionSchedule unmarshals an instance of ExtendedRetentionSchedule from the specified map of raw messages.
func UnmarshalExtendedRetentionSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExtendedRetentionSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "frequency", &obj.Frequency)
	if err != nil {
		err = core.SDKErrorf(err, "", "frequency-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExternalVendorCustomProperties : Specifies the list of custom properties associated with the tenant. External vendors can choose to set the following
// properties using provided key and value fields. The input values must always be in the string format and each key
// must be unique. API callers should make sure that no sensitive information such as passwords is sent in these fields.
type ExternalVendorCustomProperties struct {
	// Specifies the unique key for custom property.
	Key *string `json:"key,omitempty"`

	// Specifies the value for the above custom key.
	Value *string `json:"value,omitempty"`
}

// UnmarshalExternalVendorCustomProperties unmarshals an instance of ExternalVendorCustomProperties from the specified map of raw messages.
func UnmarshalExternalVendorCustomProperties(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExternalVendorCustomProperties)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExternalVendorTenantMetadata : Specifies the additional metadata for the tenant that is specifically set by the external vendors who are responsible
// for managing tenants. This field will only applicable if tenant creation is happening for a specially provisioned
// clusters for external vendors.
type ExternalVendorTenantMetadata struct {
	// Specifies the additional metadata for the tenant that is specifically set by the external vendor of type 'IBM'.
	IbmTenantMetadataParams *IbmTenantMetadataParams `json:"ibmTenantMetadataParams,omitempty"`

	// Specifies the type of the external vendor. The type specific parameters must be specified the provided type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the ExternalVendorTenantMetadata.Type property.
// Specifies the type of the external vendor. The type specific parameters must be specified the provided type.
const (
	ExternalVendorTenantMetadata_Type_Ibm = "IBM"
)

// UnmarshalExternalVendorTenantMetadata unmarshals an instance of ExternalVendorTenantMetadata from the specified map of raw messages.
func UnmarshalExternalVendorTenantMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExternalVendorTenantMetadata)
	err = core.UnmarshalModel(m, "ibmTenantMetadataParams", &obj.IbmTenantMetadataParams, UnmarshalIbmTenantMetadataParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "ibmTenantMetadataParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FailedRunDetails : Specifies a list of ids of Protection Group Runs that failed to update along with error details.
type FailedRunDetails struct {
	// Specifies the id of the failed run.
	RunID *string `json:"runId,omitempty"`

	// Specifies the error mesage for failed run.
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// UnmarshalFailedRunDetails unmarshals an instance of FailedRunDetails from the specified map of raw messages.
func UnmarshalFailedRunDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FailedRunDetails)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "errorMessage", &obj.ErrorMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "errorMessage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// File : Specifies a File.
type File struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the file name.
	Name *string `json:"name,omitempty"`

	// Specifies the path to this file.
	Path *string `json:"path,omitempty"`

	// Specifies the file type.
	Type *string `json:"type,omitempty"`

	// "Specifies the protection group id which contains this file.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this file.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *FileSourceInfo `json:"sourceInfo,omitempty"`
}

// Constants associated with the File.Type property.
// Specifies the file type.
const (
	File_Type_Directory = "Directory"
	File_Type_File      = "File"
	File_Type_Symlink   = "Symlink"
)

// UnmarshalFile unmarshals an instance of File from the specified map of raw messages.
func UnmarshalFile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(File)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalFileSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FileSourceInfo : Specifies the Source Object information.
type FileSourceInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`

	// Specifies the count and size of protected and unprotected objects for the size.
	ProtectionStats []ObjectProtectionStatsSummary `json:"protectionStats,omitempty"`

	// Specifies the list of users, groups and users that have permissions for a given object.
	Permissions *PermissionInfo `json:"permissions,omitempty"`

	// Specifies the parameters for Msssql object.
	MssqlParams *FileSourceInfoMssqlParams `json:"mssqlParams,omitempty"`

	// Specifies the parameters for Physical object.
	PhysicalParams *FileSourceInfoPhysicalParams `json:"physicalParams,omitempty"`
}

// Constants associated with the FileSourceInfo.Environment property.
// Specifies the environment of the object.
const (
	FileSourceInfo_Environment_Kphysical = "kPhysical"
	FileSourceInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the FileSourceInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	FileSourceInfo_ProtectionType_Kagent                 = "kAgent"
	FileSourceInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	FileSourceInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	FileSourceInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	FileSourceInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	FileSourceInfo_ProtectionType_Kawss3                 = "kAwsS3"
	FileSourceInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	FileSourceInfo_ProtectionType_Kfile                  = "kFile"
	FileSourceInfo_ProtectionType_Knative                = "kNative"
	FileSourceInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	FileSourceInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	FileSourceInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the FileSourceInfo.OsType property.
// Specifies the operating system type of the object.
const (
	FileSourceInfo_OsType_Klinux   = "kLinux"
	FileSourceInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalFileSourceInfo unmarshals an instance of FileSourceInfo from the specified map of raw messages.
func UnmarshalFileSourceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FileSourceInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionStats", &obj.ProtectionStats, UnmarshalObjectProtectionStatsSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionStats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalPermissionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalFileSourceInfoMssqlParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalFileSourceInfoPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FileSourceInfoMssqlParams : Specifies the parameters for Msssql object.
type FileSourceInfoMssqlParams struct {
	// Object details for Mssql.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
	// hosted by another object such as VM or physical server.
	HostInfo *HostInformation `json:"hostInfo,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
}

// UnmarshalFileSourceInfoMssqlParams unmarshals an instance of FileSourceInfoMssqlParams from the specified map of raw messages.
func UnmarshalFileSourceInfoMssqlParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FileSourceInfoMssqlParams)
	err = core.UnmarshalModel(m, "aagInfo", &obj.AagInfo, UnmarshalAAGInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostInfo", &obj.HostInfo, UnmarshalHostInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FileSourceInfoPhysicalParams : Specifies the parameters for Physical object.
type FileSourceInfoPhysicalParams struct {
	// Specifies if system backup was enabled for the source in a particular run.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`
}

// UnmarshalFileSourceInfoPhysicalParams unmarshals an instance of FileSourceInfoPhysicalParams from the specified map of raw messages.
func UnmarshalFileSourceInfoPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FileSourceInfoPhysicalParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FilenamePatternToDirectory : Specifies a filename pattern and the directory path where to keep files matching that pattern.
type FilenamePatternToDirectory struct {
	// Specifies the directory where to keep the files matching the pattern.
	Directory *string `json:"directory,omitempty"`

	// Specifies a pattern to be matched with filenames. This can be a regex expression.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
}

// UnmarshalFilenamePatternToDirectory unmarshals an instance of FilenamePatternToDirectory from the specified map of raw messages.
func UnmarshalFilenamePatternToDirectory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FilenamePatternToDirectory)
	err = core.UnmarshalPrimitive(m, "directory", &obj.Directory)
	if err != nil {
		err = core.SDKErrorf(err, "", "directory-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "filenamePattern", &obj.FilenamePattern)
	if err != nil {
		err = core.SDKErrorf(err, "", "filenamePattern-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FilesAndFoldersObject : Specifies a file or folder to download.
type FilesAndFoldersObject struct {
	// Specifies the absolute path of the file or folder.
	AbsolutePath *string `json:"absolutePath" validate:"required"`

	// Specifies whether the file or folder object is a directory.
	IsDirectory *bool `json:"isDirectory,omitempty"`
}

// NewFilesAndFoldersObject : Instantiate FilesAndFoldersObject (Generic Model Constructor)
func (*BackupRecoveryV1) NewFilesAndFoldersObject(absolutePath string) (_model *FilesAndFoldersObject, err error) {
	_model = &FilesAndFoldersObject{
		AbsolutePath: core.StringPtr(absolutePath),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalFilesAndFoldersObject unmarshals an instance of FilesAndFoldersObject from the specified map of raw messages.
func UnmarshalFilesAndFoldersObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FilesAndFoldersObject)
	err = core.UnmarshalPrimitive(m, "absolutePath", &obj.AbsolutePath)
	if err != nil {
		err = core.SDKErrorf(err, "", "absolutePath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isDirectory", &obj.IsDirectory)
	if err != nil {
		err = core.SDKErrorf(err, "", "isDirectory-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Filter : Specifies the filter details.
type Filter struct {
	// Specifies the filter string using wildcard supported strings or regular expressions.
	FilterString *string `json:"filterString,omitempty"`

	// Specifies whether the provided filter string is a regular expression or not. This needs to be explicitly set to true
	// if user is trying to filter by regular expressions. Not providing this value in case of regular expression can
	// result in unintended results. The default value is assumed to be false.
	IsRegularExpression *bool `json:"isRegularExpression,omitempty"`
}

// UnmarshalFilter unmarshals an instance of Filter from the specified map of raw messages.
func UnmarshalFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Filter)
	err = core.UnmarshalPrimitive(m, "filterString", &obj.FilterString)
	if err != nil {
		err = core.SDKErrorf(err, "", "filterString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isRegularExpression", &obj.IsRegularExpression)
	if err != nil {
		err = core.SDKErrorf(err, "", "isRegularExpression-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlashbladeObjectParams : Specifies the common parameters for Flashblade objects.
type FlashbladeObjectParams struct {
	// Specifies a list of NAS mount protocols supported by this object.
	SupportedNasMountProtocols []string `json:"supportedNasMountProtocols,omitempty"`
}

// Constants associated with the FlashbladeObjectParams.SupportedNasMountProtocols property.
const (
	FlashbladeObjectParams_SupportedNasMountProtocols_Kcifs2 = "kCifs2"
	FlashbladeObjectParams_SupportedNasMountProtocols_Khttp  = "kHttp"
	FlashbladeObjectParams_SupportedNasMountProtocols_Knfs   = "kNfs"
)

// UnmarshalFlashbladeObjectParams unmarshals an instance of FlashbladeObjectParams from the specified map of raw messages.
func UnmarshalFlashbladeObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlashbladeObjectParams)
	err = core.UnmarshalPrimitive(m, "supportedNasMountProtocols", &obj.SupportedNasMountProtocols)
	if err != nil {
		err = core.SDKErrorf(err, "", "supportedNasMountProtocols-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FullBackupPolicy : Specifies full backup settings for a Protection Group. Currently, full backup settings can be specified by using
// either of 'schedule' or 'schdulesAndRetentions' field. Using 'schdulesAndRetentions' is recommended when multiple
// full backups need to be configured. If full and incremental backup has common retention then only setting 'schedule'
// is recommended.
type FullBackupPolicy struct {
	// Specifies settings that defines how frequent full backup will be performed for a Protection Group.
	Schedule *FullSchedule `json:"schedule,omitempty"`
}

// UnmarshalFullBackupPolicy unmarshals an instance of FullBackupPolicy from the specified map of raw messages.
func UnmarshalFullBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FullBackupPolicy)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalFullSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FullSchedule : Specifies settings that defines how frequent full backup will be performed for a Protection Group.
type FullSchedule struct {
	// Specifies how often to start new runs of a Protection Group. <br>'Days' specifies that Protection Group run starts
	// periodically on every day. For full backup schedule, currently we only support frequecny of 1 which indicates that
	// full backup will be performed daily. <br>'Weeks' specifies that new Protection Group runs start weekly on certain
	// days specified using 'dayOfWeek' field. <br>'Months' specifies that new Protection Group runs start monthly on
	// certain day of specific week. This schedule needs 'weekOfMonth' and 'dayOfWeek' fields to be set. <br>'ProtectOnce'
	// specifies that groups using this policy option will run only once and after that group will permanently be disabled.
	// <br> Example: To run the Protection Group on Second Sunday of Every Month, following schedule need to be set: <br>
	// unit: 'Month' <br> dayOfWeek: 'Sunday' <br> weekOfMonth: 'Second'.
	Unit *string `json:"unit" validate:"required"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of days.
	DaySchedule *DaySchedule `json:"daySchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start on certain days of week.
	WeekSchedule *WeekSchedule `json:"weekSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to on specific week and specific days of that
	// week.
	MonthSchedule *MonthSchedule `json:"monthSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group to run on specific year and specific day of that
	// year.
	YearSchedule *YearSchedule `json:"yearSchedule,omitempty"`
}

// Constants associated with the FullSchedule.Unit property.
// Specifies how often to start new runs of a Protection Group. <br>'Days' specifies that Protection Group run starts
// periodically on every day. For full backup schedule, currently we only support frequecny of 1 which indicates that
// full backup will be performed daily. <br>'Weeks' specifies that new Protection Group runs start weekly on certain
// days specified using 'dayOfWeek' field. <br>'Months' specifies that new Protection Group runs start monthly on
// certain day of specific week. This schedule needs 'weekOfMonth' and 'dayOfWeek' fields to be set. <br>'ProtectOnce'
// specifies that groups using this policy option will run only once and after that group will permanently be disabled.
// <br> Example: To run the Protection Group on Second Sunday of Every Month, following schedule need to be set: <br>
// unit: 'Month' <br> dayOfWeek: 'Sunday' <br> weekOfMonth: 'Second'.
const (
	FullSchedule_Unit_Days        = "Days"
	FullSchedule_Unit_Months      = "Months"
	FullSchedule_Unit_Protectonce = "ProtectOnce"
	FullSchedule_Unit_Weeks       = "Weeks"
	FullSchedule_Unit_Years       = "Years"
)

// NewFullSchedule : Instantiate FullSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewFullSchedule(unit string) (_model *FullSchedule, err error) {
	_model = &FullSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalFullSchedule unmarshals an instance of FullSchedule from the specified map of raw messages.
func UnmarshalFullSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FullSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "daySchedule", &obj.DaySchedule, UnmarshalDaySchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "daySchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "weekSchedule", &obj.WeekSchedule, UnmarshalWeekSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "weekSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "monthSchedule", &obj.MonthSchedule, UnmarshalMonthSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "monthSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "yearSchedule", &obj.YearSchedule, UnmarshalYearSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "yearSchedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FullScheduleAndRetention : Specifies the settings to schedule the full backup and retention for each schedule.
type FullScheduleAndRetention struct {
	// Specifies settings that defines how frequent full backup will be performed for a Protection Group.
	Schedule *FullSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`
}

// NewFullScheduleAndRetention : Instantiate FullScheduleAndRetention (Generic Model Constructor)
func (*BackupRecoveryV1) NewFullScheduleAndRetention(schedule *FullSchedule, retention *Retention) (_model *FullScheduleAndRetention, err error) {
	_model = &FullScheduleAndRetention{
		Schedule:  schedule,
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalFullScheduleAndRetention unmarshals an instance of FullScheduleAndRetention from the specified map of raw messages.
func UnmarshalFullScheduleAndRetention(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FullScheduleAndRetention)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalFullSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FullSnapshotInfo : Specifies the info regarding how to restore to a particular full or incremental snapshot.
type FullSnapshotInfo struct {
	// Specifies the info regarding a snapshot.
	RestoreInfo *RestoreInfo `json:"restoreInfo,omitempty"`

	// Specifies the location holding snapshot copies that may be used for restore.
	TargetsConfiguration []TargetsConfiguration `json:"targetsConfiguration,omitempty"`
}

// UnmarshalFullSnapshotInfo unmarshals an instance of FullSnapshotInfo from the specified map of raw messages.
func UnmarshalFullSnapshotInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FullSnapshotInfo)
	err = core.UnmarshalModel(m, "restoreInfo", &obj.RestoreInfo, UnmarshalRestoreInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "restoreInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "targetsConfiguration", &obj.TargetsConfiguration, UnmarshalTargetsConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetsConfiguration-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GenerateDataSourceConnectionRegistrationTokenOptions : The GenerateDataSourceConnectionRegistrationToken options.
type GenerateDataSourceConnectionRegistrationTokenOptions struct {
	// Specifies the ID of the connection, connectors belonging to which are to be fetched.
	ConnectionID *string `json:"connectionId" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGenerateDataSourceConnectionRegistrationTokenOptions : Instantiate GenerateDataSourceConnectionRegistrationTokenOptions
func (*BackupRecoveryV1) NewGenerateDataSourceConnectionRegistrationTokenOptions(connectionID string, xIBMTenantID string) *GenerateDataSourceConnectionRegistrationTokenOptions {
	return &GenerateDataSourceConnectionRegistrationTokenOptions{
		ConnectionID: core.StringPtr(connectionID),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *GenerateDataSourceConnectionRegistrationTokenOptions) SetConnectionID(connectionID string) *GenerateDataSourceConnectionRegistrationTokenOptions {
	_options.ConnectionID = core.StringPtr(connectionID)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GenerateDataSourceConnectionRegistrationTokenOptions) SetXIBMTenantID(xIBMTenantID string) *GenerateDataSourceConnectionRegistrationTokenOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GenerateDataSourceConnectionRegistrationTokenOptions) SetHeaders(param map[string]string) *GenerateDataSourceConnectionRegistrationTokenOptions {
	options.Headers = param
	return options
}

// GetConnectorMetadataOptions : The GetConnectorMetadata options.
type GetConnectorMetadataOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetConnectorMetadataOptions : Instantiate GetConnectorMetadataOptions
func (*BackupRecoveryV1) NewGetConnectorMetadataOptions(xIBMTenantID string) *GetConnectorMetadataOptions {
	return &GetConnectorMetadataOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetConnectorMetadataOptions) SetXIBMTenantID(xIBMTenantID string) *GetConnectorMetadataOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetConnectorMetadataOptions) SetHeaders(param map[string]string) *GetConnectorMetadataOptions {
	options.Headers = param
	return options
}

// GetDataSourceConnectionsOptions : The GetDataSourceConnections options.
type GetDataSourceConnectionsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the unique IDs of the connections which are to be fetched.
	ConnectionIds []string `json:"connectionIds,omitempty"`

	// Specifies the names of the connections which are to be fetched.
	ConnectionNames []string `json:"connectionNames,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDataSourceConnectionsOptions : Instantiate GetDataSourceConnectionsOptions
func (*BackupRecoveryV1) NewGetDataSourceConnectionsOptions(xIBMTenantID string) *GetDataSourceConnectionsOptions {
	return &GetDataSourceConnectionsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetDataSourceConnectionsOptions) SetXIBMTenantID(xIBMTenantID string) *GetDataSourceConnectionsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetConnectionIds : Allow user to set ConnectionIds
func (_options *GetDataSourceConnectionsOptions) SetConnectionIds(connectionIds []string) *GetDataSourceConnectionsOptions {
	_options.ConnectionIds = connectionIds
	return _options
}

// SetConnectionNames : Allow user to set ConnectionNames
func (_options *GetDataSourceConnectionsOptions) SetConnectionNames(connectionNames []string) *GetDataSourceConnectionsOptions {
	_options.ConnectionNames = connectionNames
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDataSourceConnectionsOptions) SetHeaders(param map[string]string) *GetDataSourceConnectionsOptions {
	options.Headers = param
	return options
}

// GetDataSourceConnectorsOptions : The GetDataSourceConnectors options.
type GetDataSourceConnectorsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the unique IDs of the connectors which are to be fetched.
	ConnectorIds []string `json:"connectorIds,omitempty"`

	// Specifies the names of the connectors which are to be fetched.
	ConnectorNames []string `json:"connectorNames,omitempty"`

	// Specifies the ID of the connection, connectors belonging to which are to be fetched.
	ConnectionID *string `json:"connectionId,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDataSourceConnectorsOptions : Instantiate GetDataSourceConnectorsOptions
func (*BackupRecoveryV1) NewGetDataSourceConnectorsOptions(xIBMTenantID string) *GetDataSourceConnectorsOptions {
	return &GetDataSourceConnectorsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetDataSourceConnectorsOptions) SetXIBMTenantID(xIBMTenantID string) *GetDataSourceConnectorsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetConnectorIds : Allow user to set ConnectorIds
func (_options *GetDataSourceConnectorsOptions) SetConnectorIds(connectorIds []string) *GetDataSourceConnectorsOptions {
	_options.ConnectorIds = connectorIds
	return _options
}

// SetConnectorNames : Allow user to set ConnectorNames
func (_options *GetDataSourceConnectorsOptions) SetConnectorNames(connectorNames []string) *GetDataSourceConnectorsOptions {
	_options.ConnectorNames = connectorNames
	return _options
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *GetDataSourceConnectorsOptions) SetConnectionID(connectionID string) *GetDataSourceConnectorsOptions {
	_options.ConnectionID = core.StringPtr(connectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDataSourceConnectorsOptions) SetHeaders(param map[string]string) *GetDataSourceConnectorsOptions {
	options.Headers = param
	return options
}

// GetObjectSnapshotsOptions : The GetObjectSnapshots options.
type GetObjectSnapshotsOptions struct {
	// Specifies the id of the Object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this
	// value.
	FromTimeUsecs *int64 `json:"fromTimeUsecs,omitempty"`

	// Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this
	// value.
	ToTimeUsecs *int64 `json:"toTimeUsecs,omitempty"`

	// Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this
	// value.
	RunStartFromTimeUsecs *int64 `json:"runStartFromTimeUsecs,omitempty"`

	// Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this
	// value.
	RunStartToTimeUsecs *int64 `json:"runStartToTimeUsecs,omitempty"`

	// Specifies a list of recovery actions. Only snapshots that apply to these actions will be returned.
	SnapshotActions []string `json:"snapshotActions,omitempty"`

	// Filter by run type. Only protection runs matching the specified types will be returned. By default, CDP hydration
	// snapshots are not included unless explicitly queried using this field.
	RunTypes []string `json:"runTypes,omitempty"`

	// If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection
	// group IDs.
	ProtectionGroupIds []string `json:"protectionGroupIds,omitempty"`

	// Filter by a list of run instance IDs. If specified, only snapshots created by these protection runs will be
	// returned.
	RunInstanceIds []int64 `json:"runInstanceIds,omitempty"`

	// Filter by a list of region IDs.
	RegionIds []string `json:"regionIds,omitempty"`

	// Filter by ObjectActionKey, which uniquely represents the protection of an object. An object can be protected in
	// multiple ways but at most once for a given combination of ObjectActionKey. When specified, only snapshots matching
	// the given action keys are returned for the corresponding object.
	ObjectActionKeys []string `json:"objectActionKeys,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetObjectSnapshotsOptions.SnapshotActions property.
const (
	GetObjectSnapshotsOptions_SnapshotActions_Converttopst            = "ConvertToPst"
	GetObjectSnapshotsOptions_SnapshotActions_Downloadchats           = "DownloadChats"
	GetObjectSnapshotsOptions_SnapshotActions_Downloadfilesandfolders = "DownloadFilesAndFolders"
	GetObjectSnapshotsOptions_SnapshotActions_Instantvolumemount      = "InstantVolumeMount"
	GetObjectSnapshotsOptions_SnapshotActions_Mountvolumes            = "MountVolumes"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverapps             = "RecoverApps"
	GetObjectSnapshotsOptions_SnapshotActions_Recoveraurora           = "RecoverAurora"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverazuresql         = "RecoverAzureSQL"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverfiles            = "RecoverFiles"
	GetObjectSnapshotsOptions_SnapshotActions_Recovermailbox          = "RecoverMailbox"
	GetObjectSnapshotsOptions_SnapshotActions_Recovermailboxcsm       = "RecoverMailboxCSM"
	GetObjectSnapshotsOptions_SnapshotActions_Recovermsgroup          = "RecoverMsGroup"
	GetObjectSnapshotsOptions_SnapshotActions_Recovermsteam           = "RecoverMsTeam"
	GetObjectSnapshotsOptions_SnapshotActions_Recovernamespaces       = "RecoverNamespaces"
	GetObjectSnapshotsOptions_SnapshotActions_Recovernasvolume        = "RecoverNasVolume"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverobjects          = "RecoverObjects"
	GetObjectSnapshotsOptions_SnapshotActions_Recoveronedrive         = "RecoverOneDrive"
	GetObjectSnapshotsOptions_SnapshotActions_Recoveronedrivecsm      = "RecoverOneDriveCSM"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverphysicalvolumes  = "RecoverPhysicalVolumes"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverpublicfolders    = "RecoverPublicFolders"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverrds              = "RecoverRDS"
	GetObjectSnapshotsOptions_SnapshotActions_Recoverrdspostgres      = "RecoverRDSPostgres"
	GetObjectSnapshotsOptions_SnapshotActions_Recovers3buckets        = "RecoverS3Buckets"
	GetObjectSnapshotsOptions_SnapshotActions_Recoversanvolumes       = "RecoverSanVolumes"
	GetObjectSnapshotsOptions_SnapshotActions_Recoversfdcrecords      = "RecoverSfdcRecords"
	GetObjectSnapshotsOptions_SnapshotActions_Recoversharepoint       = "RecoverSharePoint"
	GetObjectSnapshotsOptions_SnapshotActions_Recoversharepointcsm    = "RecoverSharePointCSM"
	GetObjectSnapshotsOptions_SnapshotActions_Recoversystem           = "RecoverSystem"
	GetObjectSnapshotsOptions_SnapshotActions_Recovervapps            = "RecoverVApps"
	GetObjectSnapshotsOptions_SnapshotActions_Recovervapptemplates    = "RecoverVAppTemplates"
	GetObjectSnapshotsOptions_SnapshotActions_Recovervmdisks          = "RecoverVmDisks"
	GetObjectSnapshotsOptions_SnapshotActions_Recovervms              = "RecoverVMs"
)

// Constants associated with the GetObjectSnapshotsOptions.RunTypes property.
const (
	GetObjectSnapshotsOptions_RunTypes_Kfull                 = "kFull"
	GetObjectSnapshotsOptions_RunTypes_Khydratecdp           = "kHydrateCDP"
	GetObjectSnapshotsOptions_RunTypes_Klog                  = "kLog"
	GetObjectSnapshotsOptions_RunTypes_Kregular              = "kRegular"
	GetObjectSnapshotsOptions_RunTypes_Kstoragearraysnapshot = "kStorageArraySnapshot"
	GetObjectSnapshotsOptions_RunTypes_Ksystem               = "kSystem"
)

// Constants associated with the GetObjectSnapshotsOptions.ObjectActionKeys property.
const (
	GetObjectSnapshotsOptions_ObjectActionKeys_Kacropolis             = "kAcropolis"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kad                    = "kAD"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kaws                   = "kAWS"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kawsnative             = "kAWSNative"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kawsrdspostgres        = "kAwsRDSPostgres"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kawss3                 = "kAwsS3"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kawssnapshotmanager    = "kAWSSnapshotManager"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kazure                 = "kAzure"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kazurenative           = "kAzureNative"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kazuresnapshotmanager  = "kAzureSnapshotManager"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kazuresql              = "kAzureSQL"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kcassandra             = "kCassandra"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kcouchbase             = "kCouchbase"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kelastifile            = "kElastifile"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kexchange              = "kExchange"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kflashblade            = "kFlashBlade"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kgcp                   = "kGCP"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kgenericnas            = "kGenericNas"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kgpfs                  = "kGPFS"
	GetObjectSnapshotsOptions_ObjectActionKeys_Khbase                 = "kHBase"
	GetObjectSnapshotsOptions_ObjectActionKeys_Khdfs                  = "kHdfs"
	GetObjectSnapshotsOptions_ObjectActionKeys_Khive                  = "kHive"
	GetObjectSnapshotsOptions_ObjectActionKeys_Khyperv                = "kHyperV"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kibmflashsystem        = "kIbmFlashSystem"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kisilon                = "kIsilon"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kkubernetes            = "kKubernetes"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kkvm                   = "kKVM"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kmongodb               = "kMongoDB"
	GetObjectSnapshotsOptions_ObjectActionKeys_Knetapp                = "kNetapp"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365                  = "kO365"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365exchange          = "kO365Exchange"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365exchangecsm       = "kO365ExchangeCSM"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365group             = "kO365Group"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365onedrive          = "kO365OneDrive"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365onedrivecsm       = "kO365OneDriveCSM"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365publicfolders     = "kO365PublicFolders"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365sharepoint        = "kO365Sharepoint"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365sharepointcsm     = "kO365SharepointCSM"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ko365teams             = "kO365Teams"
	GetObjectSnapshotsOptions_ObjectActionKeys_Koracle                = "kOracle"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kphysical              = "kPhysical"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kphysicalfiles         = "kPhysicalFiles"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kpure                  = "kPure"
	GetObjectSnapshotsOptions_ObjectActionKeys_Krdssnapshotmanager    = "kRDSSnapshotManager"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kremoteadapter         = "kRemoteAdapter"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ksaphana               = "kSAPHANA"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ksfdc                  = "kSfdc"
	GetObjectSnapshotsOptions_ObjectActionKeys_Ksql                   = "kSQL"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kuda                   = "kUDA"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kvcd                   = "kVCD"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kview                  = "kView"
	GetObjectSnapshotsOptions_ObjectActionKeys_Kvmware                = "kVMware"
)

// NewGetObjectSnapshotsOptions : Instantiate GetObjectSnapshotsOptions
func (*BackupRecoveryV1) NewGetObjectSnapshotsOptions(id int64, xIBMTenantID string) *GetObjectSnapshotsOptions {
	return &GetObjectSnapshotsOptions{
		ID:           core.Int64Ptr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *GetObjectSnapshotsOptions) SetID(id int64) *GetObjectSnapshotsOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetObjectSnapshotsOptions) SetXIBMTenantID(xIBMTenantID string) *GetObjectSnapshotsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetFromTimeUsecs : Allow user to set FromTimeUsecs
func (_options *GetObjectSnapshotsOptions) SetFromTimeUsecs(fromTimeUsecs int64) *GetObjectSnapshotsOptions {
	_options.FromTimeUsecs = core.Int64Ptr(fromTimeUsecs)
	return _options
}

// SetToTimeUsecs : Allow user to set ToTimeUsecs
func (_options *GetObjectSnapshotsOptions) SetToTimeUsecs(toTimeUsecs int64) *GetObjectSnapshotsOptions {
	_options.ToTimeUsecs = core.Int64Ptr(toTimeUsecs)
	return _options
}

// SetRunStartFromTimeUsecs : Allow user to set RunStartFromTimeUsecs
func (_options *GetObjectSnapshotsOptions) SetRunStartFromTimeUsecs(runStartFromTimeUsecs int64) *GetObjectSnapshotsOptions {
	_options.RunStartFromTimeUsecs = core.Int64Ptr(runStartFromTimeUsecs)
	return _options
}

// SetRunStartToTimeUsecs : Allow user to set RunStartToTimeUsecs
func (_options *GetObjectSnapshotsOptions) SetRunStartToTimeUsecs(runStartToTimeUsecs int64) *GetObjectSnapshotsOptions {
	_options.RunStartToTimeUsecs = core.Int64Ptr(runStartToTimeUsecs)
	return _options
}

// SetSnapshotActions : Allow user to set SnapshotActions
func (_options *GetObjectSnapshotsOptions) SetSnapshotActions(snapshotActions []string) *GetObjectSnapshotsOptions {
	_options.SnapshotActions = snapshotActions
	return _options
}

// SetRunTypes : Allow user to set RunTypes
func (_options *GetObjectSnapshotsOptions) SetRunTypes(runTypes []string) *GetObjectSnapshotsOptions {
	_options.RunTypes = runTypes
	return _options
}

// SetProtectionGroupIds : Allow user to set ProtectionGroupIds
func (_options *GetObjectSnapshotsOptions) SetProtectionGroupIds(protectionGroupIds []string) *GetObjectSnapshotsOptions {
	_options.ProtectionGroupIds = protectionGroupIds
	return _options
}

// SetRunInstanceIds : Allow user to set RunInstanceIds
func (_options *GetObjectSnapshotsOptions) SetRunInstanceIds(runInstanceIds []int64) *GetObjectSnapshotsOptions {
	_options.RunInstanceIds = runInstanceIds
	return _options
}

// SetRegionIds : Allow user to set RegionIds
func (_options *GetObjectSnapshotsOptions) SetRegionIds(regionIds []string) *GetObjectSnapshotsOptions {
	_options.RegionIds = regionIds
	return _options
}

// SetObjectActionKeys : Allow user to set ObjectActionKeys
func (_options *GetObjectSnapshotsOptions) SetObjectActionKeys(objectActionKeys []string) *GetObjectSnapshotsOptions {
	_options.ObjectActionKeys = objectActionKeys
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetObjectSnapshotsOptions) SetHeaders(param map[string]string) *GetObjectSnapshotsOptions {
	options.Headers = param
	return options
}

// GetObjectSnapshotsResponse : Specifies the list of object snapshots.
type GetObjectSnapshotsResponse struct {
	// Specifies the list of snapshots.
	Snapshots []ObjectSnapshot `json:"snapshots,omitempty"`
}

// UnmarshalGetObjectSnapshotsResponse unmarshals an instance of GetObjectSnapshotsResponse from the specified map of raw messages.
func UnmarshalGetObjectSnapshotsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetObjectSnapshotsResponse)
	err = core.UnmarshalModel(m, "snapshots", &obj.Snapshots, UnmarshalObjectSnapshot)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshots-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetProtectionGroupByIdOptions : The GetProtectionGroupByID options.
type GetProtectionGroupByIdOptions struct {
	// Specifies a unique id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// If true, the response will include last run info. If it is false or not specified, the last run info won't be
	// returned.
	IncludeLastRunInfo *bool `json:"includeLastRunInfo,omitempty"`

	// If true, the response will not include the list of excluded source IDs in groups that contain this field. This can
	// be set to true in order to improve performance if excluded source IDs are not needed by the user.
	PruneExcludedSourceIds *bool `json:"pruneExcludedSourceIds,omitempty"`

	// If true, the response will exclude the list of source IDs within the group specified.
	PruneSourceIds *bool `json:"pruneSourceIds,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetProtectionGroupByIdOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	GetProtectionGroupByIdOptions_RequestInitiatorType_Helios = "Helios"
	GetProtectionGroupByIdOptions_RequestInitiatorType_Uiauto = "UIAuto"
	GetProtectionGroupByIdOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// NewGetProtectionGroupByIdOptions : Instantiate GetProtectionGroupByIdOptions
func (*BackupRecoveryV1) NewGetProtectionGroupByIdOptions(id string, xIBMTenantID string) *GetProtectionGroupByIdOptions {
	return &GetProtectionGroupByIdOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *GetProtectionGroupByIdOptions) SetID(id string) *GetProtectionGroupByIdOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetProtectionGroupByIdOptions) SetXIBMTenantID(xIBMTenantID string) *GetProtectionGroupByIdOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *GetProtectionGroupByIdOptions) SetRequestInitiatorType(requestInitiatorType string) *GetProtectionGroupByIdOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetIncludeLastRunInfo : Allow user to set IncludeLastRunInfo
func (_options *GetProtectionGroupByIdOptions) SetIncludeLastRunInfo(includeLastRunInfo bool) *GetProtectionGroupByIdOptions {
	_options.IncludeLastRunInfo = core.BoolPtr(includeLastRunInfo)
	return _options
}

// SetPruneExcludedSourceIds : Allow user to set PruneExcludedSourceIds
func (_options *GetProtectionGroupByIdOptions) SetPruneExcludedSourceIds(pruneExcludedSourceIds bool) *GetProtectionGroupByIdOptions {
	_options.PruneExcludedSourceIds = core.BoolPtr(pruneExcludedSourceIds)
	return _options
}

// SetPruneSourceIds : Allow user to set PruneSourceIds
func (_options *GetProtectionGroupByIdOptions) SetPruneSourceIds(pruneSourceIds bool) *GetProtectionGroupByIdOptions {
	_options.PruneSourceIds = core.BoolPtr(pruneSourceIds)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProtectionGroupByIdOptions) SetHeaders(param map[string]string) *GetProtectionGroupByIdOptions {
	options.Headers = param
	return options
}

// GetProtectionGroupRunsOptions : The GetProtectionGroupRuns options.
type GetProtectionGroupRunsOptions struct {
	// Specifies a unique id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Specifies the protection run id.
	RunID *string `json:"runId,omitempty"`

	// Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs
	// executing after this time will be returned. By default it is endTimeUsecs minus an hour.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs
	// executing before this time will be returned. By default it is current time.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Filter by run type. Only protection run matching the specified types will be returned.
	RunTypes []string `json:"runTypes,omitempty"`

	// Specifies if the result includes the object details for each protection run. If set to true, details of the
	// protected object will be returned. If set to false or not specified, details will not be returned.
	IncludeObjectDetails *bool `json:"includeObjectDetails,omitempty"`

	// Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the
	// run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the
	// run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that
	// the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded'
	// indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br>
	// 'Skipped' indicates that the run was skipped.
	LocalBackupRunStatus []string `json:"localBackupRunStatus,omitempty"`

	// Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the
	// run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the
	// run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that
	// the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded'
	// indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br>
	// 'Skipped' indicates that the run was skipped.
	ReplicationRunStatus []string `json:"replicationRunStatus,omitempty"`

	// Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run
	// is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is
	// in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the
	// run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded'
	// indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br>
	// 'Skipped' indicates that the run was skipped.
	ArchivalRunStatus []string `json:"archivalRunStatus,omitempty"`

	// Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the
	// run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the
	// run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that
	// the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded'
	// indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br>
	// 'Skipped' indicates that the run was skipped.
	CloudSpinRunStatus []string `json:"cloudSpinRunStatus,omitempty"`

	// Specifies the max number of runs. If not specified, at most 100 runs will be returned.
	NumRuns *int64 `json:"numRuns,omitempty"`

	// Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object
	// snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is
	// false.
	ExcludeNonRestorableRuns *bool `json:"excludeNonRestorableRuns,omitempty"`

	// Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be
	// returned.
	RunTags []string `json:"runTags,omitempty"`

	// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the
	// read replica and primary data source.
	UseCachedData *bool `json:"useCachedData,omitempty"`

	// If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with
	// start time in the time range are returned.
	FilterByEndTime *bool `json:"filterByEndTime,omitempty"`

	// Specifies the snapshot's target type which should be filtered.
	SnapshotTargetTypes []string `json:"snapshotTargetTypes,omitempty"`

	// only successful copyruns are returned.
	OnlyReturnSuccessfulCopyRun *bool `json:"onlyReturnSuccessfulCopyRun,omitempty"`

	// If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only
	// one of filterByEndTime and filterByCopyTaskEndTime can be set.
	FilterByCopyTaskEndTime *bool `json:"filterByCopyTaskEndTime,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetProtectionGroupRunsOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	GetProtectionGroupRunsOptions_RequestInitiatorType_Helios = "Helios"
	GetProtectionGroupRunsOptions_RequestInitiatorType_Uiauto = "UIAuto"
	GetProtectionGroupRunsOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// Constants associated with the GetProtectionGroupRunsOptions.RunTypes property.
const (
	GetProtectionGroupRunsOptions_RunTypes_Kall                  = "kAll"
	GetProtectionGroupRunsOptions_RunTypes_Kfull                 = "kFull"
	GetProtectionGroupRunsOptions_RunTypes_Khydratecdp           = "kHydrateCDP"
	GetProtectionGroupRunsOptions_RunTypes_Kincremental          = "kIncremental"
	GetProtectionGroupRunsOptions_RunTypes_Klog                  = "kLog"
	GetProtectionGroupRunsOptions_RunTypes_Kstoragearraysnapshot = "kStorageArraySnapshot"
	GetProtectionGroupRunsOptions_RunTypes_Ksystem               = "kSystem"
)

// Constants associated with the GetProtectionGroupRunsOptions.LocalBackupRunStatus property.
const (
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Accepted             = "Accepted"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Canceled             = "Canceled"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Canceling            = "Canceling"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Failed               = "Failed"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Finalizing           = "Finalizing"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Missed               = "Missed"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Onhold               = "OnHold"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Paused               = "Paused"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Running              = "Running"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Skipped              = "Skipped"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Succeeded            = "Succeeded"
	GetProtectionGroupRunsOptions_LocalBackupRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupRunsOptions.ReplicationRunStatus property.
const (
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Accepted             = "Accepted"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Canceled             = "Canceled"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Canceling            = "Canceling"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Failed               = "Failed"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Finalizing           = "Finalizing"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Missed               = "Missed"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Onhold               = "OnHold"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Paused               = "Paused"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Running              = "Running"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Skipped              = "Skipped"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Succeeded            = "Succeeded"
	GetProtectionGroupRunsOptions_ReplicationRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupRunsOptions.ArchivalRunStatus property.
const (
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Accepted             = "Accepted"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Canceled             = "Canceled"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Canceling            = "Canceling"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Failed               = "Failed"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Finalizing           = "Finalizing"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Missed               = "Missed"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Onhold               = "OnHold"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Paused               = "Paused"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Running              = "Running"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Skipped              = "Skipped"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Succeeded            = "Succeeded"
	GetProtectionGroupRunsOptions_ArchivalRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupRunsOptions.CloudSpinRunStatus property.
const (
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Accepted             = "Accepted"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Canceled             = "Canceled"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Canceling            = "Canceling"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Failed               = "Failed"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Finalizing           = "Finalizing"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Missed               = "Missed"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Onhold               = "OnHold"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Paused               = "Paused"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Running              = "Running"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Skipped              = "Skipped"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Succeeded            = "Succeeded"
	GetProtectionGroupRunsOptions_CloudSpinRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupRunsOptions.SnapshotTargetTypes property.
const (
	GetProtectionGroupRunsOptions_SnapshotTargetTypes_Archival             = "Archival"
	GetProtectionGroupRunsOptions_SnapshotTargetTypes_Local                = "Local"
	GetProtectionGroupRunsOptions_SnapshotTargetTypes_Remote               = "Remote"
	GetProtectionGroupRunsOptions_SnapshotTargetTypes_Rpaasarchival        = "RpaasArchival"
	GetProtectionGroupRunsOptions_SnapshotTargetTypes_Storagearraysnapshot = "StorageArraySnapshot"
)

// NewGetProtectionGroupRunsOptions : Instantiate GetProtectionGroupRunsOptions
func (*BackupRecoveryV1) NewGetProtectionGroupRunsOptions(id string, xIBMTenantID string) *GetProtectionGroupRunsOptions {
	return &GetProtectionGroupRunsOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *GetProtectionGroupRunsOptions) SetID(id string) *GetProtectionGroupRunsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetProtectionGroupRunsOptions) SetXIBMTenantID(xIBMTenantID string) *GetProtectionGroupRunsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *GetProtectionGroupRunsOptions) SetRequestInitiatorType(requestInitiatorType string) *GetProtectionGroupRunsOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetRunID : Allow user to set RunID
func (_options *GetProtectionGroupRunsOptions) SetRunID(runID string) *GetProtectionGroupRunsOptions {
	_options.RunID = core.StringPtr(runID)
	return _options
}

// SetStartTimeUsecs : Allow user to set StartTimeUsecs
func (_options *GetProtectionGroupRunsOptions) SetStartTimeUsecs(startTimeUsecs int64) *GetProtectionGroupRunsOptions {
	_options.StartTimeUsecs = core.Int64Ptr(startTimeUsecs)
	return _options
}

// SetEndTimeUsecs : Allow user to set EndTimeUsecs
func (_options *GetProtectionGroupRunsOptions) SetEndTimeUsecs(endTimeUsecs int64) *GetProtectionGroupRunsOptions {
	_options.EndTimeUsecs = core.Int64Ptr(endTimeUsecs)
	return _options
}

// SetRunTypes : Allow user to set RunTypes
func (_options *GetProtectionGroupRunsOptions) SetRunTypes(runTypes []string) *GetProtectionGroupRunsOptions {
	_options.RunTypes = runTypes
	return _options
}

// SetIncludeObjectDetails : Allow user to set IncludeObjectDetails
func (_options *GetProtectionGroupRunsOptions) SetIncludeObjectDetails(includeObjectDetails bool) *GetProtectionGroupRunsOptions {
	_options.IncludeObjectDetails = core.BoolPtr(includeObjectDetails)
	return _options
}

// SetLocalBackupRunStatus : Allow user to set LocalBackupRunStatus
func (_options *GetProtectionGroupRunsOptions) SetLocalBackupRunStatus(localBackupRunStatus []string) *GetProtectionGroupRunsOptions {
	_options.LocalBackupRunStatus = localBackupRunStatus
	return _options
}

// SetReplicationRunStatus : Allow user to set ReplicationRunStatus
func (_options *GetProtectionGroupRunsOptions) SetReplicationRunStatus(replicationRunStatus []string) *GetProtectionGroupRunsOptions {
	_options.ReplicationRunStatus = replicationRunStatus
	return _options
}

// SetArchivalRunStatus : Allow user to set ArchivalRunStatus
func (_options *GetProtectionGroupRunsOptions) SetArchivalRunStatus(archivalRunStatus []string) *GetProtectionGroupRunsOptions {
	_options.ArchivalRunStatus = archivalRunStatus
	return _options
}

// SetCloudSpinRunStatus : Allow user to set CloudSpinRunStatus
func (_options *GetProtectionGroupRunsOptions) SetCloudSpinRunStatus(cloudSpinRunStatus []string) *GetProtectionGroupRunsOptions {
	_options.CloudSpinRunStatus = cloudSpinRunStatus
	return _options
}

// SetNumRuns : Allow user to set NumRuns
func (_options *GetProtectionGroupRunsOptions) SetNumRuns(numRuns int64) *GetProtectionGroupRunsOptions {
	_options.NumRuns = core.Int64Ptr(numRuns)
	return _options
}

// SetExcludeNonRestorableRuns : Allow user to set ExcludeNonRestorableRuns
func (_options *GetProtectionGroupRunsOptions) SetExcludeNonRestorableRuns(excludeNonRestorableRuns bool) *GetProtectionGroupRunsOptions {
	_options.ExcludeNonRestorableRuns = core.BoolPtr(excludeNonRestorableRuns)
	return _options
}

// SetRunTags : Allow user to set RunTags
func (_options *GetProtectionGroupRunsOptions) SetRunTags(runTags []string) *GetProtectionGroupRunsOptions {
	_options.RunTags = runTags
	return _options
}

// SetUseCachedData : Allow user to set UseCachedData
func (_options *GetProtectionGroupRunsOptions) SetUseCachedData(useCachedData bool) *GetProtectionGroupRunsOptions {
	_options.UseCachedData = core.BoolPtr(useCachedData)
	return _options
}

// SetFilterByEndTime : Allow user to set FilterByEndTime
func (_options *GetProtectionGroupRunsOptions) SetFilterByEndTime(filterByEndTime bool) *GetProtectionGroupRunsOptions {
	_options.FilterByEndTime = core.BoolPtr(filterByEndTime)
	return _options
}

// SetSnapshotTargetTypes : Allow user to set SnapshotTargetTypes
func (_options *GetProtectionGroupRunsOptions) SetSnapshotTargetTypes(snapshotTargetTypes []string) *GetProtectionGroupRunsOptions {
	_options.SnapshotTargetTypes = snapshotTargetTypes
	return _options
}

// SetOnlyReturnSuccessfulCopyRun : Allow user to set OnlyReturnSuccessfulCopyRun
func (_options *GetProtectionGroupRunsOptions) SetOnlyReturnSuccessfulCopyRun(onlyReturnSuccessfulCopyRun bool) *GetProtectionGroupRunsOptions {
	_options.OnlyReturnSuccessfulCopyRun = core.BoolPtr(onlyReturnSuccessfulCopyRun)
	return _options
}

// SetFilterByCopyTaskEndTime : Allow user to set FilterByCopyTaskEndTime
func (_options *GetProtectionGroupRunsOptions) SetFilterByCopyTaskEndTime(filterByCopyTaskEndTime bool) *GetProtectionGroupRunsOptions {
	_options.FilterByCopyTaskEndTime = core.BoolPtr(filterByCopyTaskEndTime)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProtectionGroupRunsOptions) SetHeaders(param map[string]string) *GetProtectionGroupRunsOptions {
	options.Headers = param
	return options
}

// GetProtectionGroupsOptions : The GetProtectionGroups options.
type GetProtectionGroupsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Filter by a list of Protection Group ids.
	Ids []string `json:"ids,omitempty"`

	// Filter by a list of Protection Group names.
	Names []string `json:"names,omitempty"`

	// Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the
	// specified Policy ids, are returned.
	PolicyIds []string `json:"policyIds,omitempty"`

	// Whether to only return Protection Groups with a datalock.
	IncludeGroupsWithDatalockOnly *bool `json:"includeGroupsWithDatalockOnly,omitempty"`

	// Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified
	// environment types are returned.
	Environments []string `json:"environments,omitempty"`

	// Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned.
	// If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When
	// you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy
	// of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is
	// deactivated, the Protection Group becomes Inactive.
	IsActive *bool `json:"isActive,omitempty"`

	// If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If
	// false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots
	// associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these
	// cases.
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are
	// returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are
	// returned.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled'
	// indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being
	// canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take
	// place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has
	// finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some
	// warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run
	// was skipped.
	LastRunLocalBackupStatus []string `json:"lastRunLocalBackupStatus,omitempty"`

	// Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled'
	// indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being
	// canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take
	// place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has
	// finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some
	// warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run
	// was skipped.
	LastRunReplicationStatus []string `json:"lastRunReplicationStatus,omitempty"`

	// Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled'
	// indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being
	// canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take
	// place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has
	// finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some
	// warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run
	// was skipped.
	LastRunArchivalStatus []string `json:"lastRunArchivalStatus,omitempty"`

	// Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled'
	// indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being
	// canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take
	// place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has
	// finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some
	// warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run
	// was skipped.
	LastRunCloudSpinStatus []string `json:"lastRunCloudSpinStatus,omitempty"`

	// Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that
	// the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed'
	// indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled
	// time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished
	// successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning
	// messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was
	// skipped.
	LastRunAnyStatus []string `json:"lastRunAnyStatus,omitempty"`

	// If true, return Protection Groups for which last run SLA was violated.
	IsLastRunSlaViolated *bool `json:"isLastRunSlaViolated,omitempty"`

	// If true, the response will include last run info. If it is false or not specified, the last run info won't be
	// returned.
	IncludeLastRunInfo *bool `json:"includeLastRunInfo,omitempty"`

	// If true, the response will not include the list of excluded source IDs in groups that contain this field. This can
	// be set to true in order to improve performance if excluded source IDs are not needed by the user.
	PruneExcludedSourceIds *bool `json:"pruneExcludedSourceIds,omitempty"`

	// If true, the response will exclude the list of source IDs within the group specified.
	PruneSourceIds *bool `json:"pruneSourceIds,omitempty"`

	// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the
	// read replica and primary data source.
	UseCachedData *bool `json:"useCachedData,omitempty"`

	// Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the
	// specified Source ids, are returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetProtectionGroupsOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	GetProtectionGroupsOptions_RequestInitiatorType_Helios = "Helios"
	GetProtectionGroupsOptions_RequestInitiatorType_Uiauto = "UIAuto"
	GetProtectionGroupsOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// Constants associated with the GetProtectionGroupsOptions.Environments property.
const (
	GetProtectionGroupsOptions_Environments_Kphysical = "kPhysical"
	GetProtectionGroupsOptions_Environments_Ksql      = "kSQL"
)

// Constants associated with the GetProtectionGroupsOptions.LastRunLocalBackupStatus property.
const (
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Accepted             = "Accepted"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Canceled             = "Canceled"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Canceling            = "Canceling"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Failed               = "Failed"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Finalizing           = "Finalizing"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Missed               = "Missed"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Onhold               = "OnHold"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Paused               = "Paused"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Running              = "Running"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Skipped              = "Skipped"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Succeeded            = "Succeeded"
	GetProtectionGroupsOptions_LastRunLocalBackupStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupsOptions.LastRunReplicationStatus property.
const (
	GetProtectionGroupsOptions_LastRunReplicationStatus_Accepted             = "Accepted"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Canceled             = "Canceled"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Canceling            = "Canceling"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Failed               = "Failed"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Finalizing           = "Finalizing"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Missed               = "Missed"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Onhold               = "OnHold"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Paused               = "Paused"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Running              = "Running"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Skipped              = "Skipped"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Succeeded            = "Succeeded"
	GetProtectionGroupsOptions_LastRunReplicationStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupsOptions.LastRunArchivalStatus property.
const (
	GetProtectionGroupsOptions_LastRunArchivalStatus_Accepted             = "Accepted"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Canceled             = "Canceled"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Canceling            = "Canceling"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Failed               = "Failed"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Finalizing           = "Finalizing"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Missed               = "Missed"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Onhold               = "OnHold"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Paused               = "Paused"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Running              = "Running"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Skipped              = "Skipped"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Succeeded            = "Succeeded"
	GetProtectionGroupsOptions_LastRunArchivalStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupsOptions.LastRunCloudSpinStatus property.
const (
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Accepted             = "Accepted"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Canceled             = "Canceled"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Canceling            = "Canceling"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Failed               = "Failed"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Finalizing           = "Finalizing"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Missed               = "Missed"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Onhold               = "OnHold"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Paused               = "Paused"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Running              = "Running"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Skipped              = "Skipped"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Succeeded            = "Succeeded"
	GetProtectionGroupsOptions_LastRunCloudSpinStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetProtectionGroupsOptions.LastRunAnyStatus property.
const (
	GetProtectionGroupsOptions_LastRunAnyStatus_Accepted             = "Accepted"
	GetProtectionGroupsOptions_LastRunAnyStatus_Canceled             = "Canceled"
	GetProtectionGroupsOptions_LastRunAnyStatus_Canceling            = "Canceling"
	GetProtectionGroupsOptions_LastRunAnyStatus_Failed               = "Failed"
	GetProtectionGroupsOptions_LastRunAnyStatus_Finalizing           = "Finalizing"
	GetProtectionGroupsOptions_LastRunAnyStatus_Missed               = "Missed"
	GetProtectionGroupsOptions_LastRunAnyStatus_Onhold               = "OnHold"
	GetProtectionGroupsOptions_LastRunAnyStatus_Paused               = "Paused"
	GetProtectionGroupsOptions_LastRunAnyStatus_Running              = "Running"
	GetProtectionGroupsOptions_LastRunAnyStatus_Skipped              = "Skipped"
	GetProtectionGroupsOptions_LastRunAnyStatus_Succeeded            = "Succeeded"
	GetProtectionGroupsOptions_LastRunAnyStatus_Succeededwithwarning = "SucceededWithWarning"
)

// NewGetProtectionGroupsOptions : Instantiate GetProtectionGroupsOptions
func (*BackupRecoveryV1) NewGetProtectionGroupsOptions(xIBMTenantID string) *GetProtectionGroupsOptions {
	return &GetProtectionGroupsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetProtectionGroupsOptions) SetXIBMTenantID(xIBMTenantID string) *GetProtectionGroupsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *GetProtectionGroupsOptions) SetRequestInitiatorType(requestInitiatorType string) *GetProtectionGroupsOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetIds : Allow user to set Ids
func (_options *GetProtectionGroupsOptions) SetIds(ids []string) *GetProtectionGroupsOptions {
	_options.Ids = ids
	return _options
}

// SetNames : Allow user to set Names
func (_options *GetProtectionGroupsOptions) SetNames(names []string) *GetProtectionGroupsOptions {
	_options.Names = names
	return _options
}

// SetPolicyIds : Allow user to set PolicyIds
func (_options *GetProtectionGroupsOptions) SetPolicyIds(policyIds []string) *GetProtectionGroupsOptions {
	_options.PolicyIds = policyIds
	return _options
}

// SetIncludeGroupsWithDatalockOnly : Allow user to set IncludeGroupsWithDatalockOnly
func (_options *GetProtectionGroupsOptions) SetIncludeGroupsWithDatalockOnly(includeGroupsWithDatalockOnly bool) *GetProtectionGroupsOptions {
	_options.IncludeGroupsWithDatalockOnly = core.BoolPtr(includeGroupsWithDatalockOnly)
	return _options
}

// SetEnvironments : Allow user to set Environments
func (_options *GetProtectionGroupsOptions) SetEnvironments(environments []string) *GetProtectionGroupsOptions {
	_options.Environments = environments
	return _options
}

// SetIsActive : Allow user to set IsActive
func (_options *GetProtectionGroupsOptions) SetIsActive(isActive bool) *GetProtectionGroupsOptions {
	_options.IsActive = core.BoolPtr(isActive)
	return _options
}

// SetIsDeleted : Allow user to set IsDeleted
func (_options *GetProtectionGroupsOptions) SetIsDeleted(isDeleted bool) *GetProtectionGroupsOptions {
	_options.IsDeleted = core.BoolPtr(isDeleted)
	return _options
}

// SetIsPaused : Allow user to set IsPaused
func (_options *GetProtectionGroupsOptions) SetIsPaused(isPaused bool) *GetProtectionGroupsOptions {
	_options.IsPaused = core.BoolPtr(isPaused)
	return _options
}

// SetLastRunLocalBackupStatus : Allow user to set LastRunLocalBackupStatus
func (_options *GetProtectionGroupsOptions) SetLastRunLocalBackupStatus(lastRunLocalBackupStatus []string) *GetProtectionGroupsOptions {
	_options.LastRunLocalBackupStatus = lastRunLocalBackupStatus
	return _options
}

// SetLastRunReplicationStatus : Allow user to set LastRunReplicationStatus
func (_options *GetProtectionGroupsOptions) SetLastRunReplicationStatus(lastRunReplicationStatus []string) *GetProtectionGroupsOptions {
	_options.LastRunReplicationStatus = lastRunReplicationStatus
	return _options
}

// SetLastRunArchivalStatus : Allow user to set LastRunArchivalStatus
func (_options *GetProtectionGroupsOptions) SetLastRunArchivalStatus(lastRunArchivalStatus []string) *GetProtectionGroupsOptions {
	_options.LastRunArchivalStatus = lastRunArchivalStatus
	return _options
}

// SetLastRunCloudSpinStatus : Allow user to set LastRunCloudSpinStatus
func (_options *GetProtectionGroupsOptions) SetLastRunCloudSpinStatus(lastRunCloudSpinStatus []string) *GetProtectionGroupsOptions {
	_options.LastRunCloudSpinStatus = lastRunCloudSpinStatus
	return _options
}

// SetLastRunAnyStatus : Allow user to set LastRunAnyStatus
func (_options *GetProtectionGroupsOptions) SetLastRunAnyStatus(lastRunAnyStatus []string) *GetProtectionGroupsOptions {
	_options.LastRunAnyStatus = lastRunAnyStatus
	return _options
}

// SetIsLastRunSlaViolated : Allow user to set IsLastRunSlaViolated
func (_options *GetProtectionGroupsOptions) SetIsLastRunSlaViolated(isLastRunSlaViolated bool) *GetProtectionGroupsOptions {
	_options.IsLastRunSlaViolated = core.BoolPtr(isLastRunSlaViolated)
	return _options
}

// SetIncludeLastRunInfo : Allow user to set IncludeLastRunInfo
func (_options *GetProtectionGroupsOptions) SetIncludeLastRunInfo(includeLastRunInfo bool) *GetProtectionGroupsOptions {
	_options.IncludeLastRunInfo = core.BoolPtr(includeLastRunInfo)
	return _options
}

// SetPruneExcludedSourceIds : Allow user to set PruneExcludedSourceIds
func (_options *GetProtectionGroupsOptions) SetPruneExcludedSourceIds(pruneExcludedSourceIds bool) *GetProtectionGroupsOptions {
	_options.PruneExcludedSourceIds = core.BoolPtr(pruneExcludedSourceIds)
	return _options
}

// SetPruneSourceIds : Allow user to set PruneSourceIds
func (_options *GetProtectionGroupsOptions) SetPruneSourceIds(pruneSourceIds bool) *GetProtectionGroupsOptions {
	_options.PruneSourceIds = core.BoolPtr(pruneSourceIds)
	return _options
}

// SetUseCachedData : Allow user to set UseCachedData
func (_options *GetProtectionGroupsOptions) SetUseCachedData(useCachedData bool) *GetProtectionGroupsOptions {
	_options.UseCachedData = core.BoolPtr(useCachedData)
	return _options
}

// SetSourceIds : Allow user to set SourceIds
func (_options *GetProtectionGroupsOptions) SetSourceIds(sourceIds []int64) *GetProtectionGroupsOptions {
	_options.SourceIds = sourceIds
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProtectionGroupsOptions) SetHeaders(param map[string]string) *GetProtectionGroupsOptions {
	options.Headers = param
	return options
}

// GetProtectionPoliciesOptions : The GetProtectionPolicies options.
type GetProtectionPoliciesOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Filter policies by a list of policy ids.
	Ids []string `json:"ids,omitempty"`

	// Filter policies by a list of policy names.
	PolicyNames []string `json:"policyNames,omitempty"`

	// Types specifies the policy type of policies to be returned.
	Types []string `json:"types,omitempty"`

	// If excludeLinkedPolicies is set to true then only local policies created on cluster will be returned. The result
	// will exclude all linked policies created from policy templates.
	ExcludeLinkedPolicies *bool `json:"excludeLinkedPolicies,omitempty"`

	// If includeReplicatedPolicies is set to true, then response will also contain replicated policies. By default,
	// replication policies are not included in the response.
	IncludeReplicatedPolicies *bool `json:"includeReplicatedPolicies,omitempty"`

	// If includeStats is set to true, then response will return number of protection groups and objects. By default, the
	// protection stats are not included in the response.
	IncludeStats *bool `json:"includeStats,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetProtectionPoliciesOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	GetProtectionPoliciesOptions_RequestInitiatorType_Helios = "Helios"
	GetProtectionPoliciesOptions_RequestInitiatorType_Uiauto = "UIAuto"
	GetProtectionPoliciesOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// Constants associated with the GetProtectionPoliciesOptions.Types property.
const (
	GetProtectionPoliciesOptions_Types_Internal = "Internal"
	GetProtectionPoliciesOptions_Types_Regular  = "Regular"
)

// NewGetProtectionPoliciesOptions : Instantiate GetProtectionPoliciesOptions
func (*BackupRecoveryV1) NewGetProtectionPoliciesOptions(xIBMTenantID string) *GetProtectionPoliciesOptions {
	return &GetProtectionPoliciesOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetProtectionPoliciesOptions) SetXIBMTenantID(xIBMTenantID string) *GetProtectionPoliciesOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *GetProtectionPoliciesOptions) SetRequestInitiatorType(requestInitiatorType string) *GetProtectionPoliciesOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetIds : Allow user to set Ids
func (_options *GetProtectionPoliciesOptions) SetIds(ids []string) *GetProtectionPoliciesOptions {
	_options.Ids = ids
	return _options
}

// SetPolicyNames : Allow user to set PolicyNames
func (_options *GetProtectionPoliciesOptions) SetPolicyNames(policyNames []string) *GetProtectionPoliciesOptions {
	_options.PolicyNames = policyNames
	return _options
}

// SetTypes : Allow user to set Types
func (_options *GetProtectionPoliciesOptions) SetTypes(types []string) *GetProtectionPoliciesOptions {
	_options.Types = types
	return _options
}

// SetExcludeLinkedPolicies : Allow user to set ExcludeLinkedPolicies
func (_options *GetProtectionPoliciesOptions) SetExcludeLinkedPolicies(excludeLinkedPolicies bool) *GetProtectionPoliciesOptions {
	_options.ExcludeLinkedPolicies = core.BoolPtr(excludeLinkedPolicies)
	return _options
}

// SetIncludeReplicatedPolicies : Allow user to set IncludeReplicatedPolicies
func (_options *GetProtectionPoliciesOptions) SetIncludeReplicatedPolicies(includeReplicatedPolicies bool) *GetProtectionPoliciesOptions {
	_options.IncludeReplicatedPolicies = core.BoolPtr(includeReplicatedPolicies)
	return _options
}

// SetIncludeStats : Allow user to set IncludeStats
func (_options *GetProtectionPoliciesOptions) SetIncludeStats(includeStats bool) *GetProtectionPoliciesOptions {
	_options.IncludeStats = core.BoolPtr(includeStats)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProtectionPoliciesOptions) SetHeaders(param map[string]string) *GetProtectionPoliciesOptions {
	options.Headers = param
	return options
}

// GetProtectionPolicyByIdOptions : The GetProtectionPolicyByID options.
type GetProtectionPolicyByIdOptions struct {
	// Specifies a unique id of the Protection Policy to return.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetProtectionPolicyByIdOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	GetProtectionPolicyByIdOptions_RequestInitiatorType_Helios = "Helios"
	GetProtectionPolicyByIdOptions_RequestInitiatorType_Uiauto = "UIAuto"
	GetProtectionPolicyByIdOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// NewGetProtectionPolicyByIdOptions : Instantiate GetProtectionPolicyByIdOptions
func (*BackupRecoveryV1) NewGetProtectionPolicyByIdOptions(id string, xIBMTenantID string) *GetProtectionPolicyByIdOptions {
	return &GetProtectionPolicyByIdOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *GetProtectionPolicyByIdOptions) SetID(id string) *GetProtectionPolicyByIdOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetProtectionPolicyByIdOptions) SetXIBMTenantID(xIBMTenantID string) *GetProtectionPolicyByIdOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *GetProtectionPolicyByIdOptions) SetRequestInitiatorType(requestInitiatorType string) *GetProtectionPolicyByIdOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProtectionPolicyByIdOptions) SetHeaders(param map[string]string) *GetProtectionPolicyByIdOptions {
	options.Headers = param
	return options
}

// GetProtectionSourceRegistrationOptions : The GetProtectionSourceRegistration options.
type GetProtectionSourceRegistrationOptions struct {
	// Specifies the id of the Protection Source registration.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetProtectionSourceRegistrationOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	GetProtectionSourceRegistrationOptions_RequestInitiatorType_Helios = "Helios"
	GetProtectionSourceRegistrationOptions_RequestInitiatorType_Uiauto = "UIAuto"
	GetProtectionSourceRegistrationOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// NewGetProtectionSourceRegistrationOptions : Instantiate GetProtectionSourceRegistrationOptions
func (*BackupRecoveryV1) NewGetProtectionSourceRegistrationOptions(id int64, xIBMTenantID string) *GetProtectionSourceRegistrationOptions {
	return &GetProtectionSourceRegistrationOptions{
		ID:           core.Int64Ptr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *GetProtectionSourceRegistrationOptions) SetID(id int64) *GetProtectionSourceRegistrationOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetProtectionSourceRegistrationOptions) SetXIBMTenantID(xIBMTenantID string) *GetProtectionSourceRegistrationOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *GetProtectionSourceRegistrationOptions) SetRequestInitiatorType(requestInitiatorType string) *GetProtectionSourceRegistrationOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProtectionSourceRegistrationOptions) SetHeaders(param map[string]string) *GetProtectionSourceRegistrationOptions {
	options.Headers = param
	return options
}

// GetRecoveriesOptions : The GetRecoveries options.
type GetRecoveriesOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Filter Recoveries for given ids.
	Ids []string `json:"ids,omitempty"`

	// Returns only child recoveries if passed as true. This filter should always be used along with 'ids' filter.
	ReturnOnlyChildRecoveries *bool `json:"returnOnlyChildRecoveries,omitempty"`

	// Returns the recoveries which are started after the specific time. This value should be in Unix timestamp epoch in
	// microseconds.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Returns the recoveries which are started before the specific time. This value should be in Unix timestamp epoch in
	// microseconds.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the snapshot's target type from which recovery has been performed.
	SnapshotTargetType []string `json:"snapshotTargetType,omitempty"`

	// Specifies the snapshot's archival target type from which recovery has been performed. This parameter applies only if
	// 'snapshotTargetType' is 'Archival'.
	ArchivalTargetType []string `json:"archivalTargetType,omitempty"`

	// Specifies the list of snapshot environment types to filter Recoveries. If empty, Recoveries related to all
	// environments will be returned.
	SnapshotEnvironments []string `json:"snapshotEnvironments,omitempty"`

	// Specifies the list of run status to filter Recoveries. If empty, Recoveries with all run status will be returned.
	Status []string `json:"status,omitempty"`

	// Specifies the list of recovery actions to filter Recoveries. If empty, Recoveries related to all actions will be
	// returned.
	RecoveryActions []string `json:"recoveryActions,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetRecoveriesOptions.SnapshotTargetType property.
const (
	GetRecoveriesOptions_SnapshotTargetType_Archival             = "Archival"
	GetRecoveriesOptions_SnapshotTargetType_Local                = "Local"
	GetRecoveriesOptions_SnapshotTargetType_Remote               = "Remote"
	GetRecoveriesOptions_SnapshotTargetType_Rpaasarchival        = "RpaasArchival"
	GetRecoveriesOptions_SnapshotTargetType_Storagearraysnapshot = "StorageArraySnapshot"
)

// Constants associated with the GetRecoveriesOptions.ArchivalTargetType property.
const (
	GetRecoveriesOptions_ArchivalTargetType_Cloud = "Cloud"
	GetRecoveriesOptions_ArchivalTargetType_Nas   = "Nas"
	GetRecoveriesOptions_ArchivalTargetType_Tape  = "Tape"
)

// Constants associated with the GetRecoveriesOptions.SnapshotEnvironments property.
const (
	GetRecoveriesOptions_SnapshotEnvironments_Kphysical = "kPhysical"
	GetRecoveriesOptions_SnapshotEnvironments_Ksql      = "kSQL"
)

// Constants associated with the GetRecoveriesOptions.Status property.
const (
	GetRecoveriesOptions_Status_Accepted             = "Accepted"
	GetRecoveriesOptions_Status_Canceled             = "Canceled"
	GetRecoveriesOptions_Status_Canceling            = "Canceling"
	GetRecoveriesOptions_Status_Failed               = "Failed"
	GetRecoveriesOptions_Status_Finalizing           = "Finalizing"
	GetRecoveriesOptions_Status_Legalhold            = "LegalHold"
	GetRecoveriesOptions_Status_Missed               = "Missed"
	GetRecoveriesOptions_Status_Onhold               = "OnHold"
	GetRecoveriesOptions_Status_Running              = "Running"
	GetRecoveriesOptions_Status_Skipped              = "Skipped"
	GetRecoveriesOptions_Status_Succeeded            = "Succeeded"
	GetRecoveriesOptions_Status_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the GetRecoveriesOptions.RecoveryActions property.
const (
	GetRecoveriesOptions_RecoveryActions_Cloneapps               = "CloneApps"
	GetRecoveriesOptions_RecoveryActions_Cloneappview            = "CloneAppView"
	GetRecoveriesOptions_RecoveryActions_Clonerefreshapp         = "CloneRefreshApp"
	GetRecoveriesOptions_RecoveryActions_Cloneview               = "CloneView"
	GetRecoveriesOptions_RecoveryActions_Clonevms                = "CloneVMs"
	GetRecoveriesOptions_RecoveryActions_Clonevmstoview          = "CloneVMsToView"
	GetRecoveriesOptions_RecoveryActions_Convertanddeployvms     = "ConvertAndDeployVMs"
	GetRecoveriesOptions_RecoveryActions_Converttopst            = "ConvertToPst"
	GetRecoveriesOptions_RecoveryActions_Deployvms               = "DeployVMs"
	GetRecoveriesOptions_RecoveryActions_Downloadchats           = "DownloadChats"
	GetRecoveriesOptions_RecoveryActions_Downloadfilesandfolders = "DownloadFilesAndFolders"
	GetRecoveriesOptions_RecoveryActions_Instantvolumemount      = "InstantVolumeMount"
	GetRecoveriesOptions_RecoveryActions_Recoverapps             = "RecoverApps"
	GetRecoveriesOptions_RecoveryActions_Recoveraurora           = "RecoverAurora"
	GetRecoveriesOptions_RecoveryActions_Recoverazuresql         = "RecoverAzureSQL"
	GetRecoveriesOptions_RecoveryActions_Recoverexchangedbs      = "RecoverExchangeDbs"
	GetRecoveriesOptions_RecoveryActions_Recoverfiles            = "RecoverFiles"
	GetRecoveriesOptions_RecoveryActions_Recovermailbox          = "RecoverMailbox"
	GetRecoveriesOptions_RecoveryActions_Recovermailboxcsm       = "RecoverMailboxCSM"
	GetRecoveriesOptions_RecoveryActions_Recovermsgroup          = "RecoverMsGroup"
	GetRecoveriesOptions_RecoveryActions_Recovermsteam           = "RecoverMsTeam"
	GetRecoveriesOptions_RecoveryActions_Recovernamespaces       = "RecoverNamespaces"
	GetRecoveriesOptions_RecoveryActions_Recovernasvolume        = "RecoverNasVolume"
	GetRecoveriesOptions_RecoveryActions_Recoverobjects          = "RecoverObjects"
	GetRecoveriesOptions_RecoveryActions_Recoveronedrive         = "RecoverOneDrive"
	GetRecoveriesOptions_RecoveryActions_Recoveronedrivecsm      = "RecoverOneDriveCSM"
	GetRecoveriesOptions_RecoveryActions_Recoverphysicalvolumes  = "RecoverPhysicalVolumes"
	GetRecoveriesOptions_RecoveryActions_Recoverpublicfolders    = "RecoverPublicFolders"
	GetRecoveriesOptions_RecoveryActions_Recoverrds              = "RecoverRDS"
	GetRecoveriesOptions_RecoveryActions_Recoverrdspostgres      = "RecoverRDSPostgres"
	GetRecoveriesOptions_RecoveryActions_Recovers3buckets        = "RecoverS3Buckets"
	GetRecoveriesOptions_RecoveryActions_Recoversangroup         = "RecoverSanGroup"
	GetRecoveriesOptions_RecoveryActions_Recoversanvolumes       = "RecoverSanVolumes"
	GetRecoveriesOptions_RecoveryActions_Recoversfdcobjects      = "RecoverSfdcObjects"
	GetRecoveriesOptions_RecoveryActions_Recoversfdcorg          = "RecoverSfdcOrg"
	GetRecoveriesOptions_RecoveryActions_Recoversfdcrecords      = "RecoverSfdcRecords"
	GetRecoveriesOptions_RecoveryActions_Recoversharepoint       = "RecoverSharePoint"
	GetRecoveriesOptions_RecoveryActions_Recoversharepointcsm    = "RecoverSharePointCSM"
	GetRecoveriesOptions_RecoveryActions_Recoversystem           = "RecoverSystem"
	GetRecoveriesOptions_RecoveryActions_Recovervapps            = "RecoverVApps"
	GetRecoveriesOptions_RecoveryActions_Recovervapptemplates    = "RecoverVAppTemplates"
	GetRecoveriesOptions_RecoveryActions_Recovervmdisks          = "RecoverVmDisks"
	GetRecoveriesOptions_RecoveryActions_Recovervms              = "RecoverVMs"
	GetRecoveriesOptions_RecoveryActions_Uptiersnapshot          = "UptierSnapshot"
)

// NewGetRecoveriesOptions : Instantiate GetRecoveriesOptions
func (*BackupRecoveryV1) NewGetRecoveriesOptions(xIBMTenantID string) *GetRecoveriesOptions {
	return &GetRecoveriesOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetRecoveriesOptions) SetXIBMTenantID(xIBMTenantID string) *GetRecoveriesOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetIds : Allow user to set Ids
func (_options *GetRecoveriesOptions) SetIds(ids []string) *GetRecoveriesOptions {
	_options.Ids = ids
	return _options
}

// SetReturnOnlyChildRecoveries : Allow user to set ReturnOnlyChildRecoveries
func (_options *GetRecoveriesOptions) SetReturnOnlyChildRecoveries(returnOnlyChildRecoveries bool) *GetRecoveriesOptions {
	_options.ReturnOnlyChildRecoveries = core.BoolPtr(returnOnlyChildRecoveries)
	return _options
}

// SetStartTimeUsecs : Allow user to set StartTimeUsecs
func (_options *GetRecoveriesOptions) SetStartTimeUsecs(startTimeUsecs int64) *GetRecoveriesOptions {
	_options.StartTimeUsecs = core.Int64Ptr(startTimeUsecs)
	return _options
}

// SetEndTimeUsecs : Allow user to set EndTimeUsecs
func (_options *GetRecoveriesOptions) SetEndTimeUsecs(endTimeUsecs int64) *GetRecoveriesOptions {
	_options.EndTimeUsecs = core.Int64Ptr(endTimeUsecs)
	return _options
}

// SetSnapshotTargetType : Allow user to set SnapshotTargetType
func (_options *GetRecoveriesOptions) SetSnapshotTargetType(snapshotTargetType []string) *GetRecoveriesOptions {
	_options.SnapshotTargetType = snapshotTargetType
	return _options
}

// SetArchivalTargetType : Allow user to set ArchivalTargetType
func (_options *GetRecoveriesOptions) SetArchivalTargetType(archivalTargetType []string) *GetRecoveriesOptions {
	_options.ArchivalTargetType = archivalTargetType
	return _options
}

// SetSnapshotEnvironments : Allow user to set SnapshotEnvironments
func (_options *GetRecoveriesOptions) SetSnapshotEnvironments(snapshotEnvironments []string) *GetRecoveriesOptions {
	_options.SnapshotEnvironments = snapshotEnvironments
	return _options
}

// SetStatus : Allow user to set Status
func (_options *GetRecoveriesOptions) SetStatus(status []string) *GetRecoveriesOptions {
	_options.Status = status
	return _options
}

// SetRecoveryActions : Allow user to set RecoveryActions
func (_options *GetRecoveriesOptions) SetRecoveryActions(recoveryActions []string) *GetRecoveriesOptions {
	_options.RecoveryActions = recoveryActions
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetRecoveriesOptions) SetHeaders(param map[string]string) *GetRecoveriesOptions {
	options.Headers = param
	return options
}

// GetRecoveryByIdOptions : The GetRecoveryByID options.
type GetRecoveryByIdOptions struct {
	// Specifies the id of a Recovery.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRecoveryByIdOptions : Instantiate GetRecoveryByIdOptions
func (*BackupRecoveryV1) NewGetRecoveryByIdOptions(id string, xIBMTenantID string) *GetRecoveryByIdOptions {
	return &GetRecoveryByIdOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *GetRecoveryByIdOptions) SetID(id string) *GetRecoveryByIdOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetRecoveryByIdOptions) SetXIBMTenantID(xIBMTenantID string) *GetRecoveryByIdOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetRecoveryByIdOptions) SetHeaders(param map[string]string) *GetRecoveryByIdOptions {
	options.Headers = param
	return options
}

// GetRestorePointsInTimeRangeOptions : The GetRestorePointsInTimeRange options.
type GetRestorePointsInTimeRangeOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the end time specified as a Unix epoch Timestamp in microseconds.
	EndTimeUsecs *int64 `json:"endTimeUsecs" validate:"required"`

	// Specifies the protection source environment type.
	Environment *string `json:"environment" validate:"required"`

	// Specifies the jobs for which to get the full snapshot information.
	ProtectionGroupIds []string `json:"protectionGroupIds" validate:"required"`

	// Specifies the start time specified as a Unix epoch Timestamp in microseconds.
	StartTimeUsecs *int64 `json:"startTimeUsecs" validate:"required"`

	// Specifies the id of the Protection Source which is to be restored.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetRestorePointsInTimeRangeOptions.Environment property.
// Specifies the protection source environment type.
const (
	GetRestorePointsInTimeRangeOptions_Environment_Kacropolis      = "kAcropolis"
	GetRestorePointsInTimeRangeOptions_Environment_Kad             = "kAD"
	GetRestorePointsInTimeRangeOptions_Environment_Kaws            = "kAWS"
	GetRestorePointsInTimeRangeOptions_Environment_Kazure          = "kAzure"
	GetRestorePointsInTimeRangeOptions_Environment_Kcassandra      = "kCassandra"
	GetRestorePointsInTimeRangeOptions_Environment_Kcouchbase      = "kCouchbase"
	GetRestorePointsInTimeRangeOptions_Environment_Kelastifile     = "kElastifile"
	GetRestorePointsInTimeRangeOptions_Environment_Kexchange       = "kExchange"
	GetRestorePointsInTimeRangeOptions_Environment_Kflashblade     = "kFlashBlade"
	GetRestorePointsInTimeRangeOptions_Environment_Kgcp            = "kGCP"
	GetRestorePointsInTimeRangeOptions_Environment_Kgenericnas     = "kGenericNas"
	GetRestorePointsInTimeRangeOptions_Environment_Kgpfs           = "kGPFS"
	GetRestorePointsInTimeRangeOptions_Environment_Khbase          = "kHBase"
	GetRestorePointsInTimeRangeOptions_Environment_Khdfs           = "kHdfs"
	GetRestorePointsInTimeRangeOptions_Environment_Khive           = "kHive"
	GetRestorePointsInTimeRangeOptions_Environment_Khyperv         = "kHyperV"
	GetRestorePointsInTimeRangeOptions_Environment_Kibmflashsystem = "kIbmFlashSystem"
	GetRestorePointsInTimeRangeOptions_Environment_Kisilon         = "kIsilon"
	GetRestorePointsInTimeRangeOptions_Environment_Kkubernetes     = "kKubernetes"
	GetRestorePointsInTimeRangeOptions_Environment_Kkvm            = "kKVM"
	GetRestorePointsInTimeRangeOptions_Environment_Kmongodb        = "kMongoDB"
	GetRestorePointsInTimeRangeOptions_Environment_Knetapp         = "kNetapp"
	GetRestorePointsInTimeRangeOptions_Environment_Ko365           = "kO365"
	GetRestorePointsInTimeRangeOptions_Environment_Koracle         = "kOracle"
	GetRestorePointsInTimeRangeOptions_Environment_Kphysical       = "kPhysical"
	GetRestorePointsInTimeRangeOptions_Environment_Kpure           = "kPure"
	GetRestorePointsInTimeRangeOptions_Environment_Kremoteadapter  = "kRemoteAdapter"
	GetRestorePointsInTimeRangeOptions_Environment_Ksaphana        = "kSAPHANA"
	GetRestorePointsInTimeRangeOptions_Environment_Ksfdc           = "kSfdc"
	GetRestorePointsInTimeRangeOptions_Environment_Ksql            = "kSQL"
	GetRestorePointsInTimeRangeOptions_Environment_Kuda            = "kUDA"
	GetRestorePointsInTimeRangeOptions_Environment_Kview           = "kView"
	GetRestorePointsInTimeRangeOptions_Environment_Kvmware         = "kVMware"
)

// NewGetRestorePointsInTimeRangeOptions : Instantiate GetRestorePointsInTimeRangeOptions
func (*BackupRecoveryV1) NewGetRestorePointsInTimeRangeOptions(xIBMTenantID string, endTimeUsecs int64, environment string, protectionGroupIds []string, startTimeUsecs int64) *GetRestorePointsInTimeRangeOptions {
	return &GetRestorePointsInTimeRangeOptions{
		XIBMTenantID:       core.StringPtr(xIBMTenantID),
		EndTimeUsecs:       core.Int64Ptr(endTimeUsecs),
		Environment:        core.StringPtr(environment),
		ProtectionGroupIds: protectionGroupIds,
		StartTimeUsecs:     core.Int64Ptr(startTimeUsecs),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetRestorePointsInTimeRangeOptions) SetXIBMTenantID(xIBMTenantID string) *GetRestorePointsInTimeRangeOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetEndTimeUsecs : Allow user to set EndTimeUsecs
func (_options *GetRestorePointsInTimeRangeOptions) SetEndTimeUsecs(endTimeUsecs int64) *GetRestorePointsInTimeRangeOptions {
	_options.EndTimeUsecs = core.Int64Ptr(endTimeUsecs)
	return _options
}

// SetEnvironment : Allow user to set Environment
func (_options *GetRestorePointsInTimeRangeOptions) SetEnvironment(environment string) *GetRestorePointsInTimeRangeOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetProtectionGroupIds : Allow user to set ProtectionGroupIds
func (_options *GetRestorePointsInTimeRangeOptions) SetProtectionGroupIds(protectionGroupIds []string) *GetRestorePointsInTimeRangeOptions {
	_options.ProtectionGroupIds = protectionGroupIds
	return _options
}

// SetStartTimeUsecs : Allow user to set StartTimeUsecs
func (_options *GetRestorePointsInTimeRangeOptions) SetStartTimeUsecs(startTimeUsecs int64) *GetRestorePointsInTimeRangeOptions {
	_options.StartTimeUsecs = core.Int64Ptr(startTimeUsecs)
	return _options
}

// SetSourceID : Allow user to set SourceID
func (_options *GetRestorePointsInTimeRangeOptions) SetSourceID(sourceID int64) *GetRestorePointsInTimeRangeOptions {
	_options.SourceID = core.Int64Ptr(sourceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetRestorePointsInTimeRangeOptions) SetHeaders(param map[string]string) *GetRestorePointsInTimeRangeOptions {
	options.Headers = param
	return options
}

// GetRestorePointsInTimeRangeResponse : Specifies the model for the response returned by RestorePointsForTimeRange API.
type GetRestorePointsInTimeRangeResponse struct {
	// Specifies the info related to the recovery object.
	FullSnapshotInfo []FullSnapshotInfo `json:"fullSnapshotInfo,omitempty"`

	// Information about a set of disjoint, possibly annotated time ranges.
	TimeRangeInfo *TimeRangeInfo `json:"timeRangeInfo,omitempty"`
}

// UnmarshalGetRestorePointsInTimeRangeResponse unmarshals an instance of GetRestorePointsInTimeRangeResponse from the specified map of raw messages.
func UnmarshalGetRestorePointsInTimeRangeResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetRestorePointsInTimeRangeResponse)
	err = core.UnmarshalModel(m, "fullSnapshotInfo", &obj.FullSnapshotInfo, UnmarshalFullSnapshotInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullSnapshotInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "timeRangeInfo", &obj.TimeRangeInfo, UnmarshalTimeRangeInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeRangeInfo-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetSourceRegistrationsOptions : The GetSourceRegistrations options.
type GetSourceRegistrationsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Ids specifies the list of source registration ids to return. If left empty, every source registration will be
	// returned by default.
	Ids []int64 `json:"ids,omitempty"`

	// If true, the encrypted crednetial for the registered sources will be included. Credential is first encrypted with
	// internal key and then reencrypted with user supplied encryption key.
	IncludeSourceCredentials *bool `json:"includeSourceCredentials,omitempty"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the
	// read replica and primary data source.
	UseCachedData *bool `json:"useCachedData,omitempty"`

	// If true, the external entity metadata like maintenance mode config for the registered sources will be included.
	IncludeExternalMetadata *bool `json:"includeExternalMetadata,omitempty"`

	// If true, tenant migration check will be ignored.
	IgnoreTenantMigrationInProgressCheck *bool `json:"ignoreTenantMigrationInProgressCheck,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSourceRegistrationsOptions : Instantiate GetSourceRegistrationsOptions
func (*BackupRecoveryV1) NewGetSourceRegistrationsOptions(xIBMTenantID string) *GetSourceRegistrationsOptions {
	return &GetSourceRegistrationsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetSourceRegistrationsOptions) SetXIBMTenantID(xIBMTenantID string) *GetSourceRegistrationsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetIds : Allow user to set Ids
func (_options *GetSourceRegistrationsOptions) SetIds(ids []int64) *GetSourceRegistrationsOptions {
	_options.Ids = ids
	return _options
}

// SetIncludeSourceCredentials : Allow user to set IncludeSourceCredentials
func (_options *GetSourceRegistrationsOptions) SetIncludeSourceCredentials(includeSourceCredentials bool) *GetSourceRegistrationsOptions {
	_options.IncludeSourceCredentials = core.BoolPtr(includeSourceCredentials)
	return _options
}

// SetEncryptionKey : Allow user to set EncryptionKey
func (_options *GetSourceRegistrationsOptions) SetEncryptionKey(encryptionKey string) *GetSourceRegistrationsOptions {
	_options.EncryptionKey = core.StringPtr(encryptionKey)
	return _options
}

// SetUseCachedData : Allow user to set UseCachedData
func (_options *GetSourceRegistrationsOptions) SetUseCachedData(useCachedData bool) *GetSourceRegistrationsOptions {
	_options.UseCachedData = core.BoolPtr(useCachedData)
	return _options
}

// SetIncludeExternalMetadata : Allow user to set IncludeExternalMetadata
func (_options *GetSourceRegistrationsOptions) SetIncludeExternalMetadata(includeExternalMetadata bool) *GetSourceRegistrationsOptions {
	_options.IncludeExternalMetadata = core.BoolPtr(includeExternalMetadata)
	return _options
}

// SetIgnoreTenantMigrationInProgressCheck : Allow user to set IgnoreTenantMigrationInProgressCheck
func (_options *GetSourceRegistrationsOptions) SetIgnoreTenantMigrationInProgressCheck(ignoreTenantMigrationInProgressCheck bool) *GetSourceRegistrationsOptions {
	_options.IgnoreTenantMigrationInProgressCheck = core.BoolPtr(ignoreTenantMigrationInProgressCheck)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSourceRegistrationsOptions) SetHeaders(param map[string]string) *GetSourceRegistrationsOptions {
	options.Headers = param
	return options
}

// GetUpgradeTasksOptions : The GetUpgradeTasks options.
type GetUpgradeTasksOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies IDs of tasks to be fetched.
	Ids []int64 `json:"ids,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetUpgradeTasksOptions : Instantiate GetUpgradeTasksOptions
func (*BackupRecoveryV1) NewGetUpgradeTasksOptions(xIBMTenantID string) *GetUpgradeTasksOptions {
	return &GetUpgradeTasksOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *GetUpgradeTasksOptions) SetXIBMTenantID(xIBMTenantID string) *GetUpgradeTasksOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetIds : Allow user to set Ids
func (_options *GetUpgradeTasksOptions) SetIds(ids []int64) *GetUpgradeTasksOptions {
	_options.Ids = ids
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetUpgradeTasksOptions) SetHeaders(param map[string]string) *GetUpgradeTasksOptions {
	options.Headers = param
	return options
}

// GoogleTier : Specifies the settings for a Google tier.
type GoogleTier struct {
	// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
	// 'moveAfter' field specified below.
	MoveAfterUnit *string `json:"moveAfterUnit,omitempty"`

	// Specifies the time period after which the backup will be moved from current tier to next tier.
	MoveAfter *int64 `json:"moveAfter,omitempty"`

	// Specifies the Google tier types.
	TierType *string `json:"tierType" validate:"required"`
}

// Constants associated with the GoogleTier.MoveAfterUnit property.
// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
// 'moveAfter' field specified below.
const (
	GoogleTier_MoveAfterUnit_Days   = "Days"
	GoogleTier_MoveAfterUnit_Months = "Months"
	GoogleTier_MoveAfterUnit_Weeks  = "Weeks"
	GoogleTier_MoveAfterUnit_Years  = "Years"
)

// Constants associated with the GoogleTier.TierType property.
// Specifies the Google tier types.
const (
	GoogleTier_TierType_Kgooglecoldline      = "kGoogleColdline"
	GoogleTier_TierType_Kgooglemultiregional = "kGoogleMultiRegional"
	GoogleTier_TierType_Kgooglenearline      = "kGoogleNearline"
	GoogleTier_TierType_Kgoogleregional      = "kGoogleRegional"
	GoogleTier_TierType_Kgooglestandard      = "kGoogleStandard"
)

// NewGoogleTier : Instantiate GoogleTier (Generic Model Constructor)
func (*BackupRecoveryV1) NewGoogleTier(tierType string) (_model *GoogleTier, err error) {
	_model = &GoogleTier{
		TierType: core.StringPtr(tierType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGoogleTier unmarshals an instance of GoogleTier from the specified map of raw messages.
func UnmarshalGoogleTier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GoogleTier)
	err = core.UnmarshalPrimitive(m, "moveAfterUnit", &obj.MoveAfterUnit)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfterUnit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "moveAfter", &obj.MoveAfter)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tierType", &obj.TierType)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GoogleTiers : Specifies Google tiers.
type GoogleTiers struct {
	// Specifies the tiers that are used to move the archived backup from current tier to next tier. The order of the tiers
	// determines which tier will be used next for moving the archived backup. The first tier input should always be
	// default tier where backup will be acrhived. Each tier specifies how much time after the backup will be moved to next
	// tier from the current tier.
	Tiers []GoogleTier `json:"tiers" validate:"required"`
}

// NewGoogleTiers : Instantiate GoogleTiers (Generic Model Constructor)
func (*BackupRecoveryV1) NewGoogleTiers(tiers []GoogleTier) (_model *GoogleTiers, err error) {
	_model = &GoogleTiers{
		Tiers: tiers,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGoogleTiers unmarshals an instance of GoogleTiers from the specified map of raw messages.
func UnmarshalGoogleTiers(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GoogleTiers)
	err = core.UnmarshalModel(m, "tiers", &obj.Tiers, UnmarshalGoogleTier)
	if err != nil {
		err = core.SDKErrorf(err, "", "tiers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Group : Specifies a user group object.
type Group struct {
	// Specifies the name of the user group.
	Name *string `json:"name,omitempty"`

	// Specifies the sid of the user group.
	Sid *string `json:"sid,omitempty"`

	// Specifies the domain of the user group.
	Domain *string `json:"domain,omitempty"`
}

// UnmarshalGroup unmarshals an instance of Group from the specified map of raw messages.
func UnmarshalGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Group)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sid", &obj.Sid)
	if err != nil {
		err = core.SDKErrorf(err, "", "sid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		err = core.SDKErrorf(err, "", "domain-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HDFSIndexedObject : Specifies an HDFS indexed object.
type HDFSIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies the HDFS Object Type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the HDFSIndexedObject.Type property.
// Specifies the HDFS Object Type.
const (
	HDFSIndexedObject_Type_Hdfsfiles   = "HDFSFiles"
	HDFSIndexedObject_Type_Hdfsfolders = "HDFSFolders"
)

// UnmarshalHDFSIndexedObject unmarshals an instance of HDFSIndexedObject from the specified map of raw messages.
func UnmarshalHDFSIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HDFSIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HDFSOnPremSearchParams : Parameters required to search HDFS on a cluster.
type HDFSOnPremSearchParams struct {
	// Specifies types as Folders or Files or both to be searched.
	HdfsTypes []string `json:"hdfsTypes" validate:"required"`

	// Specifies the search string to search the HDFS Folders and Files.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// Constants associated with the HDFSOnPremSearchParams.HdfsTypes property.
const (
	HDFSOnPremSearchParams_HdfsTypes_Hdfsfiles   = "HDFSFiles"
	HDFSOnPremSearchParams_HdfsTypes_Hdfsfolders = "HDFSFolders"
)

// NewHDFSOnPremSearchParams : Instantiate HDFSOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewHDFSOnPremSearchParams(hdfsTypes []string, searchString string) (_model *HDFSOnPremSearchParams, err error) {
	_model = &HDFSOnPremSearchParams{
		HdfsTypes:    hdfsTypes,
		SearchString: core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalHDFSOnPremSearchParams unmarshals an instance of HDFSOnPremSearchParams from the specified map of raw messages.
func UnmarshalHDFSOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HDFSOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "hdfsTypes", &obj.HdfsTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "hdfsTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HbaseIndexedObject : Specifies an Hbase indexed object.
type HbaseIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies the Hbase Object Type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the HbaseIndexedObject.Type property.
// Specifies the Hbase Object Type.
const (
	HbaseIndexedObject_Type_Hbasenamespaces = "HbaseNamespaces"
	HbaseIndexedObject_Type_Hbasetables     = "HbaseTables"
)

// UnmarshalHbaseIndexedObject unmarshals an instance of HbaseIndexedObject from the specified map of raw messages.
func UnmarshalHbaseIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HbaseIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HbaseOnPremSearchParams : Parameters required to search Hbase on a cluster.
type HbaseOnPremSearchParams struct {
	// Specifies one or more Hbase object types be searched.
	HbaseObjectTypes []string `json:"hbaseObjectTypes" validate:"required"`

	// Specifies the search string to search the Hbase Objects.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// Constants associated with the HbaseOnPremSearchParams.HbaseObjectTypes property.
const (
	HbaseOnPremSearchParams_HbaseObjectTypes_Hbasenamespaces = "HbaseNamespaces"
	HbaseOnPremSearchParams_HbaseObjectTypes_Hbasetables     = "HbaseTables"
)

// NewHbaseOnPremSearchParams : Instantiate HbaseOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewHbaseOnPremSearchParams(hbaseObjectTypes []string, searchString string) (_model *HbaseOnPremSearchParams, err error) {
	_model = &HbaseOnPremSearchParams{
		HbaseObjectTypes: hbaseObjectTypes,
		SearchString:     core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalHbaseOnPremSearchParams unmarshals an instance of HbaseOnPremSearchParams from the specified map of raw messages.
func UnmarshalHbaseOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HbaseOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "hbaseObjectTypes", &obj.HbaseObjectTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "hbaseObjectTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HeliosTagInfo : Specifies the helios tag info for an object.
type HeliosTagInfo struct {
	// Specifies category of tag applied to the object.
	Category *string `json:"category,omitempty"`

	// Specifies name of tag applied to the object.
	Name *string `json:"name,omitempty"`

	// Specifies subCategory of tag applied to the object.
	SubCategory *string `json:"subCategory,omitempty"`

	// Specifies thirdPartyName of tag applied to the object.
	ThirdPartyName *string `json:"thirdPartyName,omitempty"`

	// Specifies the type (ex custom, thirdparty, system) of tag applied to the object.
	Type *string `json:"type,omitempty"`

	// Specifies the color of tag applied to the object.
	UiColor *string `json:"uiColor,omitempty"`

	// Specifies update time of tag applied to the object.
	UpdatedTimeUsecs *int64 `json:"updatedTimeUsecs,omitempty"`

	// Specifies Uuid of tag applied to the object.
	UUID *string `json:"uuid" validate:"required"`
}

// Constants associated with the HeliosTagInfo.Category property.
// Specifies category of tag applied to the object.
const (
	HeliosTagInfo_Category_Security = "Security"
)

// Constants associated with the HeliosTagInfo.SubCategory property.
// Specifies subCategory of tag applied to the object.
const (
	HeliosTagInfo_SubCategory_Anomalies      = "Anomalies"
	HeliosTagInfo_SubCategory_Classification = "Classification"
	HeliosTagInfo_SubCategory_Dspm           = "Dspm"
	HeliosTagInfo_SubCategory_Threats        = "Threats"
)

// Constants associated with the HeliosTagInfo.Type property.
// Specifies the type (ex custom, thirdparty, system) of tag applied to the object.
const (
	HeliosTagInfo_Type_Custom     = "Custom"
	HeliosTagInfo_Type_System     = "System"
	HeliosTagInfo_Type_Thirdparty = "ThirdParty"
)

// UnmarshalHeliosTagInfo unmarshals an instance of HeliosTagInfo from the specified map of raw messages.
func UnmarshalHeliosTagInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HeliosTagInfo)
	err = core.UnmarshalPrimitive(m, "category", &obj.Category)
	if err != nil {
		err = core.SDKErrorf(err, "", "category-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "subCategory", &obj.SubCategory)
	if err != nil {
		err = core.SDKErrorf(err, "", "subCategory-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "thirdPartyName", &obj.ThirdPartyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "thirdPartyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uiColor", &obj.UiColor)
	if err != nil {
		err = core.SDKErrorf(err, "", "uiColor-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updatedTimeUsecs", &obj.UpdatedTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "updatedTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HiveIndexedObject : Specifies a Hive indexed object.
type HiveIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies the Hive Object Type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the HiveIndexedObject.Type property.
// Specifies the Hive Object Type.
const (
	HiveIndexedObject_Type_Hivedatabases  = "HiveDatabases"
	HiveIndexedObject_Type_Hivepartitions = "HivePartitions"
	HiveIndexedObject_Type_Hivetables     = "HiveTables"
)

// UnmarshalHiveIndexedObject unmarshals an instance of HiveIndexedObject from the specified map of raw messages.
func UnmarshalHiveIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HiveIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HiveOnPremSearchParams : Parameters required to search Hive on a cluster.
type HiveOnPremSearchParams struct {
	// Specifies one or more Hive object types be searched.
	HiveObjectTypes []string `json:"hiveObjectTypes" validate:"required"`

	// Specifies the search string to search the Hive Objects.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// Constants associated with the HiveOnPremSearchParams.HiveObjectTypes property.
const (
	HiveOnPremSearchParams_HiveObjectTypes_Hivedatabases  = "HiveDatabases"
	HiveOnPremSearchParams_HiveObjectTypes_Hivepartitions = "HivePartitions"
	HiveOnPremSearchParams_HiveObjectTypes_Hivetables     = "HiveTables"
)

// NewHiveOnPremSearchParams : Instantiate HiveOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewHiveOnPremSearchParams(hiveObjectTypes []string, searchString string) (_model *HiveOnPremSearchParams, err error) {
	_model = &HiveOnPremSearchParams{
		HiveObjectTypes: hiveObjectTypes,
		SearchString:    core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalHiveOnPremSearchParams unmarshals an instance of HiveOnPremSearchParams from the specified map of raw messages.
func UnmarshalHiveOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HiveOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "hiveObjectTypes", &obj.HiveObjectTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "hiveObjectTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HostInformation : Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
// hosted by another object such as VM or physical server.
type HostInformation struct {
	// Specifies the id of the host object.
	ID *string `json:"id,omitempty"`

	// Specifies the name of the host object.
	Name *string `json:"name,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`
}

// Constants associated with the HostInformation.Environment property.
// Specifies the environment of the object.
const (
	HostInformation_Environment_Kphysical = "kPhysical"
	HostInformation_Environment_Ksql      = "kSQL"
)

// UnmarshalHostInformation unmarshals an instance of HostInformation from the specified map of raw messages.
func UnmarshalHostInformation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HostInformation)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HostSettingsCheckResult : Specifies the list of check results internally performed to verify status of various services such as 'AgnetRunning',
// 'SQLWriterRunning' etc.
type HostSettingsCheckResult struct {
	// Specifies the type of the check internally performed. Specifies the type of the host check performed internally.
	// 'kIsAgentPortAccessible' indicates the check for agent port access. 'kIsAgentRunning' indicates the status for the
	// Cohesity agent service. 'kIsSQLWriterRunning' indicates the status for SQLWriter service. 'kAreSQLInstancesRunning'
	// indicates the run status for all the SQL instances in the host. 'kCheckServiceLoginsConfig' checks the privileges
	// and sysadmin status of the logins used by the SQL instance services, Cohesity agent service and the SQLWriter
	// service. 'kCheckSQLFCIVIP' checks whether the SQL FCI is registered with a valid VIP or FQDN. 'kCheckSQLDiskSpace'
	// checks whether volumes containing SQL DBs have at least 10% free space.
	CheckType *string `json:"checkType,omitempty"`

	// Specifies the type of the result returned after performing the internal host check. Specifies the type of the host
	// check result performed internally. 'kPass' indicates that the respective check was successful. 'kFail' indicates
	// that the respective check failed as some mandatory setting is not met 'kWarning' indicates that the respective check
	// has warning as certain non-mandatory setting is not met.
	ResultType *string `json:"resultType,omitempty"`

	// Specifies a descriptive message for failed/warning types.
	UserMessage *string `json:"userMessage,omitempty"`
}

// Constants associated with the HostSettingsCheckResult.CheckType property.
// Specifies the type of the check internally performed. Specifies the type of the host check performed internally.
// 'kIsAgentPortAccessible' indicates the check for agent port access. 'kIsAgentRunning' indicates the status for the
// Cohesity agent service. 'kIsSQLWriterRunning' indicates the status for SQLWriter service. 'kAreSQLInstancesRunning'
// indicates the run status for all the SQL instances in the host. 'kCheckServiceLoginsConfig' checks the privileges and
// sysadmin status of the logins used by the SQL instance services, Cohesity agent service and the SQLWriter service.
// 'kCheckSQLFCIVIP' checks whether the SQL FCI is registered with a valid VIP or FQDN. 'kCheckSQLDiskSpace' checks
// whether volumes containing SQL DBs have at least 10% free space.
const (
	HostSettingsCheckResult_CheckType_Karesqlinstancesrunning   = "kAreSQLInstancesRunning"
	HostSettingsCheckResult_CheckType_Kcheckserviceloginsconfig = "kCheckServiceLoginsConfig"
	HostSettingsCheckResult_CheckType_Kchecksqldiskspace        = "kCheckSQLDiskSpace"
	HostSettingsCheckResult_CheckType_Kchecksqlfcivip           = "kCheckSQLFCIVIP"
	HostSettingsCheckResult_CheckType_Kisagentportaccessible    = "kIsAgentPortAccessible"
	HostSettingsCheckResult_CheckType_Kisagentrunning           = "kIsAgentRunning"
	HostSettingsCheckResult_CheckType_Kissqlwriterrunning       = "kIsSQLWriterRunning"
)

// Constants associated with the HostSettingsCheckResult.ResultType property.
// Specifies the type of the result returned after performing the internal host check. Specifies the type of the host
// check result performed internally. 'kPass' indicates that the respective check was successful. 'kFail' indicates that
// the respective check failed as some mandatory setting is not met 'kWarning' indicates that the respective check has
// warning as certain non-mandatory setting is not met.
const (
	HostSettingsCheckResult_ResultType_Kfail    = "kFail"
	HostSettingsCheckResult_ResultType_Kpass    = "kPass"
	HostSettingsCheckResult_ResultType_Kwarning = "kWarning"
)

// UnmarshalHostSettingsCheckResult unmarshals an instance of HostSettingsCheckResult from the specified map of raw messages.
func UnmarshalHostSettingsCheckResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HostSettingsCheckResult)
	err = core.UnmarshalPrimitive(m, "checkType", &obj.CheckType)
	if err != nil {
		err = core.SDKErrorf(err, "", "checkType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resultType", &obj.ResultType)
	if err != nil {
		err = core.SDKErrorf(err, "", "resultType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userMessage", &obj.UserMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "userMessage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HourSchedule : Specifies settings that define a schedule for a Protection Group runs to start after certain number of hours.
type HourSchedule struct {
	// Specifies a factor to multiply the unit by, to determine the backup schedule. <br> Example: If 'frequency' set to 2
	// and the unit is 'Hours', then Snapshots are backed up every 2 hours. <br> This field is only applicable if unit is
	// 'Minutes', 'Hours' or 'Days'.
	Frequency *int64 `json:"frequency" validate:"required"`
}

// NewHourSchedule : Instantiate HourSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewHourSchedule(frequency int64) (_model *HourSchedule, err error) {
	_model = &HourSchedule{
		Frequency: core.Int64Ptr(frequency),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalHourSchedule unmarshals an instance of HourSchedule from the specified map of raw messages.
func UnmarshalHourSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HourSchedule)
	err = core.UnmarshalPrimitive(m, "frequency", &obj.Frequency)
	if err != nil {
		err = core.SDKErrorf(err, "", "frequency-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HypervSnapshotParams : Specifies parameters of HyperV type snapshots.
type HypervSnapshotParams struct {
	// Specifies the protection type of HyperV snapshots.
	ProtectionType *string `json:"protectionType,omitempty"`
}

// Constants associated with the HypervSnapshotParams.ProtectionType property.
// Specifies the protection type of HyperV snapshots.
const (
	HypervSnapshotParams_ProtectionType_Kauto = "kAuto"
	HypervSnapshotParams_ProtectionType_Krct  = "kRCT"
	HypervSnapshotParams_ProtectionType_Kvss  = "kVSS"
)

// UnmarshalHypervSnapshotParams unmarshals an instance of HypervSnapshotParams from the specified map of raw messages.
func UnmarshalHypervSnapshotParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HypervSnapshotParams)
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IbmTenantCOSResourceConfig : Specifies the details of COS resource configuration required for posting metrics and trackinb billing information for
// IBM tenants.
type IbmTenantCOSResourceConfig struct {
	// Specifies the resource COS resource configuration endpoint that will be used for fetching bucket usage for a given
	// tenant.
	ResourceURL *string `json:"resourceURL,omitempty"`
}

// UnmarshalIbmTenantCOSResourceConfig unmarshals an instance of IbmTenantCOSResourceConfig from the specified map of raw messages.
func UnmarshalIbmTenantCOSResourceConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IbmTenantCOSResourceConfig)
	err = core.UnmarshalPrimitive(m, "resourceURL", &obj.ResourceURL)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceURL-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IbmTenantIAMMetricsConfig : Specifies the IAM configuration that will be used for accessing the billing service in IBM cloud.
type IbmTenantIAMMetricsConfig struct {
	// Specifies the IAM URL needed to fetch the operator token from IBM. The operator token is needed to make service API
	// calls to IBM billing service.
	IAMURL *string `json:"IAMUrl,omitempty"`

	// Specifies Id of the secret that contains the API key.
	BillingApiKeySecretID *string `json:"billingApiKeySecretId,omitempty"`
}

// UnmarshalIbmTenantIAMMetricsConfig unmarshals an instance of IbmTenantIAMMetricsConfig from the specified map of raw messages.
func UnmarshalIbmTenantIAMMetricsConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IbmTenantIAMMetricsConfig)
	err = core.UnmarshalPrimitive(m, "IAMUrl", &obj.IAMURL)
	if err != nil {
		err = core.SDKErrorf(err, "", "IAMUrl-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "billingApiKeySecretId", &obj.BillingApiKeySecretID)
	if err != nil {
		err = core.SDKErrorf(err, "", "billingApiKeySecretId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IbmTenantMetadataParams : Specifies the additional metadata for the tenant that is specifically set by the external vendor of type 'IBM'.
type IbmTenantMetadataParams struct {
	// Specifies the unique identifier of the IBM's account ID.
	AccountID *string `json:"accountId,omitempty"`

	// Specifies the unique CRN associated with the tenant.
	Crn *string `json:"crn,omitempty"`

	// Specifies the list of custom properties associated with the tenant. External vendors can choose to set any
	// properties inside following list. Note that the fields set inside the following will not be available for direct
	// filtering. API callers should make sure that no sensitive information such as passwords is sent in these fields.
	CustomProperties []ExternalVendorCustomProperties `json:"customProperties,omitempty"`

	// Specifies the current liveness mode of the tenant. This mode may change based on AZ failures when vendor chooses to
	// failover or failback the tenants to other AZs.
	LivenessMode *string `json:"livenessMode,omitempty"`

	// Specifies the metadata for metrics configuration. The metadata defined here will be used by cluster to send the
	// usgae metrics to IBM cloud metering service for calculating the tenant billing.
	MetricsConfig *IbmTenantMetricsConfig `json:"metricsConfig,omitempty"`

	// Specifies the current ownership mode for the tenant. The ownership of the tenant represents the active role for
	// functioning of the tenant.
	OwnershipMode *string `json:"ownershipMode,omitempty"`

	// Specifies the Plan Id associated with the tenant. This field is introduced for tracking purposes inside IBM
	// enviournment.
	PlanID *string `json:"planId,omitempty"`

	// Specifies the Resource Group ID associated with the tenant.
	ResourceGroupID *string `json:"resourceGroupId,omitempty"`

	// Specifies the Resource Instance ID associated with the tenant. This field is introduced for tracking purposes inside
	// IBM enviournment.
	ResourceInstanceID *string `json:"resourceInstanceId,omitempty"`
}

// Constants associated with the IbmTenantMetadataParams.LivenessMode property.
// Specifies the current liveness mode of the tenant. This mode may change based on AZ failures when vendor chooses to
// failover or failback the tenants to other AZs.
const (
	IbmTenantMetadataParams_LivenessMode_Active  = "Active"
	IbmTenantMetadataParams_LivenessMode_Standby = "Standby"
)

// Constants associated with the IbmTenantMetadataParams.OwnershipMode property.
// Specifies the current ownership mode for the tenant. The ownership of the tenant represents the active role for
// functioning of the tenant.
const (
	IbmTenantMetadataParams_OwnershipMode_Primary   = "Primary"
	IbmTenantMetadataParams_OwnershipMode_Secondary = "Secondary"
)

// UnmarshalIbmTenantMetadataParams unmarshals an instance of IbmTenantMetadataParams from the specified map of raw messages.
func UnmarshalIbmTenantMetadataParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IbmTenantMetadataParams)
	err = core.UnmarshalPrimitive(m, "accountId", &obj.AccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "accountId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "customProperties", &obj.CustomProperties, UnmarshalExternalVendorCustomProperties)
	if err != nil {
		err = core.SDKErrorf(err, "", "customProperties-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "livenessMode", &obj.LivenessMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "livenessMode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "metricsConfig", &obj.MetricsConfig, UnmarshalIbmTenantMetricsConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "metricsConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownershipMode", &obj.OwnershipMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownershipMode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "planId", &obj.PlanID)
	if err != nil {
		err = core.SDKErrorf(err, "", "planId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupId", &obj.ResourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceInstanceId", &obj.ResourceInstanceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceInstanceId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IbmTenantMeteringConfig : Specifies the metering configuration that will be used for IBM cluster to send the billing details to IBM billing
// service.
type IbmTenantMeteringConfig struct {
	// Specifies the list of part identifiers used for metrics identification.
	PartIds []string `json:"partIds,omitempty"`

	// Specifies the frequency in seconds at which the metrics will be pushed to IBM billing service from cluster.
	SubmissionIntervalInSecs *int64 `json:"submissionIntervalInSecs,omitempty"`

	// Specifies the base metering URL that will be used by cluster to send the billing information.
	URL *string `json:"url,omitempty"`
}

// Constants associated with the IbmTenantMeteringConfig.PartIds property.
const (
	IbmTenantMeteringConfig_PartIds_Usageterabyte = "USAGETERABYTE"
)

// UnmarshalIbmTenantMeteringConfig unmarshals an instance of IbmTenantMeteringConfig from the specified map of raw messages.
func UnmarshalIbmTenantMeteringConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IbmTenantMeteringConfig)
	err = core.UnmarshalPrimitive(m, "partIds", &obj.PartIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "partIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "submissionIntervalInSecs", &obj.SubmissionIntervalInSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "submissionIntervalInSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IbmTenantMetricsConfig : Specifies the metadata for metrics configuration. The metadata defined here will be used by cluster to send the usgae
// metrics to IBM cloud metering service for calculating the tenant billing.
type IbmTenantMetricsConfig struct {
	// Specifies the details of COS resource configuration required for posting metrics and trackinb billing information
	// for IBM tenants.
	CosResourceConfig *IbmTenantCOSResourceConfig `json:"cosResourceConfig,omitempty"`

	// Specifies the IAM configuration that will be used for accessing the billing service in IBM cloud.
	IamMetricsConfig *IbmTenantIAMMetricsConfig `json:"iamMetricsConfig,omitempty"`

	// Specifies the metering configuration that will be used for IBM cluster to send the billing details to IBM billing
	// service.
	MeteringConfig *IbmTenantMeteringConfig `json:"meteringConfig,omitempty"`
}

// UnmarshalIbmTenantMetricsConfig unmarshals an instance of IbmTenantMetricsConfig from the specified map of raw messages.
func UnmarshalIbmTenantMetricsConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IbmTenantMetricsConfig)
	err = core.UnmarshalModel(m, "cosResourceConfig", &obj.CosResourceConfig, UnmarshalIbmTenantCOSResourceConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "cosResourceConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "iamMetricsConfig", &obj.IamMetricsConfig, UnmarshalIbmTenantIAMMetricsConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "iamMetricsConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "meteringConfig", &obj.MeteringConfig, UnmarshalIbmTenantMeteringConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "meteringConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IncrementalBackupPolicy : Specifies incremental backup settings for a Protection Group.
type IncrementalBackupPolicy struct {
	// Specifies settings that defines how frequent backup will be performed for a Protection Group.
	Schedule *IncrementalSchedule `json:"schedule" validate:"required"`
}

// NewIncrementalBackupPolicy : Instantiate IncrementalBackupPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewIncrementalBackupPolicy(schedule *IncrementalSchedule) (_model *IncrementalBackupPolicy, err error) {
	_model = &IncrementalBackupPolicy{
		Schedule: schedule,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalIncrementalBackupPolicy unmarshals an instance of IncrementalBackupPolicy from the specified map of raw messages.
func UnmarshalIncrementalBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IncrementalBackupPolicy)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalIncrementalSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IncrementalSchedule : Specifies settings that defines how frequent backup will be performed for a Protection Group.
type IncrementalSchedule struct {
	// Specifies how often to start new runs of a Protection Group. <br>'Minutes' specifies that Protection Group run
	// starts periodically after certain number of minutes specified in 'frequency' field. <br>'Hours' specifies that
	// Protection Group run starts periodically after certain number of hours specified in 'frequency' field. <br>'Days'
	// specifies that Protection Group run starts periodically after certain number of days specified in 'frequency' field.
	// <br>'Week' specifies that new Protection Group runs start weekly on certain days specified using 'dayOfWeek' field.
	// <br>'Month' specifies that new Protection Group runs start monthly on certain day of specific week. This schedule
	// needs 'weekOfMonth' and 'dayOfWeek' fields to be set. <br> Example: To run the Protection Group on Second Sunday of
	// Every Month, following schedule need to be set: <br> unit: 'Month' <br> dayOfWeek: 'Sunday' <br> weekOfMonth:
	// 'Second'.
	Unit *string `json:"unit" validate:"required"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of minutes.
	MinuteSchedule *MinuteSchedule `json:"minuteSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of hours.
	HourSchedule *HourSchedule `json:"hourSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of days.
	DaySchedule *DaySchedule `json:"daySchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start on certain days of week.
	WeekSchedule *WeekSchedule `json:"weekSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to on specific week and specific days of that
	// week.
	MonthSchedule *MonthSchedule `json:"monthSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group to run on specific year and specific day of that
	// year.
	YearSchedule *YearSchedule `json:"yearSchedule,omitempty"`
}

// Constants associated with the IncrementalSchedule.Unit property.
// Specifies how often to start new runs of a Protection Group. <br>'Minutes' specifies that Protection Group run starts
// periodically after certain number of minutes specified in 'frequency' field. <br>'Hours' specifies that Protection
// Group run starts periodically after certain number of hours specified in 'frequency' field. <br>'Days' specifies that
// Protection Group run starts periodically after certain number of days specified in 'frequency' field. <br>'Week'
// specifies that new Protection Group runs start weekly on certain days specified using 'dayOfWeek' field. <br>'Month'
// specifies that new Protection Group runs start monthly on certain day of specific week. This schedule needs
// 'weekOfMonth' and 'dayOfWeek' fields to be set. <br> Example: To run the Protection Group on Second Sunday of Every
// Month, following schedule need to be set: <br> unit: 'Month' <br> dayOfWeek: 'Sunday' <br> weekOfMonth: 'Second'.
const (
	IncrementalSchedule_Unit_Days    = "Days"
	IncrementalSchedule_Unit_Hours   = "Hours"
	IncrementalSchedule_Unit_Minutes = "Minutes"
	IncrementalSchedule_Unit_Months  = "Months"
	IncrementalSchedule_Unit_Weeks   = "Weeks"
	IncrementalSchedule_Unit_Years   = "Years"
)

// NewIncrementalSchedule : Instantiate IncrementalSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewIncrementalSchedule(unit string) (_model *IncrementalSchedule, err error) {
	_model = &IncrementalSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalIncrementalSchedule unmarshals an instance of IncrementalSchedule from the specified map of raw messages.
func UnmarshalIncrementalSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IncrementalSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "minuteSchedule", &obj.MinuteSchedule, UnmarshalMinuteSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "minuteSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hourSchedule", &obj.HourSchedule, UnmarshalHourSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "hourSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "daySchedule", &obj.DaySchedule, UnmarshalDaySchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "daySchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "weekSchedule", &obj.WeekSchedule, UnmarshalWeekSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "weekSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "monthSchedule", &obj.MonthSchedule, UnmarshalMonthSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "monthSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "yearSchedule", &obj.YearSchedule, UnmarshalYearSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "yearSchedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IndexingPolicy : Specifies settings for indexing files found in an Object (such as a VM) so these files can be searched and recovered.
// This also specifies inclusion and exclusion rules that determine the directories to index.
type IndexingPolicy struct {
	// Specifies if the files found in an Object (such as a VM) should be indexed. If true (the default), files are
	// indexed.
	EnableIndexing *bool `json:"enableIndexing" validate:"required"`

	// Array of Indexed Directories. Specifies a list of directories to index. Regular expression can also be specified to
	// provide the directory paths. Example: /Users/<wildcard>/AppData.
	IncludePaths []string `json:"includePaths,omitempty"`

	// Array of Excluded Directories. Specifies a list of directories to exclude from indexing.Regular expression can also
	// be specified to provide the directory paths. Example: /Users/<wildcard>/AppData.
	ExcludePaths []string `json:"excludePaths,omitempty"`
}

// NewIndexingPolicy : Instantiate IndexingPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewIndexingPolicy(enableIndexing bool) (_model *IndexingPolicy, err error) {
	_model = &IndexingPolicy{
		EnableIndexing: core.BoolPtr(enableIndexing),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalIndexingPolicy unmarshals an instance of IndexingPolicy from the specified map of raw messages.
func UnmarshalIndexingPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IndexingPolicy)
	err = core.UnmarshalPrimitive(m, "enableIndexing", &obj.EnableIndexing)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableIndexing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "includePaths", &obj.IncludePaths)
	if err != nil {
		err = core.SDKErrorf(err, "", "includePaths-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "excludePaths", &obj.ExcludePaths)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludePaths-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IsilonObjectParams : Specifies the common parameters for Isilon objects.
type IsilonObjectParams struct {
	// Specifies a list of NAS mount protocols supported by this object.
	SupportedNasMountProtocols []string `json:"supportedNasMountProtocols,omitempty"`
}

// Constants associated with the IsilonObjectParams.SupportedNasMountProtocols property.
const (
	IsilonObjectParams_SupportedNasMountProtocols_Knfs = "kNfs"
	IsilonObjectParams_SupportedNasMountProtocols_Ksmb = "kSmb"
)

// UnmarshalIsilonObjectParams unmarshals an instance of IsilonObjectParams from the specified map of raw messages.
func UnmarshalIsilonObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IsilonObjectParams)
	err = core.UnmarshalPrimitive(m, "supportedNasMountProtocols", &obj.SupportedNasMountProtocols)
	if err != nil {
		err = core.SDKErrorf(err, "", "supportedNasMountProtocols-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyValuePair : Specifies a map structure to store Key and Values.
type KeyValuePair struct {
	// key.
	Key *string `json:"key" validate:"required"`

	// value.
	Value *string `json:"value" validate:"required"`
}

// NewKeyValuePair : Instantiate KeyValuePair (Generic Model Constructor)
func (*BackupRecoveryV1) NewKeyValuePair(key string, value string) (_model *KeyValuePair, err error) {
	_model = &KeyValuePair{
		Key:   core.StringPtr(key),
		Value: core.StringPtr(value),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalKeyValuePair unmarshals an instance of KeyValuePair from the specified map of raw messages.
func UnmarshalKeyValuePair(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyValuePair)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LatencyThresholds : Specifies latency thresholds that trigger throttling for all datastores found in the registered Protection Source or
// specific to one datastore.
type LatencyThresholds struct {
	// If the latency of a datastore is above this value, existing backup tasks using the datastore are throttled.
	ActiveTaskMsecs *int64 `json:"activeTaskMsecs,omitempty"`

	// If the latency of a datastore is above this value, then new backup tasks using the datastore will not be started.
	NewTaskMsecs *int64 `json:"newTaskMsecs,omitempty"`
}

// UnmarshalLatencyThresholds unmarshals an instance of LatencyThresholds from the specified map of raw messages.
func UnmarshalLatencyThresholds(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LatencyThresholds)
	err = core.UnmarshalPrimitive(m, "activeTaskMsecs", &obj.ActiveTaskMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "activeTaskMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "newTaskMsecs", &obj.NewTaskMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "newTaskMsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LinuxAgentParams : Linux agent parameters.
type LinuxAgentParams struct {
	// Specifies the type of installer.
	PackageType *string `json:"packageType" validate:"required"`
}

// Constants associated with the LinuxAgentParams.PackageType property.
// Specifies the type of installer.
const (
	LinuxAgentParams_PackageType_Kdeb        = "kDEB"
	LinuxAgentParams_PackageType_Kpowerpcrpm = "kPowerPCRPM"
	LinuxAgentParams_PackageType_Krpm        = "kRPM"
	LinuxAgentParams_PackageType_Kscript     = "kScript"
	LinuxAgentParams_PackageType_Ksuserpm    = "kSuseRPM"
)

// NewLinuxAgentParams : Instantiate LinuxAgentParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewLinuxAgentParams(packageType string) (_model *LinuxAgentParams, err error) {
	_model = &LinuxAgentParams{
		PackageType: core.StringPtr(packageType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalLinuxAgentParams unmarshals an instance of LinuxAgentParams from the specified map of raw messages.
func UnmarshalLinuxAgentParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LinuxAgentParams)
	err = core.UnmarshalPrimitive(m, "packageType", &obj.PackageType)
	if err != nil {
		err = core.SDKErrorf(err, "", "packageType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListProtectionSourcesOptions : The ListProtectionSources options.
type ListProtectionSourcesOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the Object types to be filtered out for Office 365 that match the passed in types such as 'kDomain',
	// 'kOutlook', 'kMailbox', etc. For example, set this parameter to 'kMailbox' to exclude Mailbox Objects from being
	// returned.
	ExcludeOffice365Types []string `json:"excludeOffice365Types,omitempty"`

	// Filter policies by a list of policy ids.
	GetTeamsChannels *bool `json:"getTeamsChannels,omitempty"`

	// Specifies the entity id starting from which the items are to be returned.
	AfterCursorEntityID *int64 `json:"afterCursorEntityId,omitempty"`

	// Specifies the entity id upto which the items are to be returned.
	BeforeCursorEntityID *int64 `json:"beforeCursorEntityId,omitempty"`

	// Specifies the entity id for the Node at any level within the Source entity hierarchy whose children are to be
	// paginated.
	NodeID *int64 `json:"nodeId,omitempty"`

	// Specifies the maximum number of entities to be returned within the page.
	PageSize *int64 `json:"pageSize,omitempty"`

	// If set to true, users with valid mailbox will be returned.
	HasValidMailbox *bool `json:"hasValidMailbox,omitempty"`

	// If set to true, users with valid onedrive will be returned.
	HasValidOnedrive *bool `json:"hasValidOnedrive,omitempty"`

	// If set to true, Groups which are security enabled will be returned.
	IsSecurityGroup *bool `json:"isSecurityGroup,omitempty"`

	// Return the Object subtree for the passed in Protection Source id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the expected number of levels from the root node to be returned in the entity hierarchy response.
	NumLevels *float64 `json:"numLevels,omitempty"`

	// Filter out the Object types (and their subtrees) that match the passed in types such as 'kVCenter', 'kFolder',
	// 'kDatacenter', 'kComputeResource', 'kResourcePool', 'kDatastore', 'kHostSystem', 'kVirtualMachine', etc. For
	// example, set this parameter to 'kResourcePool' to exclude Resource Pool Objects from being returned.
	ExcludeTypes []string `json:"excludeTypes,omitempty"`

	// Specifies the Object types to be filtered out for AWS that match the passed in types such as 'kEC2Instance',
	// 'kRDSInstance', 'kAuroraCluster', 'kTag', 'kAuroraTag', 'kRDSTag', kS3Bucket, kS3Tag. For example, set this
	// parameter to 'kEC2Instance' to exclude ec2 instance from being returned.
	ExcludeAwsTypes []string `json:"excludeAwsTypes,omitempty"`

	// Specifies the Object types to be filtered out for Kubernetes that match the passed in types such as 'kService'. For
	// example, set this parameter to 'kService' to exclude services from being returned.
	ExcludeKubernetesTypes []string `json:"excludeKubernetesTypes,omitempty"`

	// Set this parameter to true to also return kDatastore object types found in the Source in addition to their Object
	// subtrees. By default, datastores are not returned.
	IncludeDatastores *bool `json:"includeDatastores,omitempty"`

	// Set this parameter to true to also return kNetwork object types found in the Source in addition to their Object
	// subtrees. By default, network objects are not returned.
	IncludeNetworks *bool `json:"includeNetworks,omitempty"`

	// Set this parameter to true to also return kVMFolder object types found in the Source in addition to their Object
	// subtrees. By default, VM folder objects are not returned.
	IncludeVMFolders *bool `json:"includeVMFolders,omitempty"`

	// Set this parameter to true to also return fields of the object found in the Source in addition to their Object
	// subtrees. By default, Sfdc object fields are not returned.
	IncludeSfdcFields *bool `json:"includeSfdcFields,omitempty"`

	// Set this parameter to true to also return system VApp object types found in the Source in addition to their Object
	// subtrees. By default, VM folder objects are not returned.
	IncludeSystemVApps *bool `json:"includeSystemVApps,omitempty"`

	// Return only Protection Sources that match the passed in environment type such as 'kVMware', 'kSQL', 'kView'
	// 'kPhysical', 'kPuppeteer', 'kPure', 'kNetapp', 'kGenericNas', 'kHyperV', 'kAcropolis', or 'kAzure'. For example, set
	// this parameter to 'kVMware' to only return the Sources (and their Object subtrees) found in the 'kVMware' (VMware
	// vCenter Server) environment.
	Environments []string `json:"environments,omitempty"`

	// This field is deprecated. Use environments instead.
	// Deprecated: this field is deprecated and may be removed in a future release.
	Environment *string `json:"environment,omitempty"`

	// If specified, then a list of entites with permissions assigned to them are returned.
	IncludeEntityPermissionInfo *bool `json:"includeEntityPermissionInfo,omitempty"`

	// Filter the object subtree for the sids given in the list.
	Sids []string `json:"sids,omitempty"`

	// If specified, then crednetial for the registered sources will be included. Credential is first encrypted with
	// internal key and then reencrypted with user supplied 'encryption_key'.
	IncludeSourceCredentials *bool `json:"includeSourceCredentials,omitempty"`

	// Key to be used to encrypt the source credential. If include_source_credentials is set to true this key must be
	// specified.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// If specified, the object protection of entities(if any) will be returned.
	IncludeObjectProtectionInfo *bool `json:"includeObjectProtectionInfo,omitempty"`

	// Specifies whether to prune non critical info within entities. Incase of VMs, virtual disk information will be
	// pruned. Incase of Office365, metadata about user entities will be pruned. This can be used to limit the size of the
	// response by caller.
	PruneNonCriticalInfo *bool `json:"pruneNonCriticalInfo,omitempty"`

	// Specifies whether to prune the aggregation information about the number of entities protected/unprotected.
	PruneAggregationInfo *bool `json:"pruneAggregationInfo,omitempty"`

	// Specifies the type of the request. Possible values are UIUser and UIAuto, which means the request is triggered by
	// user or is an auto refresh request. Services like magneto will use this to determine the priority of the requests,
	// so that it can more intelligently handle overload situations by prioritizing higher priority requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Specifies whether we can serve the GET request to the read replica cache. setting this to true ensures that the API
	// request is served to the read replica. setting this to false will serve the request to the master.
	UseCachedData *bool `json:"useCachedData,omitempty"`

	// AllUnderHierarchy specifies if objects of all the tenants under the hierarchy of the logged in user's organization
	// should be returned.
	AllUnderHierarchy *bool `json:"allUnderHierarchy,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListProtectionSourcesOptions.ExcludeOffice365Types property.
const (
	ListProtectionSourcesOptions_ExcludeOffice365Types_Kdomain  = "kDomain"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Kgroup   = "kGroup"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Kgroups  = "kGroups"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Kmailbox = "kMailbox"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Koutlook = "kOutlook"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Ksite    = "kSite"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Ksites   = "kSites"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Kuser    = "kUser"
	ListProtectionSourcesOptions_ExcludeOffice365Types_Kusers   = "kUsers"
)

// Constants associated with the ListProtectionSourcesOptions.ExcludeTypes property.
const (
	ListProtectionSourcesOptions_ExcludeTypes_Kclustercomputeresource      = "kClusterComputeResource"
	ListProtectionSourcesOptions_ExcludeTypes_Kcomputeresource             = "kComputeResource"
	ListProtectionSourcesOptions_ExcludeTypes_Kdatacenter                  = "kDatacenter"
	ListProtectionSourcesOptions_ExcludeTypes_Kdatastore                   = "kDatastore"
	ListProtectionSourcesOptions_ExcludeTypes_Kdistributedvirtualportgroup = "kDistributedVirtualPortgroup"
	ListProtectionSourcesOptions_ExcludeTypes_Kfolder                      = "kFolder"
	ListProtectionSourcesOptions_ExcludeTypes_Khostsystem                  = "kHostSystem"
	ListProtectionSourcesOptions_ExcludeTypes_Knetwork                     = "kNetwork"
	ListProtectionSourcesOptions_ExcludeTypes_Kresourcepool                = "kResourcePool"
	ListProtectionSourcesOptions_ExcludeTypes_Kstandalonehost              = "kStandaloneHost"
	ListProtectionSourcesOptions_ExcludeTypes_Kstoragepod                  = "kStoragePod"
	ListProtectionSourcesOptions_ExcludeTypes_Ktag                         = "kTag"
	ListProtectionSourcesOptions_ExcludeTypes_Ktagcategory                 = "kTagCategory"
	ListProtectionSourcesOptions_ExcludeTypes_Kvcenter                     = "kVCenter"
	ListProtectionSourcesOptions_ExcludeTypes_Kvirtualapp                  = "kVirtualApp"
	ListProtectionSourcesOptions_ExcludeTypes_Kvirtualmachine              = "kVirtualMachine"
)

// Constants associated with the ListProtectionSourcesOptions.ExcludeAwsTypes property.
const (
	ListProtectionSourcesOptions_ExcludeAwsTypes_Kauroracluster = "kAuroraCluster"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Kauroratag     = "kAuroraTag"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Kec2instance   = "kEC2Instance"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Krdsinstance   = "kRDSInstance"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Krdstag        = "kRDSTag"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Ks3bucket      = "kS3Bucket"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Ks3tag         = "kS3Tag"
	ListProtectionSourcesOptions_ExcludeAwsTypes_Ktag           = "kTag"
)

// Constants associated with the ListProtectionSourcesOptions.ExcludeKubernetesTypes property.
const (
	ListProtectionSourcesOptions_ExcludeKubernetesTypes_Kservice = "kService"
)

// Constants associated with the ListProtectionSourcesOptions.Environments property.
const (
	ListProtectionSourcesOptions_Environments_Kacropolis          = "kAcropolis"
	ListProtectionSourcesOptions_Environments_Kad                 = "kAD"
	ListProtectionSourcesOptions_Environments_Kagent              = "kAgent"
	ListProtectionSourcesOptions_Environments_Kaws                = "kAWS"
	ListProtectionSourcesOptions_Environments_Kawsnative          = "kAWSNative"
	ListProtectionSourcesOptions_Environments_Kawss3              = "kAwsS3"
	ListProtectionSourcesOptions_Environments_Kazure              = "kAzure"
	ListProtectionSourcesOptions_Environments_Kazurenative        = "kAzureNative"
	ListProtectionSourcesOptions_Environments_Kcassandra          = "kCassandra"
	ListProtectionSourcesOptions_Environments_Kcouchbase          = "kCouchbase"
	ListProtectionSourcesOptions_Environments_Kelastifile         = "kElastifile"
	ListProtectionSourcesOptions_Environments_Kexchange           = "kExchange"
	ListProtectionSourcesOptions_Environments_Kflashblade         = "kFlashBlade"
	ListProtectionSourcesOptions_Environments_Kgcp                = "kGCP"
	ListProtectionSourcesOptions_Environments_Kgcpnative          = "kGCPNative"
	ListProtectionSourcesOptions_Environments_Kgenericnas         = "kGenericNas"
	ListProtectionSourcesOptions_Environments_Kgpfs               = "kGPFS"
	ListProtectionSourcesOptions_Environments_Khbase              = "kHBase"
	ListProtectionSourcesOptions_Environments_Khdfs               = "kHdfs"
	ListProtectionSourcesOptions_Environments_Khyperflex          = "kHyperFlex"
	ListProtectionSourcesOptions_Environments_Khyperv             = "kHyperV"
	ListProtectionSourcesOptions_Environments_Khypervvss          = "kHyperVVSS"
	ListProtectionSourcesOptions_Environments_Kisilon             = "kIsilon"
	ListProtectionSourcesOptions_Environments_Kkubernetes         = "kKubernetes"
	ListProtectionSourcesOptions_Environments_Kkvm                = "kKVM"
	ListProtectionSourcesOptions_Environments_Kmongodb            = "kMongoDB"
	ListProtectionSourcesOptions_Environments_Knetapp             = "kNetapp"
	ListProtectionSourcesOptions_Environments_Knimble             = "kNimble"
	ListProtectionSourcesOptions_Environments_Ko365               = "kO365"
	ListProtectionSourcesOptions_Environments_Ko365outlook        = "kO365Outlook"
	ListProtectionSourcesOptions_Environments_Koracle             = "kOracle"
	ListProtectionSourcesOptions_Environments_Kphysical           = "kPhysical"
	ListProtectionSourcesOptions_Environments_Kphysicalfiles      = "kPhysicalFiles"
	ListProtectionSourcesOptions_Environments_Kpuppeteer          = "kPuppeteer"
	ListProtectionSourcesOptions_Environments_Kpure               = "kPure"
	ListProtectionSourcesOptions_Environments_Krdssnapshotmanager = "kRDSSnapshotManager"
	ListProtectionSourcesOptions_Environments_Ksfdc               = "KSfdc"
	ListProtectionSourcesOptions_Environments_Ksql                = "kSQL"
	ListProtectionSourcesOptions_Environments_Kuda                = "kUDA"
	ListProtectionSourcesOptions_Environments_Kview               = "kView"
	ListProtectionSourcesOptions_Environments_Kvmware             = "kVMware"
)

// NewListProtectionSourcesOptions : Instantiate ListProtectionSourcesOptions
func (*BackupRecoveryV1) NewListProtectionSourcesOptions(xIBMTenantID string) *ListProtectionSourcesOptions {
	return &ListProtectionSourcesOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *ListProtectionSourcesOptions) SetXIBMTenantID(xIBMTenantID string) *ListProtectionSourcesOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetExcludeOffice365Types : Allow user to set ExcludeOffice365Types
func (_options *ListProtectionSourcesOptions) SetExcludeOffice365Types(excludeOffice365Types []string) *ListProtectionSourcesOptions {
	_options.ExcludeOffice365Types = excludeOffice365Types
	return _options
}

// SetGetTeamsChannels : Allow user to set GetTeamsChannels
func (_options *ListProtectionSourcesOptions) SetGetTeamsChannels(getTeamsChannels bool) *ListProtectionSourcesOptions {
	_options.GetTeamsChannels = core.BoolPtr(getTeamsChannels)
	return _options
}

// SetAfterCursorEntityID : Allow user to set AfterCursorEntityID
func (_options *ListProtectionSourcesOptions) SetAfterCursorEntityID(afterCursorEntityID int64) *ListProtectionSourcesOptions {
	_options.AfterCursorEntityID = core.Int64Ptr(afterCursorEntityID)
	return _options
}

// SetBeforeCursorEntityID : Allow user to set BeforeCursorEntityID
func (_options *ListProtectionSourcesOptions) SetBeforeCursorEntityID(beforeCursorEntityID int64) *ListProtectionSourcesOptions {
	_options.BeforeCursorEntityID = core.Int64Ptr(beforeCursorEntityID)
	return _options
}

// SetNodeID : Allow user to set NodeID
func (_options *ListProtectionSourcesOptions) SetNodeID(nodeID int64) *ListProtectionSourcesOptions {
	_options.NodeID = core.Int64Ptr(nodeID)
	return _options
}

// SetPageSize : Allow user to set PageSize
func (_options *ListProtectionSourcesOptions) SetPageSize(pageSize int64) *ListProtectionSourcesOptions {
	_options.PageSize = core.Int64Ptr(pageSize)
	return _options
}

// SetHasValidMailbox : Allow user to set HasValidMailbox
func (_options *ListProtectionSourcesOptions) SetHasValidMailbox(hasValidMailbox bool) *ListProtectionSourcesOptions {
	_options.HasValidMailbox = core.BoolPtr(hasValidMailbox)
	return _options
}

// SetHasValidOnedrive : Allow user to set HasValidOnedrive
func (_options *ListProtectionSourcesOptions) SetHasValidOnedrive(hasValidOnedrive bool) *ListProtectionSourcesOptions {
	_options.HasValidOnedrive = core.BoolPtr(hasValidOnedrive)
	return _options
}

// SetIsSecurityGroup : Allow user to set IsSecurityGroup
func (_options *ListProtectionSourcesOptions) SetIsSecurityGroup(isSecurityGroup bool) *ListProtectionSourcesOptions {
	_options.IsSecurityGroup = core.BoolPtr(isSecurityGroup)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListProtectionSourcesOptions) SetID(id int64) *ListProtectionSourcesOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetNumLevels : Allow user to set NumLevels
func (_options *ListProtectionSourcesOptions) SetNumLevels(numLevels float64) *ListProtectionSourcesOptions {
	_options.NumLevels = core.Float64Ptr(numLevels)
	return _options
}

// SetExcludeTypes : Allow user to set ExcludeTypes
func (_options *ListProtectionSourcesOptions) SetExcludeTypes(excludeTypes []string) *ListProtectionSourcesOptions {
	_options.ExcludeTypes = excludeTypes
	return _options
}

// SetExcludeAwsTypes : Allow user to set ExcludeAwsTypes
func (_options *ListProtectionSourcesOptions) SetExcludeAwsTypes(excludeAwsTypes []string) *ListProtectionSourcesOptions {
	_options.ExcludeAwsTypes = excludeAwsTypes
	return _options
}

// SetExcludeKubernetesTypes : Allow user to set ExcludeKubernetesTypes
func (_options *ListProtectionSourcesOptions) SetExcludeKubernetesTypes(excludeKubernetesTypes []string) *ListProtectionSourcesOptions {
	_options.ExcludeKubernetesTypes = excludeKubernetesTypes
	return _options
}

// SetIncludeDatastores : Allow user to set IncludeDatastores
func (_options *ListProtectionSourcesOptions) SetIncludeDatastores(includeDatastores bool) *ListProtectionSourcesOptions {
	_options.IncludeDatastores = core.BoolPtr(includeDatastores)
	return _options
}

// SetIncludeNetworks : Allow user to set IncludeNetworks
func (_options *ListProtectionSourcesOptions) SetIncludeNetworks(includeNetworks bool) *ListProtectionSourcesOptions {
	_options.IncludeNetworks = core.BoolPtr(includeNetworks)
	return _options
}

// SetIncludeVMFolders : Allow user to set IncludeVMFolders
func (_options *ListProtectionSourcesOptions) SetIncludeVMFolders(includeVMFolders bool) *ListProtectionSourcesOptions {
	_options.IncludeVMFolders = core.BoolPtr(includeVMFolders)
	return _options
}

// SetIncludeSfdcFields : Allow user to set IncludeSfdcFields
func (_options *ListProtectionSourcesOptions) SetIncludeSfdcFields(includeSfdcFields bool) *ListProtectionSourcesOptions {
	_options.IncludeSfdcFields = core.BoolPtr(includeSfdcFields)
	return _options
}

// SetIncludeSystemVApps : Allow user to set IncludeSystemVApps
func (_options *ListProtectionSourcesOptions) SetIncludeSystemVApps(includeSystemVApps bool) *ListProtectionSourcesOptions {
	_options.IncludeSystemVApps = core.BoolPtr(includeSystemVApps)
	return _options
}

// SetEnvironments : Allow user to set Environments
func (_options *ListProtectionSourcesOptions) SetEnvironments(environments []string) *ListProtectionSourcesOptions {
	_options.Environments = environments
	return _options
}

// SetEnvironment : Allow user to set Environment
// Deprecated: this method is deprecated and may be removed in a future release.
func (_options *ListProtectionSourcesOptions) SetEnvironment(environment string) *ListProtectionSourcesOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetIncludeEntityPermissionInfo : Allow user to set IncludeEntityPermissionInfo
func (_options *ListProtectionSourcesOptions) SetIncludeEntityPermissionInfo(includeEntityPermissionInfo bool) *ListProtectionSourcesOptions {
	_options.IncludeEntityPermissionInfo = core.BoolPtr(includeEntityPermissionInfo)
	return _options
}

// SetSids : Allow user to set Sids
func (_options *ListProtectionSourcesOptions) SetSids(sids []string) *ListProtectionSourcesOptions {
	_options.Sids = sids
	return _options
}

// SetIncludeSourceCredentials : Allow user to set IncludeSourceCredentials
func (_options *ListProtectionSourcesOptions) SetIncludeSourceCredentials(includeSourceCredentials bool) *ListProtectionSourcesOptions {
	_options.IncludeSourceCredentials = core.BoolPtr(includeSourceCredentials)
	return _options
}

// SetEncryptionKey : Allow user to set EncryptionKey
func (_options *ListProtectionSourcesOptions) SetEncryptionKey(encryptionKey string) *ListProtectionSourcesOptions {
	_options.EncryptionKey = core.StringPtr(encryptionKey)
	return _options
}

// SetIncludeObjectProtectionInfo : Allow user to set IncludeObjectProtectionInfo
func (_options *ListProtectionSourcesOptions) SetIncludeObjectProtectionInfo(includeObjectProtectionInfo bool) *ListProtectionSourcesOptions {
	_options.IncludeObjectProtectionInfo = core.BoolPtr(includeObjectProtectionInfo)
	return _options
}

// SetPruneNonCriticalInfo : Allow user to set PruneNonCriticalInfo
func (_options *ListProtectionSourcesOptions) SetPruneNonCriticalInfo(pruneNonCriticalInfo bool) *ListProtectionSourcesOptions {
	_options.PruneNonCriticalInfo = core.BoolPtr(pruneNonCriticalInfo)
	return _options
}

// SetPruneAggregationInfo : Allow user to set PruneAggregationInfo
func (_options *ListProtectionSourcesOptions) SetPruneAggregationInfo(pruneAggregationInfo bool) *ListProtectionSourcesOptions {
	_options.PruneAggregationInfo = core.BoolPtr(pruneAggregationInfo)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *ListProtectionSourcesOptions) SetRequestInitiatorType(requestInitiatorType string) *ListProtectionSourcesOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetUseCachedData : Allow user to set UseCachedData
func (_options *ListProtectionSourcesOptions) SetUseCachedData(useCachedData bool) *ListProtectionSourcesOptions {
	_options.UseCachedData = core.BoolPtr(useCachedData)
	return _options
}

// SetAllUnderHierarchy : Allow user to set AllUnderHierarchy
func (_options *ListProtectionSourcesOptions) SetAllUnderHierarchy(allUnderHierarchy bool) *ListProtectionSourcesOptions {
	_options.AllUnderHierarchy = core.BoolPtr(allUnderHierarchy)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListProtectionSourcesOptions) SetHeaders(param map[string]string) *ListProtectionSourcesOptions {
	options.Headers = param
	return options
}

// LogBackupPolicy : Specifies log backup settings for a Protection Group.
type LogBackupPolicy struct {
	// Specifies settings that defines how frequent log backup will be performed for a Protection Group.
	Schedule *LogSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`
}

// NewLogBackupPolicy : Instantiate LogBackupPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewLogBackupPolicy(schedule *LogSchedule, retention *Retention) (_model *LogBackupPolicy, err error) {
	_model = &LogBackupPolicy{
		Schedule:  schedule,
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalLogBackupPolicy unmarshals an instance of LogBackupPolicy from the specified map of raw messages.
func UnmarshalLogBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LogBackupPolicy)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalLogSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LogRetention : Specifies the retention of a backup.
type LogRetention struct {
	// Specificies the Retention Unit of a backup measured in days, months or years. <br> If unit is 'Months', then number
	// specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of
	// retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied
	// to 365. <br> If duration is 2 and unit is 'Years' then number of retention days will be 365 * 2 = 730 days.
	Unit *string `json:"unit" validate:"required"`

	// Specifies the duration for a backup retention. <br> Example. If duration is 7 and unit is Months, the retention of a
	// backup is 7 * 30 = 210 days.
	Duration *int64 `json:"duration" validate:"required"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
	// Protection Groups using this policy will be kept for the last N days as specified in the duration of the datalock.
	// During that time, the snapshots cannot be deleted.
	DataLockConfig *DataLockConfig `json:"dataLockConfig,omitempty"`
}

// Constants associated with the LogRetention.Unit property.
// Specificies the Retention Unit of a backup measured in days, months or years. <br> If unit is 'Months', then number
// specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of
// retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied to
// 365. <br> If duration is 2 and unit is 'Years' then number of retention days will be 365 * 2 = 730 days.
const (
	LogRetention_Unit_Days   = "Days"
	LogRetention_Unit_Months = "Months"
	LogRetention_Unit_Weeks  = "Weeks"
	LogRetention_Unit_Years  = "Years"
)

// NewLogRetention : Instantiate LogRetention (Generic Model Constructor)
func (*BackupRecoveryV1) NewLogRetention(unit string, duration int64) (_model *LogRetention, err error) {
	_model = &LogRetention{
		Unit:     core.StringPtr(unit),
		Duration: core.Int64Ptr(duration),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalLogRetention unmarshals an instance of LogRetention from the specified map of raw messages.
func UnmarshalLogRetention(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LogRetention)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "duration", &obj.Duration)
	if err != nil {
		err = core.SDKErrorf(err, "", "duration-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConfig", &obj.DataLockConfig, UnmarshalDataLockConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LogSchedule : Specifies settings that defines how frequent log backup will be performed for a Protection Group.
type LogSchedule struct {
	// Specifies how often to start new Protection Group Runs of a Protection Group. <br>'Minutes' specifies that
	// Protection Group run starts periodically after certain number of minutes specified in 'frequency' field. <br>'Hours'
	// specifies that Protection Group run starts periodically after certain number of hours specified in 'frequency'
	// field.
	Unit *string `json:"unit" validate:"required"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of minutes.
	MinuteSchedule *MinuteSchedule `json:"minuteSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of hours.
	HourSchedule *HourSchedule `json:"hourSchedule,omitempty"`
}

// Constants associated with the LogSchedule.Unit property.
// Specifies how often to start new Protection Group Runs of a Protection Group. <br>'Minutes' specifies that Protection
// Group run starts periodically after certain number of minutes specified in 'frequency' field. <br>'Hours' specifies
// that Protection Group run starts periodically after certain number of hours specified in 'frequency' field.
const (
	LogSchedule_Unit_Hours   = "Hours"
	LogSchedule_Unit_Minutes = "Minutes"
)

// NewLogSchedule : Instantiate LogSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewLogSchedule(unit string) (_model *LogSchedule, err error) {
	_model = &LogSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalLogSchedule unmarshals an instance of LogSchedule from the specified map of raw messages.
func UnmarshalLogSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LogSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "minuteSchedule", &obj.MinuteSchedule, UnmarshalMinuteSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "minuteSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hourSchedule", &obj.HourSchedule, UnmarshalHourSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "hourSchedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLFileProtectionGroupHostParams : Specifies the host specific parameters for a host container in this protection group. Objects specified here should
// only be MSSQL root containers and will not be protected unless they are also specified in the 'objects' list. This
// list is just for specifying source level settings.
type MSSQLFileProtectionGroupHostParams struct {
	// Specifies whether or not to disable source side deduplication on this source. The default behavior is false unless
	// the user has set 'performSourceSideDeduplication' to true.
	DisableSourceSideDeduplication *bool `json:"disableSourceSideDeduplication,omitempty"`

	// Specifies the id of the host container on which databases are hosted.
	HostID *int64 `json:"hostId" validate:"required"`

	// Specifies the name of the host container on which databases are hosted.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	HostName *string `json:"hostName,omitempty"`
}

// NewMSSQLFileProtectionGroupHostParams : Instantiate MSSQLFileProtectionGroupHostParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLFileProtectionGroupHostParams(hostID int64) (_model *MSSQLFileProtectionGroupHostParams, err error) {
	_model = &MSSQLFileProtectionGroupHostParams{
		HostID: core.Int64Ptr(hostID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLFileProtectionGroupHostParams unmarshals an instance of MSSQLFileProtectionGroupHostParams from the specified map of raw messages.
func UnmarshalMSSQLFileProtectionGroupHostParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLFileProtectionGroupHostParams)
	err = core.UnmarshalPrimitive(m, "disableSourceSideDeduplication", &obj.DisableSourceSideDeduplication)
	if err != nil {
		err = core.SDKErrorf(err, "", "disableSourceSideDeduplication-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostId", &obj.HostID)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostName", &obj.HostName)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLFileProtectionGroupObjectParams : Specifies the object params to create File based MSSQL Protection Group.
type MSSQLFileProtectionGroupObjectParams struct {
	// Specifies the ID of the object being protected. If this is a non leaf level object, then the object will be
	// auto-protected unless leaf objects are specified for exclusion.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object being protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies the type of source being protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SourceType *string `json:"sourceType,omitempty"`
}

// NewMSSQLFileProtectionGroupObjectParams : Instantiate MSSQLFileProtectionGroupObjectParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLFileProtectionGroupObjectParams(id int64) (_model *MSSQLFileProtectionGroupObjectParams, err error) {
	_model = &MSSQLFileProtectionGroupObjectParams{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLFileProtectionGroupObjectParams unmarshals an instance of MSSQLFileProtectionGroupObjectParams from the specified map of raw messages.
func UnmarshalMSSQLFileProtectionGroupObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLFileProtectionGroupObjectParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceType", &obj.SourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLFileProtectionGroupParams : Specifies the params to create a File based MSSQL Protection Group.
type MSSQLFileProtectionGroupParams struct {
	// Specifies the preference type for backing up databases that are part of an AAG. If not specified, then default
	// preferences of the AAG server are applied. This field wont be applicable if user DB preference is set to skip AAG
	// databases.
	AagBackupPreferenceType *string `json:"aagBackupPreferenceType,omitempty"`

	// This is used to regulate certain gflag values from the UI. The values passed by the user from the UI will be used
	// for the respective gflags.
	AdvancedSettings *AdvancedSettings `json:"advancedSettings,omitempty"`

	// Specifies whether to backup system databases. If not specified then parameter is set to true.
	BackupSystemDbs *bool `json:"backupSystemDbs,omitempty"`

	// Specifies the list of exclusion filters applied during the group creation or edit. These exclusion filters can be
	// wildcard supported strings or regular expressions. Objects satisfying the will filters will be excluded during
	// backup and also auto protected objects will be ignored if filtered by any of the filters.
	ExcludeFilters []Filter `json:"excludeFilters,omitempty"`

	// Specifies whether full backups should be copy-only.
	FullBackupsCopyOnly *bool `json:"fullBackupsCopyOnly,omitempty"`

	// Specifies the number of streams to be used for log backups.
	LogBackupNumStreams *int64 `json:"logBackupNumStreams,omitempty"`

	// Specifies the WithClause to be used for log backups.
	LogBackupWithClause *string `json:"logBackupWithClause,omitempty"`

	// Specifies the params for pre and post scripts.
	PrePostScript *PrePostScriptParams `json:"prePostScript,omitempty"`

	// Specifies whether or not the AAG backup preferences specified on the SQL Server host should be used.
	UseAagPreferencesFromServer *bool `json:"useAagPreferencesFromServer,omitempty"`

	// Specifies the preference type for backing up user databases on the host.
	UserDbBackupPreferenceType *string `json:"userDbBackupPreferenceType,omitempty"`

	// Specifies settings which are to be applied to specific host containers in this protection group.
	AdditionalHostParams []MSSQLFileProtectionGroupHostParams `json:"additionalHostParams,omitempty"`

	// Specifies the list of object params to be protected.
	Objects []MSSQLFileProtectionGroupObjectParams `json:"objects" validate:"required"`

	// Specifies whether or not to perform source side deduplication on this Protection Group.
	PerformSourceSideDeduplication *bool `json:"performSourceSideDeduplication,omitempty"`
}

// Constants associated with the MSSQLFileProtectionGroupParams.AagBackupPreferenceType property.
// Specifies the preference type for backing up databases that are part of an AAG. If not specified, then default
// preferences of the AAG server are applied. This field wont be applicable if user DB preference is set to skip AAG
// databases.
const (
	MSSQLFileProtectionGroupParams_AagBackupPreferenceType_Kanyreplica             = "kAnyReplica"
	MSSQLFileProtectionGroupParams_AagBackupPreferenceType_Kprefersecondaryreplica = "kPreferSecondaryReplica"
	MSSQLFileProtectionGroupParams_AagBackupPreferenceType_Kprimaryreplicaonly     = "kPrimaryReplicaOnly"
	MSSQLFileProtectionGroupParams_AagBackupPreferenceType_Ksecondaryreplicaonly   = "kSecondaryReplicaOnly"
)

// Constants associated with the MSSQLFileProtectionGroupParams.UserDbBackupPreferenceType property.
// Specifies the preference type for backing up user databases on the host.
const (
	MSSQLFileProtectionGroupParams_UserDbBackupPreferenceType_Kbackupalldatabases          = "kBackupAllDatabases"
	MSSQLFileProtectionGroupParams_UserDbBackupPreferenceType_Kbackupallexceptaagdatabases = "kBackupAllExceptAAGDatabases"
	MSSQLFileProtectionGroupParams_UserDbBackupPreferenceType_Kbackuponlyaagdatabases      = "kBackupOnlyAAGDatabases"
)

// NewMSSQLFileProtectionGroupParams : Instantiate MSSQLFileProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLFileProtectionGroupParams(objects []MSSQLFileProtectionGroupObjectParams) (_model *MSSQLFileProtectionGroupParams, err error) {
	_model = &MSSQLFileProtectionGroupParams{
		Objects: objects,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLFileProtectionGroupParams unmarshals an instance of MSSQLFileProtectionGroupParams from the specified map of raw messages.
func UnmarshalMSSQLFileProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLFileProtectionGroupParams)
	err = core.UnmarshalPrimitive(m, "aagBackupPreferenceType", &obj.AagBackupPreferenceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagBackupPreferenceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "advancedSettings", &obj.AdvancedSettings, UnmarshalAdvancedSettings)
	if err != nil {
		err = core.SDKErrorf(err, "", "advancedSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupSystemDbs", &obj.BackupSystemDbs)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupSystemDbs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "excludeFilters", &obj.ExcludeFilters, UnmarshalFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludeFilters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fullBackupsCopyOnly", &obj.FullBackupsCopyOnly)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullBackupsCopyOnly-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logBackupNumStreams", &obj.LogBackupNumStreams)
	if err != nil {
		err = core.SDKErrorf(err, "", "logBackupNumStreams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logBackupWithClause", &obj.LogBackupWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "logBackupWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prePostScript", &obj.PrePostScript, UnmarshalPrePostScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "prePostScript-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "useAagPreferencesFromServer", &obj.UseAagPreferencesFromServer)
	if err != nil {
		err = core.SDKErrorf(err, "", "useAagPreferencesFromServer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userDbBackupPreferenceType", &obj.UserDbBackupPreferenceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "userDbBackupPreferenceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "additionalHostParams", &obj.AdditionalHostParams, UnmarshalMSSQLFileProtectionGroupHostParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "additionalHostParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalMSSQLFileProtectionGroupObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "performSourceSideDeduplication", &obj.PerformSourceSideDeduplication)
	if err != nil {
		err = core.SDKErrorf(err, "", "performSourceSideDeduplication-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLNativeProtectionGroupObjectParams : Specifies the object params to create File based MSSQL Protection Group.
type MSSQLNativeProtectionGroupObjectParams struct {
	// Specifies the ID of the object being protected. If this is a non leaf level object, then the object will be
	// auto-protected unless leaf objects are specified for exclusion.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object being protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies the type of source being protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SourceType *string `json:"sourceType,omitempty"`
}

// NewMSSQLNativeProtectionGroupObjectParams : Instantiate MSSQLNativeProtectionGroupObjectParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLNativeProtectionGroupObjectParams(id int64) (_model *MSSQLNativeProtectionGroupObjectParams, err error) {
	_model = &MSSQLNativeProtectionGroupObjectParams{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLNativeProtectionGroupObjectParams unmarshals an instance of MSSQLNativeProtectionGroupObjectParams from the specified map of raw messages.
func UnmarshalMSSQLNativeProtectionGroupObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLNativeProtectionGroupObjectParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceType", &obj.SourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLNativeProtectionGroupParams : Specifies the params to create a Native based MSSQL Protection Group.
type MSSQLNativeProtectionGroupParams struct {
	// Specifies the preference type for backing up databases that are part of an AAG. If not specified, then default
	// preferences of the AAG server are applied. This field wont be applicable if user DB preference is set to skip AAG
	// databases.
	AagBackupPreferenceType *string `json:"aagBackupPreferenceType,omitempty"`

	// This is used to regulate certain gflag values from the UI. The values passed by the user from the UI will be used
	// for the respective gflags.
	AdvancedSettings *AdvancedSettings `json:"advancedSettings,omitempty"`

	// Specifies whether to backup system databases. If not specified then parameter is set to true.
	BackupSystemDbs *bool `json:"backupSystemDbs,omitempty"`

	// Specifies the list of exclusion filters applied during the group creation or edit. These exclusion filters can be
	// wildcard supported strings or regular expressions. Objects satisfying the will filters will be excluded during
	// backup and also auto protected objects will be ignored if filtered by any of the filters.
	ExcludeFilters []Filter `json:"excludeFilters,omitempty"`

	// Specifies whether full backups should be copy-only.
	FullBackupsCopyOnly *bool `json:"fullBackupsCopyOnly,omitempty"`

	// Specifies the number of streams to be used for log backups.
	LogBackupNumStreams *int64 `json:"logBackupNumStreams,omitempty"`

	// Specifies the WithClause to be used for log backups.
	LogBackupWithClause *string `json:"logBackupWithClause,omitempty"`

	// Specifies the params for pre and post scripts.
	PrePostScript *PrePostScriptParams `json:"prePostScript,omitempty"`

	// Specifies whether or not the AAG backup preferences specified on the SQL Server host should be used.
	UseAagPreferencesFromServer *bool `json:"useAagPreferencesFromServer,omitempty"`

	// Specifies the preference type for backing up user databases on the host.
	UserDbBackupPreferenceType *string `json:"userDbBackupPreferenceType,omitempty"`

	// Specifies the number of streams to be used.
	NumStreams *int64 `json:"numStreams,omitempty"`

	// Specifies the list of object params to be protected.
	Objects []MSSQLNativeProtectionGroupObjectParams `json:"objects" validate:"required"`

	// Specifies the WithClause to be used.
	WithClause *string `json:"withClause,omitempty"`
}

// Constants associated with the MSSQLNativeProtectionGroupParams.AagBackupPreferenceType property.
// Specifies the preference type for backing up databases that are part of an AAG. If not specified, then default
// preferences of the AAG server are applied. This field wont be applicable if user DB preference is set to skip AAG
// databases.
const (
	MSSQLNativeProtectionGroupParams_AagBackupPreferenceType_Kanyreplica             = "kAnyReplica"
	MSSQLNativeProtectionGroupParams_AagBackupPreferenceType_Kprefersecondaryreplica = "kPreferSecondaryReplica"
	MSSQLNativeProtectionGroupParams_AagBackupPreferenceType_Kprimaryreplicaonly     = "kPrimaryReplicaOnly"
	MSSQLNativeProtectionGroupParams_AagBackupPreferenceType_Ksecondaryreplicaonly   = "kSecondaryReplicaOnly"
)

// Constants associated with the MSSQLNativeProtectionGroupParams.UserDbBackupPreferenceType property.
// Specifies the preference type for backing up user databases on the host.
const (
	MSSQLNativeProtectionGroupParams_UserDbBackupPreferenceType_Kbackupalldatabases          = "kBackupAllDatabases"
	MSSQLNativeProtectionGroupParams_UserDbBackupPreferenceType_Kbackupallexceptaagdatabases = "kBackupAllExceptAAGDatabases"
	MSSQLNativeProtectionGroupParams_UserDbBackupPreferenceType_Kbackuponlyaagdatabases      = "kBackupOnlyAAGDatabases"
)

// NewMSSQLNativeProtectionGroupParams : Instantiate MSSQLNativeProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLNativeProtectionGroupParams(objects []MSSQLNativeProtectionGroupObjectParams) (_model *MSSQLNativeProtectionGroupParams, err error) {
	_model = &MSSQLNativeProtectionGroupParams{
		Objects: objects,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLNativeProtectionGroupParams unmarshals an instance of MSSQLNativeProtectionGroupParams from the specified map of raw messages.
func UnmarshalMSSQLNativeProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLNativeProtectionGroupParams)
	err = core.UnmarshalPrimitive(m, "aagBackupPreferenceType", &obj.AagBackupPreferenceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagBackupPreferenceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "advancedSettings", &obj.AdvancedSettings, UnmarshalAdvancedSettings)
	if err != nil {
		err = core.SDKErrorf(err, "", "advancedSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupSystemDbs", &obj.BackupSystemDbs)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupSystemDbs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "excludeFilters", &obj.ExcludeFilters, UnmarshalFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludeFilters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fullBackupsCopyOnly", &obj.FullBackupsCopyOnly)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullBackupsCopyOnly-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logBackupNumStreams", &obj.LogBackupNumStreams)
	if err != nil {
		err = core.SDKErrorf(err, "", "logBackupNumStreams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logBackupWithClause", &obj.LogBackupWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "logBackupWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prePostScript", &obj.PrePostScript, UnmarshalPrePostScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "prePostScript-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "useAagPreferencesFromServer", &obj.UseAagPreferencesFromServer)
	if err != nil {
		err = core.SDKErrorf(err, "", "useAagPreferencesFromServer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userDbBackupPreferenceType", &obj.UserDbBackupPreferenceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "userDbBackupPreferenceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "numStreams", &obj.NumStreams)
	if err != nil {
		err = core.SDKErrorf(err, "", "numStreams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalMSSQLNativeProtectionGroupObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "withClause", &obj.WithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "withClause-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLProtectionGroupParams : Specifies the parameters specific to MSSQL Protection Group.
type MSSQLProtectionGroupParams struct {
	// Specifies the params to create a File based MSSQL Protection Group.
	FileProtectionTypeParams *MSSQLFileProtectionGroupParams `json:"fileProtectionTypeParams,omitempty"`

	// Specifies the params to create a Native based MSSQL Protection Group.
	NativeProtectionTypeParams *MSSQLNativeProtectionGroupParams `json:"nativeProtectionTypeParams,omitempty"`

	// Specifies the MSSQL Protection Group type.
	ProtectionType *string `json:"protectionType" validate:"required"`

	// Specifies the params to create a Volume based MSSQL Protection Group.
	VolumeProtectionTypeParams *MSSQLVolumeProtectionGroupParams `json:"volumeProtectionTypeParams,omitempty"`
}

// Constants associated with the MSSQLProtectionGroupParams.ProtectionType property.
// Specifies the MSSQL Protection Group type.
const (
	MSSQLProtectionGroupParams_ProtectionType_Kfile   = "kFile"
	MSSQLProtectionGroupParams_ProtectionType_Knative = "kNative"
	MSSQLProtectionGroupParams_ProtectionType_Kvolume = "kVolume"
)

// NewMSSQLProtectionGroupParams : Instantiate MSSQLProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLProtectionGroupParams(protectionType string) (_model *MSSQLProtectionGroupParams, err error) {
	_model = &MSSQLProtectionGroupParams{
		ProtectionType: core.StringPtr(protectionType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLProtectionGroupParams unmarshals an instance of MSSQLProtectionGroupParams from the specified map of raw messages.
func UnmarshalMSSQLProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLProtectionGroupParams)
	err = core.UnmarshalModel(m, "fileProtectionTypeParams", &obj.FileProtectionTypeParams, UnmarshalMSSQLFileProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileProtectionTypeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "nativeProtectionTypeParams", &obj.NativeProtectionTypeParams, UnmarshalMSSQLNativeProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "nativeProtectionTypeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "volumeProtectionTypeParams", &obj.VolumeProtectionTypeParams, UnmarshalMSSQLVolumeProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeProtectionTypeParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLVolumeProtectionGroupHostParams : Specifies the host specific parameters for a host container in this protection group. Objects specified here should
// only be MSSQL root containers and will not be protected unless they are also specified in the 'objects' list. This
// list is just for specifying source level settings.
type MSSQLVolumeProtectionGroupHostParams struct {
	// Specifies whether to enable system/bmr backup using 3rd party tools installed on agent host.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`

	// Specifies the id of the host container on which databases are hosted.
	HostID *int64 `json:"hostId" validate:"required"`

	// Specifies the name of the host container on which databases are hosted.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	HostName *string `json:"hostName,omitempty"`

	// Specifies the list of volume GUIDs to be protected. If not specified, all the volumes of the host will be protected.
	// Note that volumes of host on which databases are hosted are protected even if its not mentioned in this list.
	VolumeGuids []string `json:"volumeGuids,omitempty"`
}

// NewMSSQLVolumeProtectionGroupHostParams : Instantiate MSSQLVolumeProtectionGroupHostParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLVolumeProtectionGroupHostParams(hostID int64) (_model *MSSQLVolumeProtectionGroupHostParams, err error) {
	_model = &MSSQLVolumeProtectionGroupHostParams{
		HostID: core.Int64Ptr(hostID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLVolumeProtectionGroupHostParams unmarshals an instance of MSSQLVolumeProtectionGroupHostParams from the specified map of raw messages.
func UnmarshalMSSQLVolumeProtectionGroupHostParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLVolumeProtectionGroupHostParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostId", &obj.HostID)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostName", &obj.HostName)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeGuids", &obj.VolumeGuids)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeGuids-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLVolumeProtectionGroupObjectParams : Specifies the object params to create File based MSSQL Protection Group.
type MSSQLVolumeProtectionGroupObjectParams struct {
	// Specifies the ID of the object being protected. If this is a non leaf level object, then the object will be
	// auto-protected unless leaf objects are specified for exclusion.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object being protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies the type of source being protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SourceType *string `json:"sourceType,omitempty"`
}

// NewMSSQLVolumeProtectionGroupObjectParams : Instantiate MSSQLVolumeProtectionGroupObjectParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLVolumeProtectionGroupObjectParams(id int64) (_model *MSSQLVolumeProtectionGroupObjectParams, err error) {
	_model = &MSSQLVolumeProtectionGroupObjectParams{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLVolumeProtectionGroupObjectParams unmarshals an instance of MSSQLVolumeProtectionGroupObjectParams from the specified map of raw messages.
func UnmarshalMSSQLVolumeProtectionGroupObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLVolumeProtectionGroupObjectParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceType", &obj.SourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSSQLVolumeProtectionGroupParams : Specifies the params to create a Volume based MSSQL Protection Group.
type MSSQLVolumeProtectionGroupParams struct {
	// Specifies the preference type for backing up databases that are part of an AAG. If not specified, then default
	// preferences of the AAG server are applied. This field wont be applicable if user DB preference is set to skip AAG
	// databases.
	AagBackupPreferenceType *string `json:"aagBackupPreferenceType,omitempty"`

	// This is used to regulate certain gflag values from the UI. The values passed by the user from the UI will be used
	// for the respective gflags.
	AdvancedSettings *AdvancedSettings `json:"advancedSettings,omitempty"`

	// Specifies whether to backup system databases. If not specified then parameter is set to true.
	BackupSystemDbs *bool `json:"backupSystemDbs,omitempty"`

	// Specifies the list of exclusion filters applied during the group creation or edit. These exclusion filters can be
	// wildcard supported strings or regular expressions. Objects satisfying the will filters will be excluded during
	// backup and also auto protected objects will be ignored if filtered by any of the filters.
	ExcludeFilters []Filter `json:"excludeFilters,omitempty"`

	// Specifies whether full backups should be copy-only.
	FullBackupsCopyOnly *bool `json:"fullBackupsCopyOnly,omitempty"`

	// Specifies the number of streams to be used for log backups.
	LogBackupNumStreams *int64 `json:"logBackupNumStreams,omitempty"`

	// Specifies the WithClause to be used for log backups.
	LogBackupWithClause *string `json:"logBackupWithClause,omitempty"`

	// Specifies the params for pre and post scripts.
	PrePostScript *PrePostScriptParams `json:"prePostScript,omitempty"`

	// Specifies whether or not the AAG backup preferences specified on the SQL Server host should be used.
	UseAagPreferencesFromServer *bool `json:"useAagPreferencesFromServer,omitempty"`

	// Specifies the preference type for backing up user databases on the host.
	UserDbBackupPreferenceType *string `json:"userDbBackupPreferenceType,omitempty"`

	// Specifies settings which are to be applied to specific host containers in this protection group.
	AdditionalHostParams []MSSQLVolumeProtectionGroupHostParams `json:"additionalHostParams,omitempty"`

	// Specifies whether to only backup volumes on which the specified databases reside. If not specified (default), all
	// the volumes of the host will be protected.
	BackupDbVolumesOnly *bool `json:"backupDbVolumesOnly,omitempty"`

	// Specifies whether or to perform incremental backups the first time after a server restarts. By default, a full
	// backup will be performed.
	IncrementalBackupAfterRestart *bool `json:"incrementalBackupAfterRestart,omitempty"`

	// Specifies settings for indexing files found in an Object (such as a VM) so these files can be searched and
	// recovered. This also specifies inclusion and exclusion rules that determine the directories to index.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies the list of object ids to be protected.
	Objects []MSSQLVolumeProtectionGroupObjectParams `json:"objects" validate:"required"`
}

// Constants associated with the MSSQLVolumeProtectionGroupParams.AagBackupPreferenceType property.
// Specifies the preference type for backing up databases that are part of an AAG. If not specified, then default
// preferences of the AAG server are applied. This field wont be applicable if user DB preference is set to skip AAG
// databases.
const (
	MSSQLVolumeProtectionGroupParams_AagBackupPreferenceType_Kanyreplica             = "kAnyReplica"
	MSSQLVolumeProtectionGroupParams_AagBackupPreferenceType_Kprefersecondaryreplica = "kPreferSecondaryReplica"
	MSSQLVolumeProtectionGroupParams_AagBackupPreferenceType_Kprimaryreplicaonly     = "kPrimaryReplicaOnly"
	MSSQLVolumeProtectionGroupParams_AagBackupPreferenceType_Ksecondaryreplicaonly   = "kSecondaryReplicaOnly"
)

// Constants associated with the MSSQLVolumeProtectionGroupParams.UserDbBackupPreferenceType property.
// Specifies the preference type for backing up user databases on the host.
const (
	MSSQLVolumeProtectionGroupParams_UserDbBackupPreferenceType_Kbackupalldatabases          = "kBackupAllDatabases"
	MSSQLVolumeProtectionGroupParams_UserDbBackupPreferenceType_Kbackupallexceptaagdatabases = "kBackupAllExceptAAGDatabases"
	MSSQLVolumeProtectionGroupParams_UserDbBackupPreferenceType_Kbackuponlyaagdatabases      = "kBackupOnlyAAGDatabases"
)

// NewMSSQLVolumeProtectionGroupParams : Instantiate MSSQLVolumeProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMSSQLVolumeProtectionGroupParams(objects []MSSQLVolumeProtectionGroupObjectParams) (_model *MSSQLVolumeProtectionGroupParams, err error) {
	_model = &MSSQLVolumeProtectionGroupParams{
		Objects: objects,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMSSQLVolumeProtectionGroupParams unmarshals an instance of MSSQLVolumeProtectionGroupParams from the specified map of raw messages.
func UnmarshalMSSQLVolumeProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSSQLVolumeProtectionGroupParams)
	err = core.UnmarshalPrimitive(m, "aagBackupPreferenceType", &obj.AagBackupPreferenceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagBackupPreferenceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "advancedSettings", &obj.AdvancedSettings, UnmarshalAdvancedSettings)
	if err != nil {
		err = core.SDKErrorf(err, "", "advancedSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupSystemDbs", &obj.BackupSystemDbs)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupSystemDbs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "excludeFilters", &obj.ExcludeFilters, UnmarshalFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludeFilters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fullBackupsCopyOnly", &obj.FullBackupsCopyOnly)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullBackupsCopyOnly-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logBackupNumStreams", &obj.LogBackupNumStreams)
	if err != nil {
		err = core.SDKErrorf(err, "", "logBackupNumStreams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logBackupWithClause", &obj.LogBackupWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "logBackupWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prePostScript", &obj.PrePostScript, UnmarshalPrePostScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "prePostScript-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "useAagPreferencesFromServer", &obj.UseAagPreferencesFromServer)
	if err != nil {
		err = core.SDKErrorf(err, "", "useAagPreferencesFromServer-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userDbBackupPreferenceType", &obj.UserDbBackupPreferenceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "userDbBackupPreferenceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "additionalHostParams", &obj.AdditionalHostParams, UnmarshalMSSQLVolumeProtectionGroupHostParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "additionalHostParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupDbVolumesOnly", &obj.BackupDbVolumesOnly)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupDbVolumesOnly-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "incrementalBackupAfterRestart", &obj.IncrementalBackupAfterRestart)
	if err != nil {
		err = core.SDKErrorf(err, "", "incrementalBackupAfterRestart-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "indexingPolicy", &obj.IndexingPolicy, UnmarshalIndexingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalMSSQLVolumeProtectionGroupObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MaintenanceModeConfig : Specifies the entity metadata for maintenance mode.
type MaintenanceModeConfig struct {
	// Specifies the absolute intervals where the maintenance schedule is valid, i.e. maintenance_shedule is considered
	// only for these time ranges. (For example, if there is one time range with [now_usecs, now_usecs + 10 days], the
	// action will be done during the maintenance_schedule for the next 10 days.)The start time must be specified. The end
	// time can be -1 which would denote an indefinite maintenance mode.
	ActivationTimeIntervals []TimeRangeUsecs `json:"activationTimeIntervals,omitempty"`

	// Specifies a schedule for actions to be taken.
	MaintenanceSchedule *Schedule `json:"maintenanceSchedule,omitempty"`

	// User provided message associated with this maintenance mode.
	UserMessage *string `json:"userMessage,omitempty"`

	// Specifies the type of intervention for different workflows when the source goes into maintenance mode.
	WorkflowInterventionSpecList []WorkflowInterventionSpec `json:"workflowInterventionSpecList,omitempty"`
}

// UnmarshalMaintenanceModeConfig unmarshals an instance of MaintenanceModeConfig from the specified map of raw messages.
func UnmarshalMaintenanceModeConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MaintenanceModeConfig)
	err = core.UnmarshalModel(m, "activationTimeIntervals", &obj.ActivationTimeIntervals, UnmarshalTimeRangeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "activationTimeIntervals-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "maintenanceSchedule", &obj.MaintenanceSchedule, UnmarshalSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "maintenanceSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userMessage", &obj.UserMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "userMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "workflowInterventionSpecList", &obj.WorkflowInterventionSpecList, UnmarshalWorkflowInterventionSpec)
	if err != nil {
		err = core.SDKErrorf(err, "", "workflowInterventionSpecList-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MaxSnapshotConfig : Specifies Storage Array Snapshot Max Snapshots Config.
type MaxSnapshotConfig struct {
	// Max number of storage snapshots allowed per volume/lun.
	MaxSnapshots *float64 `json:"maxSnapshots,omitempty"`
}

// UnmarshalMaxSnapshotConfig unmarshals an instance of MaxSnapshotConfig from the specified map of raw messages.
func UnmarshalMaxSnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MaxSnapshotConfig)
	err = core.UnmarshalPrimitive(m, "maxSnapshots", &obj.MaxSnapshots)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxSnapshots-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MaxSpaceConfig : Specifies Storage Array Snapshot Max Space Config.
type MaxSpaceConfig struct {
	// Max number of storage snapshots allowed per volume/lun.
	MaxSnapshotSpacePercentage *float64 `json:"maxSnapshotSpacePercentage,omitempty"`
}

// UnmarshalMaxSpaceConfig unmarshals an instance of MaxSpaceConfig from the specified map of raw messages.
func UnmarshalMaxSpaceConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MaxSpaceConfig)
	err = core.UnmarshalPrimitive(m, "maxSnapshotSpacePercentage", &obj.MaxSnapshotSpacePercentage)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxSnapshotSpacePercentage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MinuteSchedule : Specifies settings that define a schedule for a Protection Group runs to start after certain number of minutes.
type MinuteSchedule struct {
	// Specifies a factor to multiply the unit by, to determine the backup schedule. <br> Example: If 'frequency' set to 2
	// and the unit is 'Hours', then Snapshots are backed up every 2 hours. <br> This field is only applicable if unit is
	// 'Minutes', 'Hours' or 'Days'.
	Frequency *int64 `json:"frequency" validate:"required"`
}

// NewMinuteSchedule : Instantiate MinuteSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewMinuteSchedule(frequency int64) (_model *MinuteSchedule, err error) {
	_model = &MinuteSchedule{
		Frequency: core.Int64Ptr(frequency),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMinuteSchedule unmarshals an instance of MinuteSchedule from the specified map of raw messages.
func UnmarshalMinuteSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MinuteSchedule)
	err = core.UnmarshalPrimitive(m, "frequency", &obj.Frequency)
	if err != nil {
		err = core.SDKErrorf(err, "", "frequency-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MissingEntityParams : Specifies the information about missing entities.
type MissingEntityParams struct {
	// Specifies the ID of the object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies the id of the parent source of the object.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ParentSourceID *int64 `json:"parentSourceId,omitempty"`

	// Specifies the name of the parent source of the object.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ParentSourceName *string `json:"parentSourceName,omitempty"`
}

// UnmarshalMissingEntityParams unmarshals an instance of MissingEntityParams from the specified map of raw messages.
func UnmarshalMissingEntityParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MissingEntityParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentSourceId", &obj.ParentSourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentSourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentSourceName", &obj.ParentSourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentSourceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MongoDbOnPremSearchParams : Parameters required to search Mongo DB on a cluster.
type MongoDbOnPremSearchParams struct {
	// Specifies one or more MongoDB object types be searched.
	MongoDBObjectTypes []string `json:"mongoDBObjectTypes" validate:"required"`

	// Specifies the search string to search the MongoDB Objects.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// Constants associated with the MongoDbOnPremSearchParams.MongoDBObjectTypes property.
const (
	MongoDbOnPremSearchParams_MongoDBObjectTypes_Mongocollections = "MongoCollections"
	MongoDbOnPremSearchParams_MongoDBObjectTypes_Mongodatabases   = "MongoDatabases"
)

// NewMongoDbOnPremSearchParams : Instantiate MongoDbOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMongoDbOnPremSearchParams(mongoDBObjectTypes []string, searchString string) (_model *MongoDbOnPremSearchParams, err error) {
	_model = &MongoDbOnPremSearchParams{
		MongoDBObjectTypes: mongoDBObjectTypes,
		SearchString:       core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMongoDbOnPremSearchParams unmarshals an instance of MongoDbOnPremSearchParams from the specified map of raw messages.
func UnmarshalMongoDbOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MongoDbOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "mongoDBObjectTypes", &obj.MongoDBObjectTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "mongoDBObjectTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MongoIndexedObject : Specifies a Mongo indexed object.
type MongoIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the CDP related information for a given object. This field will only be populated when protection group is
	// configured with policy having CDP retention settings.
	CdpInfo *CdpObjectInfo `json:"cdpInfo,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies the Mongo Object Type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the MongoIndexedObject.Type property.
// Specifies the Mongo Object Type.
const (
	MongoIndexedObject_Type_Mongocollections = "MongoCollections"
	MongoIndexedObject_Type_Mongodatabases   = "MongoDatabases"
)

// UnmarshalMongoIndexedObject unmarshals an instance of MongoIndexedObject from the specified map of raw messages.
func UnmarshalMongoIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MongoIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cdpInfo", &obj.CdpInfo, UnmarshalCdpObjectInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "cdpInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MonthSchedule : Specifies settings that define a schedule for a Protection Group runs to on specific week and specific days of that
// week.
type MonthSchedule struct {
	// Specifies a list of days of the week when to start Protection Group Runs. <br> Example: To run a Protection Group on
	// every Monday and Tuesday, set the schedule with following values: <br>  unit: 'Weeks' <br>  dayOfWeek:
	// ['Monday','Tuesday'].
	DayOfWeek []string `json:"dayOfWeek,omitempty"`

	// Specifies the week of the month (such as 'Third') or nth day of month (such as 'First' or 'Last') in a Monthly
	// Schedule specified by unit field as 'Months'. <br>This field can be used in combination with 'dayOfWeek' to define
	// the day in the month to start the Protection Group Run. <br> Example: if 'weekOfMonth' is set to 'Third' and day is
	// set to 'Monday', a backup is performed on the third Monday of every month. <br> Example: if 'weekOfMonth' is set to
	// 'Last' and dayOfWeek is not set, a backup is performed on the last day of every month.
	WeekOfMonth *string `json:"weekOfMonth,omitempty"`

	// Specifies the exact date of the month (such as 18) in a Monthly Schedule specified by unit field as 'Years'. <br>
	// Example: if 'dayOfMonth' is set to '18', a backup is performed on the 18th of every month.
	DayOfMonth *int64 `json:"dayOfMonth,omitempty"`
}

// Constants associated with the MonthSchedule.DayOfWeek property.
const (
	MonthSchedule_DayOfWeek_Friday    = "Friday"
	MonthSchedule_DayOfWeek_Monday    = "Monday"
	MonthSchedule_DayOfWeek_Saturday  = "Saturday"
	MonthSchedule_DayOfWeek_Sunday    = "Sunday"
	MonthSchedule_DayOfWeek_Thursday  = "Thursday"
	MonthSchedule_DayOfWeek_Tuesday   = "Tuesday"
	MonthSchedule_DayOfWeek_Wednesday = "Wednesday"
)

// Constants associated with the MonthSchedule.WeekOfMonth property.
// Specifies the week of the month (such as 'Third') or nth day of month (such as 'First' or 'Last') in a Monthly
// Schedule specified by unit field as 'Months'. <br>This field can be used in combination with 'dayOfWeek' to define
// the day in the month to start the Protection Group Run. <br> Example: if 'weekOfMonth' is set to 'Third' and day is
// set to 'Monday', a backup is performed on the third Monday of every month. <br> Example: if 'weekOfMonth' is set to
// 'Last' and dayOfWeek is not set, a backup is performed on the last day of every month.
const (
	MonthSchedule_WeekOfMonth_First  = "First"
	MonthSchedule_WeekOfMonth_Fourth = "Fourth"
	MonthSchedule_WeekOfMonth_Last   = "Last"
	MonthSchedule_WeekOfMonth_Second = "Second"
	MonthSchedule_WeekOfMonth_Third  = "Third"
)

// UnmarshalMonthSchedule unmarshals an instance of MonthSchedule from the specified map of raw messages.
func UnmarshalMonthSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MonthSchedule)
	err = core.UnmarshalPrimitive(m, "dayOfWeek", &obj.DayOfWeek)
	if err != nil {
		err = core.SDKErrorf(err, "", "dayOfWeek-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "weekOfMonth", &obj.WeekOfMonth)
	if err != nil {
		err = core.SDKErrorf(err, "", "weekOfMonth-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dayOfMonth", &obj.DayOfMonth)
	if err != nil {
		err = core.SDKErrorf(err, "", "dayOfMonth-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MountPhysicalVolumeParamsPhysicalTargetParams : Specifies the params for recovering to a physical target.
type MountPhysicalVolumeParamsPhysicalTargetParams struct {
	// Specifies whether to mount to the original target. If true, originalTargetConfig must be specified. If false,
	// newTargetConfig must be specified.
	MountToOriginalTarget *bool `json:"mountToOriginalTarget" validate:"required"`

	// Specifies the configuration for mounting to the original target.
	OriginalTargetConfig *PhysicalTargetParamsForMountVolumeOriginalTargetConfig `json:"originalTargetConfig,omitempty"`

	// Specifies the configuration for mounting to a new target.
	NewTargetConfig *PhysicalTargetParamsForMountVolumeNewTargetConfig `json:"newTargetConfig,omitempty"`

	// Specifies whether to perform a read-only mount. Default is false.
	ReadOnlyMount *bool `json:"readOnlyMount,omitempty"`

	// Specifies the names of volumes that need to be mounted. If this is not specified then all volumes that are part of
	// the source VM will be mounted on the target VM.
	VolumeNames []string `json:"volumeNames,omitempty"`

	// Specifies the mapping of original volumes and mounted volumes.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	MountedVolumeMapping []MountedVolumeMapping `json:"mountedVolumeMapping,omitempty"`

	// Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
	// automatically selected from one of the below options: a. If VLANs are configured on Cohesity, then the VLAN host/VIP
	// will be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on Cohesity,
	// then the partition hostname or VIPs will be used for Recovery.
	VlanConfig *PhysicalTargetParamsForMountVolumeVlanConfig `json:"vlanConfig,omitempty"`
}

// NewMountPhysicalVolumeParamsPhysicalTargetParams : Instantiate MountPhysicalVolumeParamsPhysicalTargetParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewMountPhysicalVolumeParamsPhysicalTargetParams(mountToOriginalTarget bool) (_model *MountPhysicalVolumeParamsPhysicalTargetParams, err error) {
	_model = &MountPhysicalVolumeParamsPhysicalTargetParams{
		MountToOriginalTarget: core.BoolPtr(mountToOriginalTarget),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalMountPhysicalVolumeParamsPhysicalTargetParams unmarshals an instance of MountPhysicalVolumeParamsPhysicalTargetParams from the specified map of raw messages.
func UnmarshalMountPhysicalVolumeParamsPhysicalTargetParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MountPhysicalVolumeParamsPhysicalTargetParams)
	err = core.UnmarshalPrimitive(m, "mountToOriginalTarget", &obj.MountToOriginalTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountToOriginalTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "originalTargetConfig", &obj.OriginalTargetConfig, UnmarshalPhysicalTargetParamsForMountVolumeOriginalTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "originalTargetConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "newTargetConfig", &obj.NewTargetConfig, UnmarshalPhysicalTargetParamsForMountVolumeNewTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "newTargetConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "readOnlyMount", &obj.ReadOnlyMount)
	if err != nil {
		err = core.SDKErrorf(err, "", "readOnlyMount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeNames", &obj.VolumeNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mountedVolumeMapping", &obj.MountedVolumeMapping, UnmarshalMountedVolumeMapping)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountedVolumeMapping-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vlanConfig", &obj.VlanConfig, UnmarshalPhysicalTargetParamsForMountVolumeVlanConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlanConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MountedVolumeMapping : Specifies the mapping of original volume and mounted volume after Instant Volume Mount.
type MountedVolumeMapping struct {
	// Specifies the name of the original volume.
	OriginalVolume *string `json:"originalVolume,omitempty"`

	// Specifies the name of the point where the volume is mounted.
	MountedVolume *string `json:"mountedVolume,omitempty"`

	// Specifies the type of the file system of the volume.
	FileSystemType *string `json:"fileSystemType,omitempty"`
}

// UnmarshalMountedVolumeMapping unmarshals an instance of MountedVolumeMapping from the specified map of raw messages.
func UnmarshalMountedVolumeMapping(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MountedVolumeMapping)
	err = core.UnmarshalPrimitive(m, "originalVolume", &obj.OriginalVolume)
	if err != nil {
		err = core.SDKErrorf(err, "", "originalVolume-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mountedVolume", &obj.MountedVolume)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountedVolume-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fileSystemType", &obj.FileSystemType)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileSystemType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MsGroupItem : Specifies the indexed M365 Group item.
type MsGroupItem struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies an email or an email folder.
	MailboxItem *Email `json:"mailboxItem,omitempty"`

	// Specifies a Document Library indexed item.
	SiteItem *DocumentLibraryItem `json:"siteItem,omitempty"`

	// Specifies the M365 Group item type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the MsGroupItem.Type property.
// Specifies the M365 Group item type.
const (
	MsGroupItem_Type_Email       = "Email"
	MsGroupItem_Type_Emailfolder = "EmailFolder"
	MsGroupItem_Type_Sitefile    = "SiteFile"
	MsGroupItem_Type_Sitefolder  = "SiteFolder"
)

// UnmarshalMsGroupItem unmarshals an instance of MsGroupItem from the specified map of raw messages.
func UnmarshalMsGroupItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MsGroupItem)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mailboxItem", &obj.MailboxItem, UnmarshalEmail)
	if err != nil {
		err = core.SDKErrorf(err, "", "mailboxItem-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "siteItem", &obj.SiteItem, UnmarshalDocumentLibraryItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "siteItem-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultiStageRestoreOptions : Specifies the parameters related to multi stage Sql restore.
type MultiStageRestoreOptions struct {
	// Set this to true if you want to enable auto sync for multi stage restore.
	EnableAutoSync *bool `json:"enableAutoSync,omitempty"`

	// Set this to true if you are creating a multi-stage Sql restore task needed for features such as Hot-Standby.
	EnableMultiStageRestore *bool `json:"enableMultiStageRestore,omitempty"`
}

// UnmarshalMultiStageRestoreOptions unmarshals an instance of MultiStageRestoreOptions from the specified map of raw messages.
func UnmarshalMultiStageRestoreOptions(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultiStageRestoreOptions)
	err = core.UnmarshalPrimitive(m, "enableAutoSync", &obj.EnableAutoSync)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableAutoSync-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "enableMultiStageRestore", &obj.EnableMultiStageRestore)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableMultiStageRestore-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NasSourceParams : Specifies the NAS specific source throttling parameters during source registration or during backup of the source.
type NasSourceParams struct {
	// Specifies the percentage value of maximum concurrent metadata to be fetched during full backup of the source.
	MaxParallelMetadataFetchFullPercentage *float64 `json:"maxParallelMetadataFetchFullPercentage,omitempty"`

	// Specifies the percentage value of maximum concurrent metadata to be fetched during incremental backup of the source.
	MaxParallelMetadataFetchIncrementalPercentage *float64 `json:"maxParallelMetadataFetchIncrementalPercentage,omitempty"`

	// Specifies the percentage value of maximum concurrent IO during full backup of the source.
	MaxParallelReadWriteFullPercentage *float64 `json:"maxParallelReadWriteFullPercentage,omitempty"`

	// Specifies the percentage value of maximum concurrent IO during incremental backup of the source.
	MaxParallelReadWriteIncrementalPercentage *float64 `json:"maxParallelReadWriteIncrementalPercentage,omitempty"`
}

// UnmarshalNasSourceParams unmarshals an instance of NasSourceParams from the specified map of raw messages.
func UnmarshalNasSourceParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NasSourceParams)
	err = core.UnmarshalPrimitive(m, "maxParallelMetadataFetchFullPercentage", &obj.MaxParallelMetadataFetchFullPercentage)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxParallelMetadataFetchFullPercentage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "maxParallelMetadataFetchIncrementalPercentage", &obj.MaxParallelMetadataFetchIncrementalPercentage)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxParallelMetadataFetchIncrementalPercentage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "maxParallelReadWriteFullPercentage", &obj.MaxParallelReadWriteFullPercentage)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxParallelReadWriteFullPercentage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "maxParallelReadWriteIncrementalPercentage", &obj.MaxParallelReadWriteIncrementalPercentage)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxParallelReadWriteIncrementalPercentage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetappObjectParams : Specifies the common parameters for Netapp objects.
type NetappObjectParams struct {
	// Specifies a list of NAS mount protocols supported by this object.
	SupportedNasMountProtocols []string `json:"supportedNasMountProtocols,omitempty"`

	// Specifies the extended style of a NetApp volume.
	VolumeExtendedStyle *string `json:"volumeExtendedStyle,omitempty"`

	// Specifies the Netapp volume type.
	VolumeType *string `json:"volumeType,omitempty"`
}

// Constants associated with the NetappObjectParams.SupportedNasMountProtocols property.
const (
	NetappObjectParams_SupportedNasMountProtocols_Kcifs       = "kCifs"
	NetappObjectParams_SupportedNasMountProtocols_Kfc         = "kFc"
	NetappObjectParams_SupportedNasMountProtocols_Kfcache     = "kFcache"
	NetappObjectParams_SupportedNasMountProtocols_Khttp       = "kHttp"
	NetappObjectParams_SupportedNasMountProtocols_Kiscsi      = "kIscsi"
	NetappObjectParams_SupportedNasMountProtocols_Kmanagement = "kManagement"
	NetappObjectParams_SupportedNasMountProtocols_Kndmp       = "kNdmp"
	NetappObjectParams_SupportedNasMountProtocols_Knfs        = "kNfs"
	NetappObjectParams_SupportedNasMountProtocols_Knvme       = "kNvme"
)

// Constants associated with the NetappObjectParams.VolumeExtendedStyle property.
// Specifies the extended style of a NetApp volume.
const (
	NetappObjectParams_VolumeExtendedStyle_Kflexgroup = "kFlexGroup"
	NetappObjectParams_VolumeExtendedStyle_Kflexvol   = "kFlexVol"
)

// Constants associated with the NetappObjectParams.VolumeType property.
// Specifies the Netapp volume type.
const (
	NetappObjectParams_VolumeType_Datacache      = "DataCache"
	NetappObjectParams_VolumeType_Dataprotection = "DataProtection"
	NetappObjectParams_VolumeType_Loadsharing    = "LoadSharing"
	NetappObjectParams_VolumeType_Readwrite      = "ReadWrite"
	NetappObjectParams_VolumeType_Temp           = "Temp"
	NetappObjectParams_VolumeType_Unkowntype     = "UnkownType"
)

// UnmarshalNetappObjectParams unmarshals an instance of NetappObjectParams from the specified map of raw messages.
func UnmarshalNetappObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetappObjectParams)
	err = core.UnmarshalPrimitive(m, "supportedNasMountProtocols", &obj.SupportedNasMountProtocols)
	if err != nil {
		err = core.SDKErrorf(err, "", "supportedNasMountProtocols-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeExtendedStyle", &obj.VolumeExtendedStyle)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeExtendedStyle-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeType", &obj.VolumeType)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkingInformation : Specifies the struct containing information about network addresses configured on the given box. This is needed for
// dealing with Windows/Oracle Cluster resources that we discover and protect automatically.
type NetworkingInformation struct {
	// The list of resources on the system that are accessible by an IP address.
	ResourceVec []ClusterNetworkResourceInformation `json:"resourceVec,omitempty"`
}

// UnmarshalNetworkingInformation unmarshals an instance of NetworkingInformation from the specified map of raw messages.
func UnmarshalNetworkingInformation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkingInformation)
	err = core.UnmarshalModel(m, "resourceVec", &obj.ResourceVec, UnmarshalClusterNetworkResourceInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "resourceVec-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// O365SearchEmailsRequestParams : Specifies email search request params specific to O365 environment.
type O365SearchEmailsRequestParams struct {
	// Specifies the domain Ids in which mailboxes are registered.
	DomainIds []int64 `json:"domainIds,omitempty"`

	// Specifies the mailbox Ids which contains the emails/folders.
	MailboxIds []int64 `json:"mailboxIds,omitempty"`
}

// UnmarshalO365SearchEmailsRequestParams unmarshals an instance of O365SearchEmailsRequestParams from the specified map of raw messages.
func UnmarshalO365SearchEmailsRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(O365SearchEmailsRequestParams)
	err = core.UnmarshalPrimitive(m, "domainIds", &obj.DomainIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "domainIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mailboxIds", &obj.MailboxIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "mailboxIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// O365SearchRequestParams : Specifies O365 specific params search request params to search for indexed items.
type O365SearchRequestParams struct {
	// Specifies the domain Ids in which indexed items are searched.
	DomainIds []int64 `json:"domainIds,omitempty"`

	// Specifies the Group ids across which the indexed items needs to be searched.
	GroupIds []int64 `json:"groupIds,omitempty"`

	// Specifies the Sharepoint site ids across which the indexed items needs to be searched.
	SiteIds []int64 `json:"siteIds,omitempty"`

	// Specifies the Teams ids across which the indexed items needs to be searched.
	TeamsIds []int64 `json:"teamsIds,omitempty"`

	// Specifies the user ids across which the indexed items needs to be searched.
	UserIds []int64 `json:"userIds,omitempty"`
}

// UnmarshalO365SearchRequestParams unmarshals an instance of O365SearchRequestParams from the specified map of raw messages.
func UnmarshalO365SearchRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(O365SearchRequestParams)
	err = core.UnmarshalPrimitive(m, "domainIds", &obj.DomainIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "domainIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "groupIds", &obj.GroupIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "groupIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "siteIds", &obj.SiteIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "siteIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "teamsIds", &obj.TeamsIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "teamsIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userIds", &obj.UserIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "userIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// O365TeamsChannelsSearchRequestParams : Specifies the request parameters related to channels for Microsoft365 teams.
type O365TeamsChannelsSearchRequestParams struct {
	// Specifies the email id of the channel.
	ChannelEmail *string `json:"channelEmail,omitempty"`

	// Specifies the unique id of the channel.
	ChannelID *string `json:"channelId,omitempty"`

	// Specifies the name of the channel. Only items within the specified channel will be returned.
	ChannelName *string `json:"channelName,omitempty"`

	// Specifies whether to include private channels in the response. Default is true.
	IncludePrivateChannels *bool `json:"includePrivateChannels,omitempty"`

	// Specifies whether to include public channels in the response. Default is true.
	IncludePublicChannels *bool `json:"includePublicChannels,omitempty"`
}

// UnmarshalO365TeamsChannelsSearchRequestParams unmarshals an instance of O365TeamsChannelsSearchRequestParams from the specified map of raw messages.
func UnmarshalO365TeamsChannelsSearchRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(O365TeamsChannelsSearchRequestParams)
	err = core.UnmarshalPrimitive(m, "channelEmail", &obj.ChannelEmail)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelEmail-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "channelId", &obj.ChannelID)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "channelName", &obj.ChannelName)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "includePrivateChannels", &obj.IncludePrivateChannels)
	if err != nil {
		err = core.SDKErrorf(err, "", "includePrivateChannels-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "includePublicChannels", &obj.IncludePublicChannels)
	if err != nil {
		err = core.SDKErrorf(err, "", "includePublicChannels-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Object : Specifies information about an object.
type Object struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`

	// Specifies the count and size of protected and unprotected objects for the size.
	ProtectionStats []ObjectProtectionStatsSummary `json:"protectionStats,omitempty"`

	// Specifies the list of users, groups and users that have permissions for a given object.
	Permissions *PermissionInfo `json:"permissions,omitempty"`

	// Specifies the parameters for Msssql object.
	MssqlParams *ObjectMssqlParams `json:"mssqlParams,omitempty"`

	// Specifies the parameters for Physical object.
	PhysicalParams *ObjectPhysicalParams `json:"physicalParams,omitempty"`
}

// Constants associated with the Object.Environment property.
// Specifies the environment of the object.
const (
	Object_Environment_Kphysical = "kPhysical"
	Object_Environment_Ksql      = "kSQL"
)

// Constants associated with the Object.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	Object_ProtectionType_Kagent                 = "kAgent"
	Object_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	Object_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	Object_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	Object_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	Object_ProtectionType_Kawss3                 = "kAwsS3"
	Object_ProtectionType_Kazuresql              = "kAzureSQL"
	Object_ProtectionType_Kfile                  = "kFile"
	Object_ProtectionType_Knative                = "kNative"
	Object_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	Object_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	Object_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the Object.OsType property.
// Specifies the operating system type of the object.
const (
	Object_OsType_Klinux   = "kLinux"
	Object_OsType_Kwindows = "kWindows"
)

// UnmarshalObject unmarshals an instance of Object from the specified map of raw messages.
func UnmarshalObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Object)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionStats", &obj.ProtectionStats, UnmarshalObjectProtectionStatsSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionStats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalPermissionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalObjectMssqlParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalObjectPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectArchivalSnapshotInfo : Specifies the Archival snapshot information for the object.
type ObjectArchivalSnapshotInfo struct {
	// Specifies the archival target ID.
	TargetID *int64 `json:"targetId,omitempty"`

	// Specifies the archival task id. This is a protection group UID which only applies when archival type is 'Tape'.
	ArchivalTaskID *string `json:"archivalTaskId,omitempty"`

	// Specifies the archival target name.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the archival target type.
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the usage type for the target.
	UsageType *string `json:"usageType,omitempty"`

	// Specifies the ownership context for the target.
	OwnershipContext *string `json:"ownershipContext,omitempty"`

	// Specifies the tier info for archival.
	TierSettings *ArchivalTargetTierInfo `json:"tierSettings,omitempty"`

	// Specifies the id of the archival snapshot for the object.
	SnapshotID *string `json:"snapshotId,omitempty"`

	// Specifies the logical size of this snapshot in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`
}

// Constants associated with the ObjectArchivalSnapshotInfo.TargetType property.
// Specifies the archival target type.
const (
	ObjectArchivalSnapshotInfo_TargetType_Cloud = "Cloud"
	ObjectArchivalSnapshotInfo_TargetType_Nas   = "Nas"
	ObjectArchivalSnapshotInfo_TargetType_Tape  = "Tape"
)

// Constants associated with the ObjectArchivalSnapshotInfo.UsageType property.
// Specifies the usage type for the target.
const (
	ObjectArchivalSnapshotInfo_UsageType_Archival = "Archival"
	ObjectArchivalSnapshotInfo_UsageType_Rpaas    = "Rpaas"
	ObjectArchivalSnapshotInfo_UsageType_Tiering  = "Tiering"
)

// Constants associated with the ObjectArchivalSnapshotInfo.OwnershipContext property.
// Specifies the ownership context for the target.
const (
	ObjectArchivalSnapshotInfo_OwnershipContext_Fortknox = "FortKnox"
	ObjectArchivalSnapshotInfo_OwnershipContext_Local    = "Local"
)

// UnmarshalObjectArchivalSnapshotInfo unmarshals an instance of ObjectArchivalSnapshotInfo from the specified map of raw messages.
func UnmarshalObjectArchivalSnapshotInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectArchivalSnapshotInfo)
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTaskId", &obj.ArchivalTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "usageType", &obj.UsageType)
	if err != nil {
		err = core.SDKErrorf(err, "", "usageType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownershipContext", &obj.OwnershipContext)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownershipContext-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tierSettings", &obj.TierSettings, UnmarshalArchivalTargetTierInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectMssqlParams : Specifies the parameters for Msssql object.
type ObjectMssqlParams struct {
	// Object details for Mssql.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
	// hosted by another object such as VM or physical server.
	HostInfo *HostInformation `json:"hostInfo,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
}

// UnmarshalObjectMssqlParams unmarshals an instance of ObjectMssqlParams from the specified map of raw messages.
func UnmarshalObjectMssqlParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectMssqlParams)
	err = core.UnmarshalModel(m, "aagInfo", &obj.AagInfo, UnmarshalAAGInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostInfo", &obj.HostInfo, UnmarshalHostInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectPhysicalParams : Specifies the parameters for Physical object.
type ObjectPhysicalParams struct {
	// Specifies if system backup was enabled for the source in a particular run.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`
}

// UnmarshalObjectPhysicalParams unmarshals an instance of ObjectPhysicalParams from the specified map of raw messages.
func UnmarshalObjectPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectPhysicalParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectProtectionGroupSummary : Specifies a summary of a protection group protecting this object.
type ObjectProtectionGroupSummary struct {
	// Specifies the protection group name.
	Name *string `json:"name,omitempty"`

	// Specifies the protection group id.
	ID *string `json:"id,omitempty"`

	// Specifies the protection type of the job if any.
	ProtectionEnvType *string `json:"protectionEnvType,omitempty"`

	// Specifies the policy name for this group.
	PolicyName *string `json:"policyName,omitempty"`

	// Specifies the policy id for this group.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the status of last local back up run.
	LastBackupRunStatus *string `json:"lastBackupRunStatus,omitempty"`

	// Specifies the status of last archival run.
	LastArchivalRunStatus *string `json:"lastArchivalRunStatus,omitempty"`

	// Specifies the status of last replication run.
	LastReplicationRunStatus *string `json:"lastReplicationRunStatus,omitempty"`

	// Specifies if the sla is violated in last run.
	LastRunSlaViolated *bool `json:"lastRunSlaViolated,omitempty"`
}

// Constants associated with the ObjectProtectionGroupSummary.ProtectionEnvType property.
// Specifies the protection type of the job if any.
const (
	ObjectProtectionGroupSummary_ProtectionEnvType_Kagent                 = "kAgent"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kawsrdspostgres        = "kAwsRDSPostgres"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kawss3                 = "kAwsS3"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kazuresql              = "kAzureSQL"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kfile                  = "kFile"
	ObjectProtectionGroupSummary_ProtectionEnvType_Knative                = "kNative"
	ObjectProtectionGroupSummary_ProtectionEnvType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	ObjectProtectionGroupSummary_ProtectionEnvType_Ksnapshotmanager       = "kSnapshotManager"
	ObjectProtectionGroupSummary_ProtectionEnvType_Kvolume                = "kVolume"
)

// Constants associated with the ObjectProtectionGroupSummary.LastBackupRunStatus property.
// Specifies the status of last local back up run.
const (
	ObjectProtectionGroupSummary_LastBackupRunStatus_Accepted             = "Accepted"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Canceled             = "Canceled"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Canceling            = "Canceling"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Failed               = "Failed"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Finalizing           = "Finalizing"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Legalhold            = "LegalHold"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Missed               = "Missed"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Onhold               = "OnHold"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Running              = "Running"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Skipped              = "Skipped"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Succeeded            = "Succeeded"
	ObjectProtectionGroupSummary_LastBackupRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the ObjectProtectionGroupSummary.LastArchivalRunStatus property.
// Specifies the status of last archival run.
const (
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Accepted             = "Accepted"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Canceled             = "Canceled"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Canceling            = "Canceling"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Failed               = "Failed"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Finalizing           = "Finalizing"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Legalhold            = "LegalHold"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Missed               = "Missed"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Onhold               = "OnHold"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Running              = "Running"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Skipped              = "Skipped"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Succeeded            = "Succeeded"
	ObjectProtectionGroupSummary_LastArchivalRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the ObjectProtectionGroupSummary.LastReplicationRunStatus property.
// Specifies the status of last replication run.
const (
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Accepted             = "Accepted"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Canceled             = "Canceled"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Canceling            = "Canceling"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Failed               = "Failed"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Finalizing           = "Finalizing"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Legalhold            = "LegalHold"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Missed               = "Missed"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Onhold               = "OnHold"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Running              = "Running"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Skipped              = "Skipped"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Succeeded            = "Succeeded"
	ObjectProtectionGroupSummary_LastReplicationRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalObjectProtectionGroupSummary unmarshals an instance of ObjectProtectionGroupSummary from the specified map of raw messages.
func UnmarshalObjectProtectionGroupSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectProtectionGroupSummary)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionEnvType", &obj.ProtectionEnvType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionEnvType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastBackupRunStatus", &obj.LastBackupRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastBackupRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastArchivalRunStatus", &obj.LastArchivalRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastArchivalRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastReplicationRunStatus", &obj.LastReplicationRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastReplicationRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastRunSlaViolated", &obj.LastRunSlaViolated)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastRunSlaViolated-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectProtectionInfo : Specifies the object info on cluster.
type ObjectProtectionInfo struct {
	// Specifies the object id.
	ObjectID *int64 `json:"objectId,omitempty"`

	// Specifies the source id.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies the view id for the object.
	ViewID *int64 `json:"viewId,omitempty"`

	// Specifies the region id where this object belongs to.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies the cluster id where this object belongs to.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the cluster incarnation id where this object belongs to.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// List of Tenants the object belongs to.
	TenantIds []string `json:"tenantIds,omitempty"`

	// Specifies whether the object is deleted. Deleted objects can't be protected but can be recovered or unprotected.
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// Specifies a list of protection groups protecting this object.
	ProtectionGroups []ObjectProtectionGroupSummary `json:"protectionGroups,omitempty"`

	// Specifies a list of object protections.
	ObjectBackupConfiguration []ProtectionSummary `json:"objectBackupConfiguration,omitempty"`

	// Specifies the status of the object's last protection run.
	LastRunStatus *string `json:"lastRunStatus,omitempty"`
}

// Constants associated with the ObjectProtectionInfo.LastRunStatus property.
// Specifies the status of the object's last protection run.
const (
	ObjectProtectionInfo_LastRunStatus_Accepted             = "Accepted"
	ObjectProtectionInfo_LastRunStatus_Canceled             = "Canceled"
	ObjectProtectionInfo_LastRunStatus_Canceling            = "Canceling"
	ObjectProtectionInfo_LastRunStatus_Failed               = "Failed"
	ObjectProtectionInfo_LastRunStatus_Finalizing           = "Finalizing"
	ObjectProtectionInfo_LastRunStatus_Legalhold            = "LegalHold"
	ObjectProtectionInfo_LastRunStatus_Missed               = "Missed"
	ObjectProtectionInfo_LastRunStatus_Onhold               = "OnHold"
	ObjectProtectionInfo_LastRunStatus_Paused               = "Paused"
	ObjectProtectionInfo_LastRunStatus_Running              = "Running"
	ObjectProtectionInfo_LastRunStatus_Skipped              = "Skipped"
	ObjectProtectionInfo_LastRunStatus_Succeeded            = "Succeeded"
	ObjectProtectionInfo_LastRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalObjectProtectionInfo unmarshals an instance of ObjectProtectionInfo from the specified map of raw messages.
func UnmarshalObjectProtectionInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectProtectionInfo)
	err = core.UnmarshalPrimitive(m, "objectId", &obj.ObjectID)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "viewId", &obj.ViewID)
	if err != nil {
		err = core.SDKErrorf(err, "", "viewId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "regionId", &obj.RegionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "regionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIncarnationId", &obj.ClusterIncarnationID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIncarnationId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantIds", &obj.TenantIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isDeleted", &obj.IsDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionGroups", &obj.ProtectionGroups, UnmarshalObjectProtectionGroupSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objectBackupConfiguration", &obj.ObjectBackupConfiguration, UnmarshalProtectionSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectBackupConfiguration-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastRunStatus", &obj.LastRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastRunStatus-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectProtectionStatsSummary : Specifies the count and size of protected and unprotected objects for a given environment.
type ObjectProtectionStatsSummary struct {
	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the count of the protected leaf objects.
	ProtectedCount *int64 `json:"protectedCount,omitempty"`

	// Specifies the count of the unprotected leaf objects.
	UnprotectedCount *int64 `json:"unprotectedCount,omitempty"`

	// Specifies the count of protected leaf objects which were deleted from the source after being protected.
	DeletedProtectedCount *int64 `json:"deletedProtectedCount,omitempty"`

	// Specifies the protected logical size in bytes.
	ProtectedSizeBytes *int64 `json:"protectedSizeBytes,omitempty"`

	// Specifies the unprotected logical size in bytes.
	UnprotectedSizeBytes *int64 `json:"unprotectedSizeBytes,omitempty"`
}

// Constants associated with the ObjectProtectionStatsSummary.Environment property.
// Specifies the environment of the object.
const (
	ObjectProtectionStatsSummary_Environment_Koracle   = "kOracle"
	ObjectProtectionStatsSummary_Environment_Kphysical = "kPhysical"
	ObjectProtectionStatsSummary_Environment_Ksql      = "kSQL"
)

// UnmarshalObjectProtectionStatsSummary unmarshals an instance of ObjectProtectionStatsSummary from the specified map of raw messages.
func UnmarshalObjectProtectionStatsSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectProtectionStatsSummary)
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectedCount", &obj.ProtectedCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectedCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "unprotectedCount", &obj.UnprotectedCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "unprotectedCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "deletedProtectedCount", &obj.DeletedProtectedCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "deletedProtectedCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectedSizeBytes", &obj.ProtectedSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectedSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "unprotectedSizeBytes", &obj.UnprotectedSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "unprotectedSizeBytes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectRunResult : Snapshot, replication, archival results for an object.
type ObjectRunResult struct {
	// Specifies the Object Summary.
	Object *ObjectSummary `json:"object,omitempty"`

	// Specifies information about backup run for an object.
	LocalSnapshotInfo *BackupRun `json:"localSnapshotInfo,omitempty"`

	// Specifies information about backup run for an object.
	OriginalBackupInfo *BackupRun `json:"originalBackupInfo,omitempty"`

	// Specifies information about replication run for an object.
	ReplicationInfo *ReplicationRun `json:"replicationInfo,omitempty"`

	// Specifies information about archival run for an object.
	ArchivalInfo *ArchivalRun `json:"archivalInfo,omitempty"`

	// Specifies information about Cloud Spin run for an object.
	CloudSpinInfo *CloudSpinRun `json:"cloudSpinInfo,omitempty"`

	// Specifies if object's snapshot is on legal hold.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`
}

// UnmarshalObjectRunResult unmarshals an instance of ObjectRunResult from the specified map of raw messages.
func UnmarshalObjectRunResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectRunResult)
	err = core.UnmarshalModel(m, "object", &obj.Object, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "object-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "localSnapshotInfo", &obj.LocalSnapshotInfo, UnmarshalBackupRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "localSnapshotInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "originalBackupInfo", &obj.OriginalBackupInfo, UnmarshalBackupRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "originalBackupInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "replicationInfo", &obj.ReplicationInfo, UnmarshalReplicationRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalInfo", &obj.ArchivalInfo, UnmarshalArchivalRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cloudSpinInfo", &obj.CloudSpinInfo, UnmarshalCloudSpinRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudSpinInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "onLegalHold", &obj.OnLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "onLegalHold-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectSnapshot : Specifies an Object Snapshot.
type ObjectSnapshot struct {
	// Specifies parameters of AWS type snapshots.
	AwsParams *AwsSnapshotParams `json:"awsParams,omitempty"`

	// Specifies parameters of Azure type snapshots.
	AzureParams *AzureSnapshotParams `json:"azureParams,omitempty"`

	// Specifies the cluster id where this snapshot belongs to.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the cluster incarnation id where this snapshot belongs to.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the common parameters for NAS objects.
	ElastifileParams *CommonNasObjectParams `json:"elastifileParams,omitempty"`

	// Specifies the snapshot environment.
	Environment *string `json:"environment,omitempty"`

	// Specifies the expiry time of the snapshot in Unix timestamp epoch in microseconds. If the snapshot has no expiry,
	// this property will not be set.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// Specifies archival target summary information.
	ExternalTargetInfo *ArchivalTargetSummaryInfo `json:"externalTargetInfo,omitempty"`

	// Specifies the common parameters for Flashblade objects.
	FlashbladeParams *FlashbladeObjectParams `json:"flashbladeParams,omitempty"`

	// Specifies the common parameters for NAS objects.
	GenericNasParams *CommonNasObjectParams `json:"genericNasParams,omitempty"`

	// Specifies the common parameters for NAS objects.
	GpfsParams *CommonNasObjectParams `json:"gpfsParams,omitempty"`

	// Specifies if this snapshot has datalock.
	HasDataLock *bool `json:"hasDataLock,omitempty"`

	// Specifies parameters of HyperV type snapshots.
	HypervParams *HypervSnapshotParams `json:"hypervParams,omitempty"`

	// Specifies the id of the snapshot.
	ID *string `json:"id,omitempty"`

	// Specifies the indexing status of objects in this snapshot.<br> 'InProgress' indicates the indexing is in
	// progress.<br> 'Done' indicates indexing is done.<br> 'NoIndex' indicates indexing is not applicable.<br> 'Error'
	// indicates indexing failed with error.
	IndexingStatus *string `json:"indexingStatus,omitempty"`

	// Specifies the common parameters for Isilon objects.
	IsilonParams *IsilonObjectParams `json:"isilonParams,omitempty"`

	// Specifies the common parameters for Netapp objects.
	NetappParams *NetappObjectParams `json:"netappParams,omitempty"`

	// Specifies the object id which the snapshot is taken from.
	ObjectID *int64 `json:"objectId,omitempty"`

	// Specifies the object name which the snapshot is taken from.
	ObjectName *string `json:"objectName,omitempty"`

	// Specifies if this snapshot is on legalhold.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`

	// Specifies the ownership context for the target.
	OwnershipContext *string `json:"ownershipContext,omitempty"`

	// Specifies parameters of Physical type snapshots.
	PhysicalParams *PhysicalSnapshotParams `json:"physicalParams,omitempty"`

	// Specifies id of the Protection Group.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies name of the Protection Group.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies id of the Protection Group Run.
	ProtectionGroupRunID *string `json:"protectionGroupRunId,omitempty"`

	// Specifies the region id where this snapshot belongs to.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies the instance id of the protection run which create the snapshot.
	RunInstanceID *int64 `json:"runInstanceId,omitempty"`

	// Specifies the start time of the run in micro seconds.
	RunStartTimeUsecs *int64 `json:"runStartTimeUsecs,omitempty"`

	// Specifies the type of protection run created this snapshot.
	RunType *string `json:"runType,omitempty"`

	// Specifies the Salesforce objects mutation parameters.
	SfdcParams *SfdcObjectParams `json:"sfdcParams,omitempty"`

	// Specifies the target type where the Object's snapshot resides.
	SnapshotTargetType *string `json:"snapshotTargetType,omitempty"`

	// Specifies the timestamp in Unix time epoch in microseconds when the snapshot is taken for the specified Object.
	SnapshotTimestampUsecs *int64 `json:"snapshotTimestampUsecs,omitempty"`

	// Specifies the source protection group id in case of replication.
	SourceGroupID *string `json:"sourceGroupId,omitempty"`

	// Specifies the object source id which the snapshot is taken from.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies the Storage Domain id where the snapshot of object is present.
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`
}

// Constants associated with the ObjectSnapshot.Environment property.
// Specifies the snapshot environment.
const (
	ObjectSnapshot_Environment_Kacropolis      = "kAcropolis"
	ObjectSnapshot_Environment_Kad             = "kAD"
	ObjectSnapshot_Environment_Kaws            = "kAWS"
	ObjectSnapshot_Environment_Kazure          = "kAzure"
	ObjectSnapshot_Environment_Kcassandra      = "kCassandra"
	ObjectSnapshot_Environment_Kcouchbase      = "kCouchbase"
	ObjectSnapshot_Environment_Kelastifile     = "kElastifile"
	ObjectSnapshot_Environment_Kexchange       = "kExchange"
	ObjectSnapshot_Environment_Kflashblade     = "kFlashBlade"
	ObjectSnapshot_Environment_Kgcp            = "kGCP"
	ObjectSnapshot_Environment_Kgenericnas     = "kGenericNas"
	ObjectSnapshot_Environment_Kgpfs           = "kGPFS"
	ObjectSnapshot_Environment_Khbase          = "kHBase"
	ObjectSnapshot_Environment_Khdfs           = "kHdfs"
	ObjectSnapshot_Environment_Khive           = "kHive"
	ObjectSnapshot_Environment_Khyperflex      = "kHyperFlex"
	ObjectSnapshot_Environment_Khyperv         = "kHyperV"
	ObjectSnapshot_Environment_Kibmflashsystem = "kIbmFlashSystem"
	ObjectSnapshot_Environment_Kisilon         = "kIsilon"
	ObjectSnapshot_Environment_Kkubernetes     = "kKubernetes"
	ObjectSnapshot_Environment_Kkvm            = "kKVM"
	ObjectSnapshot_Environment_Kmongodb        = "kMongoDB"
	ObjectSnapshot_Environment_Knetapp         = "kNetapp"
	ObjectSnapshot_Environment_Knimble         = "kNimble"
	ObjectSnapshot_Environment_Ko365           = "kO365"
	ObjectSnapshot_Environment_Koracle         = "kOracle"
	ObjectSnapshot_Environment_Kphysical       = "kPhysical"
	ObjectSnapshot_Environment_Kphysicalfiles  = "kPhysicalFiles"
	ObjectSnapshot_Environment_Kpure           = "kPure"
	ObjectSnapshot_Environment_Ksaphana        = "kSAPHANA"
	ObjectSnapshot_Environment_Ksfdc           = "kSfdc"
	ObjectSnapshot_Environment_Ksql            = "kSQL"
	ObjectSnapshot_Environment_Kuda            = "kUDA"
	ObjectSnapshot_Environment_Kview           = "kView"
	ObjectSnapshot_Environment_Kvmware         = "kVMware"
)

// Constants associated with the ObjectSnapshot.IndexingStatus property.
// Specifies the indexing status of objects in this snapshot.<br> 'InProgress' indicates the indexing is in
// progress.<br> 'Done' indicates indexing is done.<br> 'NoIndex' indicates indexing is not applicable.<br> 'Error'
// indicates indexing failed with error.
const (
	ObjectSnapshot_IndexingStatus_Done       = "Done"
	ObjectSnapshot_IndexingStatus_Error      = "Error"
	ObjectSnapshot_IndexingStatus_Inprogress = "InProgress"
	ObjectSnapshot_IndexingStatus_Noindex    = "NoIndex"
)

// Constants associated with the ObjectSnapshot.OwnershipContext property.
// Specifies the ownership context for the target.
const (
	ObjectSnapshot_OwnershipContext_Fortknox = "FortKnox"
	ObjectSnapshot_OwnershipContext_Local    = "Local"
)

// Constants associated with the ObjectSnapshot.RunType property.
// Specifies the type of protection run created this snapshot.
const (
	ObjectSnapshot_RunType_Kfull                 = "kFull"
	ObjectSnapshot_RunType_Khydratecdp           = "kHydrateCDP"
	ObjectSnapshot_RunType_Klog                  = "kLog"
	ObjectSnapshot_RunType_Kregular              = "kRegular"
	ObjectSnapshot_RunType_Kstoragearraysnapshot = "kStorageArraySnapshot"
	ObjectSnapshot_RunType_Ksystem               = "kSystem"
)

// Constants associated with the ObjectSnapshot.SnapshotTargetType property.
// Specifies the target type where the Object's snapshot resides.
const (
	ObjectSnapshot_SnapshotTargetType_Archival             = "Archival"
	ObjectSnapshot_SnapshotTargetType_Local                = "Local"
	ObjectSnapshot_SnapshotTargetType_Remote               = "Remote"
	ObjectSnapshot_SnapshotTargetType_Rpaasarchival        = "RpaasArchival"
	ObjectSnapshot_SnapshotTargetType_Storagearraysnapshot = "StorageArraySnapshot"
)

// UnmarshalObjectSnapshot unmarshals an instance of ObjectSnapshot from the specified map of raw messages.
func UnmarshalObjectSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectSnapshot)
	err = core.UnmarshalModel(m, "awsParams", &obj.AwsParams, UnmarshalAwsSnapshotParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureParams", &obj.AzureParams, UnmarshalAzureSnapshotParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIncarnationId", &obj.ClusterIncarnationID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIncarnationId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "elastifileParams", &obj.ElastifileParams, UnmarshalCommonNasObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "elastifileParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "externalTargetInfo", &obj.ExternalTargetInfo, UnmarshalArchivalTargetSummaryInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "externalTargetInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "flashbladeParams", &obj.FlashbladeParams, UnmarshalFlashbladeObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "flashbladeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "genericNasParams", &obj.GenericNasParams, UnmarshalCommonNasObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "genericNasParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gpfsParams", &obj.GpfsParams, UnmarshalCommonNasObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "gpfsParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasDataLock", &obj.HasDataLock)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasDataLock-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hypervParams", &obj.HypervParams, UnmarshalHypervSnapshotParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "hypervParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "indexingStatus", &obj.IndexingStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "isilonParams", &obj.IsilonParams, UnmarshalIsilonObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "isilonParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "netappParams", &obj.NetappParams, UnmarshalNetappObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "netappParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectId", &obj.ObjectID)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectName", &obj.ObjectName)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "onLegalHold", &obj.OnLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "onLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownershipContext", &obj.OwnershipContext)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownershipContext-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalPhysicalSnapshotParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupRunId", &obj.ProtectionGroupRunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupRunId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "regionId", &obj.RegionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "regionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runInstanceId", &obj.RunInstanceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runInstanceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runStartTimeUsecs", &obj.RunStartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "runStartTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runType", &obj.RunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "runType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sfdcParams", &obj.SfdcParams, UnmarshalSfdcObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sfdcParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotTargetType", &obj.SnapshotTargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTargetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotTimestampUsecs", &obj.SnapshotTimestampUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTimestampUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceGroupId", &obj.SourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectSnapshotsInfo : Specifies the snapshots information for every Protection Group for a given object.
type ObjectSnapshotsInfo struct {
	// Specifies the local snapshot information.
	LocalSnapshotInfo *ObjectSnapshotsInfoLocalSnapshotInfo `json:"localSnapshotInfo,omitempty"`

	// Specifies the archival snapshots information.
	ArchivalSnapshotsInfo []ObjectArchivalSnapshotInfo `json:"archivalSnapshotsInfo,omitempty"`

	// Specifies the indexing status of objects in this snapshot.<br> 'InProgress' indicates the indexing is in
	// progress.<br> 'Done' indicates indexing is done.<br> 'NoIndex' indicates indexing is not applicable.<br> 'Error'
	// indicates indexing failed with error.
	IndexingStatus *string `json:"indexingStatus,omitempty"`

	// Specifies id of the Protection Group.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies name of the Protection Group.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the instance id of the protection run which create the snapshot.
	RunInstanceID *int64 `json:"runInstanceId,omitempty"`

	// Specifies the source protection group id in case of replication.
	SourceGroupID *string `json:"sourceGroupId,omitempty"`

	// Specifies the id of Protection Group Run.
	ProtectionRunID *string `json:"protectionRunId,omitempty"`

	// Specifies the type of protection run created this snapshot.
	RunType *string `json:"runType,omitempty"`

	// Specifies the start time of Protection Group Run in Unix timestamp epoch in microseconds.
	ProtectionRunStartTimeUsecs *int64 `json:"protectionRunStartTimeUsecs,omitempty"`

	// Specifies the end time of Protection Group Run in Unix timestamp epoch in microseconds.
	ProtectionRunEndTimeUsecs *int64 `json:"protectionRunEndTimeUsecs,omitempty"`
}

// Constants associated with the ObjectSnapshotsInfo.IndexingStatus property.
// Specifies the indexing status of objects in this snapshot.<br> 'InProgress' indicates the indexing is in
// progress.<br> 'Done' indicates indexing is done.<br> 'NoIndex' indicates indexing is not applicable.<br> 'Error'
// indicates indexing failed with error.
const (
	ObjectSnapshotsInfo_IndexingStatus_Done       = "Done"
	ObjectSnapshotsInfo_IndexingStatus_Error      = "Error"
	ObjectSnapshotsInfo_IndexingStatus_Inprogress = "InProgress"
	ObjectSnapshotsInfo_IndexingStatus_Noindex    = "NoIndex"
)

// Constants associated with the ObjectSnapshotsInfo.RunType property.
// Specifies the type of protection run created this snapshot.
const (
	ObjectSnapshotsInfo_RunType_Kfull                 = "kFull"
	ObjectSnapshotsInfo_RunType_Khydratecdp           = "kHydrateCDP"
	ObjectSnapshotsInfo_RunType_Klog                  = "kLog"
	ObjectSnapshotsInfo_RunType_Kregular              = "kRegular"
	ObjectSnapshotsInfo_RunType_Kstoragearraysnapshot = "kStorageArraySnapshot"
	ObjectSnapshotsInfo_RunType_Ksystem               = "kSystem"
)

// UnmarshalObjectSnapshotsInfo unmarshals an instance of ObjectSnapshotsInfo from the specified map of raw messages.
func UnmarshalObjectSnapshotsInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectSnapshotsInfo)
	err = core.UnmarshalModel(m, "localSnapshotInfo", &obj.LocalSnapshotInfo, UnmarshalObjectSnapshotsInfoLocalSnapshotInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "localSnapshotInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalSnapshotsInfo", &obj.ArchivalSnapshotsInfo, UnmarshalObjectArchivalSnapshotInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalSnapshotsInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "indexingStatus", &obj.IndexingStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runInstanceId", &obj.RunInstanceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runInstanceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceGroupId", &obj.SourceGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionRunId", &obj.ProtectionRunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionRunId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runType", &obj.RunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "runType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionRunStartTimeUsecs", &obj.ProtectionRunStartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionRunStartTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionRunEndTimeUsecs", &obj.ProtectionRunEndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionRunEndTimeUsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectSnapshotsInfoLocalSnapshotInfo : Specifies the local snapshot information.
type ObjectSnapshotsInfoLocalSnapshotInfo struct {
	// Specifies the id of the local snapshot for the object.
	SnapshotID *string `json:"snapshotId,omitempty"`

	// Specifies the logical size of this snapshot in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`
}

// UnmarshalObjectSnapshotsInfoLocalSnapshotInfo unmarshals an instance of ObjectSnapshotsInfoLocalSnapshotInfo from the specified map of raw messages.
func UnmarshalObjectSnapshotsInfoLocalSnapshotInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectSnapshotsInfoLocalSnapshotInfo)
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectSummary : Specifies the Object Summary.
type ObjectSummary struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`
}

// Constants associated with the ObjectSummary.Environment property.
// Specifies the environment of the object.
const (
	ObjectSummary_Environment_Kphysical = "kPhysical"
	ObjectSummary_Environment_Ksql      = "kSQL"
)

// Constants associated with the ObjectSummary.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	ObjectSummary_ProtectionType_Kagent                 = "kAgent"
	ObjectSummary_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	ObjectSummary_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	ObjectSummary_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	ObjectSummary_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	ObjectSummary_ProtectionType_Kawss3                 = "kAwsS3"
	ObjectSummary_ProtectionType_Kazuresql              = "kAzureSQL"
	ObjectSummary_ProtectionType_Kfile                  = "kFile"
	ObjectSummary_ProtectionType_Knative                = "kNative"
	ObjectSummary_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	ObjectSummary_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	ObjectSummary_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the ObjectSummary.OsType property.
// Specifies the operating system type of the object.
const (
	ObjectSummary_OsType_Klinux   = "kLinux"
	ObjectSummary_OsType_Kwindows = "kWindows"
)

// UnmarshalObjectSummary unmarshals an instance of ObjectSummary from the specified map of raw messages.
func UnmarshalObjectSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectSummary)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectTypeVCenterParams : ObjectTypeVCenterParams struct
type ObjectTypeVCenterParams struct {
	// Specifies that registered vCenter source is a VMC (VMware Cloud) environment or not.
	IsCloudEnv *bool `json:"isCloudEnv,omitempty"`
}

// UnmarshalObjectTypeVCenterParams unmarshals an instance of ObjectTypeVCenterParams from the specified map of raw messages.
func UnmarshalObjectTypeVCenterParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectTypeVCenterParams)
	err = core.UnmarshalPrimitive(m, "isCloudEnv", &obj.IsCloudEnv)
	if err != nil {
		err = core.SDKErrorf(err, "", "isCloudEnv-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectTypeWindowsClusterParams : ObjectTypeWindowsClusterParams struct
type ObjectTypeWindowsClusterParams struct {
	// Specifies the type of cluster resource this source represents.
	ClusterSourceType *string `json:"clusterSourceType,omitempty"`
}

// UnmarshalObjectTypeWindowsClusterParams unmarshals an instance of ObjectTypeWindowsClusterParams from the specified map of raw messages.
func UnmarshalObjectTypeWindowsClusterParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectTypeWindowsClusterParams)
	err = core.UnmarshalPrimitive(m, "clusterSourceType", &obj.ClusterSourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterSourceType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectsSearchResponseBody : Specifies the Objects search result.
type ObjectsSearchResponseBody struct {
	// Specifies the list of Objects.
	Objects []SearchObject `json:"objects,omitempty"`

	// Specifies the pagination cookie with which subsequent parts of the response can be fetched.
	PaginationCookie *string `json:"paginationCookie,omitempty"`

	// Specifies the number of objects to be fetched for the specified pagination cookie.
	Count *int64 `json:"count,omitempty"`
}

// UnmarshalObjectsSearchResponseBody unmarshals an instance of ObjectsSearchResponseBody from the specified map of raw messages.
func UnmarshalObjectsSearchResponseBody(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectsSearchResponseBody)
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalSearchObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "paginationCookie", &obj.PaginationCookie)
	if err != nil {
		err = core.SDKErrorf(err, "", "paginationCookie-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		err = core.SDKErrorf(err, "", "count-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OnpremDeployParams : Specifies the details about OnpremDeploy target where backup snapshots may be converted and deployed.
type OnpremDeployParams struct {
	// Specifies the unique id of the onprem entity.
	ID *int64 `json:"id,omitempty"`
}

// UnmarshalOnpremDeployParams unmarshals an instance of OnpremDeployParams from the specified map of raw messages.
func UnmarshalOnpremDeployParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OnpremDeployParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OnpremDeployTargetConfiguration : Specifies the details about OnpremDeploy for snapshots.
type OnpremDeployTargetConfiguration struct {
	// Specifies a schedule fregquency and schedule unit for copying Snapshots to backup targets.
	Schedule *TargetSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`

	// Specifies if Snapshots are copied from the first completely successful Protection Group Run or the first partially
	// successful Protection Group Run occurring at the start of the replication schedule. <br> If true, Snapshots are
	// copied from the first Protection Group Run occurring at the start of the replication schedule that was completely
	// successful i.e. Snapshots for all the Objects in the Protection Group were successfully captured. <br> If false,
	// Snapshots are copied from the first Protection Group Run occurring at the start of the replication schedule, even if
	// first Protection Group Run was not completely successful i.e. Snapshots were not captured for all Objects in the
	// Protection Group.
	CopyOnRunSuccess *bool `json:"copyOnRunSuccess,omitempty"`

	// Specifies the unique identifier for the target getting added. This field need to be passed only when policies are
	// being updated.
	ConfigID *string `json:"configId,omitempty"`

	// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
	// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
	// be set to Full.
	BackupRunType *string `json:"backupRunType,omitempty"`

	// Specifies the replication/archival timeouts for different type of runs(kFull, kRegular etc.).
	RunTimeouts []CancellationTimeoutParams `json:"runTimeouts,omitempty"`

	// Specifies the retention of a backup.
	LogRetention *LogRetention `json:"logRetention,omitempty"`

	// Specifies the details about OnpremDeploy target where backup snapshots may be converted and deployed.
	Params *OnpremDeployParams `json:"params,omitempty"`
}

// Constants associated with the OnpremDeployTargetConfiguration.BackupRunType property.
// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
// be set to Full.
const (
	OnpremDeployTargetConfiguration_BackupRunType_Full                 = "Full"
	OnpremDeployTargetConfiguration_BackupRunType_Log                  = "Log"
	OnpremDeployTargetConfiguration_BackupRunType_Regular              = "Regular"
	OnpremDeployTargetConfiguration_BackupRunType_Storagearraysnapshot = "StorageArraySnapshot"
	OnpremDeployTargetConfiguration_BackupRunType_System               = "System"
)

// NewOnpremDeployTargetConfiguration : Instantiate OnpremDeployTargetConfiguration (Generic Model Constructor)
func (*BackupRecoveryV1) NewOnpremDeployTargetConfiguration(schedule *TargetSchedule, retention *Retention) (_model *OnpremDeployTargetConfiguration, err error) {
	_model = &OnpremDeployTargetConfiguration{
		Schedule:  schedule,
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalOnpremDeployTargetConfiguration unmarshals an instance of OnpremDeployTargetConfiguration from the specified map of raw messages.
func UnmarshalOnpremDeployTargetConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OnpremDeployTargetConfiguration)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalTargetSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "copyOnRunSuccess", &obj.CopyOnRunSuccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "copyOnRunSuccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupRunType", &obj.BackupRunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "runTimeouts", &obj.RunTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "runTimeouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "logRetention", &obj.LogRetention, UnmarshalLogRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "logRetention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalOnpremDeployParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "params-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OracleTier : Specifies the settings for a Oracle tier.
type OracleTier struct {
	// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
	// 'moveAfter' field specified below.
	MoveAfterUnit *string `json:"moveAfterUnit,omitempty"`

	// Specifies the time period after which the backup will be moved from current tier to next tier.
	MoveAfter *int64 `json:"moveAfter,omitempty"`

	// Specifies the Oracle tier types.
	TierType *string `json:"tierType" validate:"required"`
}

// Constants associated with the OracleTier.MoveAfterUnit property.
// Specifies the unit for moving the data from current tier to next tier. This unit will be a base unit for the
// 'moveAfter' field specified below.
const (
	OracleTier_MoveAfterUnit_Days   = "Days"
	OracleTier_MoveAfterUnit_Months = "Months"
	OracleTier_MoveAfterUnit_Weeks  = "Weeks"
	OracleTier_MoveAfterUnit_Years  = "Years"
)

// Constants associated with the OracleTier.TierType property.
// Specifies the Oracle tier types.
const (
	OracleTier_TierType_Koracletierarchive  = "kOracleTierArchive"
	OracleTier_TierType_Koracletierstandard = "kOracleTierStandard"
)

// NewOracleTier : Instantiate OracleTier (Generic Model Constructor)
func (*BackupRecoveryV1) NewOracleTier(tierType string) (_model *OracleTier, err error) {
	_model = &OracleTier{
		TierType: core.StringPtr(tierType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalOracleTier unmarshals an instance of OracleTier from the specified map of raw messages.
func UnmarshalOracleTier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OracleTier)
	err = core.UnmarshalPrimitive(m, "moveAfterUnit", &obj.MoveAfterUnit)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfterUnit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "moveAfter", &obj.MoveAfter)
	if err != nil {
		err = core.SDKErrorf(err, "", "moveAfter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tierType", &obj.TierType)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OracleTiers : Specifies Oracle tiers.
type OracleTiers struct {
	// Specifies the tiers that are used to move the archived backup from current tier to next tier. The order of the tiers
	// determines which tier will be used next for moving the archived backup. The first tier input should always be
	// default tier where backup will be acrhived. Each tier specifies how much time after the backup will be moved to next
	// tier from the current tier.
	Tiers []OracleTier `json:"tiers" validate:"required"`
}

// NewOracleTiers : Instantiate OracleTiers (Generic Model Constructor)
func (*BackupRecoveryV1) NewOracleTiers(tiers []OracleTier) (_model *OracleTiers, err error) {
	_model = &OracleTiers{
		Tiers: tiers,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalOracleTiers unmarshals an instance of OracleTiers from the specified map of raw messages.
func UnmarshalOracleTiers(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OracleTiers)
	err = core.UnmarshalModel(m, "tiers", &obj.Tiers, UnmarshalOracleTier)
	if err != nil {
		err = core.SDKErrorf(err, "", "tiers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationParameters : Specifies the cursor based pagination parameters for Protection Source and its children. Pagination is supported at a
// given level within the Protection Source Hierarchy with the help of before or after cursors. A Cursor will always
// refer to a specific source within the source dataset but will be invalidated if the item is removed.
type PaginationParameters struct {
	// Specifies the entity id starting from which the items are to be returned.
	AfterCursorEntityID *int64 `json:"afterCursorEntityId,omitempty"`

	// Specifies the entity id upto which the items are to be returned.
	BeforeCursorEntityID *int64 `json:"beforeCursorEntityId,omitempty"`

	// Specifies the entity id for the Node at any level within the Source entity hierarchy whose children are to be
	// paginated.
	NodeID *int64 `json:"nodeId,omitempty"`

	// Specifies the maximum number of entities to be returned within the page.
	PageSize *int64 `json:"pageSize,omitempty"`
}

// UnmarshalPaginationParameters unmarshals an instance of PaginationParameters from the specified map of raw messages.
func UnmarshalPaginationParameters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationParameters)
	err = core.UnmarshalPrimitive(m, "afterCursorEntityId", &obj.AfterCursorEntityID)
	if err != nil {
		err = core.SDKErrorf(err, "", "afterCursorEntityId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "beforeCursorEntityId", &obj.BeforeCursorEntityID)
	if err != nil {
		err = core.SDKErrorf(err, "", "beforeCursorEntityId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nodeId", &obj.NodeID)
	if err != nil {
		err = core.SDKErrorf(err, "", "nodeId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "pageSize", &obj.PageSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "pageSize-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PatchDataSourceConnectionOptions : The PatchDataSourceConnection options.
type PatchDataSourceConnectionOptions struct {
	// Specifies the ID of the connection, connectors belonging to which are to be fetched.
	ConnectionID *string `json:"connectionId" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// New name for the connection being patched.
	ConnectionName *string `json:"connectionName" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchDataSourceConnectionOptions : Instantiate PatchDataSourceConnectionOptions
func (*BackupRecoveryV1) NewPatchDataSourceConnectionOptions(connectionID string, xIBMTenantID string, connectionName string) *PatchDataSourceConnectionOptions {
	return &PatchDataSourceConnectionOptions{
		ConnectionID:   core.StringPtr(connectionID),
		XIBMTenantID:   core.StringPtr(xIBMTenantID),
		ConnectionName: core.StringPtr(connectionName),
	}
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *PatchDataSourceConnectionOptions) SetConnectionID(connectionID string) *PatchDataSourceConnectionOptions {
	_options.ConnectionID = core.StringPtr(connectionID)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *PatchDataSourceConnectionOptions) SetXIBMTenantID(xIBMTenantID string) *PatchDataSourceConnectionOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetConnectionName : Allow user to set ConnectionName
func (_options *PatchDataSourceConnectionOptions) SetConnectionName(connectionName string) *PatchDataSourceConnectionOptions {
	_options.ConnectionName = core.StringPtr(connectionName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PatchDataSourceConnectionOptions) SetHeaders(param map[string]string) *PatchDataSourceConnectionOptions {
	options.Headers = param
	return options
}

// PatchDataSourceConnectorOptions : The PatchDataSourceConnector options.
type PatchDataSourceConnectorOptions struct {
	// Specifies the unique ID of the connector which is to be deleted.
	ConnectorID *string `json:"connectorId" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Name of the connector.
	ConnectorName *string `json:"connectorName,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchDataSourceConnectorOptions : Instantiate PatchDataSourceConnectorOptions
func (*BackupRecoveryV1) NewPatchDataSourceConnectorOptions(connectorID string, xIBMTenantID string) *PatchDataSourceConnectorOptions {
	return &PatchDataSourceConnectorOptions{
		ConnectorID:  core.StringPtr(connectorID),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetConnectorID : Allow user to set ConnectorID
func (_options *PatchDataSourceConnectorOptions) SetConnectorID(connectorID string) *PatchDataSourceConnectorOptions {
	_options.ConnectorID = core.StringPtr(connectorID)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *PatchDataSourceConnectorOptions) SetXIBMTenantID(xIBMTenantID string) *PatchDataSourceConnectorOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetConnectorName : Allow user to set ConnectorName
func (_options *PatchDataSourceConnectorOptions) SetConnectorName(connectorName string) *PatchDataSourceConnectorOptions {
	_options.ConnectorName = core.StringPtr(connectorName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PatchDataSourceConnectorOptions) SetHeaders(param map[string]string) *PatchDataSourceConnectorOptions {
	options.Headers = param
	return options
}

// PatchProtectionSourceRegistrationOptions : The PatchProtectionSourceRegistration options.
type PatchProtectionSourceRegistrationOptions struct {
	// Specifies the id of the Protection Source registration.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the environment type of the Protection Source to be patched. Currently the only environment supported is
	// kCassandra.
	Environment *string `json:"environment" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PatchProtectionSourceRegistrationOptions.Environment property.
// Specifies the environment type of the Protection Source to be patched. Currently the only environment supported is
// kCassandra.
const (
	PatchProtectionSourceRegistrationOptions_Environment_Kphysical = "kPhysical"
	PatchProtectionSourceRegistrationOptions_Environment_Ksql      = "kSQL"
)

// NewPatchProtectionSourceRegistrationOptions : Instantiate PatchProtectionSourceRegistrationOptions
func (*BackupRecoveryV1) NewPatchProtectionSourceRegistrationOptions(id int64, xIBMTenantID string, environment string) *PatchProtectionSourceRegistrationOptions {
	return &PatchProtectionSourceRegistrationOptions{
		ID:           core.Int64Ptr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Environment:  core.StringPtr(environment),
	}
}

// SetID : Allow user to set ID
func (_options *PatchProtectionSourceRegistrationOptions) SetID(id int64) *PatchProtectionSourceRegistrationOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *PatchProtectionSourceRegistrationOptions) SetXIBMTenantID(xIBMTenantID string) *PatchProtectionSourceRegistrationOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetEnvironment : Allow user to set Environment
func (_options *PatchProtectionSourceRegistrationOptions) SetEnvironment(environment string) *PatchProtectionSourceRegistrationOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PatchProtectionSourceRegistrationOptions) SetHeaders(param map[string]string) *PatchProtectionSourceRegistrationOptions {
	options.Headers = param
	return options
}

// PauseProtectionRunActionParams : Specifies the request to pause a protection run.
type PauseProtectionRunActionParams struct {
	// Specifies a unique run id of the Protection Group run.
	RunID *string `json:"runId" validate:"required"`
}

// NewPauseProtectionRunActionParams : Instantiate PauseProtectionRunActionParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPauseProtectionRunActionParams(runID string) (_model *PauseProtectionRunActionParams, err error) {
	_model = &PauseProtectionRunActionParams{
		RunID: core.StringPtr(runID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPauseProtectionRunActionParams unmarshals an instance of PauseProtectionRunActionParams from the specified map of raw messages.
func UnmarshalPauseProtectionRunActionParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PauseProtectionRunActionParams)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PauseProtectionRunActionResponseParams : Specifies the response of a pause action on protection runs.
type PauseProtectionRunActionResponseParams struct {
	// Specifies a unique run id of the Protection Group run.
	RunID *string `json:"runId,omitempty"`

	// Specifies an error occured when perfroming pause of a protection run.
	Error *string `json:"error,omitempty"`
}

// UnmarshalPauseProtectionRunActionResponseParams unmarshals an instance of PauseProtectionRunActionResponseParams from the specified map of raw messages.
func UnmarshalPauseProtectionRunActionResponseParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PauseProtectionRunActionResponseParams)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "error", &obj.Error)
	if err != nil {
		err = core.SDKErrorf(err, "", "error-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PerformActionOnProtectionGroupRunOptions : The PerformActionOnProtectionGroupRun options.
type PerformActionOnProtectionGroupRunOptions struct {
	// Specifies a unique id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of the action which will be performed on protection runs.
	Action *string `json:"action" validate:"required"`

	// Specifies the pause action params for a protection run.
	PauseParams []PauseProtectionRunActionParams `json:"pauseParams,omitempty"`

	// Specifies the resume action params for a protection run.
	ResumeParams []ResumeProtectionRunActionParams `json:"resumeParams,omitempty"`

	// Specifies the cancel action params for a protection run.
	CancelParams []CancelProtectionGroupRunRequest `json:"cancelParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PerformActionOnProtectionGroupRunOptions.Action property.
// Specifies the type of the action which will be performed on protection runs.
const (
	PerformActionOnProtectionGroupRunOptions_Action_Cancel = "Cancel"
	PerformActionOnProtectionGroupRunOptions_Action_Pause  = "Pause"
	PerformActionOnProtectionGroupRunOptions_Action_Resume = "Resume"
)

// NewPerformActionOnProtectionGroupRunOptions : Instantiate PerformActionOnProtectionGroupRunOptions
func (*BackupRecoveryV1) NewPerformActionOnProtectionGroupRunOptions(id string, xIBMTenantID string, action string) *PerformActionOnProtectionGroupRunOptions {
	return &PerformActionOnProtectionGroupRunOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Action:       core.StringPtr(action),
	}
}

// SetID : Allow user to set ID
func (_options *PerformActionOnProtectionGroupRunOptions) SetID(id string) *PerformActionOnProtectionGroupRunOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *PerformActionOnProtectionGroupRunOptions) SetXIBMTenantID(xIBMTenantID string) *PerformActionOnProtectionGroupRunOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *PerformActionOnProtectionGroupRunOptions) SetAction(action string) *PerformActionOnProtectionGroupRunOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPauseParams : Allow user to set PauseParams
func (_options *PerformActionOnProtectionGroupRunOptions) SetPauseParams(pauseParams []PauseProtectionRunActionParams) *PerformActionOnProtectionGroupRunOptions {
	_options.PauseParams = pauseParams
	return _options
}

// SetResumeParams : Allow user to set ResumeParams
func (_options *PerformActionOnProtectionGroupRunOptions) SetResumeParams(resumeParams []ResumeProtectionRunActionParams) *PerformActionOnProtectionGroupRunOptions {
	_options.ResumeParams = resumeParams
	return _options
}

// SetCancelParams : Allow user to set CancelParams
func (_options *PerformActionOnProtectionGroupRunOptions) SetCancelParams(cancelParams []CancelProtectionGroupRunRequest) *PerformActionOnProtectionGroupRunOptions {
	_options.CancelParams = cancelParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PerformActionOnProtectionGroupRunOptions) SetHeaders(param map[string]string) *PerformActionOnProtectionGroupRunOptions {
	options.Headers = param
	return options
}

// PerformRunActionResponse : Specifies the response of the performed run action.
type PerformRunActionResponse struct {
	// Specifies the type of the action is performed on protection runs.
	Action *string `json:"action,omitempty"`

	// Specifies the pause action response params.
	PauseParams []PauseProtectionRunActionResponseParams `json:"pauseParams,omitempty"`

	// Specifies the resume action response params.
	ResumeParams []ResumeProtectionRunActionResponseParams `json:"resumeParams,omitempty"`

	// Specifies the cancel action response params.
	CancelParams []CancelProtectionGroupRunResponseParams `json:"cancelParams,omitempty"`
}

// Constants associated with the PerformRunActionResponse.Action property.
// Specifies the type of the action is performed on protection runs.
const (
	PerformRunActionResponse_Action_Cancel = "Cancel"
	PerformRunActionResponse_Action_Pause  = "Pause"
	PerformRunActionResponse_Action_Resume = "Resume"
)

// UnmarshalPerformRunActionResponse unmarshals an instance of PerformRunActionResponse from the specified map of raw messages.
func UnmarshalPerformRunActionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PerformRunActionResponse)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "pauseParams", &obj.PauseParams, UnmarshalPauseProtectionRunActionResponseParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "pauseParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resumeParams", &obj.ResumeParams, UnmarshalResumeProtectionRunActionResponseParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "resumeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cancelParams", &obj.CancelParams, UnmarshalCancelProtectionGroupRunResponseParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "cancelParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PermissionInfo : Specifies the list of users, groups and users that have permissions for a given object.
type PermissionInfo struct {
	// Specifies the id of the object.
	ObjectID *int64 `json:"objectId,omitempty"`

	// Specifies the list of users which has the permissions to the object.
	Users []User `json:"users,omitempty"`

	// Specifies the list of user groups which has permissions to the object.
	Groups []Group `json:"groups,omitempty"`

	// Specifies a tenant object.
	Tenant *Tenant `json:"tenant,omitempty"`
}

// UnmarshalPermissionInfo unmarshals an instance of PermissionInfo from the specified map of raw messages.
func UnmarshalPermissionInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PermissionInfo)
	err = core.UnmarshalPrimitive(m, "objectId", &obj.ObjectID)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "users", &obj.Users, UnmarshalUser)
	if err != nil {
		err = core.SDKErrorf(err, "", "users-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "groups", &obj.Groups, UnmarshalGroup)
	if err != nil {
		err = core.SDKErrorf(err, "", "groups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tenant", &obj.Tenant, UnmarshalTenant)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenant-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalFileBackupPathParams : PhysicalFileBackupPathParams struct
type PhysicalFileBackupPathParams struct {
	// Specifies a path to be included on the source. All paths under this path will be included unless they are
	// specifically mentioned in excluded paths.
	IncludedPath *string `json:"includedPath" validate:"required"`

	// Specifies a set of paths nested under the include path which should be excluded from the Protection Group.
	ExcludedPaths []string `json:"excludedPaths,omitempty"`

	// Specifies whether to skip any nested volumes (both local and network) that are mounted under include path.
	// Applicable only for windows sources.
	SkipNestedVolumes *bool `json:"skipNestedVolumes,omitempty"`
}

// NewPhysicalFileBackupPathParams : Instantiate PhysicalFileBackupPathParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalFileBackupPathParams(includedPath string) (_model *PhysicalFileBackupPathParams, err error) {
	_model = &PhysicalFileBackupPathParams{
		IncludedPath: core.StringPtr(includedPath),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalFileBackupPathParams unmarshals an instance of PhysicalFileBackupPathParams from the specified map of raw messages.
func UnmarshalPhysicalFileBackupPathParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalFileBackupPathParams)
	err = core.UnmarshalPrimitive(m, "includedPath", &obj.IncludedPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "includedPath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "excludedPaths", &obj.ExcludedPaths)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludedPaths-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "skipNestedVolumes", &obj.SkipNestedVolumes)
	if err != nil {
		err = core.SDKErrorf(err, "", "skipNestedVolumes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalFileProtectionGroupObjectParams : PhysicalFileProtectionGroupObjectParams struct
type PhysicalFileProtectionGroupObjectParams struct {
	// Specifies writer names which should be excluded from physical file based backups.
	ExcludedVssWriters []string `json:"excludedVssWriters,omitempty"`

	// Specifies the ID of the object protected.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies a list of file paths to be protected by this Protection Group.
	FilePaths []PhysicalFileBackupPathParams `json:"filePaths,omitempty"`

	// Specifies whether path level or object level skip nested volume setting will be used.
	UsesPathLevelSkipNestedVolumeSetting *bool `json:"usesPathLevelSkipNestedVolumeSetting,omitempty"`

	// Specifies mount types of nested volumes to be skipped.
	NestedVolumeTypesToSkip []string `json:"nestedVolumeTypesToSkip,omitempty"`

	// Specifies whether to follow NAS target pointed by symlink for windows sources.
	FollowNasSymlinkTarget *bool `json:"followNasSymlinkTarget,omitempty"`

	// Specifies the path of metadatafile on source. This file contains absolute paths of files that needs to be backed up
	// on the same source.
	MetadataFilePath *string `json:"metadataFilePath,omitempty"`
}

// NewPhysicalFileProtectionGroupObjectParams : Instantiate PhysicalFileProtectionGroupObjectParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalFileProtectionGroupObjectParams(id int64) (_model *PhysicalFileProtectionGroupObjectParams, err error) {
	_model = &PhysicalFileProtectionGroupObjectParams{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalFileProtectionGroupObjectParams unmarshals an instance of PhysicalFileProtectionGroupObjectParams from the specified map of raw messages.
func UnmarshalPhysicalFileProtectionGroupObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalFileProtectionGroupObjectParams)
	err = core.UnmarshalPrimitive(m, "excludedVssWriters", &obj.ExcludedVssWriters)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludedVssWriters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "filePaths", &obj.FilePaths, UnmarshalPhysicalFileBackupPathParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "filePaths-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "usesPathLevelSkipNestedVolumeSetting", &obj.UsesPathLevelSkipNestedVolumeSetting)
	if err != nil {
		err = core.SDKErrorf(err, "", "usesPathLevelSkipNestedVolumeSetting-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nestedVolumeTypesToSkip", &obj.NestedVolumeTypesToSkip)
	if err != nil {
		err = core.SDKErrorf(err, "", "nestedVolumeTypesToSkip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "followNasSymlinkTarget", &obj.FollowNasSymlinkTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "followNasSymlinkTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metadataFilePath", &obj.MetadataFilePath)
	if err != nil {
		err = core.SDKErrorf(err, "", "metadataFilePath-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalFileProtectionGroupParams : Specifies the parameters which are specific to Physical related Protection Groups.
type PhysicalFileProtectionGroupParams struct {
	// Specifies writer names which should be excluded from physical file based backups.
	ExcludedVssWriters []string `json:"excludedVssWriters,omitempty"`

	// Specifies the list of objects protected by this Protection Group.
	Objects []PhysicalFileProtectionGroupObjectParams `json:"objects" validate:"required"`

	// Specifies settings for indexing files found in an Object (such as a VM) so these files can be searched and
	// recovered. This also specifies inclusion and exclusion rules that determine the directories to index.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies whether or not to perform source side deduplication on this Protection Group.
	PerformSourceSideDeduplication *bool `json:"performSourceSideDeduplication,omitempty"`

	// Specifies whether or not to perform brick based deduplication on this Protection Group.
	PerformBrickBasedDeduplication *bool `json:"performBrickBasedDeduplication,omitempty"`

	// Specifies the timeouts for all the objects inside this Protection Group, for both full and incremental backups.
	TaskTimeouts []CancellationTimeoutParams `json:"taskTimeouts,omitempty"`

	// Specifies Whether to take app-consistent snapshots by quiescing apps and the filesystem before taking a backup.
	Quiesce *bool `json:"quiesce,omitempty"`

	// Specifies whether to continue backing up on quiesce failure.
	ContinueOnQuiesceFailure *bool `json:"continueOnQuiesceFailure,omitempty"`

	// Specifies whether to take CoBMR backup.
	CobmrBackup *bool `json:"cobmrBackup,omitempty"`

	// Specifies the params for pre and post scripts.
	PrePostScript *PrePostScriptParams `json:"prePostScript,omitempty"`

	// Specifies ids of sources for which deduplication has to be disabled.
	DedupExclusionSourceIds []int64 `json:"dedupExclusionSourceIds,omitempty"`

	// Specifies global exclude filters which are applied to all sources in a job.
	GlobalExcludePaths []string `json:"globalExcludePaths,omitempty"`

	// Specifies global exclude filesystems which are applied to all sources in a job.
	GlobalExcludeFS []string `json:"globalExcludeFS,omitempty"`

	// Specifies the Errors to be ignored in error db.
	IgnorableErrors []string `json:"ignorableErrors,omitempty"`

	// Specifies whether or not this job can have parallel runs.
	AllowParallelRuns *bool `json:"allowParallelRuns,omitempty"`
}

// Constants associated with the PhysicalFileProtectionGroupParams.IgnorableErrors property.
const (
	PhysicalFileProtectionGroupParams_IgnorableErrors_Keof         = "kEOF"
	PhysicalFileProtectionGroupParams_IgnorableErrors_Knonexistent = "kNonExistent"
)

// NewPhysicalFileProtectionGroupParams : Instantiate PhysicalFileProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalFileProtectionGroupParams(objects []PhysicalFileProtectionGroupObjectParams) (_model *PhysicalFileProtectionGroupParams, err error) {
	_model = &PhysicalFileProtectionGroupParams{
		Objects: objects,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalFileProtectionGroupParams unmarshals an instance of PhysicalFileProtectionGroupParams from the specified map of raw messages.
func UnmarshalPhysicalFileProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalFileProtectionGroupParams)
	err = core.UnmarshalPrimitive(m, "excludedVssWriters", &obj.ExcludedVssWriters)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludedVssWriters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalPhysicalFileProtectionGroupObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "indexingPolicy", &obj.IndexingPolicy, UnmarshalIndexingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "performSourceSideDeduplication", &obj.PerformSourceSideDeduplication)
	if err != nil {
		err = core.SDKErrorf(err, "", "performSourceSideDeduplication-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "performBrickBasedDeduplication", &obj.PerformBrickBasedDeduplication)
	if err != nil {
		err = core.SDKErrorf(err, "", "performBrickBasedDeduplication-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "taskTimeouts", &obj.TaskTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskTimeouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "quiesce", &obj.Quiesce)
	if err != nil {
		err = core.SDKErrorf(err, "", "quiesce-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "continueOnQuiesceFailure", &obj.ContinueOnQuiesceFailure)
	if err != nil {
		err = core.SDKErrorf(err, "", "continueOnQuiesceFailure-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cobmrBackup", &obj.CobmrBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "cobmrBackup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prePostScript", &obj.PrePostScript, UnmarshalPrePostScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "prePostScript-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dedupExclusionSourceIds", &obj.DedupExclusionSourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "dedupExclusionSourceIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalExcludePaths", &obj.GlobalExcludePaths)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalExcludePaths-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalExcludeFS", &obj.GlobalExcludeFS)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalExcludeFS-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ignorableErrors", &obj.IgnorableErrors)
	if err != nil {
		err = core.SDKErrorf(err, "", "ignorableErrors-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "allowParallelRuns", &obj.AllowParallelRuns)
	if err != nil {
		err = core.SDKErrorf(err, "", "allowParallelRuns-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalMountVolumesNewTargetConfigServerCredentials : Specifies credentials to access the target server. This is required if the server is of Linux OS.
type PhysicalMountVolumesNewTargetConfigServerCredentials struct {
	// Specifies the username to access target entity.
	Username *string `json:"username" validate:"required"`

	// Specifies the password to access target entity.
	Password *string `json:"password" validate:"required"`
}

// NewPhysicalMountVolumesNewTargetConfigServerCredentials : Instantiate PhysicalMountVolumesNewTargetConfigServerCredentials (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalMountVolumesNewTargetConfigServerCredentials(username string, password string) (_model *PhysicalMountVolumesNewTargetConfigServerCredentials, err error) {
	_model = &PhysicalMountVolumesNewTargetConfigServerCredentials{
		Username: core.StringPtr(username),
		Password: core.StringPtr(password),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalMountVolumesNewTargetConfigServerCredentials unmarshals an instance of PhysicalMountVolumesNewTargetConfigServerCredentials from the specified map of raw messages.
func UnmarshalPhysicalMountVolumesNewTargetConfigServerCredentials(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalMountVolumesNewTargetConfigServerCredentials)
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		err = core.SDKErrorf(err, "", "username-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		err = core.SDKErrorf(err, "", "password-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalMountVolumesOriginalTargetConfigServerCredentials : Specifies credentials to access the target server. This is required if the server is of Linux OS.
type PhysicalMountVolumesOriginalTargetConfigServerCredentials struct {
	// Specifies the username to access target entity.
	Username *string `json:"username" validate:"required"`

	// Specifies the password to access target entity.
	Password *string `json:"password" validate:"required"`
}

// NewPhysicalMountVolumesOriginalTargetConfigServerCredentials : Instantiate PhysicalMountVolumesOriginalTargetConfigServerCredentials (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalMountVolumesOriginalTargetConfigServerCredentials(username string, password string) (_model *PhysicalMountVolumesOriginalTargetConfigServerCredentials, err error) {
	_model = &PhysicalMountVolumesOriginalTargetConfigServerCredentials{
		Username: core.StringPtr(username),
		Password: core.StringPtr(password),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalMountVolumesOriginalTargetConfigServerCredentials unmarshals an instance of PhysicalMountVolumesOriginalTargetConfigServerCredentials from the specified map of raw messages.
func UnmarshalPhysicalMountVolumesOriginalTargetConfigServerCredentials(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalMountVolumesOriginalTargetConfigServerCredentials)
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		err = core.SDKErrorf(err, "", "username-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		err = core.SDKErrorf(err, "", "password-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalProtectionGroupParams : PhysicalProtectionGroupParams struct
type PhysicalProtectionGroupParams struct {
	// Specifies the Physical Protection Group type.
	ProtectionType *string `json:"protectionType" validate:"required"`

	// Specifies the parameters which are specific to Volume based physical Protection Groups.
	VolumeProtectionTypeParams *PhysicalVolumeProtectionGroupParams `json:"volumeProtectionTypeParams,omitempty"`

	// Specifies the parameters which are specific to Physical related Protection Groups.
	FileProtectionTypeParams *PhysicalFileProtectionGroupParams `json:"fileProtectionTypeParams,omitempty"`
}

// Constants associated with the PhysicalProtectionGroupParams.ProtectionType property.
// Specifies the Physical Protection Group type.
const (
	PhysicalProtectionGroupParams_ProtectionType_Kfile   = "kFile"
	PhysicalProtectionGroupParams_ProtectionType_Kvolume = "kVolume"
)

// NewPhysicalProtectionGroupParams : Instantiate PhysicalProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalProtectionGroupParams(protectionType string) (_model *PhysicalProtectionGroupParams, err error) {
	_model = &PhysicalProtectionGroupParams{
		ProtectionType: core.StringPtr(protectionType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalProtectionGroupParams unmarshals an instance of PhysicalProtectionGroupParams from the specified map of raw messages.
func UnmarshalPhysicalProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalProtectionGroupParams)
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "volumeProtectionTypeParams", &obj.VolumeProtectionTypeParams, UnmarshalPhysicalVolumeProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeProtectionTypeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "fileProtectionTypeParams", &obj.FileProtectionTypeParams, UnmarshalPhysicalFileProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileProtectionTypeParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalProtectionSource : Specifies a Protection Source in a Physical environment.
type PhysicalProtectionSource struct {
	// Specifiles the agents running on the Physical Protection Source and the status information.
	Agents []AgentInformation `json:"agents,omitempty"`

	// Specifies the type of cluster resource this source represents.
	ClusterSourceType *string `json:"clusterSourceType,omitempty"`

	// Specifies the hostname.
	HostName *string `json:"hostName,omitempty"`

	// Specifies the environment type for the host.
	HostType *string `json:"hostType,omitempty"`

	// Specifies an id for an object that is unique across Cohesity Clusters. The id is composite of all the ids listed
	// below.
	ID *UniqueGlobalID `json:"id,omitempty"`

	// Specifies if the physical host is a proxy host.
	IsProxyHost *bool `json:"isProxyHost,omitempty"`

	// Specifies the total memory on the host in bytes.
	MemorySizeBytes *int64 `json:"memorySizeBytes,omitempty"`

	// Specifies a human readable name of the Protection Source.
	Name *string `json:"name,omitempty"`

	// Specifies the struct containing information about network addresses configured on the given box. This is needed for
	// dealing with Windows/Oracle Cluster resources that we discover and protect automatically.
	NetworkingInfo *NetworkingInformation `json:"networkingInfo,omitempty"`

	// Specifies the number of processors on the host.
	NumProcessors *int64 `json:"numProcessors,omitempty"`

	// Specifies a human readable name of the OS of the Protection Source.
	OsName *string `json:"osName,omitempty"`

	// Specifies the type of managed Object in a Physical Protection Source. 'kGroup' indicates the EH container.
	Type *string `json:"type,omitempty"`

	// Specifies cluster version for VCS host.
	VcsVersion *string `json:"vcsVersion,omitempty"`

	// Array of Physical Volumes. Specifies the volumes available on the physical host. These fields are populated only for
	// the kPhysicalHost type.
	Volumes []PhysicalVolume `json:"volumes,omitempty"`

	Vsswriters []VssWriters `json:"vsswriters,omitempty"`
}

// Constants associated with the PhysicalProtectionSource.HostType property.
// Specifies the environment type for the host.
const (
	PhysicalProtectionSource_HostType_Kaix         = "kAix"
	PhysicalProtectionSource_HostType_Kcockroachdb = "kCockroachDB"
	PhysicalProtectionSource_HostType_Kdb2         = "kDB2"
	PhysicalProtectionSource_HostType_Khpux        = "kHPUX"
	PhysicalProtectionSource_HostType_Klinux       = "kLinux"
	PhysicalProtectionSource_HostType_Kmariadb     = "kMariaDB"
	PhysicalProtectionSource_HostType_Kmysql       = "kMySQL"
	PhysicalProtectionSource_HostType_Kother       = "kOther"
	PhysicalProtectionSource_HostType_Kpostgresql  = "kPostgreSQL"
	PhysicalProtectionSource_HostType_Ksapase      = "kSapASE"
	PhysicalProtectionSource_HostType_Ksaphana     = "kSapHana"
	PhysicalProtectionSource_HostType_Ksapmaxdb    = "kSapMaxDB"
	PhysicalProtectionSource_HostType_Ksaporacle   = "kSapOracle"
	PhysicalProtectionSource_HostType_Ksapsybase   = "kSapSybase"
	PhysicalProtectionSource_HostType_Ksapsybaseiq = "kSapSybaseIQ"
	PhysicalProtectionSource_HostType_Ksolaris     = "kSolaris"
	PhysicalProtectionSource_HostType_Kvos         = "kVOS"
	PhysicalProtectionSource_HostType_Kwindows     = "kWindows"
)

// Constants associated with the PhysicalProtectionSource.Type property.
// Specifies the type of managed Object in a Physical Protection Source. 'kGroup' indicates the EH container.
const (
	PhysicalProtectionSource_Type_Kgroup            = "kGroup"
	PhysicalProtectionSource_Type_Khost             = "kHost"
	PhysicalProtectionSource_Type_Koracleapcluster  = "kOracleAPCluster"
	PhysicalProtectionSource_Type_Koracleraccluster = "kOracleRACCluster"
	PhysicalProtectionSource_Type_Kwindowscluster   = "kWindowsCluster"
)

// UnmarshalPhysicalProtectionSource unmarshals an instance of PhysicalProtectionSource from the specified map of raw messages.
func UnmarshalPhysicalProtectionSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalProtectionSource)
	err = core.UnmarshalModel(m, "agents", &obj.Agents, UnmarshalAgentInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "agents-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterSourceType", &obj.ClusterSourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterSourceType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostName", &obj.HostName)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostType", &obj.HostType)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "id", &obj.ID, UnmarshalUniqueGlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isProxyHost", &obj.IsProxyHost)
	if err != nil {
		err = core.SDKErrorf(err, "", "isProxyHost-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "memorySizeBytes", &obj.MemorySizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "memorySizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "networkingInfo", &obj.NetworkingInfo, UnmarshalNetworkingInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "networkingInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "numProcessors", &obj.NumProcessors)
	if err != nil {
		err = core.SDKErrorf(err, "", "numProcessors-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osName", &obj.OsName)
	if err != nil {
		err = core.SDKErrorf(err, "", "osName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vcsVersion", &obj.VcsVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "vcsVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalPhysicalVolume)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vsswriters", &obj.Vsswriters, UnmarshalVssWriters)
	if err != nil {
		err = core.SDKErrorf(err, "", "vsswriters-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalSnapshotParams : Specifies parameters of Physical type snapshots.
type PhysicalSnapshotParams struct {
	// Specifies if system backup was enabled for the source in that particular run.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`

	// Specifies the protection type of Physical snapshots.
	ProtectionType *string `json:"protectionType,omitempty"`
}

// Constants associated with the PhysicalSnapshotParams.ProtectionType property.
// Specifies the protection type of Physical snapshots.
const (
	PhysicalSnapshotParams_ProtectionType_Kfile   = "kFile"
	PhysicalSnapshotParams_ProtectionType_Kvolume = "kVolume"
)

// UnmarshalPhysicalSnapshotParams unmarshals an instance of PhysicalSnapshotParams from the specified map of raw messages.
func UnmarshalPhysicalSnapshotParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalSnapshotParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalSourceRegistrationParams : Specifies parameters to register physical server.
type PhysicalSourceRegistrationParams struct {
	// Specifies the endpoint IPaddress, URL or hostname of the physical host.
	Endpoint *string `json:"endpoint" validate:"required"`

	// The agent running on a physical host will fail the registration if it is already registered as part of another
	// cluster. By setting this option to true, agent can be forced to register with the current cluster.
	ForceRegister *bool `json:"forceRegister,omitempty"`

	// Specifies the type of host.
	HostType *string `json:"hostType,omitempty"`

	// Specifies the type of physical server.
	PhysicalType *string `json:"physicalType,omitempty"`

	// Specifies the list of applications to be registered with Physical Source.
	Applications []string `json:"applications,omitempty"`
}

// Constants associated with the PhysicalSourceRegistrationParams.HostType property.
// Specifies the type of host.
const (
	PhysicalSourceRegistrationParams_HostType_Klinux   = "kLinux"
	PhysicalSourceRegistrationParams_HostType_Kwindows = "kWindows"
)

// Constants associated with the PhysicalSourceRegistrationParams.PhysicalType property.
// Specifies the type of physical server.
const (
	PhysicalSourceRegistrationParams_PhysicalType_Kgroup            = "kGroup"
	PhysicalSourceRegistrationParams_PhysicalType_Khost             = "kHost"
	PhysicalSourceRegistrationParams_PhysicalType_Koracleapcluster  = "kOracleAPCluster"
	PhysicalSourceRegistrationParams_PhysicalType_Koracleraccluster = "kOracleRACCluster"
	PhysicalSourceRegistrationParams_PhysicalType_Kunixcluster      = "kUnixCluster"
	PhysicalSourceRegistrationParams_PhysicalType_Kwindowscluster   = "kWindowsCluster"
)

// Constants associated with the PhysicalSourceRegistrationParams.Applications property.
const (
	PhysicalSourceRegistrationParams_Applications_Koracle = "kOracle"
	PhysicalSourceRegistrationParams_Applications_Ksql    = "kSQL"
)

// NewPhysicalSourceRegistrationParams : Instantiate PhysicalSourceRegistrationParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalSourceRegistrationParams(endpoint string) (_model *PhysicalSourceRegistrationParams, err error) {
	_model = &PhysicalSourceRegistrationParams{
		Endpoint: core.StringPtr(endpoint),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalSourceRegistrationParams unmarshals an instance of PhysicalSourceRegistrationParams from the specified map of raw messages.
func UnmarshalPhysicalSourceRegistrationParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalSourceRegistrationParams)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		err = core.SDKErrorf(err, "", "endpoint-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "forceRegister", &obj.ForceRegister)
	if err != nil {
		err = core.SDKErrorf(err, "", "forceRegister-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostType", &obj.HostType)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "physicalType", &obj.PhysicalType)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "applications", &obj.Applications)
	if err != nil {
		err = core.SDKErrorf(err, "", "applications-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForMountVolumeNewTargetConfig : Specifies the configuration for mounting to a new target.
type PhysicalTargetParamsForMountVolumeNewTargetConfig struct {
	// Specifies the target entity to recover to.
	MountTarget *RecoverTarget `json:"mountTarget" validate:"required"`

	// Specifies credentials to access the target server. This is required if the server is of Linux OS.
	ServerCredentials *PhysicalMountVolumesNewTargetConfigServerCredentials `json:"serverCredentials,omitempty"`
}

// NewPhysicalTargetParamsForMountVolumeNewTargetConfig : Instantiate PhysicalTargetParamsForMountVolumeNewTargetConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalTargetParamsForMountVolumeNewTargetConfig(mountTarget *RecoverTarget) (_model *PhysicalTargetParamsForMountVolumeNewTargetConfig, err error) {
	_model = &PhysicalTargetParamsForMountVolumeNewTargetConfig{
		MountTarget: mountTarget,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalTargetParamsForMountVolumeNewTargetConfig unmarshals an instance of PhysicalTargetParamsForMountVolumeNewTargetConfig from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForMountVolumeNewTargetConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForMountVolumeNewTargetConfig)
	err = core.UnmarshalModel(m, "mountTarget", &obj.MountTarget, UnmarshalRecoverTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "serverCredentials", &obj.ServerCredentials, UnmarshalPhysicalMountVolumesNewTargetConfigServerCredentials)
	if err != nil {
		err = core.SDKErrorf(err, "", "serverCredentials-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForMountVolumeOriginalTargetConfig : Specifies the configuration for mounting to the original target.
type PhysicalTargetParamsForMountVolumeOriginalTargetConfig struct {
	// Specifies credentials to access the target server. This is required if the server is of Linux OS.
	ServerCredentials *PhysicalMountVolumesOriginalTargetConfigServerCredentials `json:"serverCredentials,omitempty"`
}

// UnmarshalPhysicalTargetParamsForMountVolumeOriginalTargetConfig unmarshals an instance of PhysicalTargetParamsForMountVolumeOriginalTargetConfig from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForMountVolumeOriginalTargetConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForMountVolumeOriginalTargetConfig)
	err = core.UnmarshalModel(m, "serverCredentials", &obj.ServerCredentials, UnmarshalPhysicalMountVolumesOriginalTargetConfigServerCredentials)
	if err != nil {
		err = core.SDKErrorf(err, "", "serverCredentials-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForMountVolumeVlanConfig : Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
// automatically selected from one of the below options: a. If VLANs are configured on Cohesity, then the VLAN host/VIP
// will be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on Cohesity,
// then the partition hostname or VIPs will be used for Recovery.
type PhysicalTargetParamsForMountVolumeVlanConfig struct {
	// If this is set, then the Cohesity host name or the IP address associated with this vlan is used for mounting
	// Cohesity's view on the remote host.
	ID *int64 `json:"id,omitempty"`

	// If this is set to true, then even if VLANs are configured on the system, the partition VIPs will be used for the
	// Recovery.
	DisableVlan *bool `json:"disableVlan,omitempty"`

	// Interface group to use for Recovery.
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// UnmarshalPhysicalTargetParamsForMountVolumeVlanConfig unmarshals an instance of PhysicalTargetParamsForMountVolumeVlanConfig from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForMountVolumeVlanConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForMountVolumeVlanConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "disableVlan", &obj.DisableVlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "disableVlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "interfaceName", &obj.InterfaceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "interfaceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget : Specifies the target entity where the volumes are being mounted.
type PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget struct {
	// Specifies the id of the object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the id of the parent source of the target.
	ParentSourceID *int64 `json:"parentSourceId,omitempty"`

	// Specifies the name of the parent source of the target.
	ParentSourceName *string `json:"parentSourceName,omitempty"`
}

// NewPhysicalTargetParamsForRecoverFileAndFolderRecoverTarget : Instantiate PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalTargetParamsForRecoverFileAndFolderRecoverTarget(id int64) (_model *PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget, err error) {
	_model = &PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalTargetParamsForRecoverFileAndFolderRecoverTarget unmarshals an instance of PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForRecoverFileAndFolderRecoverTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentSourceId", &obj.ParentSourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentSourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentSourceName", &obj.ParentSourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentSourceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForRecoverFileAndFolderVlanConfig : Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
// automatically selected from one of the below options: a. If VLANs are configured on Cohesity, then the VLAN host/VIP
// will be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on Cohesity,
// then the partition hostname or VIPs will be used for Recovery.
type PhysicalTargetParamsForRecoverFileAndFolderVlanConfig struct {
	// If this is set, then the Cohesity host name or the IP address associated with this vlan is used for mounting
	// Cohesity's view on the remote host.
	ID *int64 `json:"id,omitempty"`

	// If this is set to true, then even if VLANs are configured on the system, the partition VIPs will be used for the
	// Recovery.
	DisableVlan *bool `json:"disableVlan,omitempty"`

	// Interface group to use for Recovery.
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// UnmarshalPhysicalTargetParamsForRecoverFileAndFolderVlanConfig unmarshals an instance of PhysicalTargetParamsForRecoverFileAndFolderVlanConfig from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForRecoverFileAndFolderVlanConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForRecoverFileAndFolderVlanConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "disableVlan", &obj.DisableVlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "disableVlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "interfaceName", &obj.InterfaceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "interfaceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForRecoverVolumeMountTarget : Specifies the target entity where the volumes are being mounted.
type PhysicalTargetParamsForRecoverVolumeMountTarget struct {
	// Specifies the id of the object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`
}

// NewPhysicalTargetParamsForRecoverVolumeMountTarget : Instantiate PhysicalTargetParamsForRecoverVolumeMountTarget (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalTargetParamsForRecoverVolumeMountTarget(id int64) (_model *PhysicalTargetParamsForRecoverVolumeMountTarget, err error) {
	_model = &PhysicalTargetParamsForRecoverVolumeMountTarget{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalTargetParamsForRecoverVolumeMountTarget unmarshals an instance of PhysicalTargetParamsForRecoverVolumeMountTarget from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForRecoverVolumeMountTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForRecoverVolumeMountTarget)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalTargetParamsForRecoverVolumeVlanConfig : Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
// automatically selected from one of the below options: a. If VLANs are configured on Cohesity, then the VLAN host/VIP
// will be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on Cohesity,
// then the partition hostname or VIPs will be used for Recovery.
type PhysicalTargetParamsForRecoverVolumeVlanConfig struct {
	// If this is set, then the Cohesity host name or the IP address associated with this vlan is used for mounting
	// Cohesity's view on the remote host.
	ID *int64 `json:"id,omitempty"`

	// If this is set to true, then even if VLANs are configured on the system, the partition VIPs will be used for the
	// Recovery.
	DisableVlan *bool `json:"disableVlan,omitempty"`

	// Interface group to use for Recovery.
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// UnmarshalPhysicalTargetParamsForRecoverVolumeVlanConfig unmarshals an instance of PhysicalTargetParamsForRecoverVolumeVlanConfig from the specified map of raw messages.
func UnmarshalPhysicalTargetParamsForRecoverVolumeVlanConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalTargetParamsForRecoverVolumeVlanConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "disableVlan", &obj.DisableVlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "disableVlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "interfaceName", &obj.InterfaceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "interfaceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalVolume : Specifies volume information about a Physical Protection Source.
type PhysicalVolume struct {
	// Specifies the path to the device that hosts the volume locally.
	DevicePath *string `json:"devicePath,omitempty"`

	// Specifies an id for the Physical Volume.
	Guid *string `json:"guid,omitempty"`

	// Specifies whether the volume is boot volume.
	IsBootVolume *bool `json:"isBootVolume,omitempty"`

	// Specifies whether this volume supports extended attributes (like ACLs) when performing file backups.
	IsExtendedAttributesSupported *bool `json:"isExtendedAttributesSupported,omitempty"`

	// Specifies if a volume is protected by a Job.
	IsProtected *bool `json:"isProtected,omitempty"`

	// Specifies whether the volume is shared volume.
	IsSharedVolume *bool `json:"isSharedVolume,omitempty"`

	// Specifies a volume label that can be used for displaying additional identifying information about a volume.
	Label *string `json:"label,omitempty"`

	// Specifies the logical size of the volume in bytes that is not reduced by change-block tracking, compression and
	// deduplication.
	LogicalSizeBytes *float64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the mount points where the volume is mounted, for example- 'C:', '/mnt/foo' etc.
	MountPoints []string `json:"mountPoints,omitempty"`

	// Specifies mount type of volume e.g. nfs, autofs, ext4 etc.
	MountType *string `json:"mountType,omitempty"`

	// Specifies the full path to connect to the network attached volume. For example, (IP or hostname):/path/to/share for
	// NFS volumes).
	NetworkPath *string `json:"networkPath,omitempty"`

	// Specifies the size used by the volume in bytes.
	UsedSizeBytes *float64 `json:"usedSizeBytes,omitempty"`
}

// UnmarshalPhysicalVolume unmarshals an instance of PhysicalVolume from the specified map of raw messages.
func UnmarshalPhysicalVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalVolume)
	err = core.UnmarshalPrimitive(m, "devicePath", &obj.DevicePath)
	if err != nil {
		err = core.SDKErrorf(err, "", "devicePath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "guid", &obj.Guid)
	if err != nil {
		err = core.SDKErrorf(err, "", "guid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isBootVolume", &obj.IsBootVolume)
	if err != nil {
		err = core.SDKErrorf(err, "", "isBootVolume-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isExtendedAttributesSupported", &obj.IsExtendedAttributesSupported)
	if err != nil {
		err = core.SDKErrorf(err, "", "isExtendedAttributesSupported-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isProtected", &obj.IsProtected)
	if err != nil {
		err = core.SDKErrorf(err, "", "isProtected-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isSharedVolume", &obj.IsSharedVolume)
	if err != nil {
		err = core.SDKErrorf(err, "", "isSharedVolume-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		err = core.SDKErrorf(err, "", "label-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mountPoints", &obj.MountPoints)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountPoints-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mountType", &obj.MountType)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "networkPath", &obj.NetworkPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "networkPath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "usedSizeBytes", &obj.UsedSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "usedSizeBytes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalVolumeProtectionGroupObjectParams : Specifies object parameters for creating physical volume Protection Groups.
type PhysicalVolumeProtectionGroupObjectParams struct {
	// Specifies the ID of the object protected.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object protected.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`

	// Specifies the list of GUIDs of volumes protected. If empty, then all volumes will be protected by default.
	VolumeGuids []string `json:"volumeGuids,omitempty"`

	// Specifies whether or not to take a system backup. Applicable only for windows sources.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`

	// Specifies writer names which should be excluded from physical volume based backups for a given source.
	ExcludedVssWriters []string `json:"excludedVssWriters,omitempty"`
}

// NewPhysicalVolumeProtectionGroupObjectParams : Instantiate PhysicalVolumeProtectionGroupObjectParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalVolumeProtectionGroupObjectParams(id int64) (_model *PhysicalVolumeProtectionGroupObjectParams, err error) {
	_model = &PhysicalVolumeProtectionGroupObjectParams{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalVolumeProtectionGroupObjectParams unmarshals an instance of PhysicalVolumeProtectionGroupObjectParams from the specified map of raw messages.
func UnmarshalPhysicalVolumeProtectionGroupObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalVolumeProtectionGroupObjectParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeGuids", &obj.VolumeGuids)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeGuids-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "excludedVssWriters", &obj.ExcludedVssWriters)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludedVssWriters-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PhysicalVolumeProtectionGroupParams : Specifies the parameters which are specific to Volume based physical Protection Groups.
type PhysicalVolumeProtectionGroupParams struct {
	Objects []PhysicalVolumeProtectionGroupObjectParams `json:"objects" validate:"required"`

	// Specifies settings for indexing files found in an Object (such as a VM) so these files can be searched and
	// recovered. This also specifies inclusion and exclusion rules that determine the directories to index.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies whether or not to perform source side deduplication on this Protection Group.
	PerformSourceSideDeduplication *bool `json:"performSourceSideDeduplication,omitempty"`

	// Specifies Whether to take app-consistent snapshots by quiescing apps and the filesystem before taking a backup.
	Quiesce *bool `json:"quiesce,omitempty"`

	// Specifies whether to continue backing up on quiesce failure.
	ContinueOnQuiesceFailure *bool `json:"continueOnQuiesceFailure,omitempty"`

	// Specifies whether or not to perform an incremental backup after the server restarts. This is applicable to windows
	// environments.
	IncrementalBackupAfterRestart *bool `json:"incrementalBackupAfterRestart,omitempty"`

	// Specifies the params for pre and post scripts.
	PrePostScript *PrePostScriptParams `json:"prePostScript,omitempty"`

	// Specifies ids of sources for which deduplication has to be disabled.
	DedupExclusionSourceIds []int64 `json:"dedupExclusionSourceIds,omitempty"`

	// Specifies writer names which should be excluded from physical volume based backups.
	ExcludedVssWriters []string `json:"excludedVssWriters,omitempty"`

	// Specifies whether to take a CoBMR backup.
	CobmrBackup *bool `json:"cobmrBackup,omitempty"`
}

// NewPhysicalVolumeProtectionGroupParams : Instantiate PhysicalVolumeProtectionGroupParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewPhysicalVolumeProtectionGroupParams(objects []PhysicalVolumeProtectionGroupObjectParams) (_model *PhysicalVolumeProtectionGroupParams, err error) {
	_model = &PhysicalVolumeProtectionGroupParams{
		Objects: objects,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPhysicalVolumeProtectionGroupParams unmarshals an instance of PhysicalVolumeProtectionGroupParams from the specified map of raw messages.
func UnmarshalPhysicalVolumeProtectionGroupParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PhysicalVolumeProtectionGroupParams)
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalPhysicalVolumeProtectionGroupObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "indexingPolicy", &obj.IndexingPolicy, UnmarshalIndexingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "performSourceSideDeduplication", &obj.PerformSourceSideDeduplication)
	if err != nil {
		err = core.SDKErrorf(err, "", "performSourceSideDeduplication-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "quiesce", &obj.Quiesce)
	if err != nil {
		err = core.SDKErrorf(err, "", "quiesce-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "continueOnQuiesceFailure", &obj.ContinueOnQuiesceFailure)
	if err != nil {
		err = core.SDKErrorf(err, "", "continueOnQuiesceFailure-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "incrementalBackupAfterRestart", &obj.IncrementalBackupAfterRestart)
	if err != nil {
		err = core.SDKErrorf(err, "", "incrementalBackupAfterRestart-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prePostScript", &obj.PrePostScript, UnmarshalPrePostScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "prePostScript-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dedupExclusionSourceIds", &obj.DedupExclusionSourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "dedupExclusionSourceIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "excludedVssWriters", &obj.ExcludedVssWriters)
	if err != nil {
		err = core.SDKErrorf(err, "", "excludedVssWriters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cobmrBackup", &obj.CobmrBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "cobmrBackup-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrePostScriptParams : Specifies the params for pre and post scripts.
type PrePostScriptParams struct {
	// Specifies the common params for PreBackup scripts.
	PreScript *CommonPreBackupScriptParams `json:"preScript,omitempty"`

	// Specifies the common params for PostBackup scripts.
	PostScript *CommonPostBackupScriptParams `json:"postScript,omitempty"`
}

// UnmarshalPrePostScriptParams unmarshals an instance of PrePostScriptParams from the specified map of raw messages.
func UnmarshalPrePostScriptParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrePostScriptParams)
	err = core.UnmarshalModel(m, "preScript", &obj.PreScript, UnmarshalCommonPreBackupScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "preScript-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "postScript", &obj.PostScript, UnmarshalCommonPostBackupScriptParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "postScript-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrimaryArchivalTarget : Specifies the primary archival settings. Mainly used for cloud direct archive (CAD) policy where primary backup is
// stored on archival target.
type PrimaryArchivalTarget struct {
	// Specifies the Archival target id to take primary backup.
	TargetID *int64 `json:"targetId" validate:"required"`

	// Specifies the Archival target name where Snapshots are copied.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the settings tier levels configured with each archival target. The tier settings need to be applied in
	// specific order and default tier should always be passed as first entry in tiers array. The following example
	// illustrates how to configure tiering input for AWS tiering. Same type of input structure applied to other cloud
	// platforms also. <br>If user wants to achieve following tiering for backup, <br>User Desired Tiering-
	// <br><t>1.Archive Full back up for 12 Months <br><t>2.Tier Levels <br><t><t>[1,12] [ <br><t><t><t>s3 (1 to 2 months),
	// (default tier) <br><t><t><t>s3 Intelligent tiering (3 to 6 months), <br><t><t><t>s3 One Zone (7 to 9 months)
	// <br><t><t><t>Glacier (10 to 12 months)] <br><t>API Input <br><t><t>1.tiers-[ <br><t><t><t>{'tierType':
	// 'S3','moveAfterUnit':'months', <br><t><t><t>'moveAfter':2 - move from s3 to s3Inte after 2 months},
	// <br><t><t><t>{'tierType': 'S3Inte','moveAfterUnit':'months', <br><t><t><t>'moveAfter':4 - move from S3Inte to
	// Glacier after 4 months}, <br><t><t><t>{'tierType': 'Glacier', 'moveAfterUnit':'months', <br><t><t><t>'moveAfter': 3
	// - move from Glacier to S3 One Zone after 3 months }, <br><t><t><t>{'tierType': 'S3 One Zone', 'moveAfterUnit': nil,
	// <br><t><t><t>'moveAfter': nil - For the last record, 'moveAfter' and 'moveAfterUnit' <br><t><t><t>will be ignored
	// since there are no further tier for data movement } <br><t><t><t>}].
	TierSettings *TierLevelSettings `json:"tierSettings,omitempty"`
}

// NewPrimaryArchivalTarget : Instantiate PrimaryArchivalTarget (Generic Model Constructor)
func (*BackupRecoveryV1) NewPrimaryArchivalTarget(targetID int64) (_model *PrimaryArchivalTarget, err error) {
	_model = &PrimaryArchivalTarget{
		TargetID: core.Int64Ptr(targetID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPrimaryArchivalTarget unmarshals an instance of PrimaryArchivalTarget from the specified map of raw messages.
func UnmarshalPrimaryArchivalTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrimaryArchivalTarget)
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tierSettings", &obj.TierSettings, UnmarshalTierLevelSettings)
	if err != nil {
		err = core.SDKErrorf(err, "", "tierSettings-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrimaryBackupTarget : Specifies the primary backup target settings for regular backups. If the backup target field is not specified then
// backup will be taken locally on the Cohesity cluster.
type PrimaryBackupTarget struct {
	// Specifies the primary backup location where backups will be stored. If not specified, then default is assumed as
	// local backup on Cohesity cluster.
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the primary archival settings. Mainly used for cloud direct archive (CAD) policy where primary backup is
	// stored on archival target.
	ArchivalTargetSettings *PrimaryArchivalTarget `json:"archivalTargetSettings,omitempty"`

	// Specifies if the default primary backup target must be used for backups. If this is not specified or set to false,
	// then targets specified in 'archivalTargetSettings' will be used for backups. If the value is specified as true, then
	// default backup target is used internally. This field should only be set in the environment where tenant policy
	// management is enabled and external targets are assigned to tenant when provisioning tenants.
	UseDefaultBackupTarget *bool `json:"useDefaultBackupTarget,omitempty"`
}

// Constants associated with the PrimaryBackupTarget.TargetType property.
// Specifies the primary backup location where backups will be stored. If not specified, then default is assumed as
// local backup on Cohesity cluster.
const (
	PrimaryBackupTarget_TargetType_Archival = "Archival"
	PrimaryBackupTarget_TargetType_Local    = "Local"
)

// UnmarshalPrimaryBackupTarget unmarshals an instance of PrimaryBackupTarget from the specified map of raw messages.
func UnmarshalPrimaryBackupTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrimaryBackupTarget)
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalTargetSettings", &obj.ArchivalTargetSettings, UnmarshalPrimaryArchivalTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetSettings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "useDefaultBackupTarget", &obj.UseDefaultBackupTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "useDefaultBackupTarget-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectedObject : Specifies the Protected Object with last Run's snapshot information per Protection Group.
type ProtectedObject struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`

	// Specifies the count and size of protected and unprotected objects for the size.
	ProtectionStats []ObjectProtectionStatsSummary `json:"protectionStats,omitempty"`

	// Specifies the list of users, groups and users that have permissions for a given object.
	Permissions *PermissionInfo `json:"permissions,omitempty"`

	// Specifies the parameters for Msssql object.
	MssqlParams *ProtectedObjectMssqlParams `json:"mssqlParams,omitempty"`

	// Specifies the parameters for Physical object.
	PhysicalParams *ProtectedObjectPhysicalParams `json:"physicalParams,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *ProtectedObjectSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the latest snapshot information for every Protection Group for a given object.
	LatestSnapshotsInfo []ObjectSnapshotsInfo `json:"latestSnapshotsInfo,omitempty"`
}

// Constants associated with the ProtectedObject.Environment property.
// Specifies the environment of the object.
const (
	ProtectedObject_Environment_Kphysical = "kPhysical"
	ProtectedObject_Environment_Ksql      = "kSQL"
)

// Constants associated with the ProtectedObject.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	ProtectedObject_ProtectionType_Kagent                 = "kAgent"
	ProtectedObject_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	ProtectedObject_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	ProtectedObject_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	ProtectedObject_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	ProtectedObject_ProtectionType_Kawss3                 = "kAwsS3"
	ProtectedObject_ProtectionType_Kazuresql              = "kAzureSQL"
	ProtectedObject_ProtectionType_Kfile                  = "kFile"
	ProtectedObject_ProtectionType_Knative                = "kNative"
	ProtectedObject_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	ProtectedObject_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	ProtectedObject_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the ProtectedObject.OsType property.
// Specifies the operating system type of the object.
const (
	ProtectedObject_OsType_Klinux   = "kLinux"
	ProtectedObject_OsType_Kwindows = "kWindows"
)

// UnmarshalProtectedObject unmarshals an instance of ProtectedObject from the specified map of raw messages.
func UnmarshalProtectedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectedObject)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionStats", &obj.ProtectionStats, UnmarshalObjectProtectionStatsSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionStats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalPermissionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalProtectedObjectMssqlParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalProtectedObjectPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalProtectedObjectSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "latestSnapshotsInfo", &obj.LatestSnapshotsInfo, UnmarshalObjectSnapshotsInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "latestSnapshotsInfo-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectedObjectMssqlParams : Specifies the parameters for Msssql object.
type ProtectedObjectMssqlParams struct {
	// Object details for Mssql.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
	// hosted by another object such as VM or physical server.
	HostInfo *HostInformation `json:"hostInfo,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
}

// UnmarshalProtectedObjectMssqlParams unmarshals an instance of ProtectedObjectMssqlParams from the specified map of raw messages.
func UnmarshalProtectedObjectMssqlParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectedObjectMssqlParams)
	err = core.UnmarshalModel(m, "aagInfo", &obj.AagInfo, UnmarshalAAGInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostInfo", &obj.HostInfo, UnmarshalHostInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectedObjectPhysicalParams : Specifies the parameters for Physical object.
type ProtectedObjectPhysicalParams struct {
	// Specifies if system backup was enabled for the source in a particular run.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`
}

// UnmarshalProtectedObjectPhysicalParams unmarshals an instance of ProtectedObjectPhysicalParams from the specified map of raw messages.
func UnmarshalProtectedObjectPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectedObjectPhysicalParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectedObjectSourceInfo : Specifies the Source Object information.
type ProtectedObjectSourceInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`
}

// Constants associated with the ProtectedObjectSourceInfo.Environment property.
// Specifies the environment of the object.
const (
	ProtectedObjectSourceInfo_Environment_Kphysical = "kPhysical"
	ProtectedObjectSourceInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the ProtectedObjectSourceInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	ProtectedObjectSourceInfo_ProtectionType_Kagent                 = "kAgent"
	ProtectedObjectSourceInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	ProtectedObjectSourceInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	ProtectedObjectSourceInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	ProtectedObjectSourceInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	ProtectedObjectSourceInfo_ProtectionType_Kawss3                 = "kAwsS3"
	ProtectedObjectSourceInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	ProtectedObjectSourceInfo_ProtectionType_Kfile                  = "kFile"
	ProtectedObjectSourceInfo_ProtectionType_Knative                = "kNative"
	ProtectedObjectSourceInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	ProtectedObjectSourceInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	ProtectedObjectSourceInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the ProtectedObjectSourceInfo.OsType property.
// Specifies the operating system type of the object.
const (
	ProtectedObjectSourceInfo_OsType_Klinux   = "kLinux"
	ProtectedObjectSourceInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalProtectedObjectSourceInfo unmarshals an instance of ProtectedObjectSourceInfo from the specified map of raw messages.
func UnmarshalProtectedObjectSourceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectedObjectSourceInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectedObjectsSearchResponse : Specifies the Protected Objects search result.
type ProtectedObjectsSearchResponse struct {
	// Specifies the list of Protected Objects.
	Objects []ProtectedObject `json:"objects,omitempty"`

	// Specifies the metadata information about the Protection Groups, Protection Policy etc., for search result.
	Metadata *ProtectedObjectsSearchResponseMetadata `json:"metadata,omitempty"`

	// Specifies the total number of search results which matches the search criteria.
	NumResults *int64 `json:"numResults,omitempty"`
}

// UnmarshalProtectedObjectsSearchResponse unmarshals an instance of ProtectedObjectsSearchResponse from the specified map of raw messages.
func UnmarshalProtectedObjectsSearchResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectedObjectsSearchResponse)
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalProtectedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalProtectedObjectsSearchResponseMetadata)
	if err != nil {
		err = core.SDKErrorf(err, "", "metadata-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "numResults", &obj.NumResults)
	if err != nil {
		err = core.SDKErrorf(err, "", "numResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectedObjectsSearchResponseMetadata : Specifies the metadata information about the Protection Groups, Protection Policy etc., for search result.
type ProtectedObjectsSearchResponseMetadata struct {
	// Specifies the list of unique Protection Group identifiers for all the Objects returned in the response.
	UniqueProtectionGroupIdentifiers []ProtectionGroupIdentifier `json:"uniqueProtectionGroupIdentifiers,omitempty"`
}

// UnmarshalProtectedObjectsSearchResponseMetadata unmarshals an instance of ProtectedObjectsSearchResponseMetadata from the specified map of raw messages.
func UnmarshalProtectedObjectsSearchResponseMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectedObjectsSearchResponseMetadata)
	err = core.UnmarshalModel(m, "uniqueProtectionGroupIdentifiers", &obj.UniqueProtectionGroupIdentifiers, UnmarshalProtectionGroupIdentifier)
	if err != nil {
		err = core.SDKErrorf(err, "", "uniqueProtectionGroupIdentifiers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionGroupAlertingPolicy : Specifies a policy for alerting users of the status of a Protection Group.
type ProtectionGroupAlertingPolicy struct {
	// Specifies the run status for which the user would like to receive alerts.
	BackupRunStatus []string `json:"backupRunStatus" validate:"required"`

	// Specifies a list of targets to receive the alerts.
	AlertTargets []AlertTarget `json:"alertTargets,omitempty"`

	// Specifies whether object level alerts are raised for backup failures after the backup run.
	RaiseObjectLevelFailureAlert *bool `json:"raiseObjectLevelFailureAlert,omitempty"`

	// Specifies whether object level alerts are raised for backup failures after last backup attempt.
	RaiseObjectLevelFailureAlertAfterLastAttempt *bool `json:"raiseObjectLevelFailureAlertAfterLastAttempt,omitempty"`

	// Specifies whether object level alerts are raised for backup failures after each backup attempt.
	RaiseObjectLevelFailureAlertAfterEachAttempt *bool `json:"raiseObjectLevelFailureAlertAfterEachAttempt,omitempty"`
}

// Constants associated with the ProtectionGroupAlertingPolicy.BackupRunStatus property.
const (
	ProtectionGroupAlertingPolicy_BackupRunStatus_Kfailure      = "kFailure"
	ProtectionGroupAlertingPolicy_BackupRunStatus_Kslaviolation = "kSlaViolation"
	ProtectionGroupAlertingPolicy_BackupRunStatus_Ksuccess      = "kSuccess"
	ProtectionGroupAlertingPolicy_BackupRunStatus_Kwarning      = "kWarning"
)

// NewProtectionGroupAlertingPolicy : Instantiate ProtectionGroupAlertingPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewProtectionGroupAlertingPolicy(backupRunStatus []string) (_model *ProtectionGroupAlertingPolicy, err error) {
	_model = &ProtectionGroupAlertingPolicy{
		BackupRunStatus: backupRunStatus,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalProtectionGroupAlertingPolicy unmarshals an instance of ProtectionGroupAlertingPolicy from the specified map of raw messages.
func UnmarshalProtectionGroupAlertingPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionGroupAlertingPolicy)
	err = core.UnmarshalPrimitive(m, "backupRunStatus", &obj.BackupRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "alertTargets", &obj.AlertTargets, UnmarshalAlertTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "alertTargets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "raiseObjectLevelFailureAlert", &obj.RaiseObjectLevelFailureAlert)
	if err != nil {
		err = core.SDKErrorf(err, "", "raiseObjectLevelFailureAlert-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "raiseObjectLevelFailureAlertAfterLastAttempt", &obj.RaiseObjectLevelFailureAlertAfterLastAttempt)
	if err != nil {
		err = core.SDKErrorf(err, "", "raiseObjectLevelFailureAlertAfterLastAttempt-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "raiseObjectLevelFailureAlertAfterEachAttempt", &obj.RaiseObjectLevelFailureAlertAfterEachAttempt)
	if err != nil {
		err = core.SDKErrorf(err, "", "raiseObjectLevelFailureAlertAfterEachAttempt-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionGroupIdentifier : Specifies Protection Group Identifier.
type ProtectionGroupIdentifier struct {
	// Specifies Protection Group id.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies Protection Group name.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`
}

// UnmarshalProtectionGroupIdentifier unmarshals an instance of ProtectionGroupIdentifier from the specified map of raw messages.
func UnmarshalProtectionGroupIdentifier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionGroupIdentifier)
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionGroupResponse : Specifies the parameters which are common between all Protection Group responses.
type ProtectionGroupResponse struct {
	// Specifies the ID of the Protection Group.
	ID *string `json:"id,omitempty"`

	// Specifies the name of the Protection Group.
	Name *string `json:"name,omitempty"`

	// Specifies the cluster ID.
	ClusterID *string `json:"clusterId,omitempty"`

	// Specifies the region ID.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies the unique id of the Protection Policy associated with the Protection Group. The Policy provides retry
	// settings Protection Schedules, Priority, SLA, etc.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the priority of the Protection Group.
	Priority *string `json:"priority,omitempty"`

	// Specifies a description of the Protection Group.
	Description *string `json:"description,omitempty"`

	// Specifies the time of day. Used for scheduling purposes.
	StartTime *TimeOfDay `json:"startTime,omitempty"`

	// Specifies the end time in micro seconds for this Protection Group. If this is not specified, the Protection Group
	// won't be ended.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the last time this protection group was updated. If this is passed into a PUT request, then the backend
	// will validate that the timestamp passed in matches the time that the protection group was actually last modified. If
	// the two timestamps do not match, then the request will be rejected with a stale error.
	LastModifiedTimestampUsecs *int64 `json:"lastModifiedTimestampUsecs,omitempty"`

	// Specifies a policy for alerting users of the status of a Protection Group.
	AlertPolicy *ProtectionGroupAlertingPolicy `json:"alertPolicy,omitempty"`

	// Specifies the SLA parameters for this Protection Group.
	Sla []SlaRule `json:"sla,omitempty"`

	// Specifies whether the Protection Group will be written to HDD or SSD.
	QosPolicy *string `json:"qosPolicy,omitempty"`

	// Specifies whether currently executing jobs should abort if a blackout period specified by a policy starts. Available
	// only if the selected policy has at least one blackout period. Default value is false.
	AbortInBlackouts *bool `json:"abortInBlackouts,omitempty"`

	// Specifies whether currently executing jobs should be paused if a blackout period specified by a policy starts.
	// Available only if the selected policy has at least one blackout period. Default value is false. This field should
	// not be set to true if 'abortInBlackouts' is sent as true.
	PauseInBlackouts *bool `json:"pauseInBlackouts,omitempty"`

	// Specifies if the Protection Group is active or not.
	IsActive *bool `json:"isActive,omitempty"`

	// Specifies if the Protection Group has been deleted.
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// Specifies if the the Protection Group is paused. New runs are not scheduled for the paused Protection Groups. Active
	// run if any is not impacted.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Specifies the environment of the Protection Group.
	Environment *string `json:"environment,omitempty"`

	// Specifies the parameters which are common between Protection Group runs of all Protection Groups.
	LastRun *ProtectionGroupRun `json:"lastRun,omitempty"`

	// Specifies the list of tenants that have permissions for this protection group.
	Permissions []Tenant `json:"permissions,omitempty"`

	// Specifies if the the Protection Group is using a protect once type of policy. This field is helpful to identify run
	// happen for this group.
	IsProtectOnce *bool `json:"isProtectOnce,omitempty"`

	// Specifies the Information about missing entities.
	MissingEntities []MissingEntityParams `json:"missingEntities,omitempty"`

	// Specifies the Information about invalid entities. An entity will be considered invalid if it is part of an active
	// protection group but has lost compatibility for the given backup type.
	InvalidEntities []MissingEntityParams `json:"invalidEntities,omitempty"`

	// Specifies the number of protected objects of the Protection Group.
	NumProtectedObjects *int64 `json:"numProtectedObjects,omitempty"`

	// Specifies the advanced configuration for a protection job.
	AdvancedConfigs []KeyValuePair `json:"advancedConfigs,omitempty"`

	PhysicalParams *PhysicalProtectionGroupParams `json:"physicalParams,omitempty"`

	// Specifies the parameters specific to MSSQL Protection Group.
	MssqlParams *MSSQLProtectionGroupParams `json:"mssqlParams,omitempty"`
}

// Constants associated with the ProtectionGroupResponse.Priority property.
// Specifies the priority of the Protection Group.
const (
	ProtectionGroupResponse_Priority_Khigh   = "kHigh"
	ProtectionGroupResponse_Priority_Klow    = "kLow"
	ProtectionGroupResponse_Priority_Kmedium = "kMedium"
)

// Constants associated with the ProtectionGroupResponse.QosPolicy property.
// Specifies whether the Protection Group will be written to HDD or SSD.
const (
	ProtectionGroupResponse_QosPolicy_Kbackupall      = "kBackupAll"
	ProtectionGroupResponse_QosPolicy_Kbackuphdd      = "kBackupHDD"
	ProtectionGroupResponse_QosPolicy_Kbackupssd      = "kBackupSSD"
	ProtectionGroupResponse_QosPolicy_Ktestanddevhigh = "kTestAndDevHigh"
)

// Constants associated with the ProtectionGroupResponse.Environment property.
// Specifies the environment of the Protection Group.
const (
	ProtectionGroupResponse_Environment_Kphysical = "kPhysical"
	ProtectionGroupResponse_Environment_Ksql      = "kSQL"
)

// UnmarshalProtectionGroupResponse unmarshals an instance of ProtectionGroupResponse from the specified map of raw messages.
func UnmarshalProtectionGroupResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionGroupResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "regionId", &obj.RegionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "regionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		err = core.SDKErrorf(err, "", "priority-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		err = core.SDKErrorf(err, "", "description-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "startTime", &obj.StartTime, UnmarshalTimeOfDay)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTime-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModifiedTimestampUsecs", &obj.LastModifiedTimestampUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModifiedTimestampUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "alertPolicy", &obj.AlertPolicy, UnmarshalProtectionGroupAlertingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "alertPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sla", &obj.Sla, UnmarshalSlaRule)
	if err != nil {
		err = core.SDKErrorf(err, "", "sla-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "qosPolicy", &obj.QosPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "qosPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "abortInBlackouts", &obj.AbortInBlackouts)
	if err != nil {
		err = core.SDKErrorf(err, "", "abortInBlackouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "pauseInBlackouts", &obj.PauseInBlackouts)
	if err != nil {
		err = core.SDKErrorf(err, "", "pauseInBlackouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isActive", &obj.IsActive)
	if err != nil {
		err = core.SDKErrorf(err, "", "isActive-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isDeleted", &obj.IsDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaused", &obj.IsPaused)
	if err != nil {
		err = core.SDKErrorf(err, "", "isPaused-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "lastRun", &obj.LastRun, UnmarshalProtectionGroupRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastRun-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalTenant)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isProtectOnce", &obj.IsProtectOnce)
	if err != nil {
		err = core.SDKErrorf(err, "", "isProtectOnce-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "missingEntities", &obj.MissingEntities, UnmarshalMissingEntityParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "missingEntities-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "invalidEntities", &obj.InvalidEntities, UnmarshalMissingEntityParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "invalidEntities-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "numProtectedObjects", &obj.NumProtectedObjects)
	if err != nil {
		err = core.SDKErrorf(err, "", "numProtectedObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "advancedConfigs", &obj.AdvancedConfigs, UnmarshalKeyValuePair)
	if err != nil {
		err = core.SDKErrorf(err, "", "advancedConfigs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalPhysicalProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalMSSQLProtectionGroupParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionGroupRun : Specifies the parameters which are common between Protection Group runs of all Protection Groups.
type ProtectionGroupRun struct {
	// Specifies the ID of the Protection Group run.
	ID *string `json:"id,omitempty"`

	// Protection Group instance Id. This field will be removed later.
	ProtectionGroupInstanceID *int64 `json:"protectionGroupInstanceId,omitempty"`

	// ProtectionGroupId to which this run belongs.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies if this protection run is a replication run.
	IsReplicationRun *bool `json:"isReplicationRun,omitempty"`

	// Specifies the information about a cluster.
	OriginClusterIdentifier *ClusterIdentifier `json:"originClusterIdentifier,omitempty"`

	// ProtectionGroupId to which this run belongs on the primary cluster if this run is a replication run.
	OriginProtectionGroupID *string `json:"originProtectionGroupId,omitempty"`

	// Name of the Protection Group to which this run belongs.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies if snapshots for this run has been deleted.
	IsLocalSnapshotsDeleted *bool `json:"isLocalSnapshotsDeleted,omitempty"`

	// Snapahot, replication, archival results for each object.
	Objects []ObjectRunResult `json:"objects,omitempty"`

	// Specifies summary information about local snapshot run across all objects.
	LocalBackupInfo *BackupRunSummary `json:"localBackupInfo,omitempty"`

	// Specifies summary information about local snapshot run across all objects.
	OriginalBackupInfo *BackupRunSummary `json:"originalBackupInfo,omitempty"`

	// Specifies summary information about replication run.
	ReplicationInfo *ReplicationRunSummary `json:"replicationInfo,omitempty"`

	// Specifies summary information about archival run.
	ArchivalInfo *ArchivalRunSummary `json:"archivalInfo,omitempty"`

	// Specifies summary information about cloud spin run.
	CloudSpinInfo *CloudSpinRunSummary `json:"cloudSpinInfo,omitempty"`

	// Specifies if the Protection Run is on legal hold.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`

	// Specifies the list of tenants that have permissions for this protection group run.
	Permissions []Tenant `json:"permissions,omitempty"`

	// Specifies whether the run is a CAD run if cloud archive direct feature is enabled. If this field is true, the
	// primary backup copy will only be available at the given archived location.
	IsCloudArchivalDirect *bool `json:"isCloudArchivalDirect,omitempty"`

	// Specifies whether the run has a local snapshot. For cloud retrieved runs there may not be local snapshots.
	HasLocalSnapshot *bool `json:"hasLocalSnapshot,omitempty"`

	// Specifies the environment of the Protection Group.
	Environment *string `json:"environment,omitempty"`

	// The tag of externally triggered backup job.
	ExternallyTriggeredBackupTag *string `json:"externallyTriggeredBackupTag,omitempty"`
}

// UnmarshalProtectionGroupRun unmarshals an instance of ProtectionGroupRun from the specified map of raw messages.
func UnmarshalProtectionGroupRun(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionGroupRun)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupInstanceId", &obj.ProtectionGroupInstanceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupInstanceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isReplicationRun", &obj.IsReplicationRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "isReplicationRun-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "originClusterIdentifier", &obj.OriginClusterIdentifier, UnmarshalClusterIdentifier)
	if err != nil {
		err = core.SDKErrorf(err, "", "originClusterIdentifier-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "originProtectionGroupId", &obj.OriginProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "originProtectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isLocalSnapshotsDeleted", &obj.IsLocalSnapshotsDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isLocalSnapshotsDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalObjectRunResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "localBackupInfo", &obj.LocalBackupInfo, UnmarshalBackupRunSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "localBackupInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "originalBackupInfo", &obj.OriginalBackupInfo, UnmarshalBackupRunSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "originalBackupInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "replicationInfo", &obj.ReplicationInfo, UnmarshalReplicationRunSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalInfo", &obj.ArchivalInfo, UnmarshalArchivalRunSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cloudSpinInfo", &obj.CloudSpinInfo, UnmarshalCloudSpinRunSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudSpinInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "onLegalHold", &obj.OnLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "onLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalTenant)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isCloudArchivalDirect", &obj.IsCloudArchivalDirect)
	if err != nil {
		err = core.SDKErrorf(err, "", "isCloudArchivalDirect-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasLocalSnapshot", &obj.HasLocalSnapshot)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasLocalSnapshot-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "externallyTriggeredBackupTag", &obj.ExternallyTriggeredBackupTag)
	if err != nil {
		err = core.SDKErrorf(err, "", "externallyTriggeredBackupTag-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionGroupRunsResponse : Protection runs.
type ProtectionGroupRunsResponse struct {
	// Specifies the list of Protection Group runs.
	Runs []ProtectionGroupRun `json:"runs,omitempty"`

	// Specifies the count of total runs exist for the given set of filters. The number of runs in single API call are
	// limited and this count can be used to estimate query filter values to get next set of remaining runs. Please note
	// that this field will only be populated if startTimeUsecs or endTimeUsecs or both are specified in query parameters.
	TotalRuns *int64 `json:"totalRuns,omitempty"`
}

// UnmarshalProtectionGroupRunsResponse unmarshals an instance of ProtectionGroupRunsResponse from the specified map of raw messages.
func UnmarshalProtectionGroupRunsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionGroupRunsResponse)
	err = core.UnmarshalModel(m, "runs", &obj.Runs, UnmarshalProtectionGroupRun)
	if err != nil {
		err = core.SDKErrorf(err, "", "runs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "totalRuns", &obj.TotalRuns)
	if err != nil {
		err = core.SDKErrorf(err, "", "totalRuns-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionGroupsResponse : Protection Group response.
type ProtectionGroupsResponse struct {
	// Specifies the list of Protection Groups which were returned by the request.
	ProtectionGroups []ProtectionGroupResponse `json:"protectionGroups,omitempty"`
}

// UnmarshalProtectionGroupsResponse unmarshals an instance of ProtectionGroupsResponse from the specified map of raw messages.
func UnmarshalProtectionGroupsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionGroupsResponse)
	err = core.UnmarshalModel(m, "protectionGroups", &obj.ProtectionGroups, UnmarshalProtectionGroupResponse)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroups-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionPoliciesResponse : Specifies the details about the Protection Policy.
type ProtectionPoliciesResponse struct {
	// Specifies a list of protection policies.
	Policies []ProtectionPolicyResponse `json:"policies,omitempty"`
}

// UnmarshalProtectionPoliciesResponse unmarshals an instance of ProtectionPoliciesResponse from the specified map of raw messages.
func UnmarshalProtectionPoliciesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionPoliciesResponse)
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalProtectionPolicyResponse)
	if err != nil {
		err = core.SDKErrorf(err, "", "policies-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionPolicyResponse : Specifies the details about the Protection Policy.
type ProtectionPolicyResponse struct {
	// Specifies the name of the Protection Policy.
	Name *string `json:"name" validate:"required"`

	// Specifies the backup schedule and retentions of a Protection Policy.
	BackupPolicy *BackupPolicy `json:"backupPolicy" validate:"required"`

	// Specifies the description of the Protection Policy.
	Description *string `json:"description,omitempty"`

	// List of Blackout Windows. If specified, this field defines blackout periods when new Group Runs are not started. If
	// a Group Run has been scheduled but not yet executed and the blackout period starts, the behavior depends on the
	// policy field AbortInBlackoutPeriod.
	BlackoutWindow []BlackoutWindow `json:"blackoutWindow,omitempty"`

	// Specifies additional retention policies that should be applied to the backup snapshots. A backup snapshot will be
	// retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []ExtendedRetentionPolicy `json:"extendedRetention,omitempty"`

	// Specifies the replication, archival and cloud spin targets of Protection Policy.
	RemoteTargetPolicy *TargetsConfiguration `json:"remoteTargetPolicy,omitempty"`

	// Specifies the configuration for cascaded replications. Using cascaded replication, replication cluster(Rx) can
	// further replicate and archive the snapshot copies to further targets. Its recommended to create cascaded
	// configuration where protection group will be created.
	CascadedTargetsConfig []CascadedTargetConfiguration `json:"cascadedTargetsConfig,omitempty"`

	// Retry Options of a Protection Policy when a Protection Group run fails.
	RetryOptions *RetryOptions `json:"retryOptions,omitempty"`

	// This field is now deprecated. Please use the DataLockConfig in the backup retention.
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies the current policy verison. Policy version is incremented for optionally supporting new features and
	// differentialting across releases.
	Version *int64 `json:"version,omitempty"`

	// Specifies true if Calender Based Schedule is supported by client. Default value is assumed as false for this
	// feature.
	IsCBSEnabled *bool `json:"isCBSEnabled,omitempty"`

	// Specifies the last time this Policy was updated. If this is passed into a PUT request, then the backend will
	// validate that the timestamp passed in matches the time that the policy was actually last modified. If the two
	// timestamps do not match, then the request will be rejected with a stale error.
	LastModificationTimeUsecs *int64 `json:"lastModificationTimeUsecs,omitempty"`

	// Specifies a unique Policy id assigned by the Cohesity Cluster.
	ID *string `json:"id,omitempty"`

	// Specifies the parent policy template id to which the policy is linked to. This field is set only when policy is
	// created from template.
	TemplateID *string `json:"templateId,omitempty"`

	// This field is set to true if the linked policy which is internally created from a policy templates qualifies as
	// usable to create more policies on the cluster. If the linked policy is partially filled and can not create a working
	// policy then this field will be set to false. In case of normal policy created on the cluster, this field wont be
	// populated.
	IsUsable *bool `json:"isUsable,omitempty"`

	// This field is set to true when policy is the replicated policy.
	IsReplicated *bool `json:"isReplicated,omitempty"`

	// Specifies the number of protection groups using the protection policy.
	NumProtectionGroups *int64 `json:"numProtectionGroups,omitempty"`

	// Specifies the number of protected objects using the protection policy.
	NumProtectedObjects *int64 `json:"numProtectedObjects,omitempty"`
}

// Constants associated with the ProtectionPolicyResponse.DataLock property.
// This field is now deprecated. Please use the DataLockConfig in the backup retention.
const (
	ProtectionPolicyResponse_DataLock_Administrative = "Administrative"
	ProtectionPolicyResponse_DataLock_Compliance     = "Compliance"
)

// UnmarshalProtectionPolicyResponse unmarshals an instance of ProtectionPolicyResponse from the specified map of raw messages.
func UnmarshalProtectionPolicyResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionPolicyResponse)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "backupPolicy", &obj.BackupPolicy, UnmarshalBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		err = core.SDKErrorf(err, "", "description-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "blackoutWindow", &obj.BlackoutWindow, UnmarshalBlackoutWindow)
	if err != nil {
		err = core.SDKErrorf(err, "", "blackoutWindow-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "extendedRetention", &obj.ExtendedRetention, UnmarshalExtendedRetentionPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "extendedRetention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "remoteTargetPolicy", &obj.RemoteTargetPolicy, UnmarshalTargetsConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "remoteTargetPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cascadedTargetsConfig", &obj.CascadedTargetsConfig, UnmarshalCascadedTargetConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "cascadedTargetsConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retryOptions", &obj.RetryOptions, UnmarshalRetryOptions)
	if err != nil {
		err = core.SDKErrorf(err, "", "retryOptions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataLock", &obj.DataLock)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLock-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		err = core.SDKErrorf(err, "", "version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isCBSEnabled", &obj.IsCBSEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isCBSEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModificationTimeUsecs", &obj.LastModificationTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModificationTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "templateId", &obj.TemplateID)
	if err != nil {
		err = core.SDKErrorf(err, "", "templateId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isUsable", &obj.IsUsable)
	if err != nil {
		err = core.SDKErrorf(err, "", "isUsable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isReplicated", &obj.IsReplicated)
	if err != nil {
		err = core.SDKErrorf(err, "", "isReplicated-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "numProtectionGroups", &obj.NumProtectionGroups)
	if err != nil {
		err = core.SDKErrorf(err, "", "numProtectionGroups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "numProtectedObjects", &obj.NumProtectedObjects)
	if err != nil {
		err = core.SDKErrorf(err, "", "numProtectedObjects-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionSourceApplicationNodes : Specifies the child subtree used to store additional application-level Objects. Different environments use the
// subtree to store application-level information. For example for SQL Server, this subtree stores the SQL Server
// instances running on a VM.
type ProtectionSourceApplicationNodes struct {
	// Specifies children of the current node in the Protection Sources hierarchy.
	Nodes []ProtectionSourceNodes `json:"nodes,omitempty"`
}

// UnmarshalProtectionSourceApplicationNodes unmarshals an instance of ProtectionSourceApplicationNodes from the specified map of raw messages.
func UnmarshalProtectionSourceApplicationNodes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionSourceApplicationNodes)
	err = core.UnmarshalModel(m, "nodes", &obj.Nodes, UnmarshalProtectionSourceNodes)
	if err != nil {
		err = core.SDKErrorf(err, "", "nodes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionSourceNode : Specifies details about an Acropolis Protection Source when the environment is set to 'kAcropolis'.
type ProtectionSourceNode struct {
	// Specifies the connection id of the tenant.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// Specifies the connector group id of the connector groups.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Specifies the user provided custom name of the Protection Source.
	CustomName *string `json:"customName,omitempty"`

	// Specifies the environment (such as 'kVMware' or 'kSQL') where the Protection Source exists. Depending on the
	// environment, one of the following Protection Sources are initialized.
	Environment *string `json:"environment,omitempty"`

	// Specifies an id of the Protection Source.
	ID *int64 `json:"id,omitempty"`

	// Specifies a name of the Protection Source.
	Name *string `json:"name,omitempty"`

	// Specifies an id of the parent of the Protection Source.
	ParentID *int64 `json:"parentId,omitempty"`

	// Specifies a Protection Source in a Physical environment.
	PhysicalProtectionSource *PhysicalProtectionSource `json:"physicalProtectionSource,omitempty"`

	// Specifies an Object representing one SQL Server instance or database.
	SqlProtectionSource *SqlProtectionSource `json:"sqlProtectionSource,omitempty"`
}

// Constants associated with the ProtectionSourceNode.Environment property.
// Specifies the environment (such as 'kVMware' or 'kSQL') where the Protection Source exists. Depending on the
// environment, one of the following Protection Sources are initialized.
const (
	ProtectionSourceNode_Environment_Kagent         = "kAgent"
	ProtectionSourceNode_Environment_Kphysical      = "kPhysical"
	ProtectionSourceNode_Environment_Kphysicalfiles = "kPhysicalFiles"
	ProtectionSourceNode_Environment_Ksql           = "kSQL"
)

// UnmarshalProtectionSourceNode unmarshals an instance of ProtectionSourceNode from the specified map of raw messages.
func UnmarshalProtectionSourceNode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionSourceNode)
	err = core.UnmarshalPrimitive(m, "connectionId", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorGroupId", &obj.ConnectorGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customName", &obj.CustomName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentId", &obj.ParentID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalProtectionSource", &obj.PhysicalProtectionSource, UnmarshalPhysicalProtectionSource)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalProtectionSource-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sqlProtectionSource", &obj.SqlProtectionSource, UnmarshalSqlProtectionSource)
	if err != nil {
		err = core.SDKErrorf(err, "", "sqlProtectionSource-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionSourceNodes : Specifies the details about the Protection Sources.
type ProtectionSourceNodes struct {
	// Specifies the child subtree used to store additional application-level Objects. Different environments use the
	// subtree to store application-level information. For example for SQL Server, this subtree stores the SQL Server
	// instances running on a VM.
	ApplicationNodes *ProtectionSourceApplicationNodes `json:"applicationNodes,omitempty"`

	// Specifies the cursor based pagination parameters for Protection Source and its children. Pagination is supported at
	// a given level within the Protection Source Hierarchy with the help of before or after cursors. A Cursor will always
	// refer to a specific source within the source dataset but will be invalidated if the item is removed.
	EntityPaginationParameters *PaginationParameters `json:"entityPaginationParameters,omitempty"`

	// Specifies the permission information of entities.
	EntityPermissionInfo *EntityPermissionInfo `json:"entityPermissionInfo,omitempty"`

	// Specifies the logical size of the data in bytes for the Object on this node. Presence of this field indicates this
	// node is a leaf node.
	LogicalSize *int64 `json:"logicalSize,omitempty"`

	// Specifies children of the current node in the Protection Sources hierarchy. When representing Objects in memory, the
	// entire Object subtree hierarchy is represented. You can use this subtree to navigate down the Object hierarchy.
	Nodes []ProtectionSourceNodes `json:"nodes,omitempty"`

	// Specifies the Object Protection Info of the Protection Source.
	ObjectProtectionInfo *ProtectionSourceObjectProtectionInfo `json:"objectProtectionInfo,omitempty"`

	// Array of Protected Objects. Specifies aggregated information about all the child Objects of this node that are
	// currently protected by a Protection Job. There is one entry for each environment that is being backed up. The
	// aggregated information for the Object hierarchy's environment will be available at the 0th index of the vector.
	ProtectedSourcesSummary []SubtreeInfo `json:"protectedSourcesSummary,omitempty"`

	// Specifies details about an Acropolis Protection Source when the environment is set to 'kAcropolis'.
	ProtectionSource *ProtectionSourceNode `json:"protectionSource,omitempty"`

	// Specifies information about a registered Source.
	RegistrationInfo *AgentRegistrationInfo `json:"registrationInfo,omitempty"`

	// Specifies the total bytes downtiered from the source so far.
	TotalDowntieredSizeInBytes *int64 `json:"totalDowntieredSizeInBytes,omitempty"`

	// Specifies the total bytes uptiered to the source so far.
	TotalUptieredSizeInBytes *int64 `json:"totalUptieredSizeInBytes,omitempty"`

	UnprotectedSourcesSummary []SubtreeInfo `json:"unprotectedSourcesSummary,omitempty"`
}

// UnmarshalProtectionSourceNodes unmarshals an instance of ProtectionSourceNodes from the specified map of raw messages.
func UnmarshalProtectionSourceNodes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionSourceNodes)
	err = core.UnmarshalModel(m, "applicationNodes", &obj.ApplicationNodes, UnmarshalProtectionSourceApplicationNodes)
	if err != nil {
		err = core.SDKErrorf(err, "", "applicationNodes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "entityPaginationParameters", &obj.EntityPaginationParameters, UnmarshalPaginationParameters)
	if err != nil {
		err = core.SDKErrorf(err, "", "entityPaginationParameters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "entityPermissionInfo", &obj.EntityPermissionInfo, UnmarshalEntityPermissionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "entityPermissionInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSize", &obj.LogicalSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSize-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "nodes", &obj.Nodes, UnmarshalProtectionSourceNodes)
	if err != nil {
		err = core.SDKErrorf(err, "", "nodes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objectProtectionInfo", &obj.ObjectProtectionInfo, UnmarshalProtectionSourceObjectProtectionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectProtectionInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectedSourcesSummary", &obj.ProtectedSourcesSummary, UnmarshalSubtreeInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectedSourcesSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionSource", &obj.ProtectionSource, UnmarshalProtectionSourceNode)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionSource-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "registrationInfo", &obj.RegistrationInfo, UnmarshalAgentRegistrationInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "registrationInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "totalDowntieredSizeInBytes", &obj.TotalDowntieredSizeInBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "totalDowntieredSizeInBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "totalUptieredSizeInBytes", &obj.TotalUptieredSizeInBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "totalUptieredSizeInBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "unprotectedSourcesSummary", &obj.UnprotectedSourcesSummary, UnmarshalSubtreeInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "unprotectedSourcesSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionSourceObjectProtectionInfo : Specifies the Object Protection Info of the Protection Source.
type ProtectionSourceObjectProtectionInfo struct {
	// Specifies the auto protect parent id if this entity is protected based on auto protection. This is only specified
	// for leaf entities.
	AutoProtectParentID *int64 `json:"autoProtectParentId,omitempty"`

	// Specifies the entity id.
	EntityID *int64 `json:"entityId,omitempty"`

	// Specifies if the entity is under object protection.
	HasActiveObjectProtectionSpec *int64 `json:"hasActiveObjectProtectionSpec,omitempty"`
}

// UnmarshalProtectionSourceObjectProtectionInfo unmarshals an instance of ProtectionSourceObjectProtectionInfo from the specified map of raw messages.
func UnmarshalProtectionSourceObjectProtectionInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionSourceObjectProtectionInfo)
	err = core.UnmarshalPrimitive(m, "autoProtectParentId", &obj.AutoProtectParentID)
	if err != nil {
		err = core.SDKErrorf(err, "", "autoProtectParentId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "entityId", &obj.EntityID)
	if err != nil {
		err = core.SDKErrorf(err, "", "entityId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasActiveObjectProtectionSpec", &obj.HasActiveObjectProtectionSpec)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasActiveObjectProtectionSpec-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProtectionSummary : Specifies a summary of an object protection.
type ProtectionSummary struct {
	// Specifies the policy name for this group.
	PolicyName *string `json:"policyName,omitempty"`

	// Specifies the policy id for this protection.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the status of last local back up run.
	LastBackupRunStatus *string `json:"lastBackupRunStatus,omitempty"`

	// Specifies the status of last archival run.
	LastArchivalRunStatus *string `json:"lastArchivalRunStatus,omitempty"`

	// Specifies the status of last replication run.
	LastReplicationRunStatus *string `json:"lastReplicationRunStatus,omitempty"`

	// Specifies if the sla is violated in last run.
	LastRunSlaViolated *bool `json:"lastRunSlaViolated,omitempty"`
}

// Constants associated with the ProtectionSummary.LastBackupRunStatus property.
// Specifies the status of last local back up run.
const (
	ProtectionSummary_LastBackupRunStatus_Accepted             = "Accepted"
	ProtectionSummary_LastBackupRunStatus_Canceled             = "Canceled"
	ProtectionSummary_LastBackupRunStatus_Canceling            = "Canceling"
	ProtectionSummary_LastBackupRunStatus_Failed               = "Failed"
	ProtectionSummary_LastBackupRunStatus_Finalizing           = "Finalizing"
	ProtectionSummary_LastBackupRunStatus_Legalhold            = "LegalHold"
	ProtectionSummary_LastBackupRunStatus_Missed               = "Missed"
	ProtectionSummary_LastBackupRunStatus_Onhold               = "OnHold"
	ProtectionSummary_LastBackupRunStatus_Paused               = "Paused"
	ProtectionSummary_LastBackupRunStatus_Running              = "Running"
	ProtectionSummary_LastBackupRunStatus_Skipped              = "Skipped"
	ProtectionSummary_LastBackupRunStatus_Succeeded            = "Succeeded"
	ProtectionSummary_LastBackupRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the ProtectionSummary.LastArchivalRunStatus property.
// Specifies the status of last archival run.
const (
	ProtectionSummary_LastArchivalRunStatus_Accepted             = "Accepted"
	ProtectionSummary_LastArchivalRunStatus_Canceled             = "Canceled"
	ProtectionSummary_LastArchivalRunStatus_Canceling            = "Canceling"
	ProtectionSummary_LastArchivalRunStatus_Failed               = "Failed"
	ProtectionSummary_LastArchivalRunStatus_Finalizing           = "Finalizing"
	ProtectionSummary_LastArchivalRunStatus_Legalhold            = "LegalHold"
	ProtectionSummary_LastArchivalRunStatus_Missed               = "Missed"
	ProtectionSummary_LastArchivalRunStatus_Onhold               = "OnHold"
	ProtectionSummary_LastArchivalRunStatus_Paused               = "Paused"
	ProtectionSummary_LastArchivalRunStatus_Running              = "Running"
	ProtectionSummary_LastArchivalRunStatus_Skipped              = "Skipped"
	ProtectionSummary_LastArchivalRunStatus_Succeeded            = "Succeeded"
	ProtectionSummary_LastArchivalRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the ProtectionSummary.LastReplicationRunStatus property.
// Specifies the status of last replication run.
const (
	ProtectionSummary_LastReplicationRunStatus_Accepted             = "Accepted"
	ProtectionSummary_LastReplicationRunStatus_Canceled             = "Canceled"
	ProtectionSummary_LastReplicationRunStatus_Canceling            = "Canceling"
	ProtectionSummary_LastReplicationRunStatus_Failed               = "Failed"
	ProtectionSummary_LastReplicationRunStatus_Finalizing           = "Finalizing"
	ProtectionSummary_LastReplicationRunStatus_Legalhold            = "LegalHold"
	ProtectionSummary_LastReplicationRunStatus_Missed               = "Missed"
	ProtectionSummary_LastReplicationRunStatus_Onhold               = "OnHold"
	ProtectionSummary_LastReplicationRunStatus_Paused               = "Paused"
	ProtectionSummary_LastReplicationRunStatus_Running              = "Running"
	ProtectionSummary_LastReplicationRunStatus_Skipped              = "Skipped"
	ProtectionSummary_LastReplicationRunStatus_Succeeded            = "Succeeded"
	ProtectionSummary_LastReplicationRunStatus_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalProtectionSummary unmarshals an instance of ProtectionSummary from the specified map of raw messages.
func UnmarshalProtectionSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProtectionSummary)
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastBackupRunStatus", &obj.LastBackupRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastBackupRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastArchivalRunStatus", &obj.LastArchivalRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastArchivalRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastReplicationRunStatus", &obj.LastReplicationRunStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastReplicationRunStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastRunSlaViolated", &obj.LastRunSlaViolated)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastRunSlaViolated-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicFolderItem : Specifies an Public folder indexed item.
type PublicFolderItem struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the Public folder item type.
	Type *string `json:"type,omitempty"`

	// Specifies the id of the indexed item.
	ID *string `json:"id,omitempty"`

	// Specifies the subject of the indexed item.
	Subject *string `json:"subject,omitempty"`

	// Specifies whether the item has any attachments.
	HasAttachments *bool `json:"hasAttachments,omitempty"`

	// Specifies the item class of the indexed item.
	ItemClass *string `json:"itemClass,omitempty"`

	// Specifies the Unix timestamp epoch in seconds at which this item is received.
	ReceivedTimeSecs *int64 `json:"receivedTimeSecs,omitempty"`

	// Specifies the size in bytes for the indexed item.
	ItemSize *int64 `json:"itemSize,omitempty"`

	// Specifies the id of parent folder the indexed item.
	ParentFolderID *string `json:"parentFolderId,omitempty"`
}

// UnmarshalPublicFolderItem unmarshals an instance of PublicFolderItem from the specified map of raw messages.
func UnmarshalPublicFolderItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicFolderItem)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "subject", &obj.Subject)
	if err != nil {
		err = core.SDKErrorf(err, "", "subject-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasAttachments", &obj.HasAttachments)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasAttachments-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "itemClass", &obj.ItemClass)
	if err != nil {
		err = core.SDKErrorf(err, "", "itemClass-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedTimeSecs", &obj.ReceivedTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "itemSize", &obj.ItemSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "itemSize-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentFolderId", &obj.ParentFolderID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentFolderId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalFileAndFolderParamsPhysicalTargetParams : Specifies the parameters to recover to a Physical target.
type RecoverPhysicalFileAndFolderParamsPhysicalTargetParams struct {
	// Specifies the target entity where the volumes are being mounted.
	RecoverTarget *PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget `json:"recoverTarget" validate:"required"`

	// If this is true, then files will be restored to original paths.
	RestoreToOriginalPaths *bool `json:"restoreToOriginalPaths,omitempty"`

	// Specifies whether to overwrite existing file/folder during recovery.
	OverwriteExisting *bool `json:"overwriteExisting,omitempty"`

	// Specifies the directory path where restore should happen if restore_to_original_paths is set to false.
	AlternateRestoreDirectory *string `json:"alternateRestoreDirectory,omitempty"`

	// Specifies whether to preserve file/folder attributes during recovery.
	PreserveAttributes *bool `json:"preserveAttributes,omitempty"`

	// Whether to preserve the original time stamps.
	PreserveTimestamps *bool `json:"preserveTimestamps,omitempty"`

	// Whether to preserve the ACLs of the original file.
	PreserveAcls *bool `json:"preserveAcls,omitempty"`

	// Specifies whether to continue recovering other volumes if one of the volumes fails to recover. Default value is
	// false.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Specifies whether to save success files or not. Default value is false.
	SaveSuccessFiles *bool `json:"saveSuccessFiles,omitempty"`

	// Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
	// automatically selected from one of the below options: a. If VLANs are configured on Cohesity, then the VLAN host/VIP
	// will be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on Cohesity,
	// then the partition hostname or VIPs will be used for Recovery.
	VlanConfig *PhysicalTargetParamsForRecoverFileAndFolderVlanConfig `json:"vlanConfig,omitempty"`

	// Specifies the restore type (restore everything or ACLs only) when restoring or downloading files or folders from a
	// Physical file based or block based backup snapshot.
	RestoreEntityType *string `json:"restoreEntityType,omitempty"`
}

// Constants associated with the RecoverPhysicalFileAndFolderParamsPhysicalTargetParams.RestoreEntityType property.
// Specifies the restore type (restore everything or ACLs only) when restoring or downloading files or folders from a
// Physical file based or block based backup snapshot.
const (
	RecoverPhysicalFileAndFolderParamsPhysicalTargetParams_RestoreEntityType_Kaclonly = "kACLOnly"
	RecoverPhysicalFileAndFolderParamsPhysicalTargetParams_RestoreEntityType_Kregular = "kRegular"
)

// NewRecoverPhysicalFileAndFolderParamsPhysicalTargetParams : Instantiate RecoverPhysicalFileAndFolderParamsPhysicalTargetParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverPhysicalFileAndFolderParamsPhysicalTargetParams(recoverTarget *PhysicalTargetParamsForRecoverFileAndFolderRecoverTarget) (_model *RecoverPhysicalFileAndFolderParamsPhysicalTargetParams, err error) {
	_model = &RecoverPhysicalFileAndFolderParamsPhysicalTargetParams{
		RecoverTarget: recoverTarget,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverPhysicalFileAndFolderParamsPhysicalTargetParams unmarshals an instance of RecoverPhysicalFileAndFolderParamsPhysicalTargetParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalFileAndFolderParamsPhysicalTargetParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalFileAndFolderParamsPhysicalTargetParams)
	err = core.UnmarshalModel(m, "recoverTarget", &obj.RecoverTarget, UnmarshalPhysicalTargetParamsForRecoverFileAndFolderRecoverTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "restoreToOriginalPaths", &obj.RestoreToOriginalPaths)
	if err != nil {
		err = core.SDKErrorf(err, "", "restoreToOriginalPaths-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "overwriteExisting", &obj.OverwriteExisting)
	if err != nil {
		err = core.SDKErrorf(err, "", "overwriteExisting-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "alternateRestoreDirectory", &obj.AlternateRestoreDirectory)
	if err != nil {
		err = core.SDKErrorf(err, "", "alternateRestoreDirectory-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "preserveAttributes", &obj.PreserveAttributes)
	if err != nil {
		err = core.SDKErrorf(err, "", "preserveAttributes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "preserveTimestamps", &obj.PreserveTimestamps)
	if err != nil {
		err = core.SDKErrorf(err, "", "preserveTimestamps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "preserveAcls", &obj.PreserveAcls)
	if err != nil {
		err = core.SDKErrorf(err, "", "preserveAcls-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "continueOnError", &obj.ContinueOnError)
	if err != nil {
		err = core.SDKErrorf(err, "", "continueOnError-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "saveSuccessFiles", &obj.SaveSuccessFiles)
	if err != nil {
		err = core.SDKErrorf(err, "", "saveSuccessFiles-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vlanConfig", &obj.VlanConfig, UnmarshalPhysicalTargetParamsForRecoverFileAndFolderVlanConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlanConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "restoreEntityType", &obj.RestoreEntityType)
	if err != nil {
		err = core.SDKErrorf(err, "", "restoreEntityType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalParams : Specifies the recovery options specific to Physical environment.
type RecoverPhysicalParams struct {
	// Specifies the list of Recover Object parameters. For recovering files, specifies the object contains the file to
	// recover.
	Objects []CommonRecoverObjectSnapshotParams `json:"objects" validate:"required"`

	// Specifies the type of recover action to be performed.
	RecoveryAction *string `json:"recoveryAction" validate:"required"`

	// Specifies the parameters to recover Physical Volumes.
	RecoverVolumeParams *RecoverPhysicalParamsRecoverVolumeParams `json:"recoverVolumeParams,omitempty"`

	// Specifies the parameters to mount Physical Volumes.
	MountVolumeParams *RecoverPhysicalParamsMountVolumeParams `json:"mountVolumeParams,omitempty"`

	// Specifies the parameters to perform a file and folder recovery.
	RecoverFileAndFolderParams *RecoverPhysicalParamsRecoverFileAndFolderParams `json:"recoverFileAndFolderParams,omitempty"`

	// Specifies the parameters to download files and folders.
	DownloadFileAndFolderParams *RecoverPhysicalParamsDownloadFileAndFolderParams `json:"downloadFileAndFolderParams,omitempty"`

	// Specifies the parameters to perform a system recovery.
	SystemRecoveryParams *RecoverPhysicalParamsSystemRecoveryParams `json:"systemRecoveryParams,omitempty"`
}

// Constants associated with the RecoverPhysicalParams.RecoveryAction property.
// Specifies the type of recover action to be performed.
const (
	RecoverPhysicalParams_RecoveryAction_Instantvolumemount     = "InstantVolumeMount"
	RecoverPhysicalParams_RecoveryAction_Recoverfiles           = "RecoverFiles"
	RecoverPhysicalParams_RecoveryAction_Recoverphysicalvolumes = "RecoverPhysicalVolumes"
	RecoverPhysicalParams_RecoveryAction_Recoversystem          = "RecoverSystem"
)

// NewRecoverPhysicalParams : Instantiate RecoverPhysicalParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverPhysicalParams(objects []CommonRecoverObjectSnapshotParams, recoveryAction string) (_model *RecoverPhysicalParams, err error) {
	_model = &RecoverPhysicalParams{
		Objects:        objects,
		RecoveryAction: core.StringPtr(recoveryAction),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverPhysicalParams unmarshals an instance of RecoverPhysicalParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalParams)
	err = core.UnmarshalModel(m, "objects", &obj.Objects, UnmarshalCommonRecoverObjectSnapshotParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "objects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoveryAction", &obj.RecoveryAction)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoveryAction-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "recoverVolumeParams", &obj.RecoverVolumeParams, UnmarshalRecoverPhysicalParamsRecoverVolumeParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverVolumeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mountVolumeParams", &obj.MountVolumeParams, UnmarshalRecoverPhysicalParamsMountVolumeParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountVolumeParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "recoverFileAndFolderParams", &obj.RecoverFileAndFolderParams, UnmarshalRecoverPhysicalParamsRecoverFileAndFolderParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverFileAndFolderParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "downloadFileAndFolderParams", &obj.DownloadFileAndFolderParams, UnmarshalRecoverPhysicalParamsDownloadFileAndFolderParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "downloadFileAndFolderParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "systemRecoveryParams", &obj.SystemRecoveryParams, UnmarshalRecoverPhysicalParamsSystemRecoveryParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "systemRecoveryParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalParamsDownloadFileAndFolderParams : Specifies the parameters to download files and folders.
type RecoverPhysicalParamsDownloadFileAndFolderParams struct {
	// Specifies the time upto which the download link is available.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// Specifies the info about the files and folders to be recovered.
	FilesAndFolders []CommonRecoverFileAndFolderInfo `json:"filesAndFolders,omitempty"`

	// Specifies the path location to download the files and folders.
	DownloadFilePath *string `json:"downloadFilePath,omitempty"`
}

// UnmarshalRecoverPhysicalParamsDownloadFileAndFolderParams unmarshals an instance of RecoverPhysicalParamsDownloadFileAndFolderParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalParamsDownloadFileAndFolderParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalParamsDownloadFileAndFolderParams)
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "filesAndFolders", &obj.FilesAndFolders, UnmarshalCommonRecoverFileAndFolderInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "filesAndFolders-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "downloadFilePath", &obj.DownloadFilePath)
	if err != nil {
		err = core.SDKErrorf(err, "", "downloadFilePath-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalParamsMountVolumeParams : Specifies the parameters to mount Physical Volumes.
type RecoverPhysicalParamsMountVolumeParams struct {
	// Specifies the environment of the recovery target. The corresponding params below must be filled out.
	TargetEnvironment *string `json:"targetEnvironment" validate:"required"`

	// Specifies the params for recovering to a physical target.
	PhysicalTargetParams *MountPhysicalVolumeParamsPhysicalTargetParams `json:"physicalTargetParams,omitempty"`
}

// Constants associated with the RecoverPhysicalParamsMountVolumeParams.TargetEnvironment property.
// Specifies the environment of the recovery target. The corresponding params below must be filled out.
const (
	RecoverPhysicalParamsMountVolumeParams_TargetEnvironment_Kphysical = "kPhysical"
)

// NewRecoverPhysicalParamsMountVolumeParams : Instantiate RecoverPhysicalParamsMountVolumeParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverPhysicalParamsMountVolumeParams(targetEnvironment string) (_model *RecoverPhysicalParamsMountVolumeParams, err error) {
	_model = &RecoverPhysicalParamsMountVolumeParams{
		TargetEnvironment: core.StringPtr(targetEnvironment),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverPhysicalParamsMountVolumeParams unmarshals an instance of RecoverPhysicalParamsMountVolumeParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalParamsMountVolumeParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalParamsMountVolumeParams)
	err = core.UnmarshalPrimitive(m, "targetEnvironment", &obj.TargetEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetEnvironment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalTargetParams", &obj.PhysicalTargetParams, UnmarshalMountPhysicalVolumeParamsPhysicalTargetParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalTargetParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalParamsRecoverFileAndFolderParams : Specifies the parameters to perform a file and folder recovery.
type RecoverPhysicalParamsRecoverFileAndFolderParams struct {
	// Specifies the information about the files and folders to be recovered.
	FilesAndFolders []CommonRecoverFileAndFolderInfo `json:"filesAndFolders" validate:"required"`

	// Specifies the environment of the recovery target. The corresponding params below must be filled out.
	TargetEnvironment *string `json:"targetEnvironment" validate:"required"`

	// Specifies the parameters to recover to a Physical target.
	PhysicalTargetParams *RecoverPhysicalFileAndFolderParamsPhysicalTargetParams `json:"physicalTargetParams,omitempty"`
}

// Constants associated with the RecoverPhysicalParamsRecoverFileAndFolderParams.TargetEnvironment property.
// Specifies the environment of the recovery target. The corresponding params below must be filled out.
const (
	RecoverPhysicalParamsRecoverFileAndFolderParams_TargetEnvironment_Kphysical = "kPhysical"
)

// NewRecoverPhysicalParamsRecoverFileAndFolderParams : Instantiate RecoverPhysicalParamsRecoverFileAndFolderParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverPhysicalParamsRecoverFileAndFolderParams(filesAndFolders []CommonRecoverFileAndFolderInfo, targetEnvironment string) (_model *RecoverPhysicalParamsRecoverFileAndFolderParams, err error) {
	_model = &RecoverPhysicalParamsRecoverFileAndFolderParams{
		FilesAndFolders:   filesAndFolders,
		TargetEnvironment: core.StringPtr(targetEnvironment),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverPhysicalParamsRecoverFileAndFolderParams unmarshals an instance of RecoverPhysicalParamsRecoverFileAndFolderParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalParamsRecoverFileAndFolderParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalParamsRecoverFileAndFolderParams)
	err = core.UnmarshalModel(m, "filesAndFolders", &obj.FilesAndFolders, UnmarshalCommonRecoverFileAndFolderInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "filesAndFolders-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetEnvironment", &obj.TargetEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetEnvironment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalTargetParams", &obj.PhysicalTargetParams, UnmarshalRecoverPhysicalFileAndFolderParamsPhysicalTargetParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalTargetParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalParamsRecoverVolumeParams : Specifies the parameters to recover Physical Volumes.
type RecoverPhysicalParamsRecoverVolumeParams struct {
	// Specifies the environment of the recovery target. The corresponding params below must be filled out.
	TargetEnvironment *string `json:"targetEnvironment" validate:"required"`

	// Specifies the params for recovering to a physical target.
	PhysicalTargetParams *RecoverPhysicalVolumeParamsPhysicalTargetParams `json:"physicalTargetParams,omitempty"`
}

// Constants associated with the RecoverPhysicalParamsRecoverVolumeParams.TargetEnvironment property.
// Specifies the environment of the recovery target. The corresponding params below must be filled out.
const (
	RecoverPhysicalParamsRecoverVolumeParams_TargetEnvironment_Kphysical = "kPhysical"
)

// NewRecoverPhysicalParamsRecoverVolumeParams : Instantiate RecoverPhysicalParamsRecoverVolumeParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverPhysicalParamsRecoverVolumeParams(targetEnvironment string) (_model *RecoverPhysicalParamsRecoverVolumeParams, err error) {
	_model = &RecoverPhysicalParamsRecoverVolumeParams{
		TargetEnvironment: core.StringPtr(targetEnvironment),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverPhysicalParamsRecoverVolumeParams unmarshals an instance of RecoverPhysicalParamsRecoverVolumeParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalParamsRecoverVolumeParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalParamsRecoverVolumeParams)
	err = core.UnmarshalPrimitive(m, "targetEnvironment", &obj.TargetEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetEnvironment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalTargetParams", &obj.PhysicalTargetParams, UnmarshalRecoverPhysicalVolumeParamsPhysicalTargetParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalTargetParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalParamsSystemRecoveryParams : Specifies the parameters to perform a system recovery.
type RecoverPhysicalParamsSystemRecoveryParams struct {
	// Specifies the path to the recovery view.
	FullNasPath *string `json:"fullNasPath,omitempty"`
}

// UnmarshalRecoverPhysicalParamsSystemRecoveryParams unmarshals an instance of RecoverPhysicalParamsSystemRecoveryParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalParamsSystemRecoveryParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalParamsSystemRecoveryParams)
	err = core.UnmarshalPrimitive(m, "fullNasPath", &obj.FullNasPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullNasPath-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverPhysicalVolumeParamsPhysicalTargetParams : Specifies the params for recovering to a physical target.
type RecoverPhysicalVolumeParamsPhysicalTargetParams struct {
	// Specifies the target entity where the volumes are being mounted.
	MountTarget *PhysicalTargetParamsForRecoverVolumeMountTarget `json:"mountTarget" validate:"required"`

	// Specifies the mapping from source volumes to destination volumes.
	VolumeMapping []RecoverVolumeMapping `json:"volumeMapping" validate:"required"`

	// Specifies whether volume would be dismounted first during LockVolume failure. If not specified, default is false.
	ForceUnmountVolume *bool `json:"forceUnmountVolume,omitempty"`

	// Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
	// automatically selected from one of the below options: a. If VLANs are configured on Cohesity, then the VLAN host/VIP
	// will be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on Cohesity,
	// then the partition hostname or VIPs will be used for Recovery.
	VlanConfig *PhysicalTargetParamsForRecoverVolumeVlanConfig `json:"vlanConfig,omitempty"`
}

// NewRecoverPhysicalVolumeParamsPhysicalTargetParams : Instantiate RecoverPhysicalVolumeParamsPhysicalTargetParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverPhysicalVolumeParamsPhysicalTargetParams(mountTarget *PhysicalTargetParamsForRecoverVolumeMountTarget, volumeMapping []RecoverVolumeMapping) (_model *RecoverPhysicalVolumeParamsPhysicalTargetParams, err error) {
	_model = &RecoverPhysicalVolumeParamsPhysicalTargetParams{
		MountTarget:   mountTarget,
		VolumeMapping: volumeMapping,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverPhysicalVolumeParamsPhysicalTargetParams unmarshals an instance of RecoverPhysicalVolumeParamsPhysicalTargetParams from the specified map of raw messages.
func UnmarshalRecoverPhysicalVolumeParamsPhysicalTargetParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverPhysicalVolumeParamsPhysicalTargetParams)
	err = core.UnmarshalModel(m, "mountTarget", &obj.MountTarget, UnmarshalPhysicalTargetParamsForRecoverVolumeMountTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "mountTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "volumeMapping", &obj.VolumeMapping, UnmarshalRecoverVolumeMapping)
	if err != nil {
		err = core.SDKErrorf(err, "", "volumeMapping-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "forceUnmountVolume", &obj.ForceUnmountVolume)
	if err != nil {
		err = core.SDKErrorf(err, "", "forceUnmountVolume-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vlanConfig", &obj.VlanConfig, UnmarshalPhysicalTargetParamsForRecoverVolumeVlanConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlanConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverSqlAppNewSourceConfig : Specifies the new destination Source configuration where the databases will be recovered.
type RecoverSqlAppNewSourceConfig struct {
	// Specifies whether to keep CDC (Change Data Capture) on recovered databases or not. If not passed, this is assumed to
	// be true. If withNoRecovery is passed as true, then this field must not be set to true. Passing this field as true in
	// this scenario will be a invalid request.
	KeepCdc *bool `json:"keepCdc,omitempty"`

	// Specifies the parameters related to multi stage Sql restore.
	MultiStageRestoreOptions *MultiStageRestoreOptions `json:"multiStageRestoreOptions,omitempty"`

	// Specifies the WITH clause to be used in native sql log restore command. This is only applicable for native log
	// restore.
	NativeLogRecoveryWithClause *string `json:"nativeLogRecoveryWithClause,omitempty"`

	// 'with_clause' contains 'with clause' to be used in native sql restore command. This is only applicable for database
	// restore of native sql backup. Here user can specify multiple restore options. Example: 'WITH BUFFERCOUNT = 575,
	// MAXTRANSFERSIZE = 2097152'.
	NativeRecoveryWithClause *string `json:"nativeRecoveryWithClause,omitempty"`

	// Specifies a policy to be used while recovering existing databases.
	OverwritingPolicy *string `json:"overwritingPolicy,omitempty"`

	// Specifies the option to set replay last log bit while creating the sql restore task and doing restore to latest
	// point-in-time. If this is set to true, we will replay the entire last log without STOPAT.
	ReplayEntireLastLog *bool `json:"replayEntireLastLog,omitempty"`

	// Specifies the time in the past to which the Sql database needs to be restored. This allows for granular recovery of
	// Sql databases. If this is not set, the Sql database will be restored from the full/incremental snapshot.
	RestoreTimeUsecs *int64 `json:"restoreTimeUsecs,omitempty"`

	// Specifies the secondary data filename pattern and corresponding direcories of the DB. Secondary data files are
	// optional and are user defined. The recommended file extention for secondary files is ".ndf". If this option is
	// specified and the destination folders do not exist they will be automatically created.
	SecondaryDataFilesDirList []FilenamePatternToDirectory `json:"secondaryDataFilesDirList,omitempty"`

	// Specifies the flag to bring DBs online or not after successful recovery. If this is passed as true, then it means
	// DBs won't be brought online.
	WithNoRecovery *bool `json:"withNoRecovery,omitempty"`

	// Specifies the directory where to put the database data files. Missing directory will be automatically created.
	DataFileDirectoryLocation *string `json:"dataFileDirectoryLocation" validate:"required"`

	// Specifies a new name for the restored database. If this field is not specified, then the original database will be
	// overwritten after recovery.
	DatabaseName *string `json:"databaseName,omitempty"`

	// Specifies the source id of target host where databases will be recovered. This source id can be a physical host or
	// virtual machine.
	Host *RecoveryObjectIdentifier `json:"host" validate:"required"`

	// Specifies an instance name of the Sql Server that should be used for restoring databases to.
	InstanceName *string `json:"instanceName" validate:"required"`

	// Specifies the directory where to put the database log files. Missing directory will be automatically created.
	LogFileDirectoryLocation *string `json:"logFileDirectoryLocation" validate:"required"`
}

// Constants associated with the RecoverSqlAppNewSourceConfig.OverwritingPolicy property.
// Specifies a policy to be used while recovering existing databases.
const (
	RecoverSqlAppNewSourceConfig_OverwritingPolicy_Failifexists = "FailIfExists"
	RecoverSqlAppNewSourceConfig_OverwritingPolicy_Overwrite    = "Overwrite"
)

// NewRecoverSqlAppNewSourceConfig : Instantiate RecoverSqlAppNewSourceConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverSqlAppNewSourceConfig(dataFileDirectoryLocation string, host *RecoveryObjectIdentifier, instanceName string, logFileDirectoryLocation string) (_model *RecoverSqlAppNewSourceConfig, err error) {
	_model = &RecoverSqlAppNewSourceConfig{
		DataFileDirectoryLocation: core.StringPtr(dataFileDirectoryLocation),
		Host:                      host,
		InstanceName:              core.StringPtr(instanceName),
		LogFileDirectoryLocation:  core.StringPtr(logFileDirectoryLocation),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverSqlAppNewSourceConfig unmarshals an instance of RecoverSqlAppNewSourceConfig from the specified map of raw messages.
func UnmarshalRecoverSqlAppNewSourceConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverSqlAppNewSourceConfig)
	err = core.UnmarshalPrimitive(m, "keepCdc", &obj.KeepCdc)
	if err != nil {
		err = core.SDKErrorf(err, "", "keepCdc-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "multiStageRestoreOptions", &obj.MultiStageRestoreOptions, UnmarshalMultiStageRestoreOptions)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiStageRestoreOptions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nativeLogRecoveryWithClause", &obj.NativeLogRecoveryWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "nativeLogRecoveryWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nativeRecoveryWithClause", &obj.NativeRecoveryWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "nativeRecoveryWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "overwritingPolicy", &obj.OverwritingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "overwritingPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "replayEntireLastLog", &obj.ReplayEntireLastLog)
	if err != nil {
		err = core.SDKErrorf(err, "", "replayEntireLastLog-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "restoreTimeUsecs", &obj.RestoreTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "restoreTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "secondaryDataFilesDirList", &obj.SecondaryDataFilesDirList, UnmarshalFilenamePatternToDirectory)
	if err != nil {
		err = core.SDKErrorf(err, "", "secondaryDataFilesDirList-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "withNoRecovery", &obj.WithNoRecovery)
	if err != nil {
		err = core.SDKErrorf(err, "", "withNoRecovery-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataFileDirectoryLocation", &obj.DataFileDirectoryLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataFileDirectoryLocation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "databaseName", &obj.DatabaseName)
	if err != nil {
		err = core.SDKErrorf(err, "", "databaseName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "host", &obj.Host, UnmarshalRecoveryObjectIdentifier)
	if err != nil {
		err = core.SDKErrorf(err, "", "host-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceName", &obj.InstanceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "instanceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logFileDirectoryLocation", &obj.LogFileDirectoryLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "logFileDirectoryLocation-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverSqlAppOriginalSourceConfig : Specifies the additional Source configuration parameters when databases will be recovered to original location.
type RecoverSqlAppOriginalSourceConfig struct {
	// Specifies whether to keep CDC (Change Data Capture) on recovered databases or not. If not passed, this is assumed to
	// be true. If withNoRecovery is passed as true, then this field must not be set to true. Passing this field as true in
	// this scenario will be a invalid request.
	KeepCdc *bool `json:"keepCdc,omitempty"`

	// Specifies the parameters related to multi stage Sql restore.
	MultiStageRestoreOptions *MultiStageRestoreOptions `json:"multiStageRestoreOptions,omitempty"`

	// Specifies the WITH clause to be used in native sql log restore command. This is only applicable for native log
	// restore.
	NativeLogRecoveryWithClause *string `json:"nativeLogRecoveryWithClause,omitempty"`

	// 'with_clause' contains 'with clause' to be used in native sql restore command. This is only applicable for database
	// restore of native sql backup. Here user can specify multiple restore options. Example: 'WITH BUFFERCOUNT = 575,
	// MAXTRANSFERSIZE = 2097152'.
	NativeRecoveryWithClause *string `json:"nativeRecoveryWithClause,omitempty"`

	// Specifies a policy to be used while recovering existing databases.
	OverwritingPolicy *string `json:"overwritingPolicy,omitempty"`

	// Specifies the option to set replay last log bit while creating the sql restore task and doing restore to latest
	// point-in-time. If this is set to true, we will replay the entire last log without STOPAT.
	ReplayEntireLastLog *bool `json:"replayEntireLastLog,omitempty"`

	// Specifies the time in the past to which the Sql database needs to be restored. This allows for granular recovery of
	// Sql databases. If this is not set, the Sql database will be restored from the full/incremental snapshot.
	RestoreTimeUsecs *int64 `json:"restoreTimeUsecs,omitempty"`

	// Specifies the secondary data filename pattern and corresponding direcories of the DB. Secondary data files are
	// optional and are user defined. The recommended file extention for secondary files is ".ndf". If this option is
	// specified and the destination folders do not exist they will be automatically created.
	SecondaryDataFilesDirList []FilenamePatternToDirectory `json:"secondaryDataFilesDirList,omitempty"`

	// Specifies the flag to bring DBs online or not after successful recovery. If this is passed as true, then it means
	// DBs won't be brought online.
	WithNoRecovery *bool `json:"withNoRecovery,omitempty"`

	// Set this to true if tail logs are to be captured before the recovery operation. This is only applicable if database
	// is not being renamed.
	CaptureTailLogs *bool `json:"captureTailLogs,omitempty"`

	// Specifies the directory where to put the database data files. Missing directory will be automatically created. If
	// you are overwriting the existing database then this field will be ignored.
	DataFileDirectoryLocation *string `json:"dataFileDirectoryLocation,omitempty"`

	// Specifies the directory where to put the database log files. Missing directory will be automatically created. If you
	// are overwriting the existing database then this field will be ignored.
	LogFileDirectoryLocation *string `json:"logFileDirectoryLocation,omitempty"`

	// Specifies a new name for the restored database. If this field is not specified, then the original database will be
	// overwritten after recovery.
	NewDatabaseName *string `json:"newDatabaseName,omitempty"`
}

// Constants associated with the RecoverSqlAppOriginalSourceConfig.OverwritingPolicy property.
// Specifies a policy to be used while recovering existing databases.
const (
	RecoverSqlAppOriginalSourceConfig_OverwritingPolicy_Failifexists = "FailIfExists"
	RecoverSqlAppOriginalSourceConfig_OverwritingPolicy_Overwrite    = "Overwrite"
)

// UnmarshalRecoverSqlAppOriginalSourceConfig unmarshals an instance of RecoverSqlAppOriginalSourceConfig from the specified map of raw messages.
func UnmarshalRecoverSqlAppOriginalSourceConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverSqlAppOriginalSourceConfig)
	err = core.UnmarshalPrimitive(m, "keepCdc", &obj.KeepCdc)
	if err != nil {
		err = core.SDKErrorf(err, "", "keepCdc-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "multiStageRestoreOptions", &obj.MultiStageRestoreOptions, UnmarshalMultiStageRestoreOptions)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiStageRestoreOptions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nativeLogRecoveryWithClause", &obj.NativeLogRecoveryWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "nativeLogRecoveryWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nativeRecoveryWithClause", &obj.NativeRecoveryWithClause)
	if err != nil {
		err = core.SDKErrorf(err, "", "nativeRecoveryWithClause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "overwritingPolicy", &obj.OverwritingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "overwritingPolicy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "replayEntireLastLog", &obj.ReplayEntireLastLog)
	if err != nil {
		err = core.SDKErrorf(err, "", "replayEntireLastLog-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "restoreTimeUsecs", &obj.RestoreTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "restoreTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "secondaryDataFilesDirList", &obj.SecondaryDataFilesDirList, UnmarshalFilenamePatternToDirectory)
	if err != nil {
		err = core.SDKErrorf(err, "", "secondaryDataFilesDirList-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "withNoRecovery", &obj.WithNoRecovery)
	if err != nil {
		err = core.SDKErrorf(err, "", "withNoRecovery-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "captureTailLogs", &obj.CaptureTailLogs)
	if err != nil {
		err = core.SDKErrorf(err, "", "captureTailLogs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataFileDirectoryLocation", &obj.DataFileDirectoryLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataFileDirectoryLocation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logFileDirectoryLocation", &obj.LogFileDirectoryLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "logFileDirectoryLocation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "newDatabaseName", &obj.NewDatabaseName)
	if err != nil {
		err = core.SDKErrorf(err, "", "newDatabaseName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverSqlAppParams : Specifies the parameters to recover Sql databases.
type RecoverSqlAppParams struct {
	// Specifies the snapshot id.
	SnapshotID *string `json:"snapshotId" validate:"required"`

	// Specifies the timestamp (in microseconds. from epoch) for recovering to a point-in-time in the past.
	PointInTimeUsecs *int64 `json:"pointInTimeUsecs,omitempty"`

	// Specifies the protection group id of the object snapshot.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies the protection group name of the object snapshot.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the time when the snapshot is created in Unix timestamp epoch in microseconds.
	SnapshotCreationTimeUsecs *int64 `json:"snapshotCreationTimeUsecs,omitempty"`

	// Specifies the information about the object for which the snapshot is taken.
	ObjectInfo *CommonRecoverObjectSnapshotParamsObjectInfo `json:"objectInfo,omitempty"`

	// Specifies the snapshot target type.
	SnapshotTargetType *string `json:"snapshotTargetType,omitempty"`

	// Specifies the archival target information if the snapshot is an archival snapshot.
	ArchivalTargetInfo *CommonRecoverObjectSnapshotParamsArchivalTargetInfo `json:"archivalTargetInfo,omitempty"`

	// Progress monitor task id for Recovery of VM.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Specifies that user wants to perform standby restore if it is enabled for this object.
	RecoverFromStandby *bool `json:"recoverFromStandby,omitempty"`

	// Status of the Recovery. 'Running' indicates that the Recovery is still running. 'Canceled' indicates that the
	// Recovery has been cancelled. 'Canceling' indicates that the Recovery is in the process of being cancelled. 'Failed'
	// indicates that the Recovery has failed. 'Succeeded' indicates that the Recovery has finished successfully.
	// 'SucceededWithWarning' indicates that the Recovery finished successfully, but there were some warning messages.
	// 'Skipped' indicates that the Recovery task was skipped.
	Status *string `json:"status,omitempty"`

	// Specifies the start time of the Recovery in Unix timestamp epoch in microseconds.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of the Recovery in Unix timestamp epoch in microseconds. This field will be populated only
	// after Recovery is finished.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specify error messages about the object.
	Messages []string `json:"messages,omitempty"`

	// Specify the total bytes restored.
	BytesRestored *int64 `json:"bytesRestored,omitempty"`

	// Object details for Mssql.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
	// hosted by another object such as VM or physical server.
	HostInfo *HostInformation `json:"hostInfo,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`

	// Specifies the params for recovering to a sql host. Specifiy seperate settings for each db object that need to be
	// recovered. Provided sql backup should be recovered to same type of target host. For Example: If you have sql backup
	// taken from a physical host then that should be recovered to physical host only.
	SqlTargetParams *SqlTargetParamsForRecoverSqlApp `json:"sqlTargetParams,omitempty"`

	// Specifies the environment of the recovery target. The corresponding params below must be filled out.
	TargetEnvironment *string `json:"targetEnvironment" validate:"required"`
}

// Constants associated with the RecoverSqlAppParams.SnapshotTargetType property.
// Specifies the snapshot target type.
const (
	RecoverSqlAppParams_SnapshotTargetType_Archival             = "Archival"
	RecoverSqlAppParams_SnapshotTargetType_Local                = "Local"
	RecoverSqlAppParams_SnapshotTargetType_Remote               = "Remote"
	RecoverSqlAppParams_SnapshotTargetType_Rpaasarchival        = "RpaasArchival"
	RecoverSqlAppParams_SnapshotTargetType_Storagearraysnapshot = "StorageArraySnapshot"
)

// Constants associated with the RecoverSqlAppParams.Status property.
// Status of the Recovery. 'Running' indicates that the Recovery is still running. 'Canceled' indicates that the
// Recovery has been cancelled. 'Canceling' indicates that the Recovery is in the process of being cancelled. 'Failed'
// indicates that the Recovery has failed. 'Succeeded' indicates that the Recovery has finished successfully.
// 'SucceededWithWarning' indicates that the Recovery finished successfully, but there were some warning messages.
// 'Skipped' indicates that the Recovery task was skipped.
const (
	RecoverSqlAppParams_Status_Accepted             = "Accepted"
	RecoverSqlAppParams_Status_Canceled             = "Canceled"
	RecoverSqlAppParams_Status_Canceling            = "Canceling"
	RecoverSqlAppParams_Status_Failed               = "Failed"
	RecoverSqlAppParams_Status_Finalizing           = "Finalizing"
	RecoverSqlAppParams_Status_Legalhold            = "LegalHold"
	RecoverSqlAppParams_Status_Missed               = "Missed"
	RecoverSqlAppParams_Status_Onhold               = "OnHold"
	RecoverSqlAppParams_Status_Running              = "Running"
	RecoverSqlAppParams_Status_Skipped              = "Skipped"
	RecoverSqlAppParams_Status_Succeeded            = "Succeeded"
	RecoverSqlAppParams_Status_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the RecoverSqlAppParams.TargetEnvironment property.
// Specifies the environment of the recovery target. The corresponding params below must be filled out.
const (
	RecoverSqlAppParams_TargetEnvironment_Ksql = "kSQL"
)

// NewRecoverSqlAppParams : Instantiate RecoverSqlAppParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverSqlAppParams(snapshotID string, targetEnvironment string) (_model *RecoverSqlAppParams, err error) {
	_model = &RecoverSqlAppParams{
		SnapshotID:        core.StringPtr(snapshotID),
		TargetEnvironment: core.StringPtr(targetEnvironment),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverSqlAppParams unmarshals an instance of RecoverSqlAppParams from the specified map of raw messages.
func UnmarshalRecoverSqlAppParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverSqlAppParams)
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "pointInTimeUsecs", &obj.PointInTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "pointInTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotCreationTimeUsecs", &obj.SnapshotCreationTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotCreationTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objectInfo", &obj.ObjectInfo, UnmarshalCommonRecoverObjectSnapshotParamsObjectInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotTargetType", &obj.SnapshotTargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTargetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalTargetInfo", &obj.ArchivalTargetInfo, UnmarshalCommonRecoverObjectSnapshotParamsArchivalTargetInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoverFromStandby", &obj.RecoverFromStandby)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverFromStandby-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		err = core.SDKErrorf(err, "", "messages-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bytesRestored", &obj.BytesRestored)
	if err != nil {
		err = core.SDKErrorf(err, "", "bytesRestored-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "aagInfo", &obj.AagInfo, UnmarshalAAGInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostInfo", &obj.HostInfo, UnmarshalHostInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sqlTargetParams", &obj.SqlTargetParams, UnmarshalSqlTargetParamsForRecoverSqlApp)
	if err != nil {
		err = core.SDKErrorf(err, "", "sqlTargetParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetEnvironment", &obj.TargetEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetEnvironment-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverSqlParams : Specifies the recovery options specific to Sql environment.
type RecoverSqlParams struct {
	// Specifies the parameters to recover Sql databases.
	RecoverAppParams []RecoverSqlAppParams `json:"recoverAppParams,omitempty"`

	// Specifies the type of recover action to be performed.
	RecoveryAction *string `json:"recoveryAction" validate:"required"`

	// Specifies VLAN Params associated with the recovered. If this is not specified, then the VLAN settings will be
	// automatically selected from one of the below options: a. If VLANs are configured on IBM, then the VLAN host/VIP will
	// be automatically based on the client's (e.g. ESXI host) IP address. b. If VLANs are not configured on IBM, then the
	// partition hostname or VIPs will be used for Recovery.
	VlanConfig *RecoveryVlanConfig `json:"vlanConfig,omitempty"`
}

// Constants associated with the RecoverSqlParams.RecoveryAction property.
// Specifies the type of recover action to be performed.
const (
	RecoverSqlParams_RecoveryAction_Cloneapps   = "CloneApps"
	RecoverSqlParams_RecoveryAction_Recoverapps = "RecoverApps"
)

// NewRecoverSqlParams : Instantiate RecoverSqlParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverSqlParams(recoveryAction string) (_model *RecoverSqlParams, err error) {
	_model = &RecoverSqlParams{
		RecoveryAction: core.StringPtr(recoveryAction),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverSqlParams unmarshals an instance of RecoverSqlParams from the specified map of raw messages.
func UnmarshalRecoverSqlParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverSqlParams)
	err = core.UnmarshalModel(m, "recoverAppParams", &obj.RecoverAppParams, UnmarshalRecoverSqlAppParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverAppParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoveryAction", &obj.RecoveryAction)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoveryAction-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vlanConfig", &obj.VlanConfig, UnmarshalRecoveryVlanConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlanConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverTarget : Specifies the target entity to recover to.
type RecoverTarget struct {
	// Specifies the id of the object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the id of the parent source of the target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ParentSourceID *int64 `json:"parentSourceId,omitempty"`

	// Specifies the name of the parent source of the target.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ParentSourceName *string `json:"parentSourceName,omitempty"`
}

// NewRecoverTarget : Instantiate RecoverTarget (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverTarget(id int64) (_model *RecoverTarget, err error) {
	_model = &RecoverTarget{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverTarget unmarshals an instance of RecoverTarget from the specified map of raw messages.
func UnmarshalRecoverTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverTarget)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentSourceId", &obj.ParentSourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentSourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentSourceName", &obj.ParentSourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentSourceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoverVolumeMapping : Specifies the mapping from a source volume to a destination volume.
type RecoverVolumeMapping struct {
	// Specifies the guid of the source volume.
	SourceVolumeGuid *string `json:"sourceVolumeGuid" validate:"required"`

	// Specifies the guid of the destination volume.
	DestinationVolumeGuid *string `json:"destinationVolumeGuid" validate:"required"`
}

// NewRecoverVolumeMapping : Instantiate RecoverVolumeMapping (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoverVolumeMapping(sourceVolumeGuid string, destinationVolumeGuid string) (_model *RecoverVolumeMapping, err error) {
	_model = &RecoverVolumeMapping{
		SourceVolumeGuid:      core.StringPtr(sourceVolumeGuid),
		DestinationVolumeGuid: core.StringPtr(destinationVolumeGuid),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoverVolumeMapping unmarshals an instance of RecoverVolumeMapping from the specified map of raw messages.
func UnmarshalRecoverVolumeMapping(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoverVolumeMapping)
	err = core.UnmarshalPrimitive(m, "sourceVolumeGuid", &obj.SourceVolumeGuid)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceVolumeGuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "destinationVolumeGuid", &obj.DestinationVolumeGuid)
	if err != nil {
		err = core.SDKErrorf(err, "", "destinationVolumeGuid-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoveriesResponse : Specifies list of Recoveries.
type RecoveriesResponse struct {
	// Specifies list of Recoveries.
	Recoveries []Recovery `json:"recoveries,omitempty"`
}

// UnmarshalRecoveriesResponse unmarshals an instance of RecoveriesResponse from the specified map of raw messages.
func UnmarshalRecoveriesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoveriesResponse)
	err = core.UnmarshalModel(m, "recoveries", &obj.Recoveries, UnmarshalRecovery)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoveries-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Recovery : Specifies the common response parameters to create a Recovery.
type Recovery struct {
	// Specifies the id of the Recovery.
	ID *string `json:"id,omitempty"`

	// Specifies the name of the Recovery.
	Name *string `json:"name,omitempty"`

	// Specifies the start time of the Recovery in Unix timestamp epoch in microseconds.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of the Recovery in Unix timestamp epoch in microseconds. This field will be populated only
	// after Recovery is finished.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Status of the Recovery. 'Running' indicates that the Recovery is still running. 'Canceled' indicates that the
	// Recovery has been cancelled. 'Canceling' indicates that the Recovery is in the process of being cancelled. 'Failed'
	// indicates that the Recovery has failed. 'Succeeded' indicates that the Recovery has finished successfully.
	// 'SucceededWithWarning' indicates that the Recovery finished successfully, but there were some warning messages.
	// 'Skipped' indicates that the Recovery task was skipped.
	Status *string `json:"status,omitempty"`

	// Progress monitor task id for Recovery.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Specifies the type of snapshot environment for which the Recovery was performed.
	SnapshotEnvironment *string `json:"snapshotEnvironment,omitempty"`

	// Specifies the type of recover action.
	RecoveryAction *string `json:"recoveryAction,omitempty"`

	// Specifies the list of tenants that have permissions for this recovery.
	Permissions []Tenant `json:"permissions,omitempty"`

	// Specifies the information about the creation of the protection group or recovery.
	CreationInfo *CreationInfo `json:"creationInfo,omitempty"`

	// Specifies whether it's possible to tear down the objects created by the recovery.
	CanTearDown *bool `json:"canTearDown,omitempty"`

	// Specifies the status of the tear down operation. This is only set when the canTearDown is set to true.
	// 'DestroyScheduled' indicates that the tear down is ready to schedule. 'Destroying' indicates that the tear down is
	// still running. 'Destroyed' indicates that the tear down succeeded. 'DestroyError' indicates that the tear down
	// failed.
	TearDownStatus *string `json:"tearDownStatus,omitempty"`

	// Specifies the error message about the tear down operation if it fails.
	TearDownMessage *string `json:"tearDownMessage,omitempty"`

	// Specifies messages about the recovery.
	Messages []string `json:"messages,omitempty"`

	// Specifies whether the current recovery operation has created child recoveries. This is currently used in SQL
	// recovery where multiple child recoveries can be tracked under a common/parent recovery.
	IsParentRecovery *bool `json:"isParentRecovery,omitempty"`

	// If current recovery is child recovery triggered by another parent recovery operation, then this field willt specify
	// the id of the parent recovery.
	ParentRecoveryID *string `json:"parentRecoveryId,omitempty"`

	// Specifies the list of persistent state of a retrieve of an archive task.
	RetrieveArchiveTasks []RetrieveArchiveTask `json:"retrieveArchiveTasks,omitempty"`

	// Specifies whether the current recovery operation is a multi-stage restore operation. This is currently used by
	// VMware recoveres for the migration/hot-standby use case.
	IsMultiStageRestore *bool `json:"isMultiStageRestore,omitempty"`

	// Specifies the recovery options specific to Physical environment.
	PhysicalParams *RecoverPhysicalParams `json:"physicalParams,omitempty"`

	// Specifies the recovery options specific to Sql environment.
	MssqlParams *RecoverSqlParams `json:"mssqlParams,omitempty"`
}

// Constants associated with the Recovery.Status property.
// Status of the Recovery. 'Running' indicates that the Recovery is still running. 'Canceled' indicates that the
// Recovery has been cancelled. 'Canceling' indicates that the Recovery is in the process of being cancelled. 'Failed'
// indicates that the Recovery has failed. 'Succeeded' indicates that the Recovery has finished successfully.
// 'SucceededWithWarning' indicates that the Recovery finished successfully, but there were some warning messages.
// 'Skipped' indicates that the Recovery task was skipped.
const (
	Recovery_Status_Accepted             = "Accepted"
	Recovery_Status_Canceled             = "Canceled"
	Recovery_Status_Canceling            = "Canceling"
	Recovery_Status_Failed               = "Failed"
	Recovery_Status_Finalizing           = "Finalizing"
	Recovery_Status_Legalhold            = "LegalHold"
	Recovery_Status_Missed               = "Missed"
	Recovery_Status_Onhold               = "OnHold"
	Recovery_Status_Running              = "Running"
	Recovery_Status_Skipped              = "Skipped"
	Recovery_Status_Succeeded            = "Succeeded"
	Recovery_Status_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the Recovery.SnapshotEnvironment property.
// Specifies the type of snapshot environment for which the Recovery was performed.
const (
	Recovery_SnapshotEnvironment_Kphysical = "kPhysical"
	Recovery_SnapshotEnvironment_Ksql      = "kSQL"
)

// Constants associated with the Recovery.RecoveryAction property.
// Specifies the type of recover action.
const (
	Recovery_RecoveryAction_Cloneapps               = "CloneApps"
	Recovery_RecoveryAction_Cloneappview            = "CloneAppView"
	Recovery_RecoveryAction_Clonerefreshapp         = "CloneRefreshApp"
	Recovery_RecoveryAction_Cloneview               = "CloneView"
	Recovery_RecoveryAction_Clonevms                = "CloneVMs"
	Recovery_RecoveryAction_Clonevmstoview          = "CloneVMsToView"
	Recovery_RecoveryAction_Convertanddeployvms     = "ConvertAndDeployVMs"
	Recovery_RecoveryAction_Converttopst            = "ConvertToPst"
	Recovery_RecoveryAction_Deployvms               = "DeployVMs"
	Recovery_RecoveryAction_Downloadchats           = "DownloadChats"
	Recovery_RecoveryAction_Downloadfilesandfolders = "DownloadFilesAndFolders"
	Recovery_RecoveryAction_Instantvolumemount      = "InstantVolumeMount"
	Recovery_RecoveryAction_Recoverapps             = "RecoverApps"
	Recovery_RecoveryAction_Recoveraurora           = "RecoverAurora"
	Recovery_RecoveryAction_Recoverazuresql         = "RecoverAzureSQL"
	Recovery_RecoveryAction_Recoverexchangedbs      = "RecoverExchangeDbs"
	Recovery_RecoveryAction_Recoverfiles            = "RecoverFiles"
	Recovery_RecoveryAction_Recovermailbox          = "RecoverMailbox"
	Recovery_RecoveryAction_Recovermailboxcsm       = "RecoverMailboxCSM"
	Recovery_RecoveryAction_Recovermsgroup          = "RecoverMsGroup"
	Recovery_RecoveryAction_Recovermsteam           = "RecoverMsTeam"
	Recovery_RecoveryAction_Recovernamespaces       = "RecoverNamespaces"
	Recovery_RecoveryAction_Recovernasvolume        = "RecoverNasVolume"
	Recovery_RecoveryAction_Recoverobjects          = "RecoverObjects"
	Recovery_RecoveryAction_Recoveronedrive         = "RecoverOneDrive"
	Recovery_RecoveryAction_Recoveronedrivecsm      = "RecoverOneDriveCSM"
	Recovery_RecoveryAction_Recoverphysicalvolumes  = "RecoverPhysicalVolumes"
	Recovery_RecoveryAction_Recoverpublicfolders    = "RecoverPublicFolders"
	Recovery_RecoveryAction_Recoverrds              = "RecoverRDS"
	Recovery_RecoveryAction_Recoverrdspostgres      = "RecoverRDSPostgres"
	Recovery_RecoveryAction_Recovers3buckets        = "RecoverS3Buckets"
	Recovery_RecoveryAction_Recoversangroup         = "RecoverSanGroup"
	Recovery_RecoveryAction_Recoversanvolumes       = "RecoverSanVolumes"
	Recovery_RecoveryAction_Recoversfdcobjects      = "RecoverSfdcObjects"
	Recovery_RecoveryAction_Recoversfdcorg          = "RecoverSfdcOrg"
	Recovery_RecoveryAction_Recoversfdcrecords      = "RecoverSfdcRecords"
	Recovery_RecoveryAction_Recoversharepoint       = "RecoverSharePoint"
	Recovery_RecoveryAction_Recoversharepointcsm    = "RecoverSharePointCSM"
	Recovery_RecoveryAction_Recoversystem           = "RecoverSystem"
	Recovery_RecoveryAction_Recovervapps            = "RecoverVApps"
	Recovery_RecoveryAction_Recovervapptemplates    = "RecoverVAppTemplates"
	Recovery_RecoveryAction_Recovervmdisks          = "RecoverVmDisks"
	Recovery_RecoveryAction_Recovervms              = "RecoverVMs"
	Recovery_RecoveryAction_Uptiersnapshot          = "UptierSnapshot"
)

// Constants associated with the Recovery.TearDownStatus property.
// Specifies the status of the tear down operation. This is only set when the canTearDown is set to true.
// 'DestroyScheduled' indicates that the tear down is ready to schedule. 'Destroying' indicates that the tear down is
// still running. 'Destroyed' indicates that the tear down succeeded. 'DestroyError' indicates that the tear down
// failed.
const (
	Recovery_TearDownStatus_Destroyed        = "Destroyed"
	Recovery_TearDownStatus_Destroyerror     = "DestroyError"
	Recovery_TearDownStatus_Destroying       = "Destroying"
	Recovery_TearDownStatus_Destroyscheduled = "DestroyScheduled"
)

// UnmarshalRecovery unmarshals an instance of Recovery from the specified map of raw messages.
func UnmarshalRecovery(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Recovery)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotEnvironment", &obj.SnapshotEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotEnvironment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoveryAction", &obj.RecoveryAction)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoveryAction-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalTenant)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "creationInfo", &obj.CreationInfo, UnmarshalCreationInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "canTearDown", &obj.CanTearDown)
	if err != nil {
		err = core.SDKErrorf(err, "", "canTearDown-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tearDownStatus", &obj.TearDownStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "tearDownStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tearDownMessage", &obj.TearDownMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "tearDownMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		err = core.SDKErrorf(err, "", "messages-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isParentRecovery", &obj.IsParentRecovery)
	if err != nil {
		err = core.SDKErrorf(err, "", "isParentRecovery-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "parentRecoveryId", &obj.ParentRecoveryID)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentRecoveryId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retrieveArchiveTasks", &obj.RetrieveArchiveTasks, UnmarshalRetrieveArchiveTask)
	if err != nil {
		err = core.SDKErrorf(err, "", "retrieveArchiveTasks-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isMultiStageRestore", &obj.IsMultiStageRestore)
	if err != nil {
		err = core.SDKErrorf(err, "", "isMultiStageRestore-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalRecoverPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalRecoverSqlParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoveryObjectIdentifier : Specifies the object identifier to perform recovery.
type RecoveryObjectIdentifier struct {
	// Specifies the id of the object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the object.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	Name *string `json:"name,omitempty"`
}

// NewRecoveryObjectIdentifier : Instantiate RecoveryObjectIdentifier (Generic Model Constructor)
func (*BackupRecoveryV1) NewRecoveryObjectIdentifier(id int64) (_model *RecoveryObjectIdentifier, err error) {
	_model = &RecoveryObjectIdentifier{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRecoveryObjectIdentifier unmarshals an instance of RecoveryObjectIdentifier from the specified map of raw messages.
func UnmarshalRecoveryObjectIdentifier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoveryObjectIdentifier)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoveryTimeRangeInfo : Specifies a valid time range to which this object can be recovered.
type RecoveryTimeRangeInfo struct {
	// Specifies the end time of this time range.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies id of the Protection Group corresponding to this time range.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies the start time of this time range.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`
}

// UnmarshalRecoveryTimeRangeInfo unmarshals an instance of RecoveryTimeRangeInfo from the specified map of raw messages.
func UnmarshalRecoveryTimeRangeInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoveryTimeRangeInfo)
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RecoveryVlanConfig : Specifies the VLAN configuration for Recovery.
type RecoveryVlanConfig struct {
	// If this is set, then the Cohesity host name or the IP address associated with this vlan is used for mounting
	// Cohesity's view on the remote host.
	ID *int64 `json:"id,omitempty"`

	// If this is set to true, then even if VLANs are configured on the system, the partition VIPs will be used for the
	// Recovery.
	DisableVlan *bool `json:"disableVlan,omitempty"`

	// Interface group to use for Recovery.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// UnmarshalRecoveryVlanConfig unmarshals an instance of RecoveryVlanConfig from the specified map of raw messages.
func UnmarshalRecoveryVlanConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RecoveryVlanConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "disableVlan", &obj.DisableVlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "disableVlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "interfaceName", &obj.InterfaceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "interfaceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RefreshProtectionSourceByIdOptions : The RefreshProtectionSourceByID options.
type RefreshProtectionSourceByIdOptions struct {
	// Specifies the id of the Protection Source.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRefreshProtectionSourceByIdOptions : Instantiate RefreshProtectionSourceByIdOptions
func (*BackupRecoveryV1) NewRefreshProtectionSourceByIdOptions(id int64, xIBMTenantID string) *RefreshProtectionSourceByIdOptions {
	return &RefreshProtectionSourceByIdOptions{
		ID:           core.Int64Ptr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetID : Allow user to set ID
func (_options *RefreshProtectionSourceByIdOptions) SetID(id int64) *RefreshProtectionSourceByIdOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *RefreshProtectionSourceByIdOptions) SetXIBMTenantID(xIBMTenantID string) *RefreshProtectionSourceByIdOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RefreshProtectionSourceByIdOptions) SetHeaders(param map[string]string) *RefreshProtectionSourceByIdOptions {
	options.Headers = param
	return options
}

// RegisterProtectionSourceOptions : The RegisterProtectionSource options.
type RegisterProtectionSourceOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the environment type of the Protection Source.
	Environment *string `json:"environment" validate:"required"`

	// A user specified name for this source.
	Name *string `json:"name,omitempty"`

	// Specifies if credentials are encrypted by internal key.
	IsInternalEncrypted *bool `json:"isInternalEncrypted,omitempty"`

	// Specifies the key that user has encrypted the credential with.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// Specifies the id of the connection from where this source is reachable. This should only be set for a source being
	// registered by a tenant user.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// Specfies the list of connections for the source.
	Connections []ConnectionConfig `json:"connections,omitempty"`

	// Specifies the connector group id of connector groups.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Specifies the advanced configuration for a protection source.
	AdvancedConfigs []KeyValuePair `json:"advancedConfigs,omitempty"`

	// Specifies the id of the connection from where this source is reachable. This should only be set for a source being
	// registered by a tenant user. Also, this is the 'string' of connectionId. This property was added to accommodate for
	// ID values that exceed 2^53 - 1, which is the max value for which JS maintains precision.
	DataSourceConnectionID *string `json:"dataSourceConnectionId,omitempty"`

	// Specifies parameters to register physical server.
	PhysicalParams *PhysicalSourceRegistrationParams `json:"physicalParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the RegisterProtectionSourceOptions.Environment property.
// Specifies the environment type of the Protection Source.
const (
	RegisterProtectionSourceOptions_Environment_Kphysical = "kPhysical"
	RegisterProtectionSourceOptions_Environment_Ksql      = "kSQL"
)

// NewRegisterProtectionSourceOptions : Instantiate RegisterProtectionSourceOptions
func (*BackupRecoveryV1) NewRegisterProtectionSourceOptions(xIBMTenantID string, environment string) *RegisterProtectionSourceOptions {
	return &RegisterProtectionSourceOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Environment:  core.StringPtr(environment),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *RegisterProtectionSourceOptions) SetXIBMTenantID(xIBMTenantID string) *RegisterProtectionSourceOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetEnvironment : Allow user to set Environment
func (_options *RegisterProtectionSourceOptions) SetEnvironment(environment string) *RegisterProtectionSourceOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetName : Allow user to set Name
func (_options *RegisterProtectionSourceOptions) SetName(name string) *RegisterProtectionSourceOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetIsInternalEncrypted : Allow user to set IsInternalEncrypted
func (_options *RegisterProtectionSourceOptions) SetIsInternalEncrypted(isInternalEncrypted bool) *RegisterProtectionSourceOptions {
	_options.IsInternalEncrypted = core.BoolPtr(isInternalEncrypted)
	return _options
}

// SetEncryptionKey : Allow user to set EncryptionKey
func (_options *RegisterProtectionSourceOptions) SetEncryptionKey(encryptionKey string) *RegisterProtectionSourceOptions {
	_options.EncryptionKey = core.StringPtr(encryptionKey)
	return _options
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *RegisterProtectionSourceOptions) SetConnectionID(connectionID int64) *RegisterProtectionSourceOptions {
	_options.ConnectionID = core.Int64Ptr(connectionID)
	return _options
}

// SetConnections : Allow user to set Connections
func (_options *RegisterProtectionSourceOptions) SetConnections(connections []ConnectionConfig) *RegisterProtectionSourceOptions {
	_options.Connections = connections
	return _options
}

// SetConnectorGroupID : Allow user to set ConnectorGroupID
func (_options *RegisterProtectionSourceOptions) SetConnectorGroupID(connectorGroupID int64) *RegisterProtectionSourceOptions {
	_options.ConnectorGroupID = core.Int64Ptr(connectorGroupID)
	return _options
}

// SetAdvancedConfigs : Allow user to set AdvancedConfigs
func (_options *RegisterProtectionSourceOptions) SetAdvancedConfigs(advancedConfigs []KeyValuePair) *RegisterProtectionSourceOptions {
	_options.AdvancedConfigs = advancedConfigs
	return _options
}

// SetDataSourceConnectionID : Allow user to set DataSourceConnectionID
func (_options *RegisterProtectionSourceOptions) SetDataSourceConnectionID(dataSourceConnectionID string) *RegisterProtectionSourceOptions {
	_options.DataSourceConnectionID = core.StringPtr(dataSourceConnectionID)
	return _options
}

// SetPhysicalParams : Allow user to set PhysicalParams
func (_options *RegisterProtectionSourceOptions) SetPhysicalParams(physicalParams *PhysicalSourceRegistrationParams) *RegisterProtectionSourceOptions {
	_options.PhysicalParams = physicalParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RegisterProtectionSourceOptions) SetHeaders(param map[string]string) *RegisterProtectionSourceOptions {
	options.Headers = param
	return options
}

// RegisteredAppInfo : Specifies an authentication error message. This indicates the given credentials are rejected and the registration of
// the application is not successful.
type RegisteredAppInfo struct {
	// pecifies an authentication error message. This indicates the given credentials are rejected and the registration of
	// the application is not successful.
	AuthenticationErrorMessage *string `json:"authenticationErrorMessage,omitempty"`

	// Specifies the status of authenticating to the Protection Source when registering this application with Cohesity
	// Cluster. If the status is 'kFinished' and there is no error, registration is successful. Specifies the status of the
	// authentication during the registration of a Protection Source. 'kPending' indicates the authentication is in
	// progress. 'kScheduled' indicates the authentication is scheduled. 'kFinished' indicates the authentication is
	// completed. 'kRefreshInProgress' indicates the refresh is in progress.
	AuthenticationStatus *string `json:"authenticationStatus,omitempty"`

	// Specifies the application environment. Supported environment types such as 'kView', 'kSQL', 'kVMware', etc.
	Environment *string `json:"environment,omitempty"`

	HostSettingsCheckResults []HostSettingsCheckResult `json:"hostSettingsCheckResults,omitempty"`

	// Specifies a message if there was any error encountered during the last rebuild of the application tree. If there was
	// no error during the last rebuild, this field is reset.
	RefreshErrorMessage *string `json:"refreshErrorMessage,omitempty"`
}

// Constants associated with the RegisteredAppInfo.AuthenticationStatus property.
// Specifies the status of authenticating to the Protection Source when registering this application with Cohesity
// Cluster. If the status is 'kFinished' and there is no error, registration is successful. Specifies the status of the
// authentication during the registration of a Protection Source. 'kPending' indicates the authentication is in
// progress. 'kScheduled' indicates the authentication is scheduled. 'kFinished' indicates the authentication is
// completed. 'kRefreshInProgress' indicates the refresh is in progress.
const (
	RegisteredAppInfo_AuthenticationStatus_Kfinished          = "kFinished"
	RegisteredAppInfo_AuthenticationStatus_Kpending           = "kPending"
	RegisteredAppInfo_AuthenticationStatus_Krefreshinprogress = "kRefreshInProgress"
	RegisteredAppInfo_AuthenticationStatus_Kscheduled         = "kScheduled"
)

// Constants associated with the RegisteredAppInfo.Environment property.
// Specifies the application environment. Supported environment types such as 'kView', 'kSQL', 'kVMware', etc.
const (
	RegisteredAppInfo_Environment_Kagent         = "kAgent"
	RegisteredAppInfo_Environment_Kphysical      = "kPhysical"
	RegisteredAppInfo_Environment_Kphysicalfiles = "kPhysicalFiles"
	RegisteredAppInfo_Environment_Ksql           = "kSQL"
)

// UnmarshalRegisteredAppInfo unmarshals an instance of RegisteredAppInfo from the specified map of raw messages.
func UnmarshalRegisteredAppInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegisteredAppInfo)
	err = core.UnmarshalPrimitive(m, "authenticationErrorMessage", &obj.AuthenticationErrorMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "authenticationErrorMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "authenticationStatus", &obj.AuthenticationStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "authenticationStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostSettingsCheckResults", &obj.HostSettingsCheckResults, UnmarshalHostSettingsCheckResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostSettingsCheckResults-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "refreshErrorMessage", &obj.RefreshErrorMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "refreshErrorMessage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegisteredSourceVlanConfig : Specifies the VLAN configuration for Recovery.
type RegisteredSourceVlanConfig struct {
	// Specifies the VLAN to use for mounting Cohesity's view on the remote host. If specified, Cohesity hostname or the IP
	// address on this VLAN is used.
	Vlan *float64 `json:"vlan,omitempty"`

	// Specifies whether to use the VIPs even when VLANs are configured on the Cluster. If configured, VLAN IP addresses
	// are used by default. If VLANs are not configured, this flag is ignored. Set this flag to true to force using the
	// partition VIPs when VLANs are configured on the Cluster.
	DisableVlan *bool `json:"disableVlan,omitempty"`

	// Specifies the physical interface group name to use for mounting Cohesity's view on the remote host. If specified,
	// Cohesity hostname or the IP address on this VLAN is used.
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// UnmarshalRegisteredSourceVlanConfig unmarshals an instance of RegisteredSourceVlanConfig from the specified map of raw messages.
func UnmarshalRegisteredSourceVlanConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegisteredSourceVlanConfig)
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "disableVlan", &obj.DisableVlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "disableVlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "interfaceName", &obj.InterfaceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "interfaceName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegularBackupPolicy : Specifies the Incremental and Full policy settings and also the common Retention policy settings.".
type RegularBackupPolicy struct {
	// Specifies incremental backup settings for a Protection Group.
	Incremental *IncrementalBackupPolicy `json:"incremental,omitempty"`

	// Specifies full backup settings for a Protection Group. Currently, full backup settings can be specified by using
	// either of 'schedule' or 'schdulesAndRetentions' field. Using 'schdulesAndRetentions' is recommended when multiple
	// full backups need to be configured. If full and incremental backup has common retention then only setting 'schedule'
	// is recommended.
	Full *FullBackupPolicy `json:"full,omitempty"`

	// Specifies multiple schedules and retentions for full backup. Specify either of the 'full' or 'fullBackups' values.
	// Its recommended to use 'fullBaackups' value since 'full' will be deprecated after few releases.
	FullBackups []FullScheduleAndRetention `json:"fullBackups,omitempty"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention,omitempty"`

	// Specifies the primary backup target settings for regular backups. If the backup target field is not specified then
	// backup will be taken locally on the Cohesity cluster.
	PrimaryBackupTarget *PrimaryBackupTarget `json:"primaryBackupTarget,omitempty"`
}

// UnmarshalRegularBackupPolicy unmarshals an instance of RegularBackupPolicy from the specified map of raw messages.
func UnmarshalRegularBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegularBackupPolicy)
	err = core.UnmarshalModel(m, "incremental", &obj.Incremental, UnmarshalIncrementalBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "incremental-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "full", &obj.Full, UnmarshalFullBackupPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "full-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "fullBackups", &obj.FullBackups, UnmarshalFullScheduleAndRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullBackups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "primaryBackupTarget", &obj.PrimaryBackupTarget, UnmarshalPrimaryBackupTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "primaryBackupTarget-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoteTargetConfig : Specifies the configuration for adding remote cluster as repilcation target.
type RemoteTargetConfig struct {
	// Specifies the cluster id of the target replication cluster.
	ClusterID *int64 `json:"clusterId" validate:"required"`

	// Specifies the cluster name of the target replication cluster.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ClusterName *string `json:"clusterName,omitempty"`
}

// NewRemoteTargetConfig : Instantiate RemoteTargetConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewRemoteTargetConfig(clusterID int64) (_model *RemoteTargetConfig, err error) {
	_model = &RemoteTargetConfig{
		ClusterID: core.Int64Ptr(clusterID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRemoteTargetConfig unmarshals an instance of RemoteTargetConfig from the specified map of raw messages.
func UnmarshalRemoteTargetConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RemoteTargetConfig)
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterName", &obj.ClusterName)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplicationDataStats : Specifies statistics about replication data.
type ReplicationDataStats struct {
	// Specifies the total logical size in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the total logical bytes transferred.
	LogicalBytesTransferred *int64 `json:"logicalBytesTransferred,omitempty"`

	// Specifies the total physical bytes transferred.
	PhysicalBytesTransferred *int64 `json:"physicalBytesTransferred,omitempty"`
}

// UnmarshalReplicationDataStats unmarshals an instance of ReplicationDataStats from the specified map of raw messages.
func UnmarshalReplicationDataStats(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReplicationDataStats)
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalBytesTransferred", &obj.LogicalBytesTransferred)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalBytesTransferred-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "physicalBytesTransferred", &obj.PhysicalBytesTransferred)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalBytesTransferred-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplicationRun : Specifies information about replication run for an object.
type ReplicationRun struct {
	// Replication result for a target.
	ReplicationTargetResults []ReplicationTargetResult `json:"replicationTargetResults,omitempty"`
}

// UnmarshalReplicationRun unmarshals an instance of ReplicationRun from the specified map of raw messages.
func UnmarshalReplicationRun(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReplicationRun)
	err = core.UnmarshalModel(m, "replicationTargetResults", &obj.ReplicationTargetResults, UnmarshalReplicationTargetResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationTargetResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplicationRunSummary : Specifies summary information about replication run.
type ReplicationRunSummary struct {
	// Replication results for each replication target.
	ReplicationTargetResults []ReplicationTargetResult `json:"replicationTargetResults,omitempty"`
}

// UnmarshalReplicationRunSummary unmarshals an instance of ReplicationRunSummary from the specified map of raw messages.
func UnmarshalReplicationRunSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReplicationRunSummary)
	err = core.UnmarshalModel(m, "replicationTargetResults", &obj.ReplicationTargetResults, UnmarshalReplicationTargetResult)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationTargetResults-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplicationTargetConfiguration : Specifies settings for copying Snapshots to Remote Clusters. This also specifies the retention policy that should be
// applied to Snapshots after they have been copied to the specified target.
type ReplicationTargetConfiguration struct {
	// Specifies a schedule fregquency and schedule unit for copying Snapshots to backup targets.
	Schedule *TargetSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`

	// Specifies if Snapshots are copied from the first completely successful Protection Group Run or the first partially
	// successful Protection Group Run occurring at the start of the replication schedule. <br> If true, Snapshots are
	// copied from the first Protection Group Run occurring at the start of the replication schedule that was completely
	// successful i.e. Snapshots for all the Objects in the Protection Group were successfully captured. <br> If false,
	// Snapshots are copied from the first Protection Group Run occurring at the start of the replication schedule, even if
	// first Protection Group Run was not completely successful i.e. Snapshots were not captured for all Objects in the
	// Protection Group.
	CopyOnRunSuccess *bool `json:"copyOnRunSuccess,omitempty"`

	// Specifies the unique identifier for the target getting added. This field need to be passed only when policies are
	// being updated.
	ConfigID *string `json:"configId,omitempty"`

	// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
	// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
	// be set to Full.
	BackupRunType *string `json:"backupRunType,omitempty"`

	// Specifies the replication/archival timeouts for different type of runs(kFull, kRegular etc.).
	RunTimeouts []CancellationTimeoutParams `json:"runTimeouts,omitempty"`

	// Specifies the retention of a backup.
	LogRetention *LogRetention `json:"logRetention,omitempty"`

	// Specifies the configuration for adding AWS as repilcation target.
	AwsTargetConfig *AWSTargetConfig `json:"awsTargetConfig,omitempty"`

	// Specifies the configuration for adding Azure as replication target.
	AzureTargetConfig *AzureTargetConfig `json:"azureTargetConfig,omitempty"`

	// Specifies the type of target to which replication need to be performed.
	TargetType *string `json:"targetType" validate:"required"`

	// Specifies the configuration for adding remote cluster as repilcation target.
	RemoteTargetConfig *RemoteTargetConfig `json:"remoteTargetConfig,omitempty"`
}

// Constants associated with the ReplicationTargetConfiguration.BackupRunType property.
// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
// be set to Full.
const (
	ReplicationTargetConfiguration_BackupRunType_Full                 = "Full"
	ReplicationTargetConfiguration_BackupRunType_Log                  = "Log"
	ReplicationTargetConfiguration_BackupRunType_Regular              = "Regular"
	ReplicationTargetConfiguration_BackupRunType_Storagearraysnapshot = "StorageArraySnapshot"
	ReplicationTargetConfiguration_BackupRunType_System               = "System"
)

// Constants associated with the ReplicationTargetConfiguration.TargetType property.
// Specifies the type of target to which replication need to be performed.
const (
	ReplicationTargetConfiguration_TargetType_Aws           = "AWS"
	ReplicationTargetConfiguration_TargetType_Azure         = "Azure"
	ReplicationTargetConfiguration_TargetType_Remotecluster = "RemoteCluster"
)

// NewReplicationTargetConfiguration : Instantiate ReplicationTargetConfiguration (Generic Model Constructor)
func (*BackupRecoveryV1) NewReplicationTargetConfiguration(schedule *TargetSchedule, retention *Retention, targetType string) (_model *ReplicationTargetConfiguration, err error) {
	_model = &ReplicationTargetConfiguration{
		Schedule:   schedule,
		Retention:  retention,
		TargetType: core.StringPtr(targetType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalReplicationTargetConfiguration unmarshals an instance of ReplicationTargetConfiguration from the specified map of raw messages.
func UnmarshalReplicationTargetConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReplicationTargetConfiguration)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalTargetSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "copyOnRunSuccess", &obj.CopyOnRunSuccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "copyOnRunSuccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupRunType", &obj.BackupRunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "runTimeouts", &obj.RunTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "runTimeouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "logRetention", &obj.LogRetention, UnmarshalLogRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "logRetention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "awsTargetConfig", &obj.AwsTargetConfig, UnmarshalAWSTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsTargetConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureTargetConfig", &obj.AzureTargetConfig, UnmarshalAzureTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureTargetConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "remoteTargetConfig", &obj.RemoteTargetConfig, UnmarshalRemoteTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "remoteTargetConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplicationTargetResult : Replication result for a target.
type ReplicationTargetResult struct {
	// Specifies the id of the cluster.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the incarnation id of the cluster.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the name of the cluster.
	ClusterName *string `json:"clusterName,omitempty"`

	// Specifies the configuration for adding AWS as repilcation target.
	AwsTargetConfig *AWSTargetConfig `json:"awsTargetConfig,omitempty"`

	// Specifies the configuration for adding Azure as replication target.
	AzureTargetConfig *AzureTargetConfig `json:"azureTargetConfig,omitempty"`

	// Specifies the start time of replication in Unix epoch Timestamp(in microseconds) for a target.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of replication in Unix epoch Timestamp(in microseconds) for a target.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the time when the replication is queued for schedule in Unix epoch Timestamp(in microseconds) for a
	// target.
	QueuedTimeUsecs *int64 `json:"queuedTimeUsecs,omitempty"`

	// Status of the replication for a target. 'Running' indicates that the run is still running. 'Canceled' indicates that
	// the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused'
	// indicates that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that
	// the run was unable to take place at the scheduled time because the previous run was still happening. 'Succeeded'
	// indicates that the run has finished successfully. 'SucceededWithWarning' indicates that the run finished
	// successfully, but there were some warning messages. 'Skipped' indicates that the run was skipped.
	Status *string `json:"status,omitempty"`

	// Message about the replication run.
	Message *string `json:"message,omitempty"`

	// Specifies the progress in percentage.
	PercentageCompleted *int64 `json:"percentageCompleted,omitempty"`

	// Specifies statistics about replication data.
	Stats *ReplicationDataStats `json:"stats,omitempty"`

	// Specifies whether the snapshot is deleted manually.
	IsManuallyDeleted *bool `json:"isManuallyDeleted,omitempty"`

	// Specifies the expiry time of attempt in Unix epoch Timestamp (in microseconds) for an object.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// Task UID for a replication protection run. This is for tasks that are replicated from another cluster.
	ReplicationTaskID *string `json:"replicationTaskId,omitempty"`

	// Specifies the number of metadata actions completed during the protection run.
	EntriesChanged *int64 `json:"entriesChanged,omitempty"`

	// Specifies the direction of the replication. If the snapshot is replicated to this cluster, then isInBound is true.
	// If the snapshot is replicated from this cluster to another cluster, then isInBound is false.
	IsInBound *bool `json:"isInBound,omitempty"`

	// Specifies the dataLock constraints for local or target snapshot.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`

	// Specifies the legal hold status for a replication target.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`

	// Specifies whether view based replication was used. In this case, the view containing all objects is replicated as a
	// whole instead of replicating on a per object basis.
	MultiObjectReplication *bool `json:"multiObjectReplication,omitempty"`
}

// Constants associated with the ReplicationTargetResult.Status property.
// Status of the replication for a target. 'Running' indicates that the run is still running. 'Canceled' indicates that
// the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates
// that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that the run was
// unable to take place at the scheduled time because the previous run was still happening. 'Succeeded' indicates that
// the run has finished successfully. 'SucceededWithWarning' indicates that the run finished successfully, but there
// were some warning messages. 'Skipped' indicates that the run was skipped.
const (
	ReplicationTargetResult_Status_Accepted             = "Accepted"
	ReplicationTargetResult_Status_Canceled             = "Canceled"
	ReplicationTargetResult_Status_Canceling            = "Canceling"
	ReplicationTargetResult_Status_Failed               = "Failed"
	ReplicationTargetResult_Status_Finalizing           = "Finalizing"
	ReplicationTargetResult_Status_Missed               = "Missed"
	ReplicationTargetResult_Status_Onhold               = "OnHold"
	ReplicationTargetResult_Status_Paused               = "Paused"
	ReplicationTargetResult_Status_Running              = "Running"
	ReplicationTargetResult_Status_Skipped              = "Skipped"
	ReplicationTargetResult_Status_Succeeded            = "Succeeded"
	ReplicationTargetResult_Status_Succeededwithwarning = "SucceededWithWarning"
)

// UnmarshalReplicationTargetResult unmarshals an instance of ReplicationTargetResult from the specified map of raw messages.
func UnmarshalReplicationTargetResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ReplicationTargetResult)
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIncarnationId", &obj.ClusterIncarnationID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIncarnationId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterName", &obj.ClusterName)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "awsTargetConfig", &obj.AwsTargetConfig, UnmarshalAWSTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsTargetConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureTargetConfig", &obj.AzureTargetConfig, UnmarshalAzureTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureTargetConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "queuedTimeUsecs", &obj.QueuedTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "queuedTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "percentageCompleted", &obj.PercentageCompleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "percentageCompleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "stats", &obj.Stats, UnmarshalReplicationDataStats)
	if err != nil {
		err = core.SDKErrorf(err, "", "stats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isManuallyDeleted", &obj.IsManuallyDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isManuallyDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationTaskId", &obj.ReplicationTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "entriesChanged", &obj.EntriesChanged)
	if err != nil {
		err = core.SDKErrorf(err, "", "entriesChanged-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isInBound", &obj.IsInBound)
	if err != nil {
		err = core.SDKErrorf(err, "", "isInBound-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConstraints", &obj.DataLockConstraints, UnmarshalDataLockConstraints)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConstraints-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "onLegalHold", &obj.OnLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "onLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "multiObjectReplication", &obj.MultiObjectReplication)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiObjectReplication-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RestoreInfo : Specifies the info regarding a snapshot.
type RestoreInfo struct {
	// Specifies archival target summary information.
	ArchivalTargetInfo *ArchivalTargetSummaryInfo `json:"archivalTargetInfo,omitempty"`

	// Specifies the attempt number of the job run to restore from.
	AttemptNumber *int64 `json:"attemptNumber,omitempty"`

	// Specifies the details about Cloud Spin target where backup snapshots may be converted and stored.
	CloudDeployTarget *CloudSpinTarget `json:"cloudDeployTarget,omitempty"`

	// Specifies the details about Cloud Spin target where backup snapshots may be converted and stored.
	CloudReplicationTarget *CloudSpinTarget `json:"cloudReplicationTarget,omitempty"`

	// Specifies information about an object.
	ObjectInfo *Object `json:"objectInfo,omitempty"`

	// Specifies information about an object.
	ParentObjectInfo *Object `json:"parentObjectInfo,omitempty"`

	// Specifies the protection group id of the run responsible for the snapshot.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies the start time specified as a Unix epoch Timestamp (in microseconds).
	RunStartTimeUsecs *int64 `json:"runStartTimeUsecs,omitempty"`

	// Specifies the relative path to the directory containing the entity's snapshot.
	SnapshotRelativeDirPath *string `json:"snapshotRelativeDirPath,omitempty"`

	// The name of the view where the object's snapshot is located.
	ViewName *string `json:"viewName,omitempty"`

	// Specifies this is applicable only to VMs and is set to true when the VM being recovered or cloned contained
	// independent disks when it was backed up.
	VmHadIndependentDisks *bool `json:"vmHadIndependentDisks,omitempty"`
}

// UnmarshalRestoreInfo unmarshals an instance of RestoreInfo from the specified map of raw messages.
func UnmarshalRestoreInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RestoreInfo)
	err = core.UnmarshalModel(m, "archivalTargetInfo", &obj.ArchivalTargetInfo, UnmarshalArchivalTargetSummaryInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "attemptNumber", &obj.AttemptNumber)
	if err != nil {
		err = core.SDKErrorf(err, "", "attemptNumber-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cloudDeployTarget", &obj.CloudDeployTarget, UnmarshalCloudSpinTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudDeployTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cloudReplicationTarget", &obj.CloudReplicationTarget, UnmarshalCloudSpinTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudReplicationTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objectInfo", &obj.ObjectInfo, UnmarshalObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "parentObjectInfo", &obj.ParentObjectInfo, UnmarshalObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "parentObjectInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runStartTimeUsecs", &obj.RunStartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "runStartTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotRelativeDirPath", &obj.SnapshotRelativeDirPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotRelativeDirPath-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "viewName", &obj.ViewName)
	if err != nil {
		err = core.SDKErrorf(err, "", "viewName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vmHadIndependentDisks", &obj.VmHadIndependentDisks)
	if err != nil {
		err = core.SDKErrorf(err, "", "vmHadIndependentDisks-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResumeProtectionRunActionParams : Specifies the request to resume a protection run.
type ResumeProtectionRunActionParams struct {
	// Specifies a unique run id of the Protection Group run.
	RunID *string `json:"runId" validate:"required"`
}

// NewResumeProtectionRunActionParams : Instantiate ResumeProtectionRunActionParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewResumeProtectionRunActionParams(runID string) (_model *ResumeProtectionRunActionParams, err error) {
	_model = &ResumeProtectionRunActionParams{
		RunID: core.StringPtr(runID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalResumeProtectionRunActionParams unmarshals an instance of ResumeProtectionRunActionParams from the specified map of raw messages.
func UnmarshalResumeProtectionRunActionParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResumeProtectionRunActionParams)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResumeProtectionRunActionResponseParams : Specifies the response of a resume action on protection runs.
type ResumeProtectionRunActionResponseParams struct {
	// Specifies a unique run id of the Protection Group run.
	RunID *string `json:"runId,omitempty"`

	// Specifies an error occured when perfroming resume of a protection run.
	Error *string `json:"error,omitempty"`
}

// UnmarshalResumeProtectionRunActionResponseParams unmarshals an instance of ResumeProtectionRunActionResponseParams from the specified map of raw messages.
func UnmarshalResumeProtectionRunActionResponseParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResumeProtectionRunActionResponseParams)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "error", &obj.Error)
	if err != nil {
		err = core.SDKErrorf(err, "", "error-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retention : Specifies the retention of a backup.
type Retention struct {
	// Specificies the Retention Unit of a backup measured in days, months or years. <br> If unit is 'Months', then number
	// specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of
	// retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied
	// to 365. <br> If duration is 2 and unit is 'Years' then number of retention days will be 365 * 2 = 730 days.
	Unit *string `json:"unit" validate:"required"`

	// Specifies the duration for a backup retention. <br> Example. If duration is 7 and unit is Months, the retention of a
	// backup is 7 * 30 = 210 days.
	Duration *int64 `json:"duration" validate:"required"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
	// Protection Groups using this policy will be kept for the last N days as specified in the duration of the datalock.
	// During that time, the snapshots cannot be deleted.
	DataLockConfig *DataLockConfig `json:"dataLockConfig,omitempty"`
}

// Constants associated with the Retention.Unit property.
// Specificies the Retention Unit of a backup measured in days, months or years. <br> If unit is 'Months', then number
// specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of
// retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied to
// 365. <br> If duration is 2 and unit is 'Years' then number of retention days will be 365 * 2 = 730 days.
const (
	Retention_Unit_Days   = "Days"
	Retention_Unit_Months = "Months"
	Retention_Unit_Weeks  = "Weeks"
	Retention_Unit_Years  = "Years"
)

// NewRetention : Instantiate Retention (Generic Model Constructor)
func (*BackupRecoveryV1) NewRetention(unit string, duration int64) (_model *Retention, err error) {
	_model = &Retention{
		Unit:     core.StringPtr(unit),
		Duration: core.Int64Ptr(duration),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRetention unmarshals an instance of Retention from the specified map of raw messages.
func UnmarshalRetention(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Retention)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "duration", &obj.Duration)
	if err != nil {
		err = core.SDKErrorf(err, "", "duration-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConfig", &obj.DataLockConfig, UnmarshalDataLockConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RetrieveArchiveTask : Specifies the persistent state of a retrieve of an archive task.
type RetrieveArchiveTask struct {
	// Specifies the globally unique id for this retrieval of an archive task.
	TaskUid *string `json:"taskUid,omitempty"`

	// Specifies how much time the retrieved entity is present in the hot-tiers.
	UptierExpiryTimes []int64 `json:"uptierExpiryTimes,omitempty"`
}

// UnmarshalRetrieveArchiveTask unmarshals an instance of RetrieveArchiveTask from the specified map of raw messages.
func UnmarshalRetrieveArchiveTask(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RetrieveArchiveTask)
	err = core.UnmarshalPrimitive(m, "taskUid", &obj.TaskUid)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskUid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uptierExpiryTimes", &obj.UptierExpiryTimes)
	if err != nil {
		err = core.SDKErrorf(err, "", "uptierExpiryTimes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RetryOptions : Retry Options of a Protection Policy when a Protection Group run fails.
type RetryOptions struct {
	// Specifies the number of times to retry capturing Snapshots before the Protection Group Run fails.
	Retries *int64 `json:"retries,omitempty"`

	// Specifies the number of minutes before retrying a failed Protection Group.
	RetryIntervalMins *int64 `json:"retryIntervalMins,omitempty"`
}

// UnmarshalRetryOptions unmarshals an instance of RetryOptions from the specified map of raw messages.
func UnmarshalRetryOptions(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RetryOptions)
	err = core.UnmarshalPrimitive(m, "retries", &obj.Retries)
	if err != nil {
		err = core.SDKErrorf(err, "", "retries-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "retryIntervalMins", &obj.RetryIntervalMins)
	if err != nil {
		err = core.SDKErrorf(err, "", "retryIntervalMins-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RpaasTargetConfiguration : Specifies settings for copying Snapshots to RPaaS Targets.
type RpaasTargetConfiguration struct {
	// Specifies a schedule fregquency and schedule unit for copying Snapshots to backup targets.
	Schedule *TargetSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`

	// Specifies if Snapshots are copied from the first completely successful Protection Group Run or the first partially
	// successful Protection Group Run occurring at the start of the replication schedule. <br> If true, Snapshots are
	// copied from the first Protection Group Run occurring at the start of the replication schedule that was completely
	// successful i.e. Snapshots for all the Objects in the Protection Group were successfully captured. <br> If false,
	// Snapshots are copied from the first Protection Group Run occurring at the start of the replication schedule, even if
	// first Protection Group Run was not completely successful i.e. Snapshots were not captured for all Objects in the
	// Protection Group.
	CopyOnRunSuccess *bool `json:"copyOnRunSuccess,omitempty"`

	// Specifies the unique identifier for the target getting added. This field need to be passed only when policies are
	// being updated.
	ConfigID *string `json:"configId,omitempty"`

	// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
	// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
	// be set to Full.
	BackupRunType *string `json:"backupRunType,omitempty"`

	// Specifies the replication/archival timeouts for different type of runs(kFull, kRegular etc.).
	RunTimeouts []CancellationTimeoutParams `json:"runTimeouts,omitempty"`

	// Specifies the retention of a backup.
	LogRetention *LogRetention `json:"logRetention,omitempty"`

	// Specifies the RPaaS target to copy the Snapshots.
	TargetID *int64 `json:"targetId" validate:"required"`

	// Specifies the RPaaS target name where Snapshots are copied.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the RPaaS target type where Snapshots are copied.
	TargetType *string `json:"targetType,omitempty"`
}

// Constants associated with the RpaasTargetConfiguration.BackupRunType property.
// Specifies which type of run should be copied, if not set, all types of runs will be eligible for copying. If set,
// this will ensure that the first run of given type in the scheduled period will get copied. Currently, this can only
// be set to Full.
const (
	RpaasTargetConfiguration_BackupRunType_Full                 = "Full"
	RpaasTargetConfiguration_BackupRunType_Log                  = "Log"
	RpaasTargetConfiguration_BackupRunType_Regular              = "Regular"
	RpaasTargetConfiguration_BackupRunType_Storagearraysnapshot = "StorageArraySnapshot"
	RpaasTargetConfiguration_BackupRunType_System               = "System"
)

// Constants associated with the RpaasTargetConfiguration.TargetType property.
// Specifies the RPaaS target type where Snapshots are copied.
const (
	RpaasTargetConfiguration_TargetType_Cloud = "Cloud"
	RpaasTargetConfiguration_TargetType_Nas   = "Nas"
	RpaasTargetConfiguration_TargetType_Tape  = "Tape"
)

// NewRpaasTargetConfiguration : Instantiate RpaasTargetConfiguration (Generic Model Constructor)
func (*BackupRecoveryV1) NewRpaasTargetConfiguration(schedule *TargetSchedule, retention *Retention, targetID int64) (_model *RpaasTargetConfiguration, err error) {
	_model = &RpaasTargetConfiguration{
		Schedule:  schedule,
		Retention: retention,
		TargetID:  core.Int64Ptr(targetID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRpaasTargetConfiguration unmarshals an instance of RpaasTargetConfiguration from the specified map of raw messages.
func UnmarshalRpaasTargetConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RpaasTargetConfiguration)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalTargetSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "copyOnRunSuccess", &obj.CopyOnRunSuccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "copyOnRunSuccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configId", &obj.ConfigID)
	if err != nil {
		err = core.SDKErrorf(err, "", "configId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupRunType", &obj.BackupRunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "runTimeouts", &obj.RunTimeouts, UnmarshalCancellationTimeoutParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "runTimeouts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "logRetention", &obj.LogRetention, UnmarshalLogRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "logRetention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetId", &obj.TargetID)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetName", &obj.TargetName)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RunArchivalConfig : Specifies settings for copying Snapshots External Targets (such as AWS or Tape). This also specifies the retention
// policy that should be applied to Snapshots after they have been copied to the specified target.
type RunArchivalConfig struct {
	// Specifies the Archival target to copy the Snapshots to.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the snapshot's archival target type from which recovery has been performed.
	ArchivalTargetType *string `json:"archivalTargetType" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention,omitempty"`

	// Specifies if Snapshots are copied from a fully successful Protection Group Run or a partially successful Protection
	// Group Run. If false, Snapshots are copied the Protection Group Run, even if the Run was not fully successful i.e.
	// Snapshots were not captured for all Objects in the Protection Group. If true, Snapshots are copied only when the run
	// is fully successful.
	CopyOnlyFullySuccessful *bool `json:"copyOnlyFullySuccessful,omitempty"`
}

// Constants associated with the RunArchivalConfig.ArchivalTargetType property.
// Specifies the snapshot's archival target type from which recovery has been performed.
const (
	RunArchivalConfig_ArchivalTargetType_Cloud = "Cloud"
	RunArchivalConfig_ArchivalTargetType_Nas   = "Nas"
	RunArchivalConfig_ArchivalTargetType_Tape  = "Tape"
)

// NewRunArchivalConfig : Instantiate RunArchivalConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewRunArchivalConfig(id int64, archivalTargetType string) (_model *RunArchivalConfig, err error) {
	_model = &RunArchivalConfig{
		ID:                 core.Int64Ptr(id),
		ArchivalTargetType: core.StringPtr(archivalTargetType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRunArchivalConfig unmarshals an instance of RunArchivalConfig from the specified map of raw messages.
func UnmarshalRunArchivalConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RunArchivalConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTargetType", &obj.ArchivalTargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "copyOnlyFullySuccessful", &obj.CopyOnlyFullySuccessful)
	if err != nil {
		err = core.SDKErrorf(err, "", "copyOnlyFullySuccessful-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RunCloudReplicationConfig : Specifies settings for copying Snapshots to cloud targets. This also specifies the retention policy that should be
// applied to Snapshots after they have been copied to the specified target.
type RunCloudReplicationConfig struct {
	// Specifies the configuration for adding AWS as repilcation target.
	AwsTarget *AWSTargetConfig `json:"awsTarget,omitempty"`

	// Specifies the configuration for adding Azure as replication target.
	AzureTarget *AzureTargetConfig `json:"azureTarget,omitempty"`

	// Specifies the type of target to which replication need to be performed.
	TargetType *string `json:"targetType" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention,omitempty"`
}

// Constants associated with the RunCloudReplicationConfig.TargetType property.
// Specifies the type of target to which replication need to be performed.
const (
	RunCloudReplicationConfig_TargetType_Aws   = "AWS"
	RunCloudReplicationConfig_TargetType_Azure = "Azure"
)

// NewRunCloudReplicationConfig : Instantiate RunCloudReplicationConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewRunCloudReplicationConfig(targetType string) (_model *RunCloudReplicationConfig, err error) {
	_model = &RunCloudReplicationConfig{
		TargetType: core.StringPtr(targetType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRunCloudReplicationConfig unmarshals an instance of RunCloudReplicationConfig from the specified map of raw messages.
func UnmarshalRunCloudReplicationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RunCloudReplicationConfig)
	err = core.UnmarshalModel(m, "awsTarget", &obj.AwsTarget, UnmarshalAWSTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureTarget", &obj.AzureTarget, UnmarshalAzureTargetConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureTarget-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "targetType", &obj.TargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "targetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RunObject : Specifies the object details to create a protection run.
type RunObject struct {
	// Specifies the id of object.
	ID *int64 `json:"id" validate:"required"`

	// Specifies a list of ids of applications.
	AppIds []int64 `json:"appIds,omitempty"`

	// Specifies physical parameters for this run.
	PhysicalParams *RunObjectPhysicalParams `json:"physicalParams,omitempty"`
}

// NewRunObject : Instantiate RunObject (Generic Model Constructor)
func (*BackupRecoveryV1) NewRunObject(id int64) (_model *RunObject, err error) {
	_model = &RunObject{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRunObject unmarshals an instance of RunObject from the specified map of raw messages.
func UnmarshalRunObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RunObject)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "appIds", &obj.AppIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "appIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalRunObjectPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RunObjectPhysicalParams : Specifies physical parameters for this run.
type RunObjectPhysicalParams struct {
	// Specifies metadata file path during run-now requests for physical file based backups for some specific source. If
	// specified, it will override any default metadata/directive file path set at the object level for the source. Also
	// note that if the job default does not specify a metadata/directive file path for the source, then specifying this
	// field for that source during run-now request will be rejected.
	MetadataFilePath *string `json:"metadataFilePath,omitempty"`
}

// UnmarshalRunObjectPhysicalParams unmarshals an instance of RunObjectPhysicalParams from the specified map of raw messages.
func UnmarshalRunObjectPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RunObjectPhysicalParams)
	err = core.UnmarshalPrimitive(m, "metadataFilePath", &obj.MetadataFilePath)
	if err != nil {
		err = core.SDKErrorf(err, "", "metadataFilePath-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RunReplicationConfig : Specifies settings for copying Snapshots to Remote Clusters. This also specifies the retention policy that should be
// applied to Snapshots after they have been copied to the specified target.
type RunReplicationConfig struct {
	// Specifies id of Remote Cluster to copy the Snapshots to.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention,omitempty"`
}

// NewRunReplicationConfig : Instantiate RunReplicationConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewRunReplicationConfig(id int64) (_model *RunReplicationConfig, err error) {
	_model = &RunReplicationConfig{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalRunReplicationConfig unmarshals an instance of RunReplicationConfig from the specified map of raw messages.
func UnmarshalRunReplicationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RunReplicationConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RunTargetsConfiguration : Specifies the replication and archival targets.
type RunTargetsConfiguration struct {
	// Specifies whether to use default policy settings or not. If specified as true then 'replications' and 'arcihvals'
	// should not be specified. In case of true value, replicatioan targets congfigured in the policy will be added
	// internally.
	UsePolicyDefaults *bool `json:"usePolicyDefaults,omitempty"`

	// Specifies a list of replication targets configurations.
	Replications []RunReplicationConfig `json:"replications,omitempty"`

	// Specifies a list of archival targets configurations.
	Archivals []RunArchivalConfig `json:"archivals,omitempty"`

	// Specifies a list of cloud replication targets configurations.
	CloudReplications []RunCloudReplicationConfig `json:"cloudReplications,omitempty"`
}

// UnmarshalRunTargetsConfiguration unmarshals an instance of RunTargetsConfiguration from the specified map of raw messages.
func UnmarshalRunTargetsConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RunTargetsConfiguration)
	err = core.UnmarshalPrimitive(m, "usePolicyDefaults", &obj.UsePolicyDefaults)
	if err != nil {
		err = core.SDKErrorf(err, "", "usePolicyDefaults-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "replications", &obj.Replications, UnmarshalRunReplicationConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "replications-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivals", &obj.Archivals, UnmarshalRunArchivalConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivals-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cloudReplications", &obj.CloudReplications, UnmarshalRunCloudReplicationConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudReplications-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SQLServerInstanceVersion : Specifies the Server Instance Version.
type SQLServerInstanceVersion struct {
	// Specifies the build.
	Build *float64 `json:"build,omitempty"`

	// Specifies the major version.
	MajorVersion *float64 `json:"majorVersion,omitempty"`

	// Specifies the minor version.
	MinorVersion *float64 `json:"minorVersion,omitempty"`

	// Specifies the revision.
	Revision *float64 `json:"revision,omitempty"`

	// Specifies the version string.
	VersionString *float64 `json:"versionString,omitempty"`
}

// UnmarshalSQLServerInstanceVersion unmarshals an instance of SQLServerInstanceVersion from the specified map of raw messages.
func UnmarshalSQLServerInstanceVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SQLServerInstanceVersion)
	err = core.UnmarshalPrimitive(m, "build", &obj.Build)
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "majorVersion", &obj.MajorVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "majorVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "minorVersion", &obj.MinorVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "minorVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "revision", &obj.Revision)
	if err != nil {
		err = core.SDKErrorf(err, "", "revision-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "versionString", &obj.VersionString)
	if err != nil {
		err = core.SDKErrorf(err, "", "versionString-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SQLSourceID : Specifies a unique id for a SQL Protection Source.
type SQLSourceID struct {
	// Specifies a unique identifier generated from the date the database is created or renamed. Cohesity uses this
	// identifier in combination with the databaseId to uniquely identify a database.
	CreatedDateMsecs *int64 `json:"createdDateMsecs,omitempty"`

	// Specifies a unique id of the database but only for the life of the database. SQL Server may reuse database ids.
	// Cohesity uses the createDateMsecs in combination with this databaseId to uniquely identify a database.
	DatabaseID *int64 `json:"databaseId,omitempty"`

	// Specifies unique id for the SQL Server instance. This id does not change during the life of the instance.
	InstanceID *string `json:"instanceId,omitempty"`
}

// UnmarshalSQLSourceID unmarshals an instance of SQLSourceID from the specified map of raw messages.
func UnmarshalSQLSourceID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SQLSourceID)
	err = core.UnmarshalPrimitive(m, "createdDateMsecs", &obj.CreatedDateMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdDateMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "databaseId", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "databaseId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceId", &obj.InstanceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "instanceId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Schedule : Specifies a schedule for actions to be taken.
type Schedule struct {
	// Specifies the time range within the days of the week.
	PeriodicTimeWindows []TimeWindow `json:"periodicTimeWindows,omitempty"`

	// Specifies the type of schedule for this ScheduleProto.
	ScheduleType *string `json:"scheduleType,omitempty"`

	// Specifies the time ranges in usecs.
	TimeRanges []TimeRangeUsecs `json:"timeRanges,omitempty"`

	// Specifies the timezone of the user of this ScheduleProto. The timezones have unique names of the form
	// 'Area/Location'.
	Timezone *string `json:"timezone,omitempty"`
}

// Constants associated with the Schedule.ScheduleType property.
// Specifies the type of schedule for this ScheduleProto.
const (
	Schedule_ScheduleType_Customintervals     = "CustomIntervals"
	Schedule_ScheduleType_Periodictimewindows = "PeriodicTimeWindows"
)

// UnmarshalSchedule unmarshals an instance of Schedule from the specified map of raw messages.
func UnmarshalSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Schedule)
	err = core.UnmarshalModel(m, "periodicTimeWindows", &obj.PeriodicTimeWindows, UnmarshalTimeWindow)
	if err != nil {
		err = core.SDKErrorf(err, "", "periodicTimeWindows-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "scheduleType", &obj.ScheduleType)
	if err != nil {
		err = core.SDKErrorf(err, "", "scheduleType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "timeRanges", &obj.TimeRanges, UnmarshalTimeRangeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeRanges-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "timezone", &obj.Timezone)
	if err != nil {
		err = core.SDKErrorf(err, "", "timezone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchDocumentLibraryRequestParams : Specifies the request parameters to search for files/folders in document libraries.
type SearchDocumentLibraryRequestParams struct {
	// Specifies a list of document library types. Only items within the given types will be returned.
	CategoryTypes []string `json:"categoryTypes,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds when the file/folder is created.
	CreationEndTimeSecs *int64 `json:"creationEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds when the file/folder is created.
	CreationStartTimeSecs *int64 `json:"creationStartTimeSecs,omitempty"`

	// Specifies whether to include files in the response. Default is true.
	IncludeFiles *bool `json:"includeFiles,omitempty"`

	// Specifies whether to include folders in the response. Default is true.
	IncludeFolders *bool `json:"includeFolders,omitempty"`

	// Specifies O365 specific params search request params to search for indexed items.
	O365Params *O365SearchRequestParams `json:"o365Params,omitempty"`

	// Specifies the list of owner names to filter on owner of the file/folder.
	OwnerNames []string `json:"ownerNames,omitempty"`

	// Specifies the search string to filter the files/folders. User can specify a wildcard character '*' as a suffix to a
	// string where all item names are matched with the prefix string.
	SearchString *string `json:"searchString,omitempty"`

	// Specifies the minimum size of the file in bytes.
	SizeBytesLowerLimit *int64 `json:"sizeBytesLowerLimit,omitempty"`

	// Specifies the maximum size of the file in bytes.
	SizeBytesUpperLimit *int64 `json:"sizeBytesUpperLimit,omitempty"`
}

// Constants associated with the SearchDocumentLibraryRequestParams.CategoryTypes property.
const (
	SearchDocumentLibraryRequestParams_CategoryTypes_Document   = "Document"
	SearchDocumentLibraryRequestParams_CategoryTypes_Excel      = "Excel"
	SearchDocumentLibraryRequestParams_CategoryTypes_Image      = "Image"
	SearchDocumentLibraryRequestParams_CategoryTypes_Onenote    = "OneNote"
	SearchDocumentLibraryRequestParams_CategoryTypes_Powerpoint = "Powerpoint"
)

// UnmarshalSearchDocumentLibraryRequestParams unmarshals an instance of SearchDocumentLibraryRequestParams from the specified map of raw messages.
func UnmarshalSearchDocumentLibraryRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchDocumentLibraryRequestParams)
	err = core.UnmarshalPrimitive(m, "categoryTypes", &obj.CategoryTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "categoryTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "creationEndTimeSecs", &obj.CreationEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "creationStartTimeSecs", &obj.CreationStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "includeFiles", &obj.IncludeFiles)
	if err != nil {
		err = core.SDKErrorf(err, "", "includeFiles-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "includeFolders", &obj.IncludeFolders)
	if err != nil {
		err = core.SDKErrorf(err, "", "includeFolders-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "o365Params", &obj.O365Params, UnmarshalO365SearchRequestParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "o365Params-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownerNames", &obj.OwnerNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownerNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sizeBytesLowerLimit", &obj.SizeBytesLowerLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "sizeBytesLowerLimit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sizeBytesUpperLimit", &obj.SizeBytesUpperLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "sizeBytesUpperLimit-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchEmailRequestParams : Specifies the request parameters to search for emails and email folders.
type SearchEmailRequestParams struct {
	// Filters the calendar items which have specified email addresses as attendees.
	AttendeesAddresses []string `json:"attendeesAddresses,omitempty"`

	// Filters the emails which are sent to specified email addresses in BCC.
	BccRecipientAddresses []string `json:"bccRecipientAddresses,omitempty"`

	// Filters the emails which are sent to specified email addresses in CC.
	CcRecipientAddresses []string `json:"ccRecipientAddresses,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the created time of the email/item is less than
	// specified value.
	CreatedEndTimeSecs *int64 `json:"createdEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the created time of the email/item is more than
	// specified value.
	CreatedStartTimeSecs *int64 `json:"createdStartTimeSecs,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the last modification time of the email/item is less
	// than specified value.
	DueDateEndTimeSecs *int64 `json:"dueDateEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the last modification time of the email/item is
	// more than specified value.
	DueDateStartTimeSecs *int64 `json:"dueDateStartTimeSecs,omitempty"`

	// Filters the contact items which have specified text in email address.
	EmailAddress *string `json:"emailAddress,omitempty"`

	// Filters the emails which have the specified text in its subject.
	EmailSubject *string `json:"emailSubject,omitempty"`

	// Filters the contacts with specified text in first name.
	FirstName *string `json:"firstName,omitempty"`

	// Filters the emails which are categorized to specified folders.
	FolderNames []string `json:"folderNames,omitempty"`

	// Filters the emails which have attachment.
	HasAttachment *bool `json:"hasAttachment,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the last modification time of the email/item is less
	// than specified value.
	LastModifiedEndTimeSecs *int64 `json:"lastModifiedEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the last modification time of the email/item is
	// more than specified value.
	LastModifiedStartTimeSecs *int64 `json:"lastModifiedStartTimeSecs,omitempty"`

	// Filters the contacts with specified text in last name.
	LastName *string `json:"lastName,omitempty"`

	// Filters the contacts with specified text in middle name.
	MiddleName *string `json:"middleName,omitempty"`

	// Filters the calendar items which are organized by specified User's email address.
	OrganizerAddress *string `json:"organizerAddress,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the received time of the email is less than
	// specified value.
	ReceivedEndTimeSecs *int64 `json:"receivedEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the received time of the email is more than
	// specified value.
	ReceivedStartTimeSecs *int64 `json:"receivedStartTimeSecs,omitempty"`

	// Filters the emails which are sent to specified email addresses.
	RecipientAddresses []string `json:"recipientAddresses,omitempty"`

	// Filters the emails which are received from specified User's email address.
	SenderAddress *string `json:"senderAddress,omitempty"`

	// Specifies the source environment.
	SourceEnvironment *string `json:"sourceEnvironment,omitempty"`

	// Specifies a list of task item status types. Task items having status within the given types will be returned.
	TaskStatusTypes []string `json:"taskStatusTypes,omitempty"`

	// Specifies a list of mailbox item types. Only items within the given types will be returned.
	Types []string `json:"types,omitempty"`

	// Specifies email search request params specific to O365 environment.
	O365Params *O365SearchEmailsRequestParams `json:"o365Params,omitempty"`
}

// Constants associated with the SearchEmailRequestParams.SourceEnvironment property.
// Specifies the source environment.
const (
	SearchEmailRequestParams_SourceEnvironment_Ko365 = "kO365"
)

// Constants associated with the SearchEmailRequestParams.TaskStatusTypes property.
const (
	SearchEmailRequestParams_TaskStatusTypes_Completed       = "Completed"
	SearchEmailRequestParams_TaskStatusTypes_Deferred        = "Deferred"
	SearchEmailRequestParams_TaskStatusTypes_Inprogress      = "InProgress"
	SearchEmailRequestParams_TaskStatusTypes_Notstarted      = "NotStarted"
	SearchEmailRequestParams_TaskStatusTypes_Waitingonothers = "WaitingOnOthers"
)

// Constants associated with the SearchEmailRequestParams.Types property.
const (
	SearchEmailRequestParams_Types_Calendar = "Calendar"
	SearchEmailRequestParams_Types_Contact  = "Contact"
	SearchEmailRequestParams_Types_Email    = "Email"
	SearchEmailRequestParams_Types_Folder   = "Folder"
	SearchEmailRequestParams_Types_Note     = "Note"
	SearchEmailRequestParams_Types_Task     = "Task"
)

// UnmarshalSearchEmailRequestParams unmarshals an instance of SearchEmailRequestParams from the specified map of raw messages.
func UnmarshalSearchEmailRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchEmailRequestParams)
	err = core.UnmarshalPrimitive(m, "attendeesAddresses", &obj.AttendeesAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "attendeesAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bccRecipientAddresses", &obj.BccRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "bccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ccRecipientAddresses", &obj.CcRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "ccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "createdEndTimeSecs", &obj.CreatedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "createdStartTimeSecs", &obj.CreatedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dueDateEndTimeSecs", &obj.DueDateEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "dueDateEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dueDateStartTimeSecs", &obj.DueDateStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "dueDateStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "emailAddress", &obj.EmailAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "emailSubject", &obj.EmailSubject)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailSubject-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "firstName", &obj.FirstName)
	if err != nil {
		err = core.SDKErrorf(err, "", "firstName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "folderNames", &obj.FolderNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "folderNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasAttachment", &obj.HasAttachment)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasAttachment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModifiedEndTimeSecs", &obj.LastModifiedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModifiedEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModifiedStartTimeSecs", &obj.LastModifiedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModifiedStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastName", &obj.LastName)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "middleName", &obj.MiddleName)
	if err != nil {
		err = core.SDKErrorf(err, "", "middleName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "organizerAddress", &obj.OrganizerAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "organizerAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedEndTimeSecs", &obj.ReceivedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedStartTimeSecs", &obj.ReceivedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recipientAddresses", &obj.RecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "recipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "senderAddress", &obj.SenderAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "senderAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceEnvironment", &obj.SourceEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceEnvironment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "taskStatusTypes", &obj.TaskStatusTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskStatusTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "types", &obj.Types)
	if err != nil {
		err = core.SDKErrorf(err, "", "types-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "o365Params", &obj.O365Params, UnmarshalO365SearchEmailsRequestParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "o365Params-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchEmailRequestParamsBase : Specifies the request parameters to search for mailbox items and folders.
type SearchEmailRequestParamsBase struct {
	// Filters the calendar items which have specified email addresses as attendees.
	AttendeesAddresses []string `json:"attendeesAddresses,omitempty"`

	// Filters the emails which are sent to specified email addresses in BCC.
	BccRecipientAddresses []string `json:"bccRecipientAddresses,omitempty"`

	// Filters the emails which are sent to specified email addresses in CC.
	CcRecipientAddresses []string `json:"ccRecipientAddresses,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the created time of the email/item is less than
	// specified value.
	CreatedEndTimeSecs *int64 `json:"createdEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the created time of the email/item is more than
	// specified value.
	CreatedStartTimeSecs *int64 `json:"createdStartTimeSecs,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the last modification time of the email/item is less
	// than specified value.
	DueDateEndTimeSecs *int64 `json:"dueDateEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the last modification time of the email/item is
	// more than specified value.
	DueDateStartTimeSecs *int64 `json:"dueDateStartTimeSecs,omitempty"`

	// Filters the contact items which have specified text in email address.
	EmailAddress *string `json:"emailAddress,omitempty"`

	// Filters the emails which have the specified text in its subject.
	EmailSubject *string `json:"emailSubject,omitempty"`

	// Filters the contacts with specified text in first name.
	FirstName *string `json:"firstName,omitempty"`

	// Filters the emails which are categorized to specified folders.
	FolderNames []string `json:"folderNames,omitempty"`

	// Filters the emails which have attachment.
	HasAttachment *bool `json:"hasAttachment,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the last modification time of the email/item is less
	// than specified value.
	LastModifiedEndTimeSecs *int64 `json:"lastModifiedEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the last modification time of the email/item is
	// more than specified value.
	LastModifiedStartTimeSecs *int64 `json:"lastModifiedStartTimeSecs,omitempty"`

	// Filters the contacts with specified text in last name.
	LastName *string `json:"lastName,omitempty"`

	// Filters the contacts with specified text in middle name.
	MiddleName *string `json:"middleName,omitempty"`

	// Filters the calendar items which are organized by specified User's email address.
	OrganizerAddress *string `json:"organizerAddress,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the received time of the email is less than
	// specified value.
	ReceivedEndTimeSecs *int64 `json:"receivedEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the received time of the email is more than
	// specified value.
	ReceivedStartTimeSecs *int64 `json:"receivedStartTimeSecs,omitempty"`

	// Filters the emails which are sent to specified email addresses.
	RecipientAddresses []string `json:"recipientAddresses,omitempty"`

	// Filters the emails which are received from specified User's email address.
	SenderAddress *string `json:"senderAddress,omitempty"`

	// Specifies the source environment.
	SourceEnvironment *string `json:"sourceEnvironment,omitempty"`

	// Specifies a list of task item status types. Task items having status within the given types will be returned.
	TaskStatusTypes []string `json:"taskStatusTypes,omitempty"`

	// Specifies a list of mailbox item types. Only items within the given types will be returned.
	Types []string `json:"types,omitempty"`
}

// Constants associated with the SearchEmailRequestParamsBase.SourceEnvironment property.
// Specifies the source environment.
const (
	SearchEmailRequestParamsBase_SourceEnvironment_Ko365 = "kO365"
)

// Constants associated with the SearchEmailRequestParamsBase.TaskStatusTypes property.
const (
	SearchEmailRequestParamsBase_TaskStatusTypes_Completed       = "Completed"
	SearchEmailRequestParamsBase_TaskStatusTypes_Deferred        = "Deferred"
	SearchEmailRequestParamsBase_TaskStatusTypes_Inprogress      = "InProgress"
	SearchEmailRequestParamsBase_TaskStatusTypes_Notstarted      = "NotStarted"
	SearchEmailRequestParamsBase_TaskStatusTypes_Waitingonothers = "WaitingOnOthers"
)

// Constants associated with the SearchEmailRequestParamsBase.Types property.
const (
	SearchEmailRequestParamsBase_Types_Calendar = "Calendar"
	SearchEmailRequestParamsBase_Types_Contact  = "Contact"
	SearchEmailRequestParamsBase_Types_Email    = "Email"
	SearchEmailRequestParamsBase_Types_Folder   = "Folder"
	SearchEmailRequestParamsBase_Types_Note     = "Note"
	SearchEmailRequestParamsBase_Types_Task     = "Task"
)

// UnmarshalSearchEmailRequestParamsBase unmarshals an instance of SearchEmailRequestParamsBase from the specified map of raw messages.
func UnmarshalSearchEmailRequestParamsBase(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchEmailRequestParamsBase)
	err = core.UnmarshalPrimitive(m, "attendeesAddresses", &obj.AttendeesAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "attendeesAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bccRecipientAddresses", &obj.BccRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "bccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ccRecipientAddresses", &obj.CcRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "ccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "createdEndTimeSecs", &obj.CreatedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "createdStartTimeSecs", &obj.CreatedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dueDateEndTimeSecs", &obj.DueDateEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "dueDateEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dueDateStartTimeSecs", &obj.DueDateStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "dueDateStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "emailAddress", &obj.EmailAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "emailSubject", &obj.EmailSubject)
	if err != nil {
		err = core.SDKErrorf(err, "", "emailSubject-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "firstName", &obj.FirstName)
	if err != nil {
		err = core.SDKErrorf(err, "", "firstName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "folderNames", &obj.FolderNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "folderNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasAttachment", &obj.HasAttachment)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasAttachment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModifiedEndTimeSecs", &obj.LastModifiedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModifiedEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastModifiedStartTimeSecs", &obj.LastModifiedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastModifiedStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastName", &obj.LastName)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "middleName", &obj.MiddleName)
	if err != nil {
		err = core.SDKErrorf(err, "", "middleName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "organizerAddress", &obj.OrganizerAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "organizerAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedEndTimeSecs", &obj.ReceivedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedStartTimeSecs", &obj.ReceivedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recipientAddresses", &obj.RecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "recipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "senderAddress", &obj.SenderAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "senderAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceEnvironment", &obj.SourceEnvironment)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceEnvironment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "taskStatusTypes", &obj.TaskStatusTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "taskStatusTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "types", &obj.Types)
	if err != nil {
		err = core.SDKErrorf(err, "", "types-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchExchangeObjectsRequestParams : Specifies the parameters which are specific for searching Exchange mailboxes.
type SearchExchangeObjectsRequestParams struct {
	// Specifies the search string to search the Exchange Objects.
	SearchString *string `json:"searchString" validate:"required"`
}

// NewSearchExchangeObjectsRequestParams : Instantiate SearchExchangeObjectsRequestParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewSearchExchangeObjectsRequestParams(searchString string) (_model *SearchExchangeObjectsRequestParams, err error) {
	_model = &SearchExchangeObjectsRequestParams{
		SearchString: core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalSearchExchangeObjectsRequestParams unmarshals an instance of SearchExchangeObjectsRequestParams from the specified map of raw messages.
func UnmarshalSearchExchangeObjectsRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchExchangeObjectsRequestParams)
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchFileRequestParams : Specifies the request parameters to search for files and file folders.
type SearchFileRequestParams struct {
	// Specifies the search string to filter the files. User can specify a wildcard character '*' as a suffix to a string
	// where all files name are matched with the prefix string.
	SearchString *string `json:"searchString,omitempty"`

	// Specifies a list of file types. Only files within the given types will be returned.
	Types []string `json:"types,omitempty"`

	// Specifies a list of the source environments. Only files from these types of source will be returned.
	SourceEnvironments []string `json:"sourceEnvironments,omitempty"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`

	// Specifies a list of object ids. Only files found in these objects will be returned.
	ObjectIds []int64 `json:"objectIds,omitempty"`
}

// Constants associated with the SearchFileRequestParams.Types property.
const (
	SearchFileRequestParams_Types_Directory = "Directory"
	SearchFileRequestParams_Types_File      = "File"
	SearchFileRequestParams_Types_Symlink   = "Symlink"
)

// Constants associated with the SearchFileRequestParams.SourceEnvironments property.
const (
	SearchFileRequestParams_SourceEnvironments_Kacropolis      = "kAcropolis"
	SearchFileRequestParams_SourceEnvironments_Kaws            = "kAWS"
	SearchFileRequestParams_SourceEnvironments_Kazure          = "kAzure"
	SearchFileRequestParams_SourceEnvironments_Kelastifile     = "kElastifile"
	SearchFileRequestParams_SourceEnvironments_Kexchange       = "kExchange"
	SearchFileRequestParams_SourceEnvironments_Kflashblade     = "kFlashBlade"
	SearchFileRequestParams_SourceEnvironments_Kgcp            = "kGCP"
	SearchFileRequestParams_SourceEnvironments_Kgenericnas     = "kGenericNas"
	SearchFileRequestParams_SourceEnvironments_Kgpfs           = "kGPFS"
	SearchFileRequestParams_SourceEnvironments_Khyperflex      = "kHyperFlex"
	SearchFileRequestParams_SourceEnvironments_Khyperv         = "kHyperV"
	SearchFileRequestParams_SourceEnvironments_Kibmflashsystem = "kIbmFlashSystem"
	SearchFileRequestParams_SourceEnvironments_Kisilon         = "kIsilon"
	SearchFileRequestParams_SourceEnvironments_Kkubernetes     = "kKubernetes"
	SearchFileRequestParams_SourceEnvironments_Kkvm            = "kKVM"
	SearchFileRequestParams_SourceEnvironments_Knetapp         = "kNetapp"
	SearchFileRequestParams_SourceEnvironments_Ko365           = "kO365"
	SearchFileRequestParams_SourceEnvironments_Koracle         = "kOracle"
	SearchFileRequestParams_SourceEnvironments_Kphysical       = "kPhysical"
	SearchFileRequestParams_SourceEnvironments_Kphysicalfiles  = "kPhysicalFiles"
	SearchFileRequestParams_SourceEnvironments_Kpure           = "kPure"
	SearchFileRequestParams_SourceEnvironments_Kremoteadapter  = "kRemoteAdapter"
	SearchFileRequestParams_SourceEnvironments_Ksaphana        = "kSAPHANA"
	SearchFileRequestParams_SourceEnvironments_Ksfdc           = "kSfdc"
	SearchFileRequestParams_SourceEnvironments_Ksql            = "kSQL"
	SearchFileRequestParams_SourceEnvironments_Kuda            = "kUDA"
	SearchFileRequestParams_SourceEnvironments_Kview           = "kView"
	SearchFileRequestParams_SourceEnvironments_Kvmware         = "kVMware"
)

// UnmarshalSearchFileRequestParams unmarshals an instance of SearchFileRequestParams from the specified map of raw messages.
func UnmarshalSearchFileRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchFileRequestParams)
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "types", &obj.Types)
	if err != nil {
		err = core.SDKErrorf(err, "", "types-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceEnvironments", &obj.SourceEnvironments)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceEnvironments-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectIds", &obj.ObjectIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchIndexedObjectsOptions : The SearchIndexedObjects options.
type SearchIndexedObjectsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the object type to be searched for.
	ObjectType *string `json:"objectType" validate:"required"`

	// Specifies a list of Protection Group ids to filter the indexed objects. If specified, the objects indexed by
	// specified Protection Group ids will be returned.
	ProtectionGroupIds []string `json:"protectionGroupIds,omitempty"`

	// Specifies the Storage Domain ids to filter indexed objects for which Protection Groups are writing data to Cohesity
	// Views on the specified Storage Domains.
	StorageDomainIds []int64 `json:"storageDomainIds,omitempty"`

	// TenantId contains id of the tenant for which objects are to be returned.
	TenantID *string `json:"tenantId,omitempty"`

	// If true, the response will include objects which belongs to all tenants which the current user has permission to
	// see. Default value is false.
	IncludeTenants *bool `json:"includeTenants,omitempty"`

	// "This field is deprecated. Please use mightHaveTagIds.".
	Tags []string `json:"tags,omitempty"`

	// "This field is deprecated. Please use mightHaveSnapshotTagIds.".
	SnapshotTags []string `json:"snapshotTags,omitempty"`

	// Specifies tags which must be all present in the document.
	MustHaveTagIds []string `json:"mustHaveTagIds,omitempty"`

	// Specifies list of tags, one or more of which might be present in the document. These are OR'ed together and the
	// resulting criteria AND'ed with the rest of the query.
	MightHaveTagIds []string `json:"mightHaveTagIds,omitempty"`

	// Specifies snapshot tags which must be all present in the document.
	MustHaveSnapshotTagIds []string `json:"mustHaveSnapshotTagIds,omitempty"`

	// Specifies list of snapshot tags, one or more of which might be present in the document. These are OR'ed together and
	// the resulting criteria AND'ed with the rest of the query.
	MightHaveSnapshotTagIds []string `json:"mightHaveSnapshotTagIds,omitempty"`

	// Specifies the pagination cookie with which subsequent parts of the response can be fetched.
	PaginationCookie *string `json:"paginationCookie,omitempty"`

	// Specifies the number of indexed objects to be fetched for the specified pagination cookie.
	Count *int64 `json:"count,omitempty"`

	// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the
	// read replica and primary data source.
	UseCachedData *bool `json:"useCachedData,omitempty"`

	// Parameters required to search Cassandra on a cluster.
	CassandraParams *CassandraOnPremSearchParams `json:"cassandraParams,omitempty"`

	// Parameters required to search CouchBase on a cluster.
	CouchbaseParams *CouchBaseOnPremSearchParams `json:"couchbaseParams,omitempty"`

	// Specifies the request parameters to search for emails and email folders.
	EmailParams *SearchEmailRequestParams `json:"emailParams,omitempty"`

	// Specifies the parameters which are specific for searching Exchange mailboxes.
	ExchangeParams *SearchExchangeObjectsRequestParams `json:"exchangeParams,omitempty"`

	// Specifies the request parameters to search for files and file folders.
	FileParams *SearchFileRequestParams `json:"fileParams,omitempty"`

	// Parameters required to search Hbase on a cluster.
	HbaseParams *HbaseOnPremSearchParams `json:"hbaseParams,omitempty"`

	// Parameters required to search HDFS on a cluster.
	HdfsParams *HDFSOnPremSearchParams `json:"hdfsParams,omitempty"`

	// Parameters required to search Hive on a cluster.
	HiveParams *HiveOnPremSearchParams `json:"hiveParams,omitempty"`

	// Parameters required to search Mongo DB on a cluster.
	MongodbParams *MongoDbOnPremSearchParams `json:"mongodbParams,omitempty"`

	// Specifies the request params to search for Groups items.
	MsGroupsParams *SearchMsGroupsRequestParams `json:"msGroupsParams,omitempty"`

	// Specifies the request params to search for Teams items.
	MsTeamsParams *SearchMsTeamsRequestParams `json:"msTeamsParams,omitempty"`

	// Specifies the request parameters to search for files/folders in document libraries.
	OneDriveParams *SearchDocumentLibraryRequestParams `json:"oneDriveParams,omitempty"`

	// Specifies the request parameters to search for Public Folder items.
	PublicFolderParams *SearchPublicFolderRequestParams `json:"publicFolderParams,omitempty"`

	// Specifies the parameters which are specific for searching Salesforce records.
	SfdcParams *SearchSfdcRecordsRequestParams `json:"sfdcParams,omitempty"`

	// Specifies the request parameters to search for files/folders in document libraries.
	SharepointParams *SearchDocumentLibraryRequestParams `json:"sharepointParams,omitempty"`

	// Parameters required to search Universal Data Adapter objects.
	UdaParams *UdaOnPremSearchParams `json:"udaParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the SearchIndexedObjectsOptions.ObjectType property.
// Specifies the object type to be searched for.
const (
	SearchIndexedObjectsOptions_ObjectType_Cassandraobjects  = "CassandraObjects"
	SearchIndexedObjectsOptions_ObjectType_Couchbaseobjects  = "CouchbaseObjects"
	SearchIndexedObjectsOptions_ObjectType_Emails            = "Emails"
	SearchIndexedObjectsOptions_ObjectType_Exchangeobjects   = "ExchangeObjects"
	SearchIndexedObjectsOptions_ObjectType_Files             = "Files"
	SearchIndexedObjectsOptions_ObjectType_Groupsobjects     = "GroupsObjects"
	SearchIndexedObjectsOptions_ObjectType_Hbaseobjects      = "HbaseObjects"
	SearchIndexedObjectsOptions_ObjectType_Hdfsobjects       = "HDFSObjects"
	SearchIndexedObjectsOptions_ObjectType_Hiveobjects       = "HiveObjects"
	SearchIndexedObjectsOptions_ObjectType_Mongoobjects      = "MongoObjects"
	SearchIndexedObjectsOptions_ObjectType_Onedriveobjects   = "OneDriveObjects"
	SearchIndexedObjectsOptions_ObjectType_Publicfolders     = "PublicFolders"
	SearchIndexedObjectsOptions_ObjectType_Sfdcrecords       = "SfdcRecords"
	SearchIndexedObjectsOptions_ObjectType_Sharepointobjects = "SharepointObjects"
	SearchIndexedObjectsOptions_ObjectType_Teamsobjects      = "TeamsObjects"
	SearchIndexedObjectsOptions_ObjectType_Udaobjects        = "UdaObjects"
)

// NewSearchIndexedObjectsOptions : Instantiate SearchIndexedObjectsOptions
func (*BackupRecoveryV1) NewSearchIndexedObjectsOptions(xIBMTenantID string, objectType string) *SearchIndexedObjectsOptions {
	return &SearchIndexedObjectsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		ObjectType:   core.StringPtr(objectType),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *SearchIndexedObjectsOptions) SetXIBMTenantID(xIBMTenantID string) *SearchIndexedObjectsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetObjectType : Allow user to set ObjectType
func (_options *SearchIndexedObjectsOptions) SetObjectType(objectType string) *SearchIndexedObjectsOptions {
	_options.ObjectType = core.StringPtr(objectType)
	return _options
}

// SetProtectionGroupIds : Allow user to set ProtectionGroupIds
func (_options *SearchIndexedObjectsOptions) SetProtectionGroupIds(protectionGroupIds []string) *SearchIndexedObjectsOptions {
	_options.ProtectionGroupIds = protectionGroupIds
	return _options
}

// SetStorageDomainIds : Allow user to set StorageDomainIds
func (_options *SearchIndexedObjectsOptions) SetStorageDomainIds(storageDomainIds []int64) *SearchIndexedObjectsOptions {
	_options.StorageDomainIds = storageDomainIds
	return _options
}

// SetTenantID : Allow user to set TenantID
func (_options *SearchIndexedObjectsOptions) SetTenantID(tenantID string) *SearchIndexedObjectsOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetIncludeTenants : Allow user to set IncludeTenants
func (_options *SearchIndexedObjectsOptions) SetIncludeTenants(includeTenants bool) *SearchIndexedObjectsOptions {
	_options.IncludeTenants = core.BoolPtr(includeTenants)
	return _options
}

// SetTags : Allow user to set Tags
func (_options *SearchIndexedObjectsOptions) SetTags(tags []string) *SearchIndexedObjectsOptions {
	_options.Tags = tags
	return _options
}

// SetSnapshotTags : Allow user to set SnapshotTags
func (_options *SearchIndexedObjectsOptions) SetSnapshotTags(snapshotTags []string) *SearchIndexedObjectsOptions {
	_options.SnapshotTags = snapshotTags
	return _options
}

// SetMustHaveTagIds : Allow user to set MustHaveTagIds
func (_options *SearchIndexedObjectsOptions) SetMustHaveTagIds(mustHaveTagIds []string) *SearchIndexedObjectsOptions {
	_options.MustHaveTagIds = mustHaveTagIds
	return _options
}

// SetMightHaveTagIds : Allow user to set MightHaveTagIds
func (_options *SearchIndexedObjectsOptions) SetMightHaveTagIds(mightHaveTagIds []string) *SearchIndexedObjectsOptions {
	_options.MightHaveTagIds = mightHaveTagIds
	return _options
}

// SetMustHaveSnapshotTagIds : Allow user to set MustHaveSnapshotTagIds
func (_options *SearchIndexedObjectsOptions) SetMustHaveSnapshotTagIds(mustHaveSnapshotTagIds []string) *SearchIndexedObjectsOptions {
	_options.MustHaveSnapshotTagIds = mustHaveSnapshotTagIds
	return _options
}

// SetMightHaveSnapshotTagIds : Allow user to set MightHaveSnapshotTagIds
func (_options *SearchIndexedObjectsOptions) SetMightHaveSnapshotTagIds(mightHaveSnapshotTagIds []string) *SearchIndexedObjectsOptions {
	_options.MightHaveSnapshotTagIds = mightHaveSnapshotTagIds
	return _options
}

// SetPaginationCookie : Allow user to set PaginationCookie
func (_options *SearchIndexedObjectsOptions) SetPaginationCookie(paginationCookie string) *SearchIndexedObjectsOptions {
	_options.PaginationCookie = core.StringPtr(paginationCookie)
	return _options
}

// SetCount : Allow user to set Count
func (_options *SearchIndexedObjectsOptions) SetCount(count int64) *SearchIndexedObjectsOptions {
	_options.Count = core.Int64Ptr(count)
	return _options
}

// SetUseCachedData : Allow user to set UseCachedData
func (_options *SearchIndexedObjectsOptions) SetUseCachedData(useCachedData bool) *SearchIndexedObjectsOptions {
	_options.UseCachedData = core.BoolPtr(useCachedData)
	return _options
}

// SetCassandraParams : Allow user to set CassandraParams
func (_options *SearchIndexedObjectsOptions) SetCassandraParams(cassandraParams *CassandraOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.CassandraParams = cassandraParams
	return _options
}

// SetCouchbaseParams : Allow user to set CouchbaseParams
func (_options *SearchIndexedObjectsOptions) SetCouchbaseParams(couchbaseParams *CouchBaseOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.CouchbaseParams = couchbaseParams
	return _options
}

// SetEmailParams : Allow user to set EmailParams
func (_options *SearchIndexedObjectsOptions) SetEmailParams(emailParams *SearchEmailRequestParams) *SearchIndexedObjectsOptions {
	_options.EmailParams = emailParams
	return _options
}

// SetExchangeParams : Allow user to set ExchangeParams
func (_options *SearchIndexedObjectsOptions) SetExchangeParams(exchangeParams *SearchExchangeObjectsRequestParams) *SearchIndexedObjectsOptions {
	_options.ExchangeParams = exchangeParams
	return _options
}

// SetFileParams : Allow user to set FileParams
func (_options *SearchIndexedObjectsOptions) SetFileParams(fileParams *SearchFileRequestParams) *SearchIndexedObjectsOptions {
	_options.FileParams = fileParams
	return _options
}

// SetHbaseParams : Allow user to set HbaseParams
func (_options *SearchIndexedObjectsOptions) SetHbaseParams(hbaseParams *HbaseOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.HbaseParams = hbaseParams
	return _options
}

// SetHdfsParams : Allow user to set HdfsParams
func (_options *SearchIndexedObjectsOptions) SetHdfsParams(hdfsParams *HDFSOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.HdfsParams = hdfsParams
	return _options
}

// SetHiveParams : Allow user to set HiveParams
func (_options *SearchIndexedObjectsOptions) SetHiveParams(hiveParams *HiveOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.HiveParams = hiveParams
	return _options
}

// SetMongodbParams : Allow user to set MongodbParams
func (_options *SearchIndexedObjectsOptions) SetMongodbParams(mongodbParams *MongoDbOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.MongodbParams = mongodbParams
	return _options
}

// SetMsGroupsParams : Allow user to set MsGroupsParams
func (_options *SearchIndexedObjectsOptions) SetMsGroupsParams(msGroupsParams *SearchMsGroupsRequestParams) *SearchIndexedObjectsOptions {
	_options.MsGroupsParams = msGroupsParams
	return _options
}

// SetMsTeamsParams : Allow user to set MsTeamsParams
func (_options *SearchIndexedObjectsOptions) SetMsTeamsParams(msTeamsParams *SearchMsTeamsRequestParams) *SearchIndexedObjectsOptions {
	_options.MsTeamsParams = msTeamsParams
	return _options
}

// SetOneDriveParams : Allow user to set OneDriveParams
func (_options *SearchIndexedObjectsOptions) SetOneDriveParams(oneDriveParams *SearchDocumentLibraryRequestParams) *SearchIndexedObjectsOptions {
	_options.OneDriveParams = oneDriveParams
	return _options
}

// SetPublicFolderParams : Allow user to set PublicFolderParams
func (_options *SearchIndexedObjectsOptions) SetPublicFolderParams(publicFolderParams *SearchPublicFolderRequestParams) *SearchIndexedObjectsOptions {
	_options.PublicFolderParams = publicFolderParams
	return _options
}

// SetSfdcParams : Allow user to set SfdcParams
func (_options *SearchIndexedObjectsOptions) SetSfdcParams(sfdcParams *SearchSfdcRecordsRequestParams) *SearchIndexedObjectsOptions {
	_options.SfdcParams = sfdcParams
	return _options
}

// SetSharepointParams : Allow user to set SharepointParams
func (_options *SearchIndexedObjectsOptions) SetSharepointParams(sharepointParams *SearchDocumentLibraryRequestParams) *SearchIndexedObjectsOptions {
	_options.SharepointParams = sharepointParams
	return _options
}

// SetUdaParams : Allow user to set UdaParams
func (_options *SearchIndexedObjectsOptions) SetUdaParams(udaParams *UdaOnPremSearchParams) *SearchIndexedObjectsOptions {
	_options.UdaParams = udaParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SearchIndexedObjectsOptions) SetHeaders(param map[string]string) *SearchIndexedObjectsOptions {
	options.Headers = param
	return options
}

// SearchIndexedObjectsResponse : Specifies the common search indexed objects response params.
type SearchIndexedObjectsResponse struct {
	// Specifies the object type.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the total number of indexed objects that match the filter and search criteria. Use this value to determine
	// how many additional requests are required to get the full result.
	Count *int64 `json:"count,omitempty"`

	// Specifies cookie for resuming search if pagination is being used.
	PaginationCookie *string `json:"paginationCookie,omitempty"`

	// Specifies the indexed Cassandra objects.
	CassandraObjects []CassandraIndexedObject `json:"cassandraObjects,omitempty"`

	// Specifies the indexed Couchbase objects.
	CouchbaseObjects []CouchbaseIndexedObject `json:"couchbaseObjects,omitempty"`

	// Specifies the indexed emails and email folders.
	Emails []Email `json:"emails,omitempty"`

	// Specifies the indexed HDFS objects.
	ExchangeObjects []ExchangeIndexedObject `json:"exchangeObjects,omitempty"`

	// Specifies the indexed files.
	Files []File `json:"files,omitempty"`

	// Specifies the indexed Hbase objects.
	HbaseObjects []HbaseIndexedObject `json:"hbaseObjects,omitempty"`

	// Specifies the indexed HDFS objects.
	HdfsObjects []HDFSIndexedObject `json:"hdfsObjects,omitempty"`

	// Specifies the indexed Hive objects.
	HiveObjects []HiveIndexedObject `json:"hiveObjects,omitempty"`

	// Specifies the indexed Mongo objects.
	MongoObjects []MongoIndexedObject `json:"mongoObjects,omitempty"`

	// Specifies the indexed M365 Groups items like group mail items, files etc.
	MsGroupItems []MsGroupItem `json:"msGroupItems,omitempty"`

	// Specifies the indexed one drive items.
	OneDriveItems []DocumentLibraryItem `json:"oneDriveItems,omitempty"`

	// Specifies the indexed Public folder items.
	PublicFolderItems []PublicFolderItem `json:"publicFolderItems,omitempty"`

	// Specifies the list of salesforce records.
	SfdcRecords *SfdcRecords `json:"sfdcRecords,omitempty"`

	// Specifies the indexed Sharepoint items.
	SharepointItems []SharepointItem `json:"sharepointItems,omitempty"`

	// Specifies the indexed M365 Teams items like channels, files etc.
	TeamsItems []TeamsItem `json:"teamsItems,omitempty"`

	// Specifies the indexed Universal Data Adapter objects.
	UdaObjects []UdaIndexedObject `json:"udaObjects,omitempty"`
}

// Constants associated with the SearchIndexedObjectsResponse.ObjectType property.
// Specifies the object type.
const (
	SearchIndexedObjectsResponse_ObjectType_Cassandraobjects  = "CassandraObjects"
	SearchIndexedObjectsResponse_ObjectType_Couchbaseobjects  = "CouchbaseObjects"
	SearchIndexedObjectsResponse_ObjectType_Emails            = "Emails"
	SearchIndexedObjectsResponse_ObjectType_Exchangeobjects   = "ExchangeObjects"
	SearchIndexedObjectsResponse_ObjectType_Files             = "Files"
	SearchIndexedObjectsResponse_ObjectType_Groupsobjects     = "GroupsObjects"
	SearchIndexedObjectsResponse_ObjectType_Hbaseobjects      = "HbaseObjects"
	SearchIndexedObjectsResponse_ObjectType_Hdfsobjects       = "HDFSObjects"
	SearchIndexedObjectsResponse_ObjectType_Hiveobjects       = "HiveObjects"
	SearchIndexedObjectsResponse_ObjectType_Mongoobjects      = "MongoObjects"
	SearchIndexedObjectsResponse_ObjectType_Onedriveobjects   = "OneDriveObjects"
	SearchIndexedObjectsResponse_ObjectType_Publicfolders     = "PublicFolders"
	SearchIndexedObjectsResponse_ObjectType_Sfdcrecords       = "SfdcRecords"
	SearchIndexedObjectsResponse_ObjectType_Sharepointobjects = "SharepointObjects"
	SearchIndexedObjectsResponse_ObjectType_Teamsobjects      = "TeamsObjects"
	SearchIndexedObjectsResponse_ObjectType_Udaobjects        = "UdaObjects"
)

// UnmarshalSearchIndexedObjectsResponse unmarshals an instance of SearchIndexedObjectsResponse from the specified map of raw messages.
func UnmarshalSearchIndexedObjectsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchIndexedObjectsResponse)
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		err = core.SDKErrorf(err, "", "count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "paginationCookie", &obj.PaginationCookie)
	if err != nil {
		err = core.SDKErrorf(err, "", "paginationCookie-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cassandraObjects", &obj.CassandraObjects, UnmarshalCassandraIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "cassandraObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "couchbaseObjects", &obj.CouchbaseObjects, UnmarshalCouchbaseIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "couchbaseObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "emails", &obj.Emails, UnmarshalEmail)
	if err != nil {
		err = core.SDKErrorf(err, "", "emails-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "exchangeObjects", &obj.ExchangeObjects, UnmarshalExchangeIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "exchangeObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "files", &obj.Files, UnmarshalFile)
	if err != nil {
		err = core.SDKErrorf(err, "", "files-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hbaseObjects", &obj.HbaseObjects, UnmarshalHbaseIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "hbaseObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hdfsObjects", &obj.HdfsObjects, UnmarshalHDFSIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "hdfsObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hiveObjects", &obj.HiveObjects, UnmarshalHiveIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "hiveObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mongoObjects", &obj.MongoObjects, UnmarshalMongoIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "mongoObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "msGroupItems", &obj.MsGroupItems, UnmarshalMsGroupItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "msGroupItems-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "oneDriveItems", &obj.OneDriveItems, UnmarshalDocumentLibraryItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "oneDriveItems-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "publicFolderItems", &obj.PublicFolderItems, UnmarshalPublicFolderItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "publicFolderItems-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sfdcRecords", &obj.SfdcRecords, UnmarshalSfdcRecords)
	if err != nil {
		err = core.SDKErrorf(err, "", "sfdcRecords-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointItems", &obj.SharepointItems, UnmarshalSharepointItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointItems-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "teamsItems", &obj.TeamsItems, UnmarshalTeamsItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "teamsItems-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "udaObjects", &obj.UdaObjects, UnmarshalUdaIndexedObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "udaObjects-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchMsGroupsRequestParams : Specifies the request params to search for Groups items.
type SearchMsGroupsRequestParams struct {
	// Specifies the request parameters to search for mailbox items and folders.
	MailboxParams *SearchEmailRequestParamsBase `json:"mailboxParams,omitempty"`

	// Specifies O365 specific params search request params to search for indexed items.
	O365Params *O365SearchRequestParams `json:"o365Params,omitempty"`

	// Specifies the request parameters to search for files/folders in document libraries.
	SiteParams *SearchDocumentLibraryRequestParams `json:"siteParams,omitempty"`
}

// UnmarshalSearchMsGroupsRequestParams unmarshals an instance of SearchMsGroupsRequestParams from the specified map of raw messages.
func UnmarshalSearchMsGroupsRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchMsGroupsRequestParams)
	err = core.UnmarshalModel(m, "mailboxParams", &obj.MailboxParams, UnmarshalSearchEmailRequestParamsBase)
	if err != nil {
		err = core.SDKErrorf(err, "", "mailboxParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "o365Params", &obj.O365Params, UnmarshalO365SearchRequestParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "o365Params-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "siteParams", &obj.SiteParams, UnmarshalSearchDocumentLibraryRequestParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "siteParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchMsTeamsRequestParams : Specifies the request params to search for Teams items.
type SearchMsTeamsRequestParams struct {
	// Specifies a list of teams files types. Only items within the given types will be returned.
	CategoryTypes []string `json:"categoryTypes,omitempty"`

	// Specifies the list of channel names to filter while doing search for files.
	ChannelNames []string `json:"channelNames,omitempty"`

	// Specifies the request parameters related to channels for Microsoft365 teams.
	ChannelParams *O365TeamsChannelsSearchRequestParams `json:"channelParams,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds when the item is created.
	CreationEndTimeSecs *int64 `json:"creationEndTimeSecs,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds when the item is created.
	CreationStartTimeSecs *int64 `json:"creationStartTimeSecs,omitempty"`

	// Specifies O365 specific params search request params to search for indexed items.
	O365Params *O365SearchRequestParams `json:"o365Params,omitempty"`

	// Specifies the list of owner email ids to filter on owner of the item.
	OwnerNames []string `json:"ownerNames,omitempty"`

	// Specifies the search string to filter the items. User can specify a wildcard character '*' as a suffix to a string
	// where all item names are matched with the prefix string.
	SearchString *string `json:"searchString,omitempty"`

	// Specifies the minimum size of the item in bytes.
	SizeBytesLowerLimit *int64 `json:"sizeBytesLowerLimit,omitempty"`

	// Specifies the maximum size of the item in bytes.
	SizeBytesUpperLimit *int64 `json:"sizeBytesUpperLimit,omitempty"`

	// Specifies a list of Teams item types. Only items within the given types will be returned.
	Types []string `json:"types,omitempty"`
}

// Constants associated with the SearchMsTeamsRequestParams.CategoryTypes property.
const (
	SearchMsTeamsRequestParams_CategoryTypes_Document   = "Document"
	SearchMsTeamsRequestParams_CategoryTypes_Excel      = "Excel"
	SearchMsTeamsRequestParams_CategoryTypes_Image      = "Image"
	SearchMsTeamsRequestParams_CategoryTypes_Onenote    = "OneNote"
	SearchMsTeamsRequestParams_CategoryTypes_Powerpoint = "Powerpoint"
)

// Constants associated with the SearchMsTeamsRequestParams.Types property.
const (
	SearchMsTeamsRequestParams_Types_Channel      = "Channel"
	SearchMsTeamsRequestParams_Types_Chat         = "Chat"
	SearchMsTeamsRequestParams_Types_Conversation = "Conversation"
	SearchMsTeamsRequestParams_Types_File         = "File"
	SearchMsTeamsRequestParams_Types_Folder       = "Folder"
)

// UnmarshalSearchMsTeamsRequestParams unmarshals an instance of SearchMsTeamsRequestParams from the specified map of raw messages.
func UnmarshalSearchMsTeamsRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchMsTeamsRequestParams)
	err = core.UnmarshalPrimitive(m, "categoryTypes", &obj.CategoryTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "categoryTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "channelNames", &obj.ChannelNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "channelParams", &obj.ChannelParams, UnmarshalO365TeamsChannelsSearchRequestParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "creationEndTimeSecs", &obj.CreationEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "creationStartTimeSecs", &obj.CreationStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "o365Params", &obj.O365Params, UnmarshalO365SearchRequestParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "o365Params-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownerNames", &obj.OwnerNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownerNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sizeBytesLowerLimit", &obj.SizeBytesLowerLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "sizeBytesLowerLimit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sizeBytesUpperLimit", &obj.SizeBytesUpperLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "sizeBytesUpperLimit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "types", &obj.Types)
	if err != nil {
		err = core.SDKErrorf(err, "", "types-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObject : Specifies an object.
type SearchObject struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`

	// Specifies the count and size of protected and unprotected objects for the size.
	ProtectionStats []ObjectProtectionStatsSummary `json:"protectionStats,omitempty"`

	// Specifies the list of users, groups and users that have permissions for a given object.
	Permissions *PermissionInfo `json:"permissions,omitempty"`

	// Specifies the parameters for Msssql object.
	MssqlParams *SearchObjectMssqlParams `json:"mssqlParams,omitempty"`

	// Specifies the parameters for Physical object.
	PhysicalParams *SearchObjectPhysicalParams `json:"physicalParams,omitempty"`

	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the helios tag information for the object.
	HeliosTags []HeliosTagInfo `json:"heliosTags,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *SearchObjectSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the object info on each cluster.
	ObjectProtectionInfos []ObjectProtectionInfo `json:"objectProtectionInfos,omitempty"`

	// Specifies secondary IDs associated to the object.
	SecondaryIds []SecondaryID `json:"secondaryIds,omitempty"`

	// Specifies the helios tagged snapshots (snapshots which are tagged by user or thirdparty in control plane) for the
	// object.
	TaggedSnapshots []TaggedSnapshotInfo `json:"taggedSnapshots,omitempty"`
}

// Constants associated with the SearchObject.Environment property.
// Specifies the environment of the object.
const (
	SearchObject_Environment_Kphysical = "kPhysical"
	SearchObject_Environment_Ksql      = "kSQL"
)

// Constants associated with the SearchObject.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	SearchObject_ProtectionType_Kagent                 = "kAgent"
	SearchObject_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	SearchObject_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	SearchObject_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	SearchObject_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	SearchObject_ProtectionType_Kawss3                 = "kAwsS3"
	SearchObject_ProtectionType_Kazuresql              = "kAzureSQL"
	SearchObject_ProtectionType_Kfile                  = "kFile"
	SearchObject_ProtectionType_Knative                = "kNative"
	SearchObject_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	SearchObject_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	SearchObject_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the SearchObject.OsType property.
// Specifies the operating system type of the object.
const (
	SearchObject_OsType_Klinux   = "kLinux"
	SearchObject_OsType_Kwindows = "kWindows"
)

// UnmarshalSearchObject unmarshals an instance of SearchObject from the specified map of raw messages.
func UnmarshalSearchObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchObject)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionStats", &obj.ProtectionStats, UnmarshalObjectProtectionStatsSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionStats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalPermissionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalSearchObjectMssqlParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalSearchObjectPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "heliosTags", &obj.HeliosTags, UnmarshalHeliosTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "heliosTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalSearchObjectSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "objectProtectionInfos", &obj.ObjectProtectionInfos, UnmarshalObjectProtectionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectProtectionInfos-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "secondaryIds", &obj.SecondaryIds, UnmarshalSecondaryID)
	if err != nil {
		err = core.SDKErrorf(err, "", "secondaryIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "taggedSnapshots", &obj.TaggedSnapshots, UnmarshalTaggedSnapshotInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "taggedSnapshots-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObjectMssqlParams : Specifies the parameters for Msssql object.
type SearchObjectMssqlParams struct {
	// Object details for Mssql.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
	// hosted by another object such as VM or physical server.
	HostInfo *HostInformation `json:"hostInfo,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
}

// UnmarshalSearchObjectMssqlParams unmarshals an instance of SearchObjectMssqlParams from the specified map of raw messages.
func UnmarshalSearchObjectMssqlParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchObjectMssqlParams)
	err = core.UnmarshalModel(m, "aagInfo", &obj.AagInfo, UnmarshalAAGInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostInfo", &obj.HostInfo, UnmarshalHostInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObjectPhysicalParams : Specifies the parameters for Physical object.
type SearchObjectPhysicalParams struct {
	// Specifies if system backup was enabled for the source in a particular run.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`
}

// UnmarshalSearchObjectPhysicalParams unmarshals an instance of SearchObjectPhysicalParams from the specified map of raw messages.
func UnmarshalSearchObjectPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchObjectPhysicalParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObjectSourceInfo : Specifies the Source Object information.
type SearchObjectSourceInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`

	// Specifies the count and size of protected and unprotected objects for the size.
	ProtectionStats []ObjectProtectionStatsSummary `json:"protectionStats,omitempty"`

	// Specifies the list of users, groups and users that have permissions for a given object.
	Permissions *PermissionInfo `json:"permissions,omitempty"`

	// Specifies the parameters for Msssql object.
	MssqlParams *SearchObjectSourceInfoMssqlParams `json:"mssqlParams,omitempty"`

	// Specifies the parameters for Physical object.
	PhysicalParams *SearchObjectSourceInfoPhysicalParams `json:"physicalParams,omitempty"`
}

// Constants associated with the SearchObjectSourceInfo.Environment property.
// Specifies the environment of the object.
const (
	SearchObjectSourceInfo_Environment_Kphysical = "kPhysical"
	SearchObjectSourceInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the SearchObjectSourceInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	SearchObjectSourceInfo_ProtectionType_Kagent                 = "kAgent"
	SearchObjectSourceInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	SearchObjectSourceInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	SearchObjectSourceInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	SearchObjectSourceInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	SearchObjectSourceInfo_ProtectionType_Kawss3                 = "kAwsS3"
	SearchObjectSourceInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	SearchObjectSourceInfo_ProtectionType_Kfile                  = "kFile"
	SearchObjectSourceInfo_ProtectionType_Knative                = "kNative"
	SearchObjectSourceInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	SearchObjectSourceInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	SearchObjectSourceInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the SearchObjectSourceInfo.OsType property.
// Specifies the operating system type of the object.
const (
	SearchObjectSourceInfo_OsType_Klinux   = "kLinux"
	SearchObjectSourceInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalSearchObjectSourceInfo unmarshals an instance of SearchObjectSourceInfo from the specified map of raw messages.
func UnmarshalSearchObjectSourceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchObjectSourceInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "protectionStats", &obj.ProtectionStats, UnmarshalObjectProtectionStatsSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionStats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "permissions", &obj.Permissions, UnmarshalPermissionInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "permissions-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "mssqlParams", &obj.MssqlParams, UnmarshalSearchObjectSourceInfoMssqlParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "mssqlParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalSearchObjectSourceInfoPhysicalParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObjectSourceInfoMssqlParams : Specifies the parameters for Msssql object.
type SearchObjectSourceInfoMssqlParams struct {
	// Object details for Mssql.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the host information for a objects. This is mainly populated in case of App objects where app object is
	// hosted by another object such as VM or physical server.
	HostInfo *HostInformation `json:"hostInfo,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
}

// UnmarshalSearchObjectSourceInfoMssqlParams unmarshals an instance of SearchObjectSourceInfoMssqlParams from the specified map of raw messages.
func UnmarshalSearchObjectSourceInfoMssqlParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchObjectSourceInfoMssqlParams)
	err = core.UnmarshalModel(m, "aagInfo", &obj.AagInfo, UnmarshalAAGInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "aagInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hostInfo", &obj.HostInfo, UnmarshalHostInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObjectSourceInfoPhysicalParams : Specifies the parameters for Physical object.
type SearchObjectSourceInfoPhysicalParams struct {
	// Specifies if system backup was enabled for the source in a particular run.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`
}

// UnmarshalSearchObjectSourceInfoPhysicalParams unmarshals an instance of SearchObjectSourceInfoPhysicalParams from the specified map of raw messages.
func UnmarshalSearchObjectSourceInfoPhysicalParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchObjectSourceInfoPhysicalParams)
	err = core.UnmarshalPrimitive(m, "enableSystemBackup", &obj.EnableSystemBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableSystemBackup-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchObjectsOptions : The SearchObjects options.
type SearchObjectsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Specifies the search string to filter the objects. This search string will be applicable for objectnames. User can
	// specify a wildcard character '*' as a suffix to a string where all object names are matched with the prefix string.
	// For example, if vm1 and vm2 are the names of objects, user can specify vm* to list the objects. If not specified,
	// then all the objects will be returned which will match other filtering criteria.
	SearchString *string `json:"searchString,omitempty"`

	// Specifies the environment type to filter objects.
	Environments []string `json:"environments,omitempty"`

	// Specifies the protection type to filter objects.
	ProtectionTypes []string `json:"protectionTypes,omitempty"`

	// Specifies a list of Protection Group ids to filter the objects. If specified, the objects protected by specified
	// Protection Group ids will be returned.
	ProtectionGroupIds []string `json:"protectionGroupIds,omitempty"`

	// Specifies a list of Object ids to filter.
	ObjectIds []int64 `json:"objectIds,omitempty"`

	// Specifies the operating system types to filter objects on.
	OsTypes []string `json:"osTypes,omitempty"`

	// Specifies a list of Protection Source object ids to filter the objects. If specified, the object which are present
	// in those Sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`

	// Specifies a list of Protection Source object uuids to filter the objects. If specified, the object which are present
	// in those Sources will be returned.
	SourceUUIDs []string `json:"sourceUuids,omitempty"`

	// Specifies the protection status of objects. If set to true, only protected objects will be returned. If set to
	// false, only unprotected objects will be returned. If not specified, all objects will be returned.
	IsProtected *bool `json:"isProtected,omitempty"`

	// If set to true, then objects which are deleted on atleast one cluster will be returned. If not set or set to false
	// then objects which are registered on atleast one cluster are returned.
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// Specifies a list of status of the object's last protection run. Only objects with last run status of these will be
	// returned.
	LastRunStatusList []string `json:"lastRunStatusList,omitempty"`

	// Specifies the list of cluster identifiers. Format is clusterId:clusterIncarnationId. Only records from clusters
	// having these identifiers will be returned.
	ClusterIdentifiers []string `json:"clusterIdentifiers,omitempty"`

	// Specifies whether to include deleted objects in response. These objects can't be protected but can be recovered.
	// This field is deprecated.
	IncludeDeletedObjects *bool `json:"includeDeletedObjects,omitempty"`

	// Specifies the pagination cookie with which subsequent parts of the response can be fetched.
	PaginationCookie *string `json:"paginationCookie,omitempty"`

	// Specifies the number of objects to be fetched for the specified pagination cookie.
	Count *int64 `json:"count,omitempty"`

	// Specifies tags which must be all present in the document.
	MustHaveTagIds []string `json:"mustHaveTagIds,omitempty"`

	// Specifies list of tags, one or more of which might be present in the document. These are OR'ed together and the
	// resulting criteria AND'ed with the rest of the query.
	MightHaveTagIds []string `json:"mightHaveTagIds,omitempty"`

	// Specifies snapshot tags which must be all present in the document.
	MustHaveSnapshotTagIds []string `json:"mustHaveSnapshotTagIds,omitempty"`

	// Specifies list of snapshot tags, one or more of which might be present in the document. These are OR'ed together and
	// the resulting criteria AND'ed with the rest of the query.
	MightHaveSnapshotTagIds []string `json:"mightHaveSnapshotTagIds,omitempty"`

	// Specifies the tag name to filter the tagged objects and snapshots. User can specify a wildcard character '*' as a
	// suffix to a string where all object's tag names are matched with the prefix string.
	TagSearchName *string `json:"tagSearchName,omitempty"`

	// Specifies the tag names to filter the tagged objects and snapshots.
	TagNames []string `json:"tagNames,omitempty"`

	// Specifies the tag names to filter the tagged objects and snapshots.
	TagTypes []string `json:"tagTypes,omitempty"`

	// Specifies the tag category to filter the objects and snapshots.
	TagCategories []string `json:"tagCategories,omitempty"`

	// Specifies the tag subcategory to filter the objects and snapshots.
	TagSubCategories []string `json:"tagSubCategories,omitempty"`

	// pecifies whether to include helios tags information for objects in response. Default value is false.
	IncludeHeliosTagInfoForObjects *bool `json:"includeHeliosTagInfoForObjects,omitempty"`

	// Specifies the key-value pairs to filtering the results for the search. Each filter is of the form 'key:value'. The
	// filter 'externalFilters:k1:v1&externalFilters:k2:v2&externalFilters:k2:v3' returns the documents where each document
	// will match the query (k1=v1) AND (k2=v2 OR k2 = v3). Allowed keys: - vmBiosUuid - graphUuid - arn - instanceId -
	// bucketName - azureId.
	ExternalFilters []string `json:"externalFilters,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the SearchObjectsOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	SearchObjectsOptions_RequestInitiatorType_Helios = "Helios"
	SearchObjectsOptions_RequestInitiatorType_Uiauto = "UIAuto"
	SearchObjectsOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// Constants associated with the SearchObjectsOptions.Environments property.
const (
	SearchObjectsOptions_Environments_Kphysical = "kPhysical"
	SearchObjectsOptions_Environments_Ksql      = "kSQL"
)

// Constants associated with the SearchObjectsOptions.ProtectionTypes property.
const (
	SearchObjectsOptions_ProtectionTypes_Kagent                 = "kAgent"
	SearchObjectsOptions_ProtectionTypes_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	SearchObjectsOptions_ProtectionTypes_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	SearchObjectsOptions_ProtectionTypes_Kawsrdspostgres        = "kAwsRDSPostgres"
	SearchObjectsOptions_ProtectionTypes_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	SearchObjectsOptions_ProtectionTypes_Kawss3                 = "kAwsS3"
	SearchObjectsOptions_ProtectionTypes_Kazuresql              = "kAzureSQL"
	SearchObjectsOptions_ProtectionTypes_Kfile                  = "kFile"
	SearchObjectsOptions_ProtectionTypes_Knative                = "kNative"
	SearchObjectsOptions_ProtectionTypes_Krdssnapshotmanager    = "kRDSSnapshotManager"
	SearchObjectsOptions_ProtectionTypes_Ksnapshotmanager       = "kSnapshotManager"
	SearchObjectsOptions_ProtectionTypes_Kvolume                = "kVolume"
)

// Constants associated with the SearchObjectsOptions.OsTypes property.
const (
	SearchObjectsOptions_OsTypes_Klinux   = "kLinux"
	SearchObjectsOptions_OsTypes_Kwindows = "kWindows"
)

// Constants associated with the SearchObjectsOptions.LastRunStatusList property.
const (
	SearchObjectsOptions_LastRunStatusList_Accepted             = "Accepted"
	SearchObjectsOptions_LastRunStatusList_Canceled             = "Canceled"
	SearchObjectsOptions_LastRunStatusList_Canceling            = "Canceling"
	SearchObjectsOptions_LastRunStatusList_Failed               = "Failed"
	SearchObjectsOptions_LastRunStatusList_Finalizing           = "Finalizing"
	SearchObjectsOptions_LastRunStatusList_Legalhold            = "LegalHold"
	SearchObjectsOptions_LastRunStatusList_Missed               = "Missed"
	SearchObjectsOptions_LastRunStatusList_Onhold               = "OnHold"
	SearchObjectsOptions_LastRunStatusList_Running              = "Running"
	SearchObjectsOptions_LastRunStatusList_Skipped              = "Skipped"
	SearchObjectsOptions_LastRunStatusList_Succeeded            = "Succeeded"
	SearchObjectsOptions_LastRunStatusList_Succeededwithwarning = "SucceededWithWarning"
)

// Constants associated with the SearchObjectsOptions.TagTypes property.
const (
	SearchObjectsOptions_TagTypes_Custom     = "Custom"
	SearchObjectsOptions_TagTypes_System     = "System"
	SearchObjectsOptions_TagTypes_Thirdparty = "ThirdParty"
)

// Constants associated with the SearchObjectsOptions.TagCategories property.
const (
	SearchObjectsOptions_TagCategories_Security = "Security"
)

// Constants associated with the SearchObjectsOptions.TagSubCategories property.
const (
	SearchObjectsOptions_TagSubCategories_Anomalies      = "Anomalies"
	SearchObjectsOptions_TagSubCategories_Classification = "Classification"
	SearchObjectsOptions_TagSubCategories_Dspm           = "Dspm"
	SearchObjectsOptions_TagSubCategories_Threats        = "Threats"
)

// NewSearchObjectsOptions : Instantiate SearchObjectsOptions
func (*BackupRecoveryV1) NewSearchObjectsOptions(xIBMTenantID string) *SearchObjectsOptions {
	return &SearchObjectsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *SearchObjectsOptions) SetXIBMTenantID(xIBMTenantID string) *SearchObjectsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *SearchObjectsOptions) SetRequestInitiatorType(requestInitiatorType string) *SearchObjectsOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetSearchString : Allow user to set SearchString
func (_options *SearchObjectsOptions) SetSearchString(searchString string) *SearchObjectsOptions {
	_options.SearchString = core.StringPtr(searchString)
	return _options
}

// SetEnvironments : Allow user to set Environments
func (_options *SearchObjectsOptions) SetEnvironments(environments []string) *SearchObjectsOptions {
	_options.Environments = environments
	return _options
}

// SetProtectionTypes : Allow user to set ProtectionTypes
func (_options *SearchObjectsOptions) SetProtectionTypes(protectionTypes []string) *SearchObjectsOptions {
	_options.ProtectionTypes = protectionTypes
	return _options
}

// SetProtectionGroupIds : Allow user to set ProtectionGroupIds
func (_options *SearchObjectsOptions) SetProtectionGroupIds(protectionGroupIds []string) *SearchObjectsOptions {
	_options.ProtectionGroupIds = protectionGroupIds
	return _options
}

// SetObjectIds : Allow user to set ObjectIds
func (_options *SearchObjectsOptions) SetObjectIds(objectIds []int64) *SearchObjectsOptions {
	_options.ObjectIds = objectIds
	return _options
}

// SetOsTypes : Allow user to set OsTypes
func (_options *SearchObjectsOptions) SetOsTypes(osTypes []string) *SearchObjectsOptions {
	_options.OsTypes = osTypes
	return _options
}

// SetSourceIds : Allow user to set SourceIds
func (_options *SearchObjectsOptions) SetSourceIds(sourceIds []int64) *SearchObjectsOptions {
	_options.SourceIds = sourceIds
	return _options
}

// SetSourceUUIDs : Allow user to set SourceUUIDs
func (_options *SearchObjectsOptions) SetSourceUUIDs(sourceUUIDs []string) *SearchObjectsOptions {
	_options.SourceUUIDs = sourceUUIDs
	return _options
}

// SetIsProtected : Allow user to set IsProtected
func (_options *SearchObjectsOptions) SetIsProtected(isProtected bool) *SearchObjectsOptions {
	_options.IsProtected = core.BoolPtr(isProtected)
	return _options
}

// SetIsDeleted : Allow user to set IsDeleted
func (_options *SearchObjectsOptions) SetIsDeleted(isDeleted bool) *SearchObjectsOptions {
	_options.IsDeleted = core.BoolPtr(isDeleted)
	return _options
}

// SetLastRunStatusList : Allow user to set LastRunStatusList
func (_options *SearchObjectsOptions) SetLastRunStatusList(lastRunStatusList []string) *SearchObjectsOptions {
	_options.LastRunStatusList = lastRunStatusList
	return _options
}

// SetClusterIdentifiers : Allow user to set ClusterIdentifiers
func (_options *SearchObjectsOptions) SetClusterIdentifiers(clusterIdentifiers []string) *SearchObjectsOptions {
	_options.ClusterIdentifiers = clusterIdentifiers
	return _options
}

// SetIncludeDeletedObjects : Allow user to set IncludeDeletedObjects
func (_options *SearchObjectsOptions) SetIncludeDeletedObjects(includeDeletedObjects bool) *SearchObjectsOptions {
	_options.IncludeDeletedObjects = core.BoolPtr(includeDeletedObjects)
	return _options
}

// SetPaginationCookie : Allow user to set PaginationCookie
func (_options *SearchObjectsOptions) SetPaginationCookie(paginationCookie string) *SearchObjectsOptions {
	_options.PaginationCookie = core.StringPtr(paginationCookie)
	return _options
}

// SetCount : Allow user to set Count
func (_options *SearchObjectsOptions) SetCount(count int64) *SearchObjectsOptions {
	_options.Count = core.Int64Ptr(count)
	return _options
}

// SetMustHaveTagIds : Allow user to set MustHaveTagIds
func (_options *SearchObjectsOptions) SetMustHaveTagIds(mustHaveTagIds []string) *SearchObjectsOptions {
	_options.MustHaveTagIds = mustHaveTagIds
	return _options
}

// SetMightHaveTagIds : Allow user to set MightHaveTagIds
func (_options *SearchObjectsOptions) SetMightHaveTagIds(mightHaveTagIds []string) *SearchObjectsOptions {
	_options.MightHaveTagIds = mightHaveTagIds
	return _options
}

// SetMustHaveSnapshotTagIds : Allow user to set MustHaveSnapshotTagIds
func (_options *SearchObjectsOptions) SetMustHaveSnapshotTagIds(mustHaveSnapshotTagIds []string) *SearchObjectsOptions {
	_options.MustHaveSnapshotTagIds = mustHaveSnapshotTagIds
	return _options
}

// SetMightHaveSnapshotTagIds : Allow user to set MightHaveSnapshotTagIds
func (_options *SearchObjectsOptions) SetMightHaveSnapshotTagIds(mightHaveSnapshotTagIds []string) *SearchObjectsOptions {
	_options.MightHaveSnapshotTagIds = mightHaveSnapshotTagIds
	return _options
}

// SetTagSearchName : Allow user to set TagSearchName
func (_options *SearchObjectsOptions) SetTagSearchName(tagSearchName string) *SearchObjectsOptions {
	_options.TagSearchName = core.StringPtr(tagSearchName)
	return _options
}

// SetTagNames : Allow user to set TagNames
func (_options *SearchObjectsOptions) SetTagNames(tagNames []string) *SearchObjectsOptions {
	_options.TagNames = tagNames
	return _options
}

// SetTagTypes : Allow user to set TagTypes
func (_options *SearchObjectsOptions) SetTagTypes(tagTypes []string) *SearchObjectsOptions {
	_options.TagTypes = tagTypes
	return _options
}

// SetTagCategories : Allow user to set TagCategories
func (_options *SearchObjectsOptions) SetTagCategories(tagCategories []string) *SearchObjectsOptions {
	_options.TagCategories = tagCategories
	return _options
}

// SetTagSubCategories : Allow user to set TagSubCategories
func (_options *SearchObjectsOptions) SetTagSubCategories(tagSubCategories []string) *SearchObjectsOptions {
	_options.TagSubCategories = tagSubCategories
	return _options
}

// SetIncludeHeliosTagInfoForObjects : Allow user to set IncludeHeliosTagInfoForObjects
func (_options *SearchObjectsOptions) SetIncludeHeliosTagInfoForObjects(includeHeliosTagInfoForObjects bool) *SearchObjectsOptions {
	_options.IncludeHeliosTagInfoForObjects = core.BoolPtr(includeHeliosTagInfoForObjects)
	return _options
}

// SetExternalFilters : Allow user to set ExternalFilters
func (_options *SearchObjectsOptions) SetExternalFilters(externalFilters []string) *SearchObjectsOptions {
	_options.ExternalFilters = externalFilters
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SearchObjectsOptions) SetHeaders(param map[string]string) *SearchObjectsOptions {
	options.Headers = param
	return options
}

// SearchProtectedObjectsOptions : The SearchProtectedObjects options.
type SearchProtectedObjectsOptions struct {
	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the type of request from UI, which is used for services like magneto to determine the priority of
	// requests.
	RequestInitiatorType *string `json:"requestInitiatorType,omitempty"`

	// Specifies the search string to filter the objects. This search string will be applicable for objectnames and
	// Protection Group names. User can specify a wildcard character '*' as a suffix to a string where all object and their
	// Protection Group names are matched with the prefix string. For example, if vm1 and vm2 are the names of objects,
	// user can specify vm* to list the objects. If not specified, then all the objects with Protection Groups will be
	// returned which will match other filtering criteria.
	SearchString *string `json:"searchString,omitempty"`

	// Specifies the environment type to filter objects.
	Environments []string `json:"environments,omitempty"`

	// Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.
	SnapshotActions []string `json:"snapshotActions,omitempty"`

	// Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple
	// ways but atmost once for a given combination of ObjectActionKey. When specified, latest snapshot info matching the
	// objectActionKey is for corresponding object.
	ObjectActionKey *string `json:"objectActionKey,omitempty"`

	// Specifies a list of Protection Group ids to filter the objects. If specified, the objects protected by specified
	// Protection Group ids will be returned.
	ProtectionGroupIds []string `json:"protectionGroupIds,omitempty"`

	// Specifies a list of Object ids to filter.
	ObjectIds []int64 `json:"objectIds,omitempty"`

	// Specifies the size of objects to be fetched for a single subresult.
	SubResultSize *int64 `json:"subResultSize,omitempty"`

	// Specifies the timestamp in Unix time epoch in microseconds to filter the objects if the Object has a successful
	// snapshot after this value.
	FilterSnapshotFromUsecs *int64 `json:"filterSnapshotFromUsecs,omitempty"`

	// Specifies the timestamp in Unix time epoch in microseconds to filter the objects if the Object has a successful
	// snapshot before this value.
	FilterSnapshotToUsecs *int64 `json:"filterSnapshotToUsecs,omitempty"`

	// Specifies the operating system types to filter objects on.
	OsTypes []string `json:"osTypes,omitempty"`

	// Specifies a list of Protection Source object ids to filter the objects. If specified, the object which are present
	// in those Sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`

	// Specifies a list of run instance ids. If specified only objects belonging to the provided run id will be retunrned.
	RunInstanceIds []int64 `json:"runInstanceIds,omitempty"`

	// Specifies whether to only return the CDP protected objects.
	CdpProtectedOnly *bool `json:"cdpProtectedOnly,omitempty"`

	// Specifies whether we can serve the GET request to the read replica cache cache. There is a lag of 15 seconds between
	// the read replica and primary data source.
	UseCachedData *bool `json:"useCachedData,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the SearchProtectedObjectsOptions.RequestInitiatorType property.
// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
const (
	SearchProtectedObjectsOptions_RequestInitiatorType_Helios = "Helios"
	SearchProtectedObjectsOptions_RequestInitiatorType_Uiauto = "UIAuto"
	SearchProtectedObjectsOptions_RequestInitiatorType_Uiuser = "UIUser"
)

// Constants associated with the SearchProtectedObjectsOptions.Environments property.
const (
	SearchProtectedObjectsOptions_Environments_Kphysical = "kPhysical"
	SearchProtectedObjectsOptions_Environments_Ksql      = "kSQL"
)

// Constants associated with the SearchProtectedObjectsOptions.SnapshotActions property.
const (
	SearchProtectedObjectsOptions_SnapshotActions_Converttopst            = "ConvertToPst"
	SearchProtectedObjectsOptions_SnapshotActions_Downloadchats           = "DownloadChats"
	SearchProtectedObjectsOptions_SnapshotActions_Downloadfilesandfolders = "DownloadFilesAndFolders"
	SearchProtectedObjectsOptions_SnapshotActions_Instantvolumemount      = "InstantVolumeMount"
	SearchProtectedObjectsOptions_SnapshotActions_Mountvolumes            = "MountVolumes"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverapps             = "RecoverApps"
	SearchProtectedObjectsOptions_SnapshotActions_Recoveraurora           = "RecoverAurora"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverazuresql         = "RecoverAzureSQL"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverfiles            = "RecoverFiles"
	SearchProtectedObjectsOptions_SnapshotActions_Recovermailbox          = "RecoverMailbox"
	SearchProtectedObjectsOptions_SnapshotActions_Recovermailboxcsm       = "RecoverMailboxCSM"
	SearchProtectedObjectsOptions_SnapshotActions_Recovermsgroup          = "RecoverMsGroup"
	SearchProtectedObjectsOptions_SnapshotActions_Recovermsteam           = "RecoverMsTeam"
	SearchProtectedObjectsOptions_SnapshotActions_Recovernamespaces       = "RecoverNamespaces"
	SearchProtectedObjectsOptions_SnapshotActions_Recovernasvolume        = "RecoverNasVolume"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverobjects          = "RecoverObjects"
	SearchProtectedObjectsOptions_SnapshotActions_Recoveronedrive         = "RecoverOneDrive"
	SearchProtectedObjectsOptions_SnapshotActions_Recoveronedrivecsm      = "RecoverOneDriveCSM"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverphysicalvolumes  = "RecoverPhysicalVolumes"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverpublicfolders    = "RecoverPublicFolders"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverrds              = "RecoverRDS"
	SearchProtectedObjectsOptions_SnapshotActions_Recoverrdspostgres      = "RecoverRDSPostgres"
	SearchProtectedObjectsOptions_SnapshotActions_Recovers3buckets        = "RecoverS3Buckets"
	SearchProtectedObjectsOptions_SnapshotActions_Recoversanvolumes       = "RecoverSanVolumes"
	SearchProtectedObjectsOptions_SnapshotActions_Recoversfdcrecords      = "RecoverSfdcRecords"
	SearchProtectedObjectsOptions_SnapshotActions_Recoversharepoint       = "RecoverSharePoint"
	SearchProtectedObjectsOptions_SnapshotActions_Recoversharepointcsm    = "RecoverSharePointCSM"
	SearchProtectedObjectsOptions_SnapshotActions_Recoversystem           = "RecoverSystem"
	SearchProtectedObjectsOptions_SnapshotActions_Recovervapps            = "RecoverVApps"
	SearchProtectedObjectsOptions_SnapshotActions_Recovervapptemplates    = "RecoverVAppTemplates"
	SearchProtectedObjectsOptions_SnapshotActions_Recovervmdisks          = "RecoverVmDisks"
	SearchProtectedObjectsOptions_SnapshotActions_Recovervms              = "RecoverVMs"
)

// Constants associated with the SearchProtectedObjectsOptions.ObjectActionKey property.
// Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple
// ways but atmost once for a given combination of ObjectActionKey. When specified, latest snapshot info matching the
// objectActionKey is for corresponding object.
const (
	SearchProtectedObjectsOptions_ObjectActionKey_Kphysical = "kPhysical"
	SearchProtectedObjectsOptions_ObjectActionKey_Ksql      = "kSQL"
)

// Constants associated with the SearchProtectedObjectsOptions.OsTypes property.
const (
	SearchProtectedObjectsOptions_OsTypes_Klinux   = "kLinux"
	SearchProtectedObjectsOptions_OsTypes_Kwindows = "kWindows"
)

// NewSearchProtectedObjectsOptions : Instantiate SearchProtectedObjectsOptions
func (*BackupRecoveryV1) NewSearchProtectedObjectsOptions(xIBMTenantID string) *SearchProtectedObjectsOptions {
	return &SearchProtectedObjectsOptions{
		XIBMTenantID: core.StringPtr(xIBMTenantID),
	}
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *SearchProtectedObjectsOptions) SetXIBMTenantID(xIBMTenantID string) *SearchProtectedObjectsOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetRequestInitiatorType : Allow user to set RequestInitiatorType
func (_options *SearchProtectedObjectsOptions) SetRequestInitiatorType(requestInitiatorType string) *SearchProtectedObjectsOptions {
	_options.RequestInitiatorType = core.StringPtr(requestInitiatorType)
	return _options
}

// SetSearchString : Allow user to set SearchString
func (_options *SearchProtectedObjectsOptions) SetSearchString(searchString string) *SearchProtectedObjectsOptions {
	_options.SearchString = core.StringPtr(searchString)
	return _options
}

// SetEnvironments : Allow user to set Environments
func (_options *SearchProtectedObjectsOptions) SetEnvironments(environments []string) *SearchProtectedObjectsOptions {
	_options.Environments = environments
	return _options
}

// SetSnapshotActions : Allow user to set SnapshotActions
func (_options *SearchProtectedObjectsOptions) SetSnapshotActions(snapshotActions []string) *SearchProtectedObjectsOptions {
	_options.SnapshotActions = snapshotActions
	return _options
}

// SetObjectActionKey : Allow user to set ObjectActionKey
func (_options *SearchProtectedObjectsOptions) SetObjectActionKey(objectActionKey string) *SearchProtectedObjectsOptions {
	_options.ObjectActionKey = core.StringPtr(objectActionKey)
	return _options
}

// SetProtectionGroupIds : Allow user to set ProtectionGroupIds
func (_options *SearchProtectedObjectsOptions) SetProtectionGroupIds(protectionGroupIds []string) *SearchProtectedObjectsOptions {
	_options.ProtectionGroupIds = protectionGroupIds
	return _options
}

// SetObjectIds : Allow user to set ObjectIds
func (_options *SearchProtectedObjectsOptions) SetObjectIds(objectIds []int64) *SearchProtectedObjectsOptions {
	_options.ObjectIds = objectIds
	return _options
}

// SetSubResultSize : Allow user to set SubResultSize
func (_options *SearchProtectedObjectsOptions) SetSubResultSize(subResultSize int64) *SearchProtectedObjectsOptions {
	_options.SubResultSize = core.Int64Ptr(subResultSize)
	return _options
}

// SetFilterSnapshotFromUsecs : Allow user to set FilterSnapshotFromUsecs
func (_options *SearchProtectedObjectsOptions) SetFilterSnapshotFromUsecs(filterSnapshotFromUsecs int64) *SearchProtectedObjectsOptions {
	_options.FilterSnapshotFromUsecs = core.Int64Ptr(filterSnapshotFromUsecs)
	return _options
}

// SetFilterSnapshotToUsecs : Allow user to set FilterSnapshotToUsecs
func (_options *SearchProtectedObjectsOptions) SetFilterSnapshotToUsecs(filterSnapshotToUsecs int64) *SearchProtectedObjectsOptions {
	_options.FilterSnapshotToUsecs = core.Int64Ptr(filterSnapshotToUsecs)
	return _options
}

// SetOsTypes : Allow user to set OsTypes
func (_options *SearchProtectedObjectsOptions) SetOsTypes(osTypes []string) *SearchProtectedObjectsOptions {
	_options.OsTypes = osTypes
	return _options
}

// SetSourceIds : Allow user to set SourceIds
func (_options *SearchProtectedObjectsOptions) SetSourceIds(sourceIds []int64) *SearchProtectedObjectsOptions {
	_options.SourceIds = sourceIds
	return _options
}

// SetRunInstanceIds : Allow user to set RunInstanceIds
func (_options *SearchProtectedObjectsOptions) SetRunInstanceIds(runInstanceIds []int64) *SearchProtectedObjectsOptions {
	_options.RunInstanceIds = runInstanceIds
	return _options
}

// SetCdpProtectedOnly : Allow user to set CdpProtectedOnly
func (_options *SearchProtectedObjectsOptions) SetCdpProtectedOnly(cdpProtectedOnly bool) *SearchProtectedObjectsOptions {
	_options.CdpProtectedOnly = core.BoolPtr(cdpProtectedOnly)
	return _options
}

// SetUseCachedData : Allow user to set UseCachedData
func (_options *SearchProtectedObjectsOptions) SetUseCachedData(useCachedData bool) *SearchProtectedObjectsOptions {
	_options.UseCachedData = core.BoolPtr(useCachedData)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SearchProtectedObjectsOptions) SetHeaders(param map[string]string) *SearchProtectedObjectsOptions {
	options.Headers = param
	return options
}

// SearchPublicFolderRequestParams : Specifies the request parameters to search for Public Folder items.
type SearchPublicFolderRequestParams struct {
	// Specifies the search string to filter the items. User can specify a wildcard character '*' as a suffix to a string
	// where all item names are matched with the prefix string.
	SearchString *string `json:"searchString,omitempty"`

	// Specifies a list of public folder item types. Only items within the given types will be returned.
	Types []string `json:"types,omitempty"`

	// Filters the public folder items which have attachment.
	HasAttachment *bool `json:"hasAttachment,omitempty"`

	// Filters the public folder items which are received from specified user's email address.
	SenderAddress *string `json:"senderAddress,omitempty"`

	// Filters the public folder items which are sent to specified email addresses.
	RecipientAddresses []string `json:"recipientAddresses,omitempty"`

	// Filters the public folder items which are sent to specified email addresses in CC.
	CcRecipientAddresses []string `json:"ccRecipientAddresses,omitempty"`

	// Filters the public folder items which are sent to specified email addresses in BCC.
	BccRecipientAddresses []string `json:"bccRecipientAddresses,omitempty"`

	// Specifies the start time in Unix timestamp epoch in seconds where the received time of the public folder item is
	// more than specified value.
	ReceivedStartTimeSecs *int64 `json:"receivedStartTimeSecs,omitempty"`

	// Specifies the end time in Unix timestamp epoch in seconds where the received time of the public folder items is less
	// than specified value.
	ReceivedEndTimeSecs *int64 `json:"receivedEndTimeSecs,omitempty"`
}

// Constants associated with the SearchPublicFolderRequestParams.Types property.
const (
	SearchPublicFolderRequestParams_Types_Calendar = "Calendar"
	SearchPublicFolderRequestParams_Types_Contact  = "Contact"
	SearchPublicFolderRequestParams_Types_Folder   = "Folder"
	SearchPublicFolderRequestParams_Types_Journal  = "Journal"
	SearchPublicFolderRequestParams_Types_Note     = "Note"
	SearchPublicFolderRequestParams_Types_Post     = "Post"
	SearchPublicFolderRequestParams_Types_Task     = "Task"
)

// UnmarshalSearchPublicFolderRequestParams unmarshals an instance of SearchPublicFolderRequestParams from the specified map of raw messages.
func UnmarshalSearchPublicFolderRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchPublicFolderRequestParams)
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "types", &obj.Types)
	if err != nil {
		err = core.SDKErrorf(err, "", "types-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hasAttachment", &obj.HasAttachment)
	if err != nil {
		err = core.SDKErrorf(err, "", "hasAttachment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "senderAddress", &obj.SenderAddress)
	if err != nil {
		err = core.SDKErrorf(err, "", "senderAddress-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recipientAddresses", &obj.RecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "recipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ccRecipientAddresses", &obj.CcRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "ccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bccRecipientAddresses", &obj.BccRecipientAddresses)
	if err != nil {
		err = core.SDKErrorf(err, "", "bccRecipientAddresses-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedStartTimeSecs", &obj.ReceivedStartTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedStartTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedEndTimeSecs", &obj.ReceivedEndTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "receivedEndTimeSecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SearchSfdcRecordsRequestParams : Specifies the parameters which are specific for searching Salesforce records.
type SearchSfdcRecordsRequestParams struct {
	// Specifies a list of mutuation types for an object.
	MutationTypes []string `json:"mutationTypes" validate:"required"`

	// Specifies the name of the object.
	ObjectName *string `json:"objectName" validate:"required"`

	// Specifies the query string to search records. Query string can be one or multiples clauses joined together by 'AND'
	// or 'OR' claused.
	QueryString *string `json:"queryString,omitempty"`

	// Specifies the id of the snapshot for the object.
	SnapshotID *string `json:"snapshotId" validate:"required"`
}

// Constants associated with the SearchSfdcRecordsRequestParams.MutationTypes property.
const (
	SearchSfdcRecordsRequestParams_MutationTypes_Added   = "Added"
	SearchSfdcRecordsRequestParams_MutationTypes_All     = "All"
	SearchSfdcRecordsRequestParams_MutationTypes_Changed = "Changed"
	SearchSfdcRecordsRequestParams_MutationTypes_Removed = "Removed"
)

// NewSearchSfdcRecordsRequestParams : Instantiate SearchSfdcRecordsRequestParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewSearchSfdcRecordsRequestParams(mutationTypes []string, objectName string, snapshotID string) (_model *SearchSfdcRecordsRequestParams, err error) {
	_model = &SearchSfdcRecordsRequestParams{
		MutationTypes: mutationTypes,
		ObjectName:    core.StringPtr(objectName),
		SnapshotID:    core.StringPtr(snapshotID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalSearchSfdcRecordsRequestParams unmarshals an instance of SearchSfdcRecordsRequestParams from the specified map of raw messages.
func UnmarshalSearchSfdcRecordsRequestParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SearchSfdcRecordsRequestParams)
	err = core.UnmarshalPrimitive(m, "mutationTypes", &obj.MutationTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "mutationTypes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectName", &obj.ObjectName)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "queryString", &obj.QueryString)
	if err != nil {
		err = core.SDKErrorf(err, "", "queryString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecondaryID : Specifies the secondary ID for an object.
type SecondaryID struct {
	// Specifies name of the secondary ID for an object.
	Name *string `json:"name" validate:"required"`

	// Specifies value of the secondary ID for an object.
	Value *string `json:"value,omitempty"`
}

// UnmarshalSecondaryID unmarshals an instance of SecondaryID from the specified map of raw messages.
func UnmarshalSecondaryID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecondaryID)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SfdcObjectParams : Specifies the Salesforce objects mutation parameters.
type SfdcObjectParams struct {
	// Specifies the number of records added for the Object.
	RecordsAdded *int64 `json:"recordsAdded,omitempty"`

	// Specifies the number of records updated for the Object.
	RecordsModified *int64 `json:"recordsModified,omitempty"`

	// Specifies the number of records removed from the Object.
	RecordsRemoved *int64 `json:"recordsRemoved,omitempty"`
}

// UnmarshalSfdcObjectParams unmarshals an instance of SfdcObjectParams from the specified map of raw messages.
func UnmarshalSfdcObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SfdcObjectParams)
	err = core.UnmarshalPrimitive(m, "recordsAdded", &obj.RecordsAdded)
	if err != nil {
		err = core.SDKErrorf(err, "", "recordsAdded-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recordsModified", &obj.RecordsModified)
	if err != nil {
		err = core.SDKErrorf(err, "", "recordsModified-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recordsRemoved", &obj.RecordsRemoved)
	if err != nil {
		err = core.SDKErrorf(err, "", "recordsRemoved-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SfdcRecords : Specifies the list of salesforce records.
type SfdcRecords struct {
	// Specifies the column names for the records.
	ColumnNames []string `json:"columnNames,omitempty"`

	// Each record is represented by an array of strings having the same order as the 'columnNames'.
	Records []string `json:"records,omitempty"`
}

// UnmarshalSfdcRecords unmarshals an instance of SfdcRecords from the specified map of raw messages.
func UnmarshalSfdcRecords(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SfdcRecords)
	err = core.UnmarshalPrimitive(m, "columnNames", &obj.ColumnNames)
	if err != nil {
		err = core.SDKErrorf(err, "", "columnNames-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "records", &obj.Records)
	if err != nil {
		err = core.SDKErrorf(err, "", "records-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharepointItem : Specifies the indexed Sharepoint item.
type SharepointItem struct {
	// Specifies a Document Library indexed item.
	DocumentLibraryItem *DocumentLibraryItem `json:"documentLibraryItem,omitempty"`
}

// UnmarshalSharepointItem unmarshals an instance of SharepointItem from the specified map of raw messages.
func UnmarshalSharepointItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharepointItem)
	err = core.UnmarshalModel(m, "documentLibraryItem", &obj.DocumentLibraryItem, UnmarshalDocumentLibraryItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "documentLibraryItem-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharepointObjectParams : Specifies the common parameters for Sharepoint site objects.
type SharepointObjectParams struct {
	// Specifies the web url for the Sharepoint site.
	SiteWebURL *string `json:"siteWebUrl,omitempty"`
}

// UnmarshalSharepointObjectParams unmarshals an instance of SharepointObjectParams from the specified map of raw messages.
func UnmarshalSharepointObjectParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharepointObjectParams)
	err = core.UnmarshalPrimitive(m, "siteWebUrl", &obj.SiteWebURL)
	if err != nil {
		err = core.SDKErrorf(err, "", "siteWebUrl-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SlaRule : Specifies an SLA rule for a specific Protection Group run type.
type SlaRule struct {
	// Specifies the type of run this rule should apply to.
	BackupRunType *string `json:"backupRunType,omitempty"`

	// Specifies the number of minutes allotted to a run of the specified type before SLA is considered violated.
	SlaMinutes *int64 `json:"slaMinutes,omitempty"`
}

// Constants associated with the SlaRule.BackupRunType property.
// Specifies the type of run this rule should apply to.
const (
	SlaRule_BackupRunType_Kfull        = "kFull"
	SlaRule_BackupRunType_Kincremental = "kIncremental"
	SlaRule_BackupRunType_Klog         = "kLog"
)

// UnmarshalSlaRule unmarshals an instance of SlaRule from the specified map of raw messages.
func UnmarshalSlaRule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SlaRule)
	err = core.UnmarshalPrimitive(m, "backupRunType", &obj.BackupRunType)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupRunType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "slaMinutes", &obj.SlaMinutes)
	if err != nil {
		err = core.SDKErrorf(err, "", "slaMinutes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotInfo : Snapshot info for an object.
type SnapshotInfo struct {
	// Snapshot id for a successful snapshot. This field will not be set if the Protection Group Run has no successful
	// attempt.
	SnapshotID *string `json:"snapshotId,omitempty"`

	// Status of snapshot.
	Status *string `json:"status,omitempty"`

	// A message decribing the status. This will be populated currently only for kWaitingForOlderBackupRun status.
	StatusMessage *string `json:"statusMessage,omitempty"`

	// Specifies the start time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the time at which the backup task was admitted to run in Unix epoch Timestamp(in microseconds) for an
	// object.
	AdmittedTimeUsecs *int64 `json:"admittedTimeUsecs,omitempty"`

	// Specifies the time when gatekeeper permit is granted to the backup task. If the backup task is rescheduled due to
	// errors, the field is updated to the time when permit is granted again.
	PermitGrantTimeUsecs *int64 `json:"permitGrantTimeUsecs,omitempty"`

	// Specifies the duration between the startTime and when gatekeeper permit is granted to the backup task. If the backup
	// task is rescheduled due to errors, the field is updated considering the time when permit is granted again. Queue
	// duration = PermitGrantTimeUsecs - StartTimeUsecs.
	QueueDurationUsecs *int64 `json:"queueDurationUsecs,omitempty"`

	// Specifies the time at which the source snapshot was taken in Unix epoch Timestamp(in microseconds) for an object.
	SnapshotCreationTimeUsecs *int64 `json:"snapshotCreationTimeUsecs,omitempty"`

	// Specifies statistics about local snapshot.
	Stats *BackupDataStats `json:"stats,omitempty"`

	// Progress monitor task for backup of the object.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Progress monitor task for the indexing of documents in an object.
	IndexingTaskID *string `json:"indexingTaskId,omitempty"`

	// Stats task for an object.
	StatsTaskID *string `json:"statsTaskId,omitempty"`

	// Specifies a list of warning messages.
	Warnings []string `json:"warnings,omitempty"`

	// Specifies whether the snapshot is deleted manually.
	IsManuallyDeleted *bool `json:"isManuallyDeleted,omitempty"`

	// Specifies the expiry time of attempt in Unix epoch Timestamp (in microseconds) for an object.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// The total number of file and directory entities visited in this backup. Only applicable to file based backups.
	TotalFileCount *int64 `json:"totalFileCount,omitempty"`

	// The total number of file and directory entities that are backed up in this run. Only applicable to file based
	// backups.
	BackupFileCount *int64 `json:"backupFileCount,omitempty"`

	// Specifies the dataLock constraints for local or target snapshot.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`
}

// Constants associated with the SnapshotInfo.Status property.
// Status of snapshot.
const (
	SnapshotInfo_Status_Kcurrentattemptpaused     = "kCurrentAttemptPaused"
	SnapshotInfo_Status_Kcurrentattemptpausing    = "kCurrentAttemptPausing"
	SnapshotInfo_Status_Kcurrentattemptresuming   = "kCurrentAttemptResuming"
	SnapshotInfo_Status_Kfailed                   = "kFailed"
	SnapshotInfo_Status_Kinprogress               = "kInProgress"
	SnapshotInfo_Status_Ksuccessful               = "kSuccessful"
	SnapshotInfo_Status_Kwaitingfornextattempt    = "kWaitingForNextAttempt"
	SnapshotInfo_Status_Kwaitingforolderbackuprun = "kWaitingForOlderBackupRun"
	SnapshotInfo_Status_Kwarning                  = "kWarning"
)

// UnmarshalSnapshotInfo unmarshals an instance of SnapshotInfo from the specified map of raw messages.
func UnmarshalSnapshotInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotInfo)
	err = core.UnmarshalPrimitive(m, "snapshotId", &obj.SnapshotID)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "statusMessage", &obj.StatusMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "statusMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "admittedTimeUsecs", &obj.AdmittedTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "admittedTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "permitGrantTimeUsecs", &obj.PermitGrantTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "permitGrantTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "queueDurationUsecs", &obj.QueueDurationUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "queueDurationUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotCreationTimeUsecs", &obj.SnapshotCreationTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotCreationTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "stats", &obj.Stats, UnmarshalBackupDataStats)
	if err != nil {
		err = core.SDKErrorf(err, "", "stats-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "progressTaskId", &obj.ProgressTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "progressTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "indexingTaskId", &obj.IndexingTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "indexingTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "statsTaskId", &obj.StatsTaskID)
	if err != nil {
		err = core.SDKErrorf(err, "", "statsTaskId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "warnings", &obj.Warnings)
	if err != nil {
		err = core.SDKErrorf(err, "", "warnings-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isManuallyDeleted", &obj.IsManuallyDeleted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isManuallyDeleted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "expiryTimeUsecs", &obj.ExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "expiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "totalFileCount", &obj.TotalFileCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "totalFileCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "backupFileCount", &obj.BackupFileCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "backupFileCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dataLockConstraints", &obj.DataLockConstraints, UnmarshalDataLockConstraints)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLockConstraints-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotTagInfo : Specifies the snapshot tag info for an object.
type SnapshotTagInfo struct {
	// Specifies Id of tag applied to the object.
	TagID *string `json:"tagId" validate:"required"`

	// Specifies runs the tags are applied to.
	RunIds []string `json:"runIds,omitempty"`
}

// UnmarshalSnapshotTagInfo unmarshals an instance of SnapshotTagInfo from the specified map of raw messages.
func UnmarshalSnapshotTagInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotTagInfo)
	err = core.UnmarshalPrimitive(m, "tagId", &obj.TagID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tagId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runIds", &obj.RunIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "runIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceRegistrationReponseParams : Specifies the parameters which are common between all Protection Source registrations.
type SourceRegistrationReponseParams struct {
	// Source Registration ID. This can be used to retrieve, edit or delete the source registration.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	ID *int64 `json:"id,omitempty"`

	// ID of top level source object discovered after the registration.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies information about an object.
	SourceInfo *Object `json:"sourceInfo,omitempty"`

	// Specifies the environment type of the Protection Source.
	Environment *string `json:"environment,omitempty"`

	// The user specified name for this source.
	Name *string `json:"name,omitempty"`

	// Specifies the id of the connection from where this source is reachable. This should only be set for a source being
	// registered by a tenant user. This field will be depricated in future. Use connections field.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// Specfies the list of connections for the source.
	Connections []ConnectionConfig `json:"connections,omitempty"`

	// Specifies the connector group id of connector groups.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Specifies the id of the connection from where this source is reachable. This should only be set for a source being
	// registered by a tenant user. Also, this is the 'string' of connectionId. This property was added to accommodate for
	// ID values that exceed 2^53 - 1, which is the max value for which JS maintains precision.
	DataSourceConnectionID *string `json:"dataSourceConnectionId,omitempty"`

	// Specifies the advanced configuration for a protection source.
	AdvancedConfigs []KeyValuePair `json:"advancedConfigs,omitempty"`

	// Specifies the status of the authentication during the registration of a Protection Source. 'Pending' indicates the
	// authentication is in progress. 'Scheduled' indicates the authentication is scheduled. 'Finished' indicates the
	// authentication is completed. 'RefreshInProgress' indicates the refresh is in progress.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	AuthenticationStatus *string `json:"authenticationStatus,omitempty"`

	// Specifies the time when the source was registered in milliseconds.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	RegistrationTimeMsecs *int64 `json:"registrationTimeMsecs,omitempty"`

	// Specifies the time when the source was last refreshed in milliseconds.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	LastRefreshedTimeMsecs *int64 `json:"lastRefreshedTimeMsecs,omitempty"`

	// Specifies the External metadata of an entity.
	ExternalMetadata *EntityExternalMetadata `json:"externalMetadata,omitempty"`

	// Specifies parameters to register physical server.
	PhysicalParams *PhysicalSourceRegistrationParams `json:"physicalParams,omitempty"`
}

// Constants associated with the SourceRegistrationReponseParams.Environment property.
// Specifies the environment type of the Protection Source.
const (
	SourceRegistrationReponseParams_Environment_Kphysical = "kPhysical"
	SourceRegistrationReponseParams_Environment_Ksql      = "kSQL"
)

// Constants associated with the SourceRegistrationReponseParams.AuthenticationStatus property.
// Specifies the status of the authentication during the registration of a Protection Source. 'Pending' indicates the
// authentication is in progress. 'Scheduled' indicates the authentication is scheduled. 'Finished' indicates the
// authentication is completed. 'RefreshInProgress' indicates the refresh is in progress.
const (
	SourceRegistrationReponseParams_AuthenticationStatus_Finished          = "Finished"
	SourceRegistrationReponseParams_AuthenticationStatus_Pending           = "Pending"
	SourceRegistrationReponseParams_AuthenticationStatus_Refreshinprogress = "RefreshInProgress"
	SourceRegistrationReponseParams_AuthenticationStatus_Scheduled         = "Scheduled"
)

// UnmarshalSourceRegistrationReponseParams unmarshals an instance of SourceRegistrationReponseParams from the specified map of raw messages.
func UnmarshalSourceRegistrationReponseParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceRegistrationReponseParams)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalObject)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectionId", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalConnectionConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connectorGroupId", &obj.ConnectorGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataSourceConnectionId", &obj.DataSourceConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataSourceConnectionId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "advancedConfigs", &obj.AdvancedConfigs, UnmarshalKeyValuePair)
	if err != nil {
		err = core.SDKErrorf(err, "", "advancedConfigs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "authenticationStatus", &obj.AuthenticationStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "authenticationStatus-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "registrationTimeMsecs", &obj.RegistrationTimeMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "registrationTimeMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastRefreshedTimeMsecs", &obj.LastRefreshedTimeMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastRefreshedTimeMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "externalMetadata", &obj.ExternalMetadata, UnmarshalEntityExternalMetadata)
	if err != nil {
		err = core.SDKErrorf(err, "", "externalMetadata-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "physicalParams", &obj.PhysicalParams, UnmarshalPhysicalSourceRegistrationParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "physicalParams-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceRegistrations : Protection Source Registrations.
type SourceRegistrations struct {
	// Specifies the list of Protection Source Registrations.
	Registrations []SourceRegistrationReponseParams `json:"registrations,omitempty"`
}

// UnmarshalSourceRegistrations unmarshals an instance of SourceRegistrations from the specified map of raw messages.
func UnmarshalSourceRegistrations(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceRegistrations)
	err = core.UnmarshalModel(m, "registrations", &obj.Registrations, UnmarshalSourceRegistrationReponseParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "registrations-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SqlProtectionSource : Specifies an Object representing one SQL Server instance or database.
type SqlProtectionSource struct {
	// Specifies whether the database is marked as available for backup according to the SQL Server VSS writer. This may be
	// false if either the state of the databases is not online, or if the VSS writer is not online. This field is set only
	// for type 'kDatabase'.
	IsAvailableForVssBackup *bool `json:"IsAvailableForVssBackup,omitempty"`

	// Specifies the time when the database was created. It is displayed in the timezone of the SQL server on which this
	// database is running.
	CreatedTimestamp *string `json:"createdTimestamp,omitempty"`

	// Specifies the database name of the SQL Protection Source, if the type is database.
	DatabaseName *string `json:"databaseName,omitempty"`

	// Specifies the AAG entity id if the database is part of an AAG. This field is set only for type 'kDatabase'.
	DbAagEntityID *int64 `json:"dbAagEntityId,omitempty"`

	// Specifies the name of the AAG if the database is part of an AAG. This field is set only for type 'kDatabase'.
	DbAagName *string `json:"dbAagName,omitempty"`

	// Specifies the versions of SQL server that the database is compatible with.
	DbCompatibilityLevel *int64 `json:"dbCompatibilityLevel,omitempty"`

	// Specifies the information about the set of file groups for this db on the host. This is only set if the type is
	// kDatabase.
	DbFileGroups []string `json:"dbFileGroups,omitempty"`

	// Specifies the last known information about the set of database files on the host. This field is set only for type
	// 'kDatabase'.
	DbFiles []DatabaseFileInformation `json:"dbFiles,omitempty"`

	// Specifies the name of the database owner.
	DbOwnerUsername *string `json:"dbOwnerUsername,omitempty"`

	// Specifies the default path for data files for DBs in an instance.
	DefaultDatabaseLocation *string `json:"defaultDatabaseLocation,omitempty"`

	// Specifies the default path for log files for DBs in an instance.
	DefaultLogLocation *string `json:"defaultLogLocation,omitempty"`

	// Specifies a unique id for a SQL Protection Source.
	ID *SQLSourceID `json:"id,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`

	// Specifies the instance name of the SQL Protection Source.
	Name *string `json:"name,omitempty"`

	// Specifies the id of the container VM for the SQL Protection Source.
	OwnerID *int64 `json:"ownerId,omitempty"`

	// Specifies the Recovery Model for the database in SQL environment. Only meaningful for the 'kDatabase' SQL Protection
	// Source. Specifies the Recovery Model set for the Microsoft SQL Server. 'kSimpleRecoveryModel' indicates the Simple
	// SQL Recovery Model which does not utilize log backups. 'kFullRecoveryModel' indicates the Full SQL Recovery Model
	// which requires log backups and allows recovery to a single point in time. 'kBulkLoggedRecoveryModel' indicates the
	// Bulk Logged SQL Recovery Model which requires log backups and allows high-performance bulk copy operations.
	RecoveryModel *string `json:"recoveryModel,omitempty"`

	// The state of the database as returned by SQL Server. Indicates the state of the database. The values correspond to
	// the 'state' field in the system table sys.databases. See https://goo.gl/P66XqM. 'kOnline' indicates that database is
	// in online state. 'kRestoring' indicates that database is in restore state. 'kRecovering' indicates that database is
	// in recovery state. 'kRecoveryPending' indicates that database recovery is in pending state. 'kSuspect' indicates
	// that primary filegroup is suspect and may be damaged. 'kEmergency' indicates that manually forced emergency state.
	// 'kOffline' indicates that database is in offline state. 'kCopying' indicates that database is in copying state.
	// 'kOfflineSecondary' indicates that secondary database is in offline state.
	SqlServerDbState *string `json:"sqlServerDbState,omitempty"`

	// Specifies the Server Instance Version.
	SqlServerInstanceVersion *SQLServerInstanceVersion `json:"sqlServerInstanceVersion,omitempty"`

	// Specifies the type of the managed Object in a SQL Protection Source. Examples of SQL Objects include 'kInstance' and
	// 'kDatabase'. 'kInstance' indicates that SQL server instance is being protected. 'kDatabase' indicates that SQL
	// server database is being protected. 'kAAG' indicates that SQL AAG (AlwaysOn Availability Group) is being protected.
	// 'kAAGRootContainer' indicates that SQL AAG's root container is being protected. 'kRootContainer' indicates root
	// container for SQL sources.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the SqlProtectionSource.RecoveryModel property.
// Specifies the Recovery Model for the database in SQL environment. Only meaningful for the 'kDatabase' SQL Protection
// Source. Specifies the Recovery Model set for the Microsoft SQL Server. 'kSimpleRecoveryModel' indicates the Simple
// SQL Recovery Model which does not utilize log backups. 'kFullRecoveryModel' indicates the Full SQL Recovery Model
// which requires log backups and allows recovery to a single point in time. 'kBulkLoggedRecoveryModel' indicates the
// Bulk Logged SQL Recovery Model which requires log backups and allows high-performance bulk copy operations.
const (
	SqlProtectionSource_RecoveryModel_Kbulkloggedrecoverymodel = "kBulkLoggedRecoveryModel"
	SqlProtectionSource_RecoveryModel_Kfullrecoverymodel       = "kFullRecoveryModel"
	SqlProtectionSource_RecoveryModel_Ksimplerecoverymodel     = "kSimpleRecoveryModel"
)

// Constants associated with the SqlProtectionSource.SqlServerDbState property.
// The state of the database as returned by SQL Server. Indicates the state of the database. The values correspond to
// the 'state' field in the system table sys.databases. See https://goo.gl/P66XqM. 'kOnline' indicates that database is
// in online state. 'kRestoring' indicates that database is in restore state. 'kRecovering' indicates that database is
// in recovery state. 'kRecoveryPending' indicates that database recovery is in pending state. 'kSuspect' indicates that
// primary filegroup is suspect and may be damaged. 'kEmergency' indicates that manually forced emergency state.
// 'kOffline' indicates that database is in offline state. 'kCopying' indicates that database is in copying state.
// 'kOfflineSecondary' indicates that secondary database is in offline state.
const (
	SqlProtectionSource_SqlServerDbState_Kcopying          = "kCopying"
	SqlProtectionSource_SqlServerDbState_Kemergency        = "kEmergency"
	SqlProtectionSource_SqlServerDbState_Koffline          = "kOffline"
	SqlProtectionSource_SqlServerDbState_Kofflinesecondary = "kOfflineSecondary"
	SqlProtectionSource_SqlServerDbState_Konline           = "kOnline"
	SqlProtectionSource_SqlServerDbState_Krecovering       = "kRecovering"
	SqlProtectionSource_SqlServerDbState_Krecoverypending  = "kRecoveryPending"
	SqlProtectionSource_SqlServerDbState_Krestoring        = "kRestoring"
	SqlProtectionSource_SqlServerDbState_Ksuspect          = "kSuspect"
)

// Constants associated with the SqlProtectionSource.Type property.
// Specifies the type of the managed Object in a SQL Protection Source. Examples of SQL Objects include 'kInstance' and
// 'kDatabase'. 'kInstance' indicates that SQL server instance is being protected. 'kDatabase' indicates that SQL server
// database is being protected. 'kAAG' indicates that SQL AAG (AlwaysOn Availability Group) is being protected.
// 'kAAGRootContainer' indicates that SQL AAG's root container is being protected. 'kRootContainer' indicates root
// container for SQL sources.
const (
	SqlProtectionSource_Type_Kaag              = "kAAG"
	SqlProtectionSource_Type_Kaagrootcontainer = "kAAGRootContainer"
	SqlProtectionSource_Type_Kdatabase         = "kDatabase"
	SqlProtectionSource_Type_Kinstance         = "kInstance"
	SqlProtectionSource_Type_Krootcontainer    = "kRootContainer"
)

// UnmarshalSqlProtectionSource unmarshals an instance of SqlProtectionSource from the specified map of raw messages.
func UnmarshalSqlProtectionSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SqlProtectionSource)
	err = core.UnmarshalPrimitive(m, "IsAvailableForVssBackup", &obj.IsAvailableForVssBackup)
	if err != nil {
		err = core.SDKErrorf(err, "", "IsAvailableForVssBackup-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "createdTimestamp", &obj.CreatedTimestamp)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdTimestamp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "databaseName", &obj.DatabaseName)
	if err != nil {
		err = core.SDKErrorf(err, "", "databaseName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dbAagEntityId", &obj.DbAagEntityID)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbAagEntityId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dbAagName", &obj.DbAagName)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbAagName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dbCompatibilityLevel", &obj.DbCompatibilityLevel)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbCompatibilityLevel-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dbFileGroups", &obj.DbFileGroups)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbFileGroups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "dbFiles", &obj.DbFiles, UnmarshalDatabaseFileInformation)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbFiles-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dbOwnerUsername", &obj.DbOwnerUsername)
	if err != nil {
		err = core.SDKErrorf(err, "", "dbOwnerUsername-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "defaultDatabaseLocation", &obj.DefaultDatabaseLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "defaultDatabaseLocation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "defaultLogLocation", &obj.DefaultLogLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "defaultLogLocation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "id", &obj.ID, UnmarshalSQLSourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEncrypted", &obj.IsEncrypted)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEncrypted-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ownerId", &obj.OwnerID)
	if err != nil {
		err = core.SDKErrorf(err, "", "ownerId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoveryModel", &obj.RecoveryModel)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoveryModel-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sqlServerDbState", &obj.SqlServerDbState)
	if err != nil {
		err = core.SDKErrorf(err, "", "sqlServerDbState-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sqlServerInstanceVersion", &obj.SqlServerInstanceVersion, UnmarshalSQLServerInstanceVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "sqlServerInstanceVersion-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SqlTargetParamsForRecoverSqlApp : Specifies the params for recovering to a sql host. Specifiy seperate settings for each db object that need to be
// recovered. Provided sql backup should be recovered to same type of target host. For Example: If you have sql backup
// taken from a physical host then that should be recovered to physical host only.
type SqlTargetParamsForRecoverSqlApp struct {
	// Specifies the destination Source configuration parameters where the databases will be recovered. This is mandatory
	// if recoverToNewSource is set to true.
	NewSourceConfig *RecoverSqlAppNewSourceConfig `json:"newSourceConfig,omitempty"`

	// Specifies the Source configuration if databases are being recovered to Original Source. If not specified, all the
	// configuration parameters will be retained.
	OriginalSourceConfig *RecoverSqlAppOriginalSourceConfig `json:"originalSourceConfig,omitempty"`

	// Specifies the parameter whether the recovery should be performed to a new sources or an original Source Target.
	RecoverToNewSource *bool `json:"recoverToNewSource" validate:"required"`
}

// NewSqlTargetParamsForRecoverSqlApp : Instantiate SqlTargetParamsForRecoverSqlApp (Generic Model Constructor)
func (*BackupRecoveryV1) NewSqlTargetParamsForRecoverSqlApp(recoverToNewSource bool) (_model *SqlTargetParamsForRecoverSqlApp, err error) {
	_model = &SqlTargetParamsForRecoverSqlApp{
		RecoverToNewSource: core.BoolPtr(recoverToNewSource),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalSqlTargetParamsForRecoverSqlApp unmarshals an instance of SqlTargetParamsForRecoverSqlApp from the specified map of raw messages.
func UnmarshalSqlTargetParamsForRecoverSqlApp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SqlTargetParamsForRecoverSqlApp)
	err = core.UnmarshalModel(m, "newSourceConfig", &obj.NewSourceConfig, UnmarshalRecoverSqlAppNewSourceConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "newSourceConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "originalSourceConfig", &obj.OriginalSourceConfig, UnmarshalRecoverSqlAppOriginalSourceConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "originalSourceConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "recoverToNewSource", &obj.RecoverToNewSource)
	if err != nil {
		err = core.SDKErrorf(err, "", "recoverToNewSource-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageArraySnapshotBackupPolicy : Specifies storage snapshot managment backup settings for a Protection Group.
type StorageArraySnapshotBackupPolicy struct {
	// Specifies settings that defines how frequent Storage Snapshot Management backup will be performed for a Protection
	// Group.
	Schedule *StorageArraySnapshotSchedule `json:"schedule" validate:"required"`

	// Specifies the retention of a backup.
	Retention *Retention `json:"retention" validate:"required"`
}

// NewStorageArraySnapshotBackupPolicy : Instantiate StorageArraySnapshotBackupPolicy (Generic Model Constructor)
func (*BackupRecoveryV1) NewStorageArraySnapshotBackupPolicy(schedule *StorageArraySnapshotSchedule, retention *Retention) (_model *StorageArraySnapshotBackupPolicy, err error) {
	_model = &StorageArraySnapshotBackupPolicy{
		Schedule:  schedule,
		Retention: retention,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalStorageArraySnapshotBackupPolicy unmarshals an instance of StorageArraySnapshotBackupPolicy from the specified map of raw messages.
func UnmarshalStorageArraySnapshotBackupPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageArraySnapshotBackupPolicy)
	err = core.UnmarshalModel(m, "schedule", &obj.Schedule, UnmarshalStorageArraySnapshotSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "schedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "retention", &obj.Retention, UnmarshalRetention)
	if err != nil {
		err = core.SDKErrorf(err, "", "retention-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageArraySnapshotConfig : Specifies Storage Array Snapshot Configuration.
type StorageArraySnapshotConfig struct {
	// Specifies if the storage array snapshot max snapshots config is enabled or not.
	IsMaxSnapshotsConfigEnabled *bool `json:"isMaxSnapshotsConfigEnabled,omitempty"`

	// Specifies if the storage array snapshot max space config is enabled or not.
	IsMaxSpaceConfigEnabled *bool `json:"isMaxSpaceConfigEnabled,omitempty"`

	// Specifies Storage Array Snapshot Max Space Config.
	StorageArraySnapshotMaxSpaceConfig *StorageArraySnapshotMaxSpaceConfig `json:"storageArraySnapshotMaxSpaceConfig,omitempty"`

	// Specifies throttling policies configured for individual volume/lun.
	StorageArraySnapshotThrottlingPolicies []StorageArraySnapshotThrottlingPolicies `json:"storageArraySnapshotThrottlingPolicies,omitempty"`
}

// UnmarshalStorageArraySnapshotConfig unmarshals an instance of StorageArraySnapshotConfig from the specified map of raw messages.
func UnmarshalStorageArraySnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageArraySnapshotConfig)
	err = core.UnmarshalPrimitive(m, "isMaxSnapshotsConfigEnabled", &obj.IsMaxSnapshotsConfigEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isMaxSnapshotsConfigEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isMaxSpaceConfigEnabled", &obj.IsMaxSpaceConfigEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isMaxSpaceConfigEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "storageArraySnapshotMaxSpaceConfig", &obj.StorageArraySnapshotMaxSpaceConfig, UnmarshalStorageArraySnapshotMaxSpaceConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageArraySnapshotMaxSpaceConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "storageArraySnapshotThrottlingPolicies", &obj.StorageArraySnapshotThrottlingPolicies, UnmarshalStorageArraySnapshotThrottlingPolicies)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageArraySnapshotThrottlingPolicies-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageArraySnapshotMaxSpaceConfig : Specifies Storage Array Snapshot Max Space Config.
type StorageArraySnapshotMaxSpaceConfig struct {
	// Max number of storage snapshots allowed per volume/lun.
	MaxSnapshotSpacePercentage *float64 `json:"maxSnapshotSpacePercentage,omitempty"`
}

// UnmarshalStorageArraySnapshotMaxSpaceConfig unmarshals an instance of StorageArraySnapshotMaxSpaceConfig from the specified map of raw messages.
func UnmarshalStorageArraySnapshotMaxSpaceConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageArraySnapshotMaxSpaceConfig)
	err = core.UnmarshalPrimitive(m, "maxSnapshotSpacePercentage", &obj.MaxSnapshotSpacePercentage)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxSnapshotSpacePercentage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageArraySnapshotSchedule : Specifies settings that defines how frequent Storage Snapshot Management backup will be performed for a Protection
// Group.
type StorageArraySnapshotSchedule struct {
	// Specifies how often to start new Protection Group Runs of a Protection Group. <br>'Minutes' specifies that
	// Protection Group run starts periodically after certain number of minutes specified in 'frequency' field. <br>'Hours'
	// specifies that Protection Group run starts periodically after certain number of hours specified in 'frequency'
	// field.
	Unit *string `json:"unit" validate:"required"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of minutes.
	MinuteSchedule *MinuteSchedule `json:"minuteSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of hours.
	HourSchedule *HourSchedule `json:"hourSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start after certain number of days.
	DaySchedule *DaySchedule `json:"daySchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to start on certain days of week.
	WeekSchedule *WeekSchedule `json:"weekSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group runs to on specific week and specific days of that
	// week.
	MonthSchedule *MonthSchedule `json:"monthSchedule,omitempty"`

	// Specifies settings that define a schedule for a Protection Group to run on specific year and specific day of that
	// year.
	YearSchedule *YearSchedule `json:"yearSchedule,omitempty"`
}

// Constants associated with the StorageArraySnapshotSchedule.Unit property.
// Specifies how often to start new Protection Group Runs of a Protection Group. <br>'Minutes' specifies that Protection
// Group run starts periodically after certain number of minutes specified in 'frequency' field. <br>'Hours' specifies
// that Protection Group run starts periodically after certain number of hours specified in 'frequency' field.
const (
	StorageArraySnapshotSchedule_Unit_Days    = "Days"
	StorageArraySnapshotSchedule_Unit_Hours   = "Hours"
	StorageArraySnapshotSchedule_Unit_Minutes = "Minutes"
	StorageArraySnapshotSchedule_Unit_Months  = "Months"
	StorageArraySnapshotSchedule_Unit_Weeks   = "Weeks"
	StorageArraySnapshotSchedule_Unit_Years   = "Years"
)

// NewStorageArraySnapshotSchedule : Instantiate StorageArraySnapshotSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewStorageArraySnapshotSchedule(unit string) (_model *StorageArraySnapshotSchedule, err error) {
	_model = &StorageArraySnapshotSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalStorageArraySnapshotSchedule unmarshals an instance of StorageArraySnapshotSchedule from the specified map of raw messages.
func UnmarshalStorageArraySnapshotSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageArraySnapshotSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "minuteSchedule", &obj.MinuteSchedule, UnmarshalMinuteSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "minuteSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "hourSchedule", &obj.HourSchedule, UnmarshalHourSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "hourSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "daySchedule", &obj.DaySchedule, UnmarshalDaySchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "daySchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "weekSchedule", &obj.WeekSchedule, UnmarshalWeekSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "weekSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "monthSchedule", &obj.MonthSchedule, UnmarshalMonthSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "monthSchedule-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "yearSchedule", &obj.YearSchedule, UnmarshalYearSchedule)
	if err != nil {
		err = core.SDKErrorf(err, "", "yearSchedule-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageArraySnapshotThrottlingPolicies : Specifies Storage Array Snapshot Configuration.
type StorageArraySnapshotThrottlingPolicies struct {
	// Specifies the volume id of the storage array snapshot config.
	ID *int64 `json:"id,omitempty"`

	// Specifies if the storage array snapshot max snapshots config is enabled or not.
	IsMaxSnapshotsConfigEnabled *bool `json:"isMaxSnapshotsConfigEnabled,omitempty"`

	// Specifies if the storage array snapshot max space config is enabled or not.
	IsMaxSpaceConfigEnabled *bool `json:"isMaxSpaceConfigEnabled,omitempty"`

	// Specifies Storage Array Snapshot Max Snapshots Config.
	MaxSnapshotConfig *MaxSnapshotConfig `json:"maxSnapshotConfig,omitempty"`

	// Specifies Storage Array Snapshot Max Space Config.
	MaxSpaceConfig *MaxSpaceConfig `json:"maxSpaceConfig,omitempty"`
}

// UnmarshalStorageArraySnapshotThrottlingPolicies unmarshals an instance of StorageArraySnapshotThrottlingPolicies from the specified map of raw messages.
func UnmarshalStorageArraySnapshotThrottlingPolicies(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageArraySnapshotThrottlingPolicies)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isMaxSnapshotsConfigEnabled", &obj.IsMaxSnapshotsConfigEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isMaxSnapshotsConfigEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isMaxSpaceConfigEnabled", &obj.IsMaxSpaceConfigEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isMaxSpaceConfigEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "maxSnapshotConfig", &obj.MaxSnapshotConfig, UnmarshalMaxSnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "maxSpaceConfig", &obj.MaxSpaceConfig, UnmarshalMaxSpaceConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxSpaceConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subnet : Defines a Subnet (Subnetwork). The netmask can be specified by setting netmaskBits or netmaskIp4. The netmask can
// only be set using netmaskIp4 if the IP address is an IPv4 address.
type Subnet struct {
	// Component that has reserved the subnet.
	Component *string `json:"component,omitempty"`

	// Description of the subnet.
	Description *string `json:"description,omitempty"`

	// ID of the subnet.
	ID *float64 `json:"id,omitempty"`

	// Specifies either an IPv6 address or an IPv4 address.
	Ip *string `json:"ip,omitempty"`

	// netmaskBits.
	NetmaskBits *float64 `json:"netmaskBits,omitempty"`

	// Specifies the netmask using an IP4 address. The netmask can only be set using netmaskIp4 if the IP address is an
	// IPv4 address.
	NetmaskIp4 *string `json:"netmaskIp4,omitempty"`

	// Component that has reserved the subnet.
	NfsAccess *string `json:"nfsAccess,omitempty"`

	// Specifies whether all clients from this subnet can map view with view_all_squash_uid/view_all_squash_gid configured
	// in the view.
	NfsAllSquash *bool `json:"nfsAllSquash,omitempty"`

	// Specifies whether clients from this subnet can mount as root on NFS.
	NfsRootSquash *bool `json:"nfsRootSquash,omitempty"`

	// Specifies whether clients from this subnet can access using S3 protocol. Protocol access level. 'kDisabled'
	// indicates Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite'
	// indicates Protocol access level 'ReadWrite'.
	S3Access *string `json:"s3Access,omitempty"`

	// Specifies whether clients from this subnet can mount using SMB protocol. Protocol access level. 'kDisabled'
	// indicates Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite'
	// indicates Protocol access level 'ReadWrite'.
	SmbAccess *string `json:"smbAccess,omitempty"`

	// Specifies the unique id of the tenant.
	TenantID *string `json:"tenantId,omitempty"`
}

// Constants associated with the Subnet.NfsAccess property.
// Component that has reserved the subnet.
const (
	Subnet_NfsAccess_Kdisabled  = "kDisabled"
	Subnet_NfsAccess_Kreadonly  = "kReadOnly"
	Subnet_NfsAccess_Kreadwrite = "kReadWrite"
)

// Constants associated with the Subnet.S3Access property.
// Specifies whether clients from this subnet can access using S3 protocol. Protocol access level. 'kDisabled' indicates
// Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite' indicates
// Protocol access level 'ReadWrite'.
const (
	Subnet_S3Access_Kdisabled  = "kDisabled"
	Subnet_S3Access_Kreadonly  = "kReadOnly"
	Subnet_S3Access_Kreadwrite = "kReadWrite"
)

// Constants associated with the Subnet.SmbAccess property.
// Specifies whether clients from this subnet can mount using SMB protocol. Protocol access level. 'kDisabled' indicates
// Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite' indicates
// Protocol access level 'ReadWrite'.
const (
	Subnet_SmbAccess_Kdisabled  = "kDisabled"
	Subnet_SmbAccess_Kreadonly  = "kReadOnly"
	Subnet_SmbAccess_Kreadwrite = "kReadWrite"
)

// UnmarshalSubnet unmarshals an instance of Subnet from the specified map of raw messages.
func UnmarshalSubnet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subnet)
	err = core.UnmarshalPrimitive(m, "component", &obj.Component)
	if err != nil {
		err = core.SDKErrorf(err, "", "component-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		err = core.SDKErrorf(err, "", "description-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ip", &obj.Ip)
	if err != nil {
		err = core.SDKErrorf(err, "", "ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "netmaskBits", &obj.NetmaskBits)
	if err != nil {
		err = core.SDKErrorf(err, "", "netmaskBits-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "netmaskIp4", &obj.NetmaskIp4)
	if err != nil {
		err = core.SDKErrorf(err, "", "netmaskIp4-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nfsAccess", &obj.NfsAccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "nfsAccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nfsAllSquash", &obj.NfsAllSquash)
	if err != nil {
		err = core.SDKErrorf(err, "", "nfsAllSquash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "nfsRootSquash", &obj.NfsRootSquash)
	if err != nil {
		err = core.SDKErrorf(err, "", "nfsRootSquash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "s3Access", &obj.S3Access)
	if err != nil {
		err = core.SDKErrorf(err, "", "s3Access-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "smbAccess", &obj.SmbAccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "smbAccess-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantId", &obj.TenantID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tenantId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubtreeInfo : Aggregated information about a node subtree.
type SubtreeInfo struct {
	// Specifies the environment such as 'kSQL' or 'kVMware', where the Protection Source exists. Supported environment
	// types such as 'kView', 'kSQL', 'kVMware', etc. NOTE 'kPuppeteer' refers to Cohesity's Remote Adapter. 'kVMware'
	// indicates the VMware Protection Source environment. 'kHyperV' indicates the HyperV Protection Source environment.
	// 'kSQL' indicates the SQL Protection Source environment. 'kView' indicates the View Protection Source environment.
	// 'kPuppeteer' indicates the Cohesity's Remote Adapter. 'kPhysical' indicates the physical Protection Source
	// environment. 'kPure' indicates the Pure Storage Protection Source environment. 'kNimble' indicates the Nimble
	// Storage Protection Source environment. 'kAzure' indicates the Microsoft's Azure Protection Source environment.
	// 'kNetapp' indicates the Netapp Protection Source environment. 'kAgent' indicates the Agent Protection Source
	// environment. 'kGenericNas' indicates the Generic Network Attached Storage Protection Source environment.
	// 'kAcropolis' indicates the Acropolis Protection Source environment. 'kPhysicalFiles' indicates the Physical Files
	// Protection Source environment. 'kIbmFlashSystem' indicates the IBM Flash System Protection Source environment.
	// 'kIsilon' indicates the Dell EMC's Isilon Protection Source environment. 'kGPFS' indicates IBM's GPFS Protection
	// Source environment. 'kKVM' indicates the KVM Protection Source environment. 'kAWS' indicates the AWS Protection
	// Source environment. 'kExchange' indicates the Exchange Protection Source environment. 'kHyperVVSS' indicates the
	// HyperV VSS Protection Source environment. 'kOracle' indicates the Oracle Protection Source environment. 'kGCP'
	// indicates the Google Cloud Platform Protection Source environment. 'kFlashBlade' indicates the Flash Blade
	// Protection Source environment. 'kAWSNative' indicates the AWS Native Protection Source environment. 'kO365'
	// indicates the Office 365 Protection Source environment. 'kO365Outlook' indicates Office 365 outlook Protection
	// Source environment. 'kHyperFlex' indicates the Hyper Flex Protection Source environment. 'kGCPNative' indicates the
	// GCP Native Protection Source environment. 'kAzureNative' indicates the Azure Native Protection Source environment.
	// 'kKubernetes' indicates a Kubernetes Protection Source environment. 'kElastifile' indicates Elastifile Protection
	// Source environment. 'kAD' indicates Active Directory Protection Source environment. 'kRDSSnapshotManager' indicates
	// AWS RDS Protection Source environment. 'kCassandra' indicates Cassandra Protection Source environment. 'kMongoDB'
	// indicates MongoDB Protection Source environment. 'kCouchbase' indicates Couchbase Protection Source environment.
	// 'kHdfs' indicates Hdfs Protection Source environment. 'kHive' indicates Hive Protection Source environment. 'kHBase'
	// indicates HBase Protection Source environment. 'kUDA' indicates Universal Data Adapter Protection Source
	// environment. 'kO365Teams' indicates the Office365 Teams Protection Source environment. 'kO365Group' indicates the
	// Office365 Groups Protection Source environment. 'kO365Exchange' indicates the Office365 Mailbox Protection Source
	// environment. 'kO365OneDrive' indicates the Office365 OneDrive Protection Source environment. 'kO365Sharepoint'
	// indicates the Office365 SharePoint Protection Source environment. 'kO365PublicFolders' indicates the Office365
	// PublicFolders Protection Source environment.
	Environment *string `json:"environment,omitempty"`

	// Specifies the number of leaf nodes under the subtree of this node.
	LeavesCount *int64 `json:"leavesCount,omitempty"`

	// Specifies the total logical size of the data under the subtree of this node.
	TotalLogicalSize *int64 `json:"totalLogicalSize,omitempty"`
}

// Constants associated with the SubtreeInfo.Environment property.
// Specifies the environment such as 'kSQL' or 'kVMware', where the Protection Source exists. Supported environment
// types such as 'kView', 'kSQL', 'kVMware', etc. NOTE 'kPuppeteer' refers to Cohesity's Remote Adapter. 'kVMware'
// indicates the VMware Protection Source environment. 'kHyperV' indicates the HyperV Protection Source environment.
// 'kSQL' indicates the SQL Protection Source environment. 'kView' indicates the View Protection Source environment.
// 'kPuppeteer' indicates the Cohesity's Remote Adapter. 'kPhysical' indicates the physical Protection Source
// environment. 'kPure' indicates the Pure Storage Protection Source environment. 'kNimble' indicates the Nimble Storage
// Protection Source environment. 'kAzure' indicates the Microsoft's Azure Protection Source environment. 'kNetapp'
// indicates the Netapp Protection Source environment. 'kAgent' indicates the Agent Protection Source environment.
// 'kGenericNas' indicates the Generic Network Attached Storage Protection Source environment. 'kAcropolis' indicates
// the Acropolis Protection Source environment. 'kPhysicalFiles' indicates the Physical Files Protection Source
// environment. 'kIbmFlashSystem' indicates the IBM Flash System Protection Source environment. 'kIsilon' indicates the
// Dell EMC's Isilon Protection Source environment. 'kGPFS' indicates IBM's GPFS Protection Source environment. 'kKVM'
// indicates the KVM Protection Source environment. 'kAWS' indicates the AWS Protection Source environment. 'kExchange'
// indicates the Exchange Protection Source environment. 'kHyperVVSS' indicates the HyperV VSS Protection Source
// environment. 'kOracle' indicates the Oracle Protection Source environment. 'kGCP' indicates the Google Cloud Platform
// Protection Source environment. 'kFlashBlade' indicates the Flash Blade Protection Source environment. 'kAWSNative'
// indicates the AWS Native Protection Source environment. 'kO365' indicates the Office 365 Protection Source
// environment. 'kO365Outlook' indicates Office 365 outlook Protection Source environment. 'kHyperFlex' indicates the
// Hyper Flex Protection Source environment. 'kGCPNative' indicates the GCP Native Protection Source environment.
// 'kAzureNative' indicates the Azure Native Protection Source environment. 'kKubernetes' indicates a Kubernetes
// Protection Source environment. 'kElastifile' indicates Elastifile Protection Source environment. 'kAD' indicates
// Active Directory Protection Source environment. 'kRDSSnapshotManager' indicates AWS RDS Protection Source
// environment. 'kCassandra' indicates Cassandra Protection Source environment. 'kMongoDB' indicates MongoDB Protection
// Source environment. 'kCouchbase' indicates Couchbase Protection Source environment. 'kHdfs' indicates Hdfs Protection
// Source environment. 'kHive' indicates Hive Protection Source environment. 'kHBase' indicates HBase Protection Source
// environment. 'kUDA' indicates Universal Data Adapter Protection Source environment. 'kO365Teams' indicates the
// Office365 Teams Protection Source environment. 'kO365Group' indicates the Office365 Groups Protection Source
// environment. 'kO365Exchange' indicates the Office365 Mailbox Protection Source environment. 'kO365OneDrive' indicates
// the Office365 OneDrive Protection Source environment. 'kO365Sharepoint' indicates the Office365 SharePoint Protection
// Source environment. 'kO365PublicFolders' indicates the Office365 PublicFolders Protection Source environment.
const (
	SubtreeInfo_Environment_Kacropolis          = "kAcropolis"
	SubtreeInfo_Environment_Kad                 = "kAD"
	SubtreeInfo_Environment_Kagent              = "kAgent"
	SubtreeInfo_Environment_Kaws                = "kAWS"
	SubtreeInfo_Environment_Kawsnative          = "kAWSNative"
	SubtreeInfo_Environment_Kazure              = "kAzure"
	SubtreeInfo_Environment_Kazurenative        = "kAzureNative"
	SubtreeInfo_Environment_Kcassandra          = "kCassandra"
	SubtreeInfo_Environment_Kcouchbase          = "kCouchbase"
	SubtreeInfo_Environment_Kelastifile         = "kElastifile"
	SubtreeInfo_Environment_Kexchange           = "kExchange"
	SubtreeInfo_Environment_Kflashblade         = "kFlashBlade"
	SubtreeInfo_Environment_Kgcp                = "kGCP"
	SubtreeInfo_Environment_Kgcpnative          = "kGCPNative"
	SubtreeInfo_Environment_Kgenericnas         = "kGenericNas"
	SubtreeInfo_Environment_Kgpfs               = "kGPFS"
	SubtreeInfo_Environment_Khbase              = "kHBase"
	SubtreeInfo_Environment_Khdfs               = "kHdfs"
	SubtreeInfo_Environment_Khive               = "kHive"
	SubtreeInfo_Environment_Khyperflex          = "kHyperFlex"
	SubtreeInfo_Environment_Khyperv             = "kHyperV"
	SubtreeInfo_Environment_Khypervvss          = "kHyperVVSS"
	SubtreeInfo_Environment_Kibmflashsystem     = "kIbmFlashSystem"
	SubtreeInfo_Environment_Kisilon             = "kIsilon"
	SubtreeInfo_Environment_Kkubernetes         = "kKubernetes"
	SubtreeInfo_Environment_Kkvm                = "kKVM"
	SubtreeInfo_Environment_Kmongodb            = "kMongoDB"
	SubtreeInfo_Environment_Knetapp             = "kNetapp"
	SubtreeInfo_Environment_Knimble             = "kNimble"
	SubtreeInfo_Environment_Ko365               = "kO365"
	SubtreeInfo_Environment_Ko365exchange       = "kO365Exchange"
	SubtreeInfo_Environment_Ko365group          = "kO365Group"
	SubtreeInfo_Environment_Ko365onedrive       = "kO365OneDrive"
	SubtreeInfo_Environment_Ko365outlook        = "kO365Outlook"
	SubtreeInfo_Environment_Ko365publicfolders  = "kO365PublicFolders"
	SubtreeInfo_Environment_Ko365sharepoint     = "kO365Sharepoint"
	SubtreeInfo_Environment_Ko365teams          = "kO365Teams"
	SubtreeInfo_Environment_Koracle             = "kOracle"
	SubtreeInfo_Environment_Kphysical           = "kPhysical"
	SubtreeInfo_Environment_Kphysicalfiles      = "kPhysicalFiles"
	SubtreeInfo_Environment_Kpure               = "kPure"
	SubtreeInfo_Environment_Krdssnapshotmanager = "kRDSSnapshotManager"
	SubtreeInfo_Environment_Ksql                = "kSQL"
	SubtreeInfo_Environment_Kuda                = "kUDA"
	SubtreeInfo_Environment_Kview               = "kView"
	SubtreeInfo_Environment_Kvmware             = "kVMware"
)

// UnmarshalSubtreeInfo unmarshals an instance of SubtreeInfo from the specified map of raw messages.
func UnmarshalSubtreeInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubtreeInfo)
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leavesCount", &obj.LeavesCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "leavesCount-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "totalLogicalSize", &obj.TotalLogicalSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "totalLogicalSize-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagInfo : Specifies the tag info for an object.
type TagInfo struct {
	// Specifies Id of tag applied to the object.
	TagID *string `json:"tagId" validate:"required"`
}

// UnmarshalTagInfo unmarshals an instance of TagInfo from the specified map of raw messages.
func UnmarshalTagInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagInfo)
	err = core.UnmarshalPrimitive(m, "tagId", &obj.TagID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tagId-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TaggedSnapshotInfo : Specifies helios tagged related snapshot info for an object.
type TaggedSnapshotInfo struct {
	// Specifies the cluster Id of the tagged snapshot.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the clusterIncarnationId of the tagged snapshot.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the jobId of the tagged snapshot.
	JobID *int64 `json:"jobId,omitempty"`

	// Specifies the object uuid of the tagged snapshot.
	ObjectUUID *string `json:"objectUuid,omitempty"`

	// Specifies the runStartTimeUsecs of the tagged snapshot.
	RunStartTimeUsecs *int64 `json:"runStartTimeUsecs,omitempty"`

	// Specifies tag applied to the object.
	Tags []HeliosTagInfo `json:"tags,omitempty"`
}

// UnmarshalTaggedSnapshotInfo unmarshals an instance of TaggedSnapshotInfo from the specified map of raw messages.
func UnmarshalTaggedSnapshotInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TaggedSnapshotInfo)
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIncarnationId", &obj.ClusterIncarnationID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIncarnationId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "jobId", &obj.JobID)
	if err != nil {
		err = core.SDKErrorf(err, "", "jobId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectUuid", &obj.ObjectUUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectUuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "runStartTimeUsecs", &obj.RunStartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "runStartTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalHeliosTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TargetSchedule : Specifies a schedule fregquency and schedule unit for copying Snapshots to backup targets.
type TargetSchedule struct {
	// Specifies the frequency that Snapshots should be copied to the specified target. Used in combination with
	// multiplier. <br>'Runs' means that the Snapshot copy occurs after the number of Protection Group Runs equals the
	// number specified in the frequency. <br>'Hours' means that the Snapshot copy occurs hourly at the frequency set in
	// the frequency, for example if scheduleFrequency is 2, the copy occurs every 2 hours. <br>'Days' means that the
	// Snapshot copy occurs daily at the frequency set in the frequency. <br>'Weeks' means that the Snapshot copy occurs
	// weekly at the frequency set in the frequency. <br>'Months' means that the Snapshot copy occurs monthly at the
	// frequency set in the Frequency. <br>'Years' means that the Snapshot copy occurs yearly at the frequency set in the
	// scheduleFrequency.
	Unit *string `json:"unit" validate:"required"`

	// Specifies a factor to multiply the unit by, to determine the copy schedule. For example if set to 2 and the unit is
	// hourly, then Snapshots from the first eligible Job Run for every 2 hour period is copied.
	Frequency *int64 `json:"frequency,omitempty"`
}

// Constants associated with the TargetSchedule.Unit property.
// Specifies the frequency that Snapshots should be copied to the specified target. Used in combination with multiplier.
// <br>'Runs' means that the Snapshot copy occurs after the number of Protection Group Runs equals the number specified
// in the frequency. <br>'Hours' means that the Snapshot copy occurs hourly at the frequency set in the frequency, for
// example if scheduleFrequency is 2, the copy occurs every 2 hours. <br>'Days' means that the Snapshot copy occurs
// daily at the frequency set in the frequency. <br>'Weeks' means that the Snapshot copy occurs weekly at the frequency
// set in the frequency. <br>'Months' means that the Snapshot copy occurs monthly at the frequency set in the Frequency.
// <br>'Years' means that the Snapshot copy occurs yearly at the frequency set in the scheduleFrequency.
const (
	TargetSchedule_Unit_Days   = "Days"
	TargetSchedule_Unit_Hours  = "Hours"
	TargetSchedule_Unit_Months = "Months"
	TargetSchedule_Unit_Runs   = "Runs"
	TargetSchedule_Unit_Weeks  = "Weeks"
	TargetSchedule_Unit_Years  = "Years"
)

// NewTargetSchedule : Instantiate TargetSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewTargetSchedule(unit string) (_model *TargetSchedule, err error) {
	_model = &TargetSchedule{
		Unit: core.StringPtr(unit),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalTargetSchedule unmarshals an instance of TargetSchedule from the specified map of raw messages.
func UnmarshalTargetSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TargetSchedule)
	err = core.UnmarshalPrimitive(m, "unit", &obj.Unit)
	if err != nil {
		err = core.SDKErrorf(err, "", "unit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "frequency", &obj.Frequency)
	if err != nil {
		err = core.SDKErrorf(err, "", "frequency-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TargetsConfiguration : Specifies the replication, archival and cloud spin targets of Protection Policy.
type TargetsConfiguration struct {
	ReplicationTargets []ReplicationTargetConfiguration `json:"replicationTargets,omitempty"`

	ArchivalTargets []ArchivalTargetConfiguration `json:"archivalTargets,omitempty"`

	CloudSpinTargets []CloudSpinTargetConfiguration `json:"cloudSpinTargets,omitempty"`

	OnpremDeployTargets []OnpremDeployTargetConfiguration `json:"onpremDeployTargets,omitempty"`

	RpaasTargets []RpaasTargetConfiguration `json:"rpaasTargets,omitempty"`
}

// UnmarshalTargetsConfiguration unmarshals an instance of TargetsConfiguration from the specified map of raw messages.
func UnmarshalTargetsConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TargetsConfiguration)
	err = core.UnmarshalModel(m, "replicationTargets", &obj.ReplicationTargets, UnmarshalReplicationTargetConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationTargets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalTargets", &obj.ArchivalTargets, UnmarshalArchivalTargetConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "cloudSpinTargets", &obj.CloudSpinTargets, UnmarshalCloudSpinTargetConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudSpinTargets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "onpremDeployTargets", &obj.OnpremDeployTargets, UnmarshalOnpremDeployTargetConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "onpremDeployTargets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "rpaasTargets", &obj.RpaasTargets, UnmarshalRpaasTargetConfiguration)
	if err != nil {
		err = core.SDKErrorf(err, "", "rpaasTargets-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TeamsFileItem : Specifies a M365 Teams channel file item.
type TeamsFileItem struct {
	// Specifies the Unix timestamp epoch in seconds at which this item is created.
	CreationTimeSecs *int64 `json:"creationTimeSecs,omitempty"`

	// Specifies the name of the drive location for this file.
	DriveName *string `json:"driveName,omitempty"`

	// Specifies the file type.
	FileType *string `json:"fileType,omitempty"`

	// Specifies the size in bytes for the indexed item.
	ItemSize *int64 `json:"itemSize,omitempty"`
}

// Constants associated with the TeamsFileItem.FileType property.
// Specifies the file type.
const (
	TeamsFileItem_FileType_Directory = "Directory"
	TeamsFileItem_FileType_File      = "File"
	TeamsFileItem_FileType_Symlink   = "Symlink"
)

// UnmarshalTeamsFileItem unmarshals an instance of TeamsFileItem from the specified map of raw messages.
func UnmarshalTeamsFileItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TeamsFileItem)
	err = core.UnmarshalPrimitive(m, "creationTimeSecs", &obj.CreationTimeSecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "creationTimeSecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "driveName", &obj.DriveName)
	if err != nil {
		err = core.SDKErrorf(err, "", "driveName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fileType", &obj.FileType)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "itemSize", &obj.ItemSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "itemSize-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TeamsItem : Specifies the indexed M365 Teams item.
type TeamsItem struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *TeamsItemSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies a M365 Teams channel item.
	ChannelItem *ChannelItem `json:"channelItem,omitempty"`

	// Specifies a M365 Teams channel file item.
	FileItem *TeamsFileItem `json:"fileItem,omitempty"`

	// Specifies the M365 Teams item type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the TeamsItem.Type property.
// Specifies the M365 Teams item type.
const (
	TeamsItem_Type_Channel      = "Channel"
	TeamsItem_Type_Chat         = "Chat"
	TeamsItem_Type_Conversation = "Conversation"
	TeamsItem_Type_File         = "File"
	TeamsItem_Type_Folder       = "Folder"
)

// UnmarshalTeamsItem unmarshals an instance of TeamsItem from the specified map of raw messages.
func UnmarshalTeamsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TeamsItem)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalTeamsItemSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "channelItem", &obj.ChannelItem, UnmarshalChannelItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "channelItem-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "fileItem", &obj.FileItem, UnmarshalTeamsFileItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "fileItem-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TeamsItemSourceInfo : Specifies the Source Object information.
type TeamsItemSourceInfo struct {
	// Specifies object id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies registered source id to which object belongs.
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies registered source name to which object belongs.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the environment of the object.
	Environment *string `json:"environment,omitempty"`

	// Specifies the hash identifier of the object.
	ObjectHash *string `json:"objectHash,omitempty"`

	// Specifies the type of the object.
	ObjectType *string `json:"objectType,omitempty"`

	// Specifies the logical size of object in bytes.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the uuid which is a unique identifier of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the global id which is a unique identifier of the object.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies the protection type of the object if any.
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the common parameters for Sharepoint site objects.
	SharepointSiteSummary *SharepointObjectParams `json:"sharepointSiteSummary,omitempty"`

	// Specifies the operating system type of the object.
	OsType *string `json:"osType,omitempty"`

	// Specifies child object details.
	ChildObjects []ObjectSummary `json:"childObjects,omitempty"`

	VCenterSummary *ObjectTypeVCenterParams `json:"vCenterSummary,omitempty"`

	WindowsClusterSummary *ObjectTypeWindowsClusterParams `json:"windowsClusterSummary,omitempty"`
}

// Constants associated with the TeamsItemSourceInfo.Environment property.
// Specifies the environment of the object.
const (
	TeamsItemSourceInfo_Environment_Kphysical = "kPhysical"
	TeamsItemSourceInfo_Environment_Ksql      = "kSQL"
)

// Constants associated with the TeamsItemSourceInfo.ProtectionType property.
// Specifies the protection type of the object if any.
const (
	TeamsItemSourceInfo_ProtectionType_Kagent                 = "kAgent"
	TeamsItemSourceInfo_ProtectionType_Kaurorasnapshotmanager = "kAuroraSnapshotManager"
	TeamsItemSourceInfo_ProtectionType_Kawsaurorapostgres     = "kAwsAuroraPostgres"
	TeamsItemSourceInfo_ProtectionType_Kawsrdspostgres        = "kAwsRDSPostgres"
	TeamsItemSourceInfo_ProtectionType_Kawsrdspostgresbackup  = "kAwsRDSPostgresBackup"
	TeamsItemSourceInfo_ProtectionType_Kawss3                 = "kAwsS3"
	TeamsItemSourceInfo_ProtectionType_Kazuresql              = "kAzureSQL"
	TeamsItemSourceInfo_ProtectionType_Kfile                  = "kFile"
	TeamsItemSourceInfo_ProtectionType_Knative                = "kNative"
	TeamsItemSourceInfo_ProtectionType_Krdssnapshotmanager    = "kRDSSnapshotManager"
	TeamsItemSourceInfo_ProtectionType_Ksnapshotmanager       = "kSnapshotManager"
	TeamsItemSourceInfo_ProtectionType_Kvolume                = "kVolume"
)

// Constants associated with the TeamsItemSourceInfo.OsType property.
// Specifies the operating system type of the object.
const (
	TeamsItemSourceInfo_OsType_Klinux   = "kLinux"
	TeamsItemSourceInfo_OsType_Kwindows = "kWindows"
)

// UnmarshalTeamsItemSourceInfo unmarshals an instance of TeamsItemSourceInfo from the specified map of raw messages.
func UnmarshalTeamsItemSourceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TeamsItemSourceInfo)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceId", &obj.SourceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceName", &obj.SourceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "environment", &obj.Environment)
	if err != nil {
		err = core.SDKErrorf(err, "", "environment-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectHash", &obj.ObjectHash)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectHash-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "logicalSizeBytes", &obj.LogicalSizeBytes)
	if err != nil {
		err = core.SDKErrorf(err, "", "logicalSizeBytes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "globalId", &obj.GlobalID)
	if err != nil {
		err = core.SDKErrorf(err, "", "globalId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionType", &obj.ProtectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sharepointSiteSummary", &obj.SharepointSiteSummary, UnmarshalSharepointObjectParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "sharepointSiteSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		err = core.SDKErrorf(err, "", "osType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "childObjects", &obj.ChildObjects, UnmarshalObjectSummary)
	if err != nil {
		err = core.SDKErrorf(err, "", "childObjects-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vCenterSummary", &obj.VCenterSummary, UnmarshalObjectTypeVCenterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "vCenterSummary-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "windowsClusterSummary", &obj.WindowsClusterSummary, UnmarshalObjectTypeWindowsClusterParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "windowsClusterSummary-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Tenant : Specifies a tenant object.
type Tenant struct {
	// Epoch time when tenant was created.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	CreatedAtTimeMsecs *int64 `json:"createdAtTimeMsecs,omitempty"`

	// Epoch time when tenant was last updated.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	DeletedAtTimeMsecs *int64 `json:"deletedAtTimeMsecs,omitempty"`

	// Description about the tenant.
	Description *string `json:"description,omitempty"`

	// Specifies the additional metadata for the tenant that is specifically set by the external vendors who are
	// responsible for managing tenants. This field will only applicable if tenant creation is happening for a specially
	// provisioned clusters for external vendors.
	ExternalVendorMetadata *ExternalVendorTenantMetadata `json:"externalVendorMetadata,omitempty"`

	// The tenant id.
	ID *string `json:"id,omitempty"`

	// Flag to indicate if tenant is managed on helios.
	IsManagedOnHelios *bool `json:"isManagedOnHelios,omitempty"`

	// Epoch time when tenant was last updated.
	// This parameter is read-only and is included only in the response. It should
	// not be included in any requests, as doing so will result in an error.
	LastUpdatedAtTimeMsecs *int64 `json:"lastUpdatedAtTimeMsecs,omitempty"`

	// Name of the Tenant.
	Name *string `json:"name,omitempty"`

	// Networking information about a Tenant on a Cluster.
	Network *TenantNetwork `json:"network,omitempty"`

	// Current Status of the Tenant.
	Status *string `json:"status,omitempty"`
}

// Constants associated with the Tenant.Status property.
// Current Status of the Tenant.
const (
	Tenant_Status_Active            = "Active"
	Tenant_Status_Deleted           = "Deleted"
	Tenant_Status_Inactive          = "Inactive"
	Tenant_Status_Markedfordeletion = "MarkedForDeletion"
)

// UnmarshalTenant unmarshals an instance of Tenant from the specified map of raw messages.
func UnmarshalTenant(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Tenant)
	err = core.UnmarshalPrimitive(m, "createdAtTimeMsecs", &obj.CreatedAtTimeMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "createdAtTimeMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "deletedAtTimeMsecs", &obj.DeletedAtTimeMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "deletedAtTimeMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		err = core.SDKErrorf(err, "", "description-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "externalVendorMetadata", &obj.ExternalVendorMetadata, UnmarshalExternalVendorTenantMetadata)
	if err != nil {
		err = core.SDKErrorf(err, "", "externalVendorMetadata-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isManagedOnHelios", &obj.IsManagedOnHelios)
	if err != nil {
		err = core.SDKErrorf(err, "", "isManagedOnHelios-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdatedAtTimeMsecs", &obj.LastUpdatedAtTimeMsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "lastUpdatedAtTimeMsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "network", &obj.Network, UnmarshalTenantNetwork)
	if err != nil {
		err = core.SDKErrorf(err, "", "network-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TenantNetwork : Networking information about a Tenant on a Cluster.
type TenantNetwork struct {
	// Whether connector (hybrid extender) is enabled.
	ConnectorEnabled *bool `json:"connectorEnabled" validate:"required"`

	// The hostname for Cohesity cluster as seen by tenants and as is routable from the tenant's network. Tenant's VLAN's
	// hostname, if available can be used instead but it is mandatory to provide this value if there's no VLAN hostname to
	// use. Also, when set, this field would take precedence over VLAN hostname.
	ClusterHostname *string `json:"clusterHostname,omitempty"`

	// Set of IPs as seen from the tenant's network for the Cohesity cluster. Only one from 'clusterHostname' and
	// 'clusterIps' is needed.
	ClusterIps []string `json:"clusterIps,omitempty"`
}

// UnmarshalTenantNetwork unmarshals an instance of TenantNetwork from the specified map of raw messages.
func UnmarshalTenantNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TenantNetwork)
	err = core.UnmarshalPrimitive(m, "connectorEnabled", &obj.ConnectorEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "connectorEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterHostname", &obj.ClusterHostname)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterHostname-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIps", &obj.ClusterIps)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIps-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ThrottlingConfig : Specifies the source side throttling configuration.
type ThrottlingConfig struct {
	// Specifies the Throttling Configuration Parameters.
	CpuThrottlingConfig *ThrottlingConfigurationParams `json:"cpuThrottlingConfig,omitempty"`

	// Specifies the Throttling Configuration Parameters.
	NetworkThrottlingConfig *ThrottlingConfigurationParams `json:"networkThrottlingConfig,omitempty"`
}

// UnmarshalThrottlingConfig unmarshals an instance of ThrottlingConfig from the specified map of raw messages.
func UnmarshalThrottlingConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ThrottlingConfig)
	err = core.UnmarshalModel(m, "cpuThrottlingConfig", &obj.CpuThrottlingConfig, UnmarshalThrottlingConfigurationParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "cpuThrottlingConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "networkThrottlingConfig", &obj.NetworkThrottlingConfig, UnmarshalThrottlingConfigurationParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "networkThrottlingConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ThrottlingConfigurationParams : Specifies the Throttling Configuration Parameters.
type ThrottlingConfigurationParams struct {
	// Fixed baseline threshold for throttling. This is mandatory for any other throttling type than kNoThrottling.
	FixedThreshold *int64 `json:"fixedThreshold,omitempty"`

	// Type of the throttling pattern. 'kNoThrottling' indicates that throttling is not in force. 'kBaseThrottling'
	// indicates indicates a constant base level throttling. 'kFixed' indicates a constant base level throttling.
	PatternType *string `json:"patternType,omitempty"`

	ThrottlingWindows []ThrottlingWindow `json:"throttlingWindows,omitempty"`
}

// Constants associated with the ThrottlingConfigurationParams.PatternType property.
// Type of the throttling pattern. 'kNoThrottling' indicates that throttling is not in force. 'kBaseThrottling'
// indicates indicates a constant base level throttling. 'kFixed' indicates a constant base level throttling.
const (
	ThrottlingConfigurationParams_PatternType_Kbasethrottling = "kBaseThrottling"
	ThrottlingConfigurationParams_PatternType_Kfixed          = "kFixed"
	ThrottlingConfigurationParams_PatternType_Knothrottling   = "kNoThrottling"
)

// UnmarshalThrottlingConfigurationParams unmarshals an instance of ThrottlingConfigurationParams from the specified map of raw messages.
func UnmarshalThrottlingConfigurationParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ThrottlingConfigurationParams)
	err = core.UnmarshalPrimitive(m, "fixedThreshold", &obj.FixedThreshold)
	if err != nil {
		err = core.SDKErrorf(err, "", "fixedThreshold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patternType", &obj.PatternType)
	if err != nil {
		err = core.SDKErrorf(err, "", "patternType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "throttlingWindows", &obj.ThrottlingWindows, UnmarshalThrottlingWindow)
	if err != nil {
		err = core.SDKErrorf(err, "", "throttlingWindows-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ThrottlingPolicy : Specifies the throttling policy for a registered Protection Source.
type ThrottlingPolicy struct {
	// Specifies whether datastore streams are configured for all datastores that are part of the registered entity. If set
	// to true, number of streams from Cohesity cluster to the registered entity will be limited to the value set for
	// maxConcurrentStreams. If not set or set to false, there is no max limit for the number of concurrent streams.
	EnforceMaxStreams *bool `json:"enforceMaxStreams,omitempty"`

	// Specifies whether no. of backups are configured for the registered entity. If set to true, number of backups made by
	// Cohesity cluster in the registered entity will be limited to the value set for RegisteredSourceMaxConcurrentBackups.
	// If not set or set to false, there is no max limit for the number of concurrent backups.
	EnforceRegisteredSourceMaxBackups *bool `json:"enforceRegisteredSourceMaxBackups,omitempty"`

	// Indicates whether read operations to the datastores, which are part of the registered Protection Source, are
	// throttled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Specifies latency thresholds that trigger throttling for all datastores found in the registered Protection Source or
	// specific to one datastore.
	LatencyThresholds *LatencyThresholds `json:"latencyThresholds,omitempty"`

	// Specifies the limit on the number of streams Cohesity cluster will make concurrently to the datastores of the
	// registered entity. This limit is enforced only when the flag enforceMaxStreams is set to true.
	MaxConcurrentStreams *float64 `json:"maxConcurrentStreams,omitempty"`

	// Specifies the NAS specific source throttling parameters during source registration or during backup of the source.
	NasSourceParams *NasSourceParams `json:"nasSourceParams,omitempty"`

	// Specifies the limit on the number of backups Cohesity cluster will make concurrently to the registered entity. This
	// limit is enforced only when the flag enforceRegisteredSourceMaxBackups is set to true.
	RegisteredSourceMaxConcurrentBackups *float64 `json:"registeredSourceMaxConcurrentBackups,omitempty"`

	// Specifies Storage Array Snapshot Configuration.
	StorageArraySnapshotConfig *StorageArraySnapshotConfig `json:"storageArraySnapshotConfig,omitempty"`
}

// UnmarshalThrottlingPolicy unmarshals an instance of ThrottlingPolicy from the specified map of raw messages.
func UnmarshalThrottlingPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ThrottlingPolicy)
	err = core.UnmarshalPrimitive(m, "enforceMaxStreams", &obj.EnforceMaxStreams)
	if err != nil {
		err = core.SDKErrorf(err, "", "enforceMaxStreams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "enforceRegisteredSourceMaxBackups", &obj.EnforceRegisteredSourceMaxBackups)
	if err != nil {
		err = core.SDKErrorf(err, "", "enforceRegisteredSourceMaxBackups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "isEnabled", &obj.IsEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "isEnabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "latencyThresholds", &obj.LatencyThresholds, UnmarshalLatencyThresholds)
	if err != nil {
		err = core.SDKErrorf(err, "", "latencyThresholds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "maxConcurrentStreams", &obj.MaxConcurrentStreams)
	if err != nil {
		err = core.SDKErrorf(err, "", "maxConcurrentStreams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "nasSourceParams", &obj.NasSourceParams, UnmarshalNasSourceParams)
	if err != nil {
		err = core.SDKErrorf(err, "", "nasSourceParams-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "registeredSourceMaxConcurrentBackups", &obj.RegisteredSourceMaxConcurrentBackups)
	if err != nil {
		err = core.SDKErrorf(err, "", "registeredSourceMaxConcurrentBackups-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "storageArraySnapshotConfig", &obj.StorageArraySnapshotConfig, UnmarshalStorageArraySnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageArraySnapshotConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ThrottlingPolicyOverrides : Specifies throttling policy override for a Datastore in a registered entity.
type ThrottlingPolicyOverrides struct {
	// Specifies the Protection Source id of the Datastore.
	DatastoreID *int64 `json:"datastoreId,omitempty"`

	// Specifies the display name of the Datastore.
	DatastoreName *string `json:"datastoreName,omitempty"`

	// Specifies the throttling policy for a registered Protection Source.
	ThrottlingPolicy *ThrottlingPolicy `json:"throttlingPolicy,omitempty"`
}

// UnmarshalThrottlingPolicyOverrides unmarshals an instance of ThrottlingPolicyOverrides from the specified map of raw messages.
func UnmarshalThrottlingPolicyOverrides(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ThrottlingPolicyOverrides)
	err = core.UnmarshalPrimitive(m, "datastoreId", &obj.DatastoreID)
	if err != nil {
		err = core.SDKErrorf(err, "", "datastoreId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "datastoreName", &obj.DatastoreName)
	if err != nil {
		err = core.SDKErrorf(err, "", "datastoreName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "throttlingPolicy", &obj.ThrottlingPolicy, UnmarshalThrottlingPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "throttlingPolicy-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ThrottlingWindow : Specifies the Throttling Window Parameters Definition.
type ThrottlingWindow struct {
	// Specifies the Day Time Window Parameters.
	DayTimeWindow *DayTimeWindow `json:"dayTimeWindow,omitempty"`

	// Throttling threshold applicable in the window.
	Threshold *int64 `json:"threshold,omitempty"`
}

// UnmarshalThrottlingWindow unmarshals an instance of ThrottlingWindow from the specified map of raw messages.
func UnmarshalThrottlingWindow(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ThrottlingWindow)
	err = core.UnmarshalModel(m, "dayTimeWindow", &obj.DayTimeWindow, UnmarshalDayTimeWindow)
	if err != nil {
		err = core.SDKErrorf(err, "", "dayTimeWindow-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "threshold", &obj.Threshold)
	if err != nil {
		err = core.SDKErrorf(err, "", "threshold-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TierLevelSettings : Specifies the settings tier levels configured with each archival target. The tier settings need to be applied in
// specific order and default tier should always be passed as first entry in tiers array. The following example
// illustrates how to configure tiering input for AWS tiering. Same type of input structure applied to other cloud
// platforms also. <br>If user wants to achieve following tiering for backup, <br>User Desired Tiering- <br><t>1.Archive
// Full back up for 12 Months <br><t>2.Tier Levels <br><t><t>[1,12] [ <br><t><t><t>s3 (1 to 2 months), (default tier)
// <br><t><t><t>s3 Intelligent tiering (3 to 6 months), <br><t><t><t>s3 One Zone (7 to 9 months) <br><t><t><t>Glacier
// (10 to 12 months)] <br><t>API Input <br><t><t>1.tiers-[ <br><t><t><t>{'tierType': 'S3','moveAfterUnit':'months',
// <br><t><t><t>'moveAfter':2 - move from s3 to s3Inte after 2 months}, <br><t><t><t>{'tierType':
// 'S3Inte','moveAfterUnit':'months', <br><t><t><t>'moveAfter':4 - move from S3Inte to Glacier after 4 months},
// <br><t><t><t>{'tierType': 'Glacier', 'moveAfterUnit':'months', <br><t><t><t>'moveAfter': 3 - move from Glacier to S3
// One Zone after 3 months }, <br><t><t><t>{'tierType': 'S3 One Zone', 'moveAfterUnit': nil, <br><t><t><t>'moveAfter':
// nil - For the last record, 'moveAfter' and 'moveAfterUnit' <br><t><t><t>will be ignored since there are no further
// tier for data movement } <br><t><t><t>}].
type TierLevelSettings struct {
	// Specifies aws tiers.
	AwsTiering *AWSTiers `json:"awsTiering,omitempty"`

	// Specifies Azure tiers.
	AzureTiering *AzureTiers `json:"azureTiering,omitempty"`

	// Specifies the cloud platform to enable tiering.
	CloudPlatform *string `json:"cloudPlatform,omitempty"`

	// Specifies Google tiers.
	GoogleTiering *GoogleTiers `json:"googleTiering,omitempty"`

	// Specifies Oracle tiers.
	OracleTiering *OracleTiers `json:"oracleTiering,omitempty"`
}

// Constants associated with the TierLevelSettings.CloudPlatform property.
// Specifies the cloud platform to enable tiering.
const (
	TierLevelSettings_CloudPlatform_Aws    = "AWS"
	TierLevelSettings_CloudPlatform_Azure  = "Azure"
	TierLevelSettings_CloudPlatform_Google = "Google"
	TierLevelSettings_CloudPlatform_Oracle = "Oracle"
)

// UnmarshalTierLevelSettings unmarshals an instance of TierLevelSettings from the specified map of raw messages.
func UnmarshalTierLevelSettings(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TierLevelSettings)
	err = core.UnmarshalModel(m, "awsTiering", &obj.AwsTiering, UnmarshalAWSTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "awsTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "azureTiering", &obj.AzureTiering, UnmarshalAzureTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "azureTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudPlatform", &obj.CloudPlatform)
	if err != nil {
		err = core.SDKErrorf(err, "", "cloudPlatform-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "googleTiering", &obj.GoogleTiering, UnmarshalGoogleTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "googleTiering-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "oracleTiering", &obj.OracleTiering, UnmarshalOracleTiers)
	if err != nil {
		err = core.SDKErrorf(err, "", "oracleTiering-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Time : Specifies the time in hours and minutes.
type Time struct {
	// Specifies the hour of this time.
	Hour *int64 `json:"hour,omitempty"`

	// Specifies the minute of this time.
	Minute *int64 `json:"minute,omitempty"`
}

// UnmarshalTime unmarshals an instance of Time from the specified map of raw messages.
func UnmarshalTime(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Time)
	err = core.UnmarshalPrimitive(m, "hour", &obj.Hour)
	if err != nil {
		err = core.SDKErrorf(err, "", "hour-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "minute", &obj.Minute)
	if err != nil {
		err = core.SDKErrorf(err, "", "minute-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TimeOfDay : Specifies the time of day. Used for scheduling purposes.
type TimeOfDay struct {
	// Specifies the hour of the day (0-23).
	Hour *int64 `json:"hour" validate:"required"`

	// Specifies the minute of the hour (0-59).
	Minute *int64 `json:"minute" validate:"required"`

	// Specifies the time zone of the user. If not specified, default value is assumed as America/Los_Angeles.
	TimeZone *string `json:"timeZone,omitempty"`
}

// NewTimeOfDay : Instantiate TimeOfDay (Generic Model Constructor)
func (*BackupRecoveryV1) NewTimeOfDay(hour int64, minute int64) (_model *TimeOfDay, err error) {
	_model = &TimeOfDay{
		Hour:   core.Int64Ptr(hour),
		Minute: core.Int64Ptr(minute),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalTimeOfDay unmarshals an instance of TimeOfDay from the specified map of raw messages.
func UnmarshalTimeOfDay(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TimeOfDay)
	err = core.UnmarshalPrimitive(m, "hour", &obj.Hour)
	if err != nil {
		err = core.SDKErrorf(err, "", "hour-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "minute", &obj.Minute)
	if err != nil {
		err = core.SDKErrorf(err, "", "minute-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "timeZone", &obj.TimeZone)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeZone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TimeRangeInfo : Information about a set of disjoint, possibly annotated time ranges.
type TimeRangeInfo struct {
	// Error (if any) associated with the time range.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// The set of time ranges, each of which may be tagged with its job. These ranges will be non-overlapping and sorted by
	// increasing start time.
	TimeRanges []RecoveryTimeRangeInfo `json:"timeRanges,omitempty"`

	// User message (if any) associated with the time range.
	UserMessage *string `json:"userMessage,omitempty"`
}

// UnmarshalTimeRangeInfo unmarshals an instance of TimeRangeInfo from the specified map of raw messages.
func UnmarshalTimeRangeInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TimeRangeInfo)
	err = core.UnmarshalPrimitive(m, "errorMessage", &obj.ErrorMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "errorMessage-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "timeRanges", &obj.TimeRanges, UnmarshalRecoveryTimeRangeInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "timeRanges-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "userMessage", &obj.UserMessage)
	if err != nil {
		err = core.SDKErrorf(err, "", "userMessage-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TimeRangeUsecs : Specifies a valid time range in micro seconds.
type TimeRangeUsecs struct {
	// Specifies the end time of this time range.
	EndTimeUsecs *int64 `json:"endTimeUsecs" validate:"required"`

	// Specifies the start time of this time range.
	StartTimeUsecs *int64 `json:"startTimeUsecs" validate:"required"`
}

// UnmarshalTimeRangeUsecs unmarshals an instance of TimeRangeUsecs from the specified map of raw messages.
func UnmarshalTimeRangeUsecs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TimeRangeUsecs)
	err = core.UnmarshalPrimitive(m, "endTimeUsecs", &obj.EndTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTimeUsecs-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "startTimeUsecs", &obj.StartTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTimeUsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TimeWindow : Specifies a a time range within a day.
type TimeWindow struct {
	// Specifies the week day.
	DayOfTheWeek *string `json:"dayOfTheWeek,omitempty"`

	// Specifies the time in hours and minutes.
	EndTime *Time `json:"endTime,omitempty"`

	// Specifies the time in hours and minutes.
	StartTime *Time `json:"startTime,omitempty"`
}

// Constants associated with the TimeWindow.DayOfTheWeek property.
// Specifies the week day.
const (
	TimeWindow_DayOfTheWeek_Friday    = "Friday"
	TimeWindow_DayOfTheWeek_Monday    = "Monday"
	TimeWindow_DayOfTheWeek_Saturday  = "Saturday"
	TimeWindow_DayOfTheWeek_Sunday    = "Sunday"
	TimeWindow_DayOfTheWeek_Thursday  = "Thursday"
	TimeWindow_DayOfTheWeek_Tuesday   = "Tuesday"
	TimeWindow_DayOfTheWeek_Wednesday = "Wednesday"
)

// UnmarshalTimeWindow unmarshals an instance of TimeWindow from the specified map of raw messages.
func UnmarshalTimeWindow(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TimeWindow)
	err = core.UnmarshalPrimitive(m, "dayOfTheWeek", &obj.DayOfTheWeek)
	if err != nil {
		err = core.SDKErrorf(err, "", "dayOfTheWeek-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "endTime", &obj.EndTime, UnmarshalTime)
	if err != nil {
		err = core.SDKErrorf(err, "", "endTime-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "startTime", &obj.StartTime, UnmarshalTime)
	if err != nil {
		err = core.SDKErrorf(err, "", "startTime-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UdaIndexedObject : Specifies a Universal Data Adapter indexed object.
type UdaIndexedObject struct {
	// Specifies tag applied to the object.
	Tags []TagInfo `json:"tags,omitempty"`

	// Specifies snapshot tags applied to the object.
	SnapshotTags []SnapshotTagInfo `json:"snapshotTags,omitempty"`

	// Specifies the name of the object.
	Name *string `json:"name,omitempty"`

	// Specifies the path of the object.
	Path *string `json:"path,omitempty"`

	// "Specifies the protection group id which contains this object.".
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the protection group name which contains this object.".
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies the protection policy id for this file.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies the protection policy name for this file.
	PolicyName *string `json:"policyName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object is present.".
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the Source Object information.
	SourceInfo *CommonIndexedObjectParamsSourceInfo `json:"sourceInfo,omitempty"`

	// Specifies the full name of the indexed object.
	FullName *string `json:"fullName,omitempty"`

	// Specifies the id of the indexed object.
	ID *string `json:"id,omitempty"`

	// Specifies the type of the indexed object.
	ObjectType *string `json:"objectType,omitempty"`
}

// UnmarshalUdaIndexedObject unmarshals an instance of UdaIndexedObject from the specified map of raw messages.
func UnmarshalUdaIndexedObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UdaIndexedObject)
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "tags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "snapshotTags", &obj.SnapshotTags, UnmarshalSnapshotTagInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "snapshotTags-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		err = core.SDKErrorf(err, "", "path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupId", &obj.ProtectionGroupID)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "protectionGroupName", &obj.ProtectionGroupName)
	if err != nil {
		err = core.SDKErrorf(err, "", "protectionGroupName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyId", &obj.PolicyID)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policyName", &obj.PolicyName)
	if err != nil {
		err = core.SDKErrorf(err, "", "policyName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "storageDomainId", &obj.StorageDomainID)
	if err != nil {
		err = core.SDKErrorf(err, "", "storageDomainId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sourceInfo", &obj.SourceInfo, UnmarshalCommonIndexedObjectParamsSourceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceInfo-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "fullName", &obj.FullName)
	if err != nil {
		err = core.SDKErrorf(err, "", "fullName-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "objectType", &obj.ObjectType)
	if err != nil {
		err = core.SDKErrorf(err, "", "objectType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UdaOnPremSearchParams : Parameters required to search Universal Data Adapter objects.
type UdaOnPremSearchParams struct {
	// Specifies the search string to search the Universal Data Adapter Objects.
	SearchString *string `json:"searchString" validate:"required"`

	// Specifies a list of source ids. Only files found in these sources will be returned.
	SourceIds []int64 `json:"sourceIds,omitempty"`
}

// NewUdaOnPremSearchParams : Instantiate UdaOnPremSearchParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewUdaOnPremSearchParams(searchString string) (_model *UdaOnPremSearchParams, err error) {
	_model = &UdaOnPremSearchParams{
		SearchString: core.StringPtr(searchString),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalUdaOnPremSearchParams unmarshals an instance of UdaOnPremSearchParams from the specified map of raw messages.
func UnmarshalUdaOnPremSearchParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UdaOnPremSearchParams)
	err = core.UnmarshalPrimitive(m, "searchString", &obj.SearchString)
	if err != nil {
		err = core.SDKErrorf(err, "", "searchString-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIds", &obj.SourceIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "sourceIds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UniqueGlobalID : Specifies an id for an object that is unique across Cohesity Clusters. The id is composite of all the ids listed
// below.
type UniqueGlobalID struct {
	// Specifies the Cohesity Cluster id where the object was created.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies an id for the Cohesity Cluster that is generated when a Cohesity Cluster is initially created.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies a unique id assigned to an object (such as a Job) by the Cohesity Cluster.
	ID *int64 `json:"id,omitempty"`
}

// UnmarshalUniqueGlobalID unmarshals an instance of UniqueGlobalID from the specified map of raw messages.
func UnmarshalUniqueGlobalID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UniqueGlobalID)
	err = core.UnmarshalPrimitive(m, "clusterId", &obj.ClusterID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterIncarnationId", &obj.ClusterIncarnationID)
	if err != nil {
		err = core.SDKErrorf(err, "", "clusterIncarnationId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateArchivalSnapshotConfig : Specifies the params to perform actions on archival snapshots taken by a Protection Group Run.
type UpdateArchivalSnapshotConfig struct {
	// Specifies the new configuration about adding Archival Snapshot to existing Protection Group Run.
	NewSnapshotConfig []RunArchivalConfig `json:"newSnapshotConfig,omitempty"`

	// Specifies the configuration about updating an existing Archival Snapshot Run.
	UpdateExistingSnapshotConfig []UpdateExistingArchivalSnapshotConfig `json:"updateExistingSnapshotConfig,omitempty"`
}

// UnmarshalUpdateArchivalSnapshotConfig unmarshals an instance of UpdateArchivalSnapshotConfig from the specified map of raw messages.
func UnmarshalUpdateArchivalSnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateArchivalSnapshotConfig)
	err = core.UnmarshalModel(m, "newSnapshotConfig", &obj.NewSnapshotConfig, UnmarshalRunArchivalConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "newSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "updateExistingSnapshotConfig", &obj.UpdateExistingSnapshotConfig, UnmarshalUpdateExistingArchivalSnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "updateExistingSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateExistingArchivalSnapshotConfig : Specifies the configuration about updating an existing Archival Snapshot Run.
type UpdateExistingArchivalSnapshotConfig struct {
	// Specifies the id of the archival target.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the name of the archival target.
	Name *string `json:"name,omitempty"`

	// Specifies the snapshot's archival target type from which recovery has been performed.
	ArchivalTargetType *string `json:"archivalTargetType" validate:"required"`

	// Specifies whether to retain the snapshot for legal purpose. If set to true, the snapshots cannot be deleted until
	// the retention period. Note that using this option may cause the Cluster to run out of space. If set to false
	// explicitly, the hold is removed, and the snapshots will expire as specified in the policy of the Protection Group.
	// If this field is not specified, there is no change to the hold of the run. This field can be set only by a User
	// having Data Security Role.
	EnableLegalHold *bool `json:"enableLegalHold,omitempty"`

	// Specifies whether to delete the snapshot. When this is set to true, all other params will be ignored.
	DeleteSnapshot *bool `json:"deleteSnapshot,omitempty"`

	// Specifies whether to retry the archival operation in case if earlier attempt failed. If not specified or set to
	// false, archival is not retried.
	Resync *bool `json:"resync,omitempty"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
	// Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time,
	// the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason.
	// <br>'Administrative' implies WORM retention is set for administrative purposes.
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies number of days to retain the snapshots. If positive, then this value is added to exisiting expiry time
	// thereby increasing  the retention period of the snapshot. Conversly, if this value is negative, then value is
	// subtracted to existing expiry time thereby decreasing the retention period of the snaphot. Here, by this operation
	// if expiry time goes below current time then snapshot is immediately deleted.
	DaysToKeep *int64 `json:"daysToKeep,omitempty"`
}

// Constants associated with the UpdateExistingArchivalSnapshotConfig.ArchivalTargetType property.
// Specifies the snapshot's archival target type from which recovery has been performed.
const (
	UpdateExistingArchivalSnapshotConfig_ArchivalTargetType_Cloud = "Cloud"
	UpdateExistingArchivalSnapshotConfig_ArchivalTargetType_Nas   = "Nas"
	UpdateExistingArchivalSnapshotConfig_ArchivalTargetType_Tape  = "Tape"
)

// Constants associated with the UpdateExistingArchivalSnapshotConfig.DataLock property.
// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
// Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time,
// the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason.
// <br>'Administrative' implies WORM retention is set for administrative purposes.
const (
	UpdateExistingArchivalSnapshotConfig_DataLock_Administrative = "Administrative"
	UpdateExistingArchivalSnapshotConfig_DataLock_Compliance     = "Compliance"
)

// NewUpdateExistingArchivalSnapshotConfig : Instantiate UpdateExistingArchivalSnapshotConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewUpdateExistingArchivalSnapshotConfig(id int64, archivalTargetType string) (_model *UpdateExistingArchivalSnapshotConfig, err error) {
	_model = &UpdateExistingArchivalSnapshotConfig{
		ID:                 core.Int64Ptr(id),
		ArchivalTargetType: core.StringPtr(archivalTargetType),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalUpdateExistingArchivalSnapshotConfig unmarshals an instance of UpdateExistingArchivalSnapshotConfig from the specified map of raw messages.
func UnmarshalUpdateExistingArchivalSnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateExistingArchivalSnapshotConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "archivalTargetType", &obj.ArchivalTargetType)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalTargetType-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "enableLegalHold", &obj.EnableLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "deleteSnapshot", &obj.DeleteSnapshot)
	if err != nil {
		err = core.SDKErrorf(err, "", "deleteSnapshot-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resync", &obj.Resync)
	if err != nil {
		err = core.SDKErrorf(err, "", "resync-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataLock", &obj.DataLock)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLock-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "daysToKeep", &obj.DaysToKeep)
	if err != nil {
		err = core.SDKErrorf(err, "", "daysToKeep-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateExistingReplicationSnapshotConfig : Specifies the configuration about updating an existing Replication Snapshot Run.
type UpdateExistingReplicationSnapshotConfig struct {
	// Specifies the cluster id of the replication cluster.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the cluster name of the replication cluster.
	Name *string `json:"name,omitempty"`

	// Specifies whether to retain the snapshot for legal purpose. If set to true, the snapshots cannot be deleted until
	// the retention period. Note that using this option may cause the Cluster to run out of space. If set to false
	// explicitly, the hold is removed, and the snapshots will expire as specified in the policy of the Protection Group.
	// If this field is not specified, there is no change to the hold of the run. This field can be set only by a User
	// having Data Security Role.
	EnableLegalHold *bool `json:"enableLegalHold,omitempty"`

	// Specifies whether to delete the snapshot. When this is set to true, all other params will be ignored.
	DeleteSnapshot *bool `json:"deleteSnapshot,omitempty"`

	// Specifies whether to retry the replication operation in case if earlier attempt failed. If not specified or set to
	// false, replication is not retried.
	Resync *bool `json:"resync,omitempty"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
	// Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time,
	// the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason.
	// <br>'Administrative' implies WORM retention is set for administrative purposes.
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies number of days to retain the snapshots. If positive, then this value is added to exisiting expiry time
	// thereby increasing  the retention period of the snapshot. Conversly, if this value is negative, then value is
	// subtracted to existing expiry time thereby decreasing the retention period of the snaphot. Here, by this operation
	// if expiry time goes below current time then snapshot is immediately deleted.
	DaysToKeep *int64 `json:"daysToKeep,omitempty"`
}

// Constants associated with the UpdateExistingReplicationSnapshotConfig.DataLock property.
// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
// Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time,
// the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason.
// <br>'Administrative' implies WORM retention is set for administrative purposes.
const (
	UpdateExistingReplicationSnapshotConfig_DataLock_Administrative = "Administrative"
	UpdateExistingReplicationSnapshotConfig_DataLock_Compliance     = "Compliance"
)

// NewUpdateExistingReplicationSnapshotConfig : Instantiate UpdateExistingReplicationSnapshotConfig (Generic Model Constructor)
func (*BackupRecoveryV1) NewUpdateExistingReplicationSnapshotConfig(id int64) (_model *UpdateExistingReplicationSnapshotConfig, err error) {
	_model = &UpdateExistingReplicationSnapshotConfig{
		ID: core.Int64Ptr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalUpdateExistingReplicationSnapshotConfig unmarshals an instance of UpdateExistingReplicationSnapshotConfig from the specified map of raw messages.
func UnmarshalUpdateExistingReplicationSnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateExistingReplicationSnapshotConfig)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "enableLegalHold", &obj.EnableLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "deleteSnapshot", &obj.DeleteSnapshot)
	if err != nil {
		err = core.SDKErrorf(err, "", "deleteSnapshot-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resync", &obj.Resync)
	if err != nil {
		err = core.SDKErrorf(err, "", "resync-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataLock", &obj.DataLock)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLock-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "daysToKeep", &obj.DaysToKeep)
	if err != nil {
		err = core.SDKErrorf(err, "", "daysToKeep-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateLocalSnapshotConfig : Specifies the params to perform actions on local snapshot taken by a Protection Group Run.
type UpdateLocalSnapshotConfig struct {
	// Specifies whether to retain the snapshot for legal purpose. If set to true, the snapshots cannot be deleted until
	// the retention period. Note that using this option may cause the Cluster to run out of space. If set to false
	// explicitly, the hold is removed, and the snapshots will expire as specified in the policy of the Protection Group.
	// If this field is not specified, there is no change to the hold of the run. This field can be set only by a User
	// having Data Security Role.
	EnableLegalHold *bool `json:"enableLegalHold,omitempty"`

	// Specifies whether to delete the snapshot. When this is set to true, all other params will be ignored.
	DeleteSnapshot *bool `json:"deleteSnapshot,omitempty"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
	// Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time,
	// the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason.
	// <br>'Administrative' implies WORM retention is set for administrative purposes.
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies number of days to retain the snapshots. If positive, then this value is added to exisiting expiry time
	// thereby increasing  the retention period of the snapshot. Conversly, if this value is negative, then value is
	// subtracted to existing expiry time thereby decreasing the retention period of the snaphot. Here, by this operation
	// if expiry time goes below current time then snapshot is immediately deleted.
	DaysToKeep *int64 `json:"daysToKeep,omitempty"`
}

// Constants associated with the UpdateLocalSnapshotConfig.DataLock property.
// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the
// Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time,
// the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason.
// <br>'Administrative' implies WORM retention is set for administrative purposes.
const (
	UpdateLocalSnapshotConfig_DataLock_Administrative = "Administrative"
	UpdateLocalSnapshotConfig_DataLock_Compliance     = "Compliance"
)

// UnmarshalUpdateLocalSnapshotConfig unmarshals an instance of UpdateLocalSnapshotConfig from the specified map of raw messages.
func UnmarshalUpdateLocalSnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateLocalSnapshotConfig)
	err = core.UnmarshalPrimitive(m, "enableLegalHold", &obj.EnableLegalHold)
	if err != nil {
		err = core.SDKErrorf(err, "", "enableLegalHold-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "deleteSnapshot", &obj.DeleteSnapshot)
	if err != nil {
		err = core.SDKErrorf(err, "", "deleteSnapshot-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "dataLock", &obj.DataLock)
	if err != nil {
		err = core.SDKErrorf(err, "", "dataLock-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "daysToKeep", &obj.DaysToKeep)
	if err != nil {
		err = core.SDKErrorf(err, "", "daysToKeep-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateProtectionGroupOptions : The UpdateProtectionGroup options.
type UpdateProtectionGroupOptions struct {
	// Specifies the id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the name of the Protection Group.
	Name *string `json:"name" validate:"required"`

	// Specifies the unique id of the Protection Policy associated with the Protection Group. The Policy provides retry
	// settings Protection Schedules, Priority, SLA, etc.
	PolicyID *string `json:"policyId" validate:"required"`

	// Specifies the environment type of the Protection Group.
	Environment *string `json:"environment" validate:"required"`

	// Specifies the priority of the Protection Group.
	Priority *string `json:"priority,omitempty"`

	// Specifies a description of the Protection Group.
	Description *string `json:"description,omitempty"`

	// Specifies the time of day. Used for scheduling purposes.
	StartTime *TimeOfDay `json:"startTime,omitempty"`

	// Specifies the end time in micro seconds for this Protection Group. If this is not specified, the Protection Group
	// won't be ended.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the last time this protection group was updated. If this is passed into a PUT request, then the backend
	// will validate that the timestamp passed in matches the time that the protection group was actually last modified. If
	// the two timestamps do not match, then the request will be rejected with a stale error.
	LastModifiedTimestampUsecs *int64 `json:"lastModifiedTimestampUsecs,omitempty"`

	// Specifies a policy for alerting users of the status of a Protection Group.
	AlertPolicy *ProtectionGroupAlertingPolicy `json:"alertPolicy,omitempty"`

	// Specifies the SLA parameters for this Protection Group.
	Sla []SlaRule `json:"sla,omitempty"`

	// Specifies whether the Protection Group will be written to HDD or SSD.
	QosPolicy *string `json:"qosPolicy,omitempty"`

	// Specifies whether currently executing jobs should abort if a blackout period specified by a policy starts. Available
	// only if the selected policy has at least one blackout period. Default value is false. This field should not be set
	// to true if 'pauseInBlackouts' is set to true.
	AbortInBlackouts *bool `json:"abortInBlackouts,omitempty"`

	// Specifies whether currently executing jobs should be paused if a blackout period specified by a policy starts.
	// Available only if the selected policy has at least one blackout period. Default value is false. This field should
	// not be set to true if 'abortInBlackouts' is sent as true.
	PauseInBlackouts *bool `json:"pauseInBlackouts,omitempty"`

	// Specifies if the the Protection Group is paused. New runs are not scheduled for the paused Protection Groups. Active
	// run if any is not impacted.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Specifies the advanced configuration for a protection job.
	AdvancedConfigs []KeyValuePair `json:"advancedConfigs,omitempty"`

	PhysicalParams *PhysicalProtectionGroupParams `json:"physicalParams,omitempty"`

	// Specifies the parameters specific to MSSQL Protection Group.
	MssqlParams *MSSQLProtectionGroupParams `json:"mssqlParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateProtectionGroupOptions.Environment property.
// Specifies the environment type of the Protection Group.
const (
	UpdateProtectionGroupOptions_Environment_Kphysical = "kPhysical"
	UpdateProtectionGroupOptions_Environment_Ksql      = "kSQL"
)

// Constants associated with the UpdateProtectionGroupOptions.Priority property.
// Specifies the priority of the Protection Group.
const (
	UpdateProtectionGroupOptions_Priority_Khigh   = "kHigh"
	UpdateProtectionGroupOptions_Priority_Klow    = "kLow"
	UpdateProtectionGroupOptions_Priority_Kmedium = "kMedium"
)

// Constants associated with the UpdateProtectionGroupOptions.QosPolicy property.
// Specifies whether the Protection Group will be written to HDD or SSD.
const (
	UpdateProtectionGroupOptions_QosPolicy_Kbackupall      = "kBackupAll"
	UpdateProtectionGroupOptions_QosPolicy_Kbackuphdd      = "kBackupHDD"
	UpdateProtectionGroupOptions_QosPolicy_Kbackupssd      = "kBackupSSD"
	UpdateProtectionGroupOptions_QosPolicy_Ktestanddevhigh = "kTestAndDevHigh"
)

// NewUpdateProtectionGroupOptions : Instantiate UpdateProtectionGroupOptions
func (*BackupRecoveryV1) NewUpdateProtectionGroupOptions(id string, xIBMTenantID string, name string, policyID string, environment string) *UpdateProtectionGroupOptions {
	return &UpdateProtectionGroupOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Name:         core.StringPtr(name),
		PolicyID:     core.StringPtr(policyID),
		Environment:  core.StringPtr(environment),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateProtectionGroupOptions) SetID(id string) *UpdateProtectionGroupOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *UpdateProtectionGroupOptions) SetXIBMTenantID(xIBMTenantID string) *UpdateProtectionGroupOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateProtectionGroupOptions) SetName(name string) *UpdateProtectionGroupOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPolicyID : Allow user to set PolicyID
func (_options *UpdateProtectionGroupOptions) SetPolicyID(policyID string) *UpdateProtectionGroupOptions {
	_options.PolicyID = core.StringPtr(policyID)
	return _options
}

// SetEnvironment : Allow user to set Environment
func (_options *UpdateProtectionGroupOptions) SetEnvironment(environment string) *UpdateProtectionGroupOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetPriority : Allow user to set Priority
func (_options *UpdateProtectionGroupOptions) SetPriority(priority string) *UpdateProtectionGroupOptions {
	_options.Priority = core.StringPtr(priority)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateProtectionGroupOptions) SetDescription(description string) *UpdateProtectionGroupOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetStartTime : Allow user to set StartTime
func (_options *UpdateProtectionGroupOptions) SetStartTime(startTime *TimeOfDay) *UpdateProtectionGroupOptions {
	_options.StartTime = startTime
	return _options
}

// SetEndTimeUsecs : Allow user to set EndTimeUsecs
func (_options *UpdateProtectionGroupOptions) SetEndTimeUsecs(endTimeUsecs int64) *UpdateProtectionGroupOptions {
	_options.EndTimeUsecs = core.Int64Ptr(endTimeUsecs)
	return _options
}

// SetLastModifiedTimestampUsecs : Allow user to set LastModifiedTimestampUsecs
func (_options *UpdateProtectionGroupOptions) SetLastModifiedTimestampUsecs(lastModifiedTimestampUsecs int64) *UpdateProtectionGroupOptions {
	_options.LastModifiedTimestampUsecs = core.Int64Ptr(lastModifiedTimestampUsecs)
	return _options
}

// SetAlertPolicy : Allow user to set AlertPolicy
func (_options *UpdateProtectionGroupOptions) SetAlertPolicy(alertPolicy *ProtectionGroupAlertingPolicy) *UpdateProtectionGroupOptions {
	_options.AlertPolicy = alertPolicy
	return _options
}

// SetSla : Allow user to set Sla
func (_options *UpdateProtectionGroupOptions) SetSla(sla []SlaRule) *UpdateProtectionGroupOptions {
	_options.Sla = sla
	return _options
}

// SetQosPolicy : Allow user to set QosPolicy
func (_options *UpdateProtectionGroupOptions) SetQosPolicy(qosPolicy string) *UpdateProtectionGroupOptions {
	_options.QosPolicy = core.StringPtr(qosPolicy)
	return _options
}

// SetAbortInBlackouts : Allow user to set AbortInBlackouts
func (_options *UpdateProtectionGroupOptions) SetAbortInBlackouts(abortInBlackouts bool) *UpdateProtectionGroupOptions {
	_options.AbortInBlackouts = core.BoolPtr(abortInBlackouts)
	return _options
}

// SetPauseInBlackouts : Allow user to set PauseInBlackouts
func (_options *UpdateProtectionGroupOptions) SetPauseInBlackouts(pauseInBlackouts bool) *UpdateProtectionGroupOptions {
	_options.PauseInBlackouts = core.BoolPtr(pauseInBlackouts)
	return _options
}

// SetIsPaused : Allow user to set IsPaused
func (_options *UpdateProtectionGroupOptions) SetIsPaused(isPaused bool) *UpdateProtectionGroupOptions {
	_options.IsPaused = core.BoolPtr(isPaused)
	return _options
}

// SetAdvancedConfigs : Allow user to set AdvancedConfigs
func (_options *UpdateProtectionGroupOptions) SetAdvancedConfigs(advancedConfigs []KeyValuePair) *UpdateProtectionGroupOptions {
	_options.AdvancedConfigs = advancedConfigs
	return _options
}

// SetPhysicalParams : Allow user to set PhysicalParams
func (_options *UpdateProtectionGroupOptions) SetPhysicalParams(physicalParams *PhysicalProtectionGroupParams) *UpdateProtectionGroupOptions {
	_options.PhysicalParams = physicalParams
	return _options
}

// SetMssqlParams : Allow user to set MssqlParams
func (_options *UpdateProtectionGroupOptions) SetMssqlParams(mssqlParams *MSSQLProtectionGroupParams) *UpdateProtectionGroupOptions {
	_options.MssqlParams = mssqlParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateProtectionGroupOptions) SetHeaders(param map[string]string) *UpdateProtectionGroupOptions {
	options.Headers = param
	return options
}

// UpdateProtectionGroupRunOptions : The UpdateProtectionGroupRun options.
type UpdateProtectionGroupRunOptions struct {
	// Specifies a unique id of the Protection Group.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	UpdateProtectionGroupRunParams []UpdateProtectionGroupRunParams `json:"updateProtectionGroupRunParams" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateProtectionGroupRunOptions : Instantiate UpdateProtectionGroupRunOptions
func (*BackupRecoveryV1) NewUpdateProtectionGroupRunOptions(id string, xIBMTenantID string, updateProtectionGroupRunParams []UpdateProtectionGroupRunParams) *UpdateProtectionGroupRunOptions {
	return &UpdateProtectionGroupRunOptions{
		ID:                             core.StringPtr(id),
		XIBMTenantID:                   core.StringPtr(xIBMTenantID),
		UpdateProtectionGroupRunParams: updateProtectionGroupRunParams,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateProtectionGroupRunOptions) SetID(id string) *UpdateProtectionGroupRunOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *UpdateProtectionGroupRunOptions) SetXIBMTenantID(xIBMTenantID string) *UpdateProtectionGroupRunOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetUpdateProtectionGroupRunParams : Allow user to set UpdateProtectionGroupRunParams
func (_options *UpdateProtectionGroupRunOptions) SetUpdateProtectionGroupRunParams(updateProtectionGroupRunParams []UpdateProtectionGroupRunParams) *UpdateProtectionGroupRunOptions {
	_options.UpdateProtectionGroupRunParams = updateProtectionGroupRunParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateProtectionGroupRunOptions) SetHeaders(param map[string]string) *UpdateProtectionGroupRunOptions {
	options.Headers = param
	return options
}

// UpdateProtectionGroupRunParams : Specifies the params to update a Protection Group Run.
type UpdateProtectionGroupRunParams struct {
	// Specifies a unique Protection Group Run id.
	RunID *string `json:"runId" validate:"required"`

	// Specifies the params to perform actions on local snapshot taken by a Protection Group Run.
	LocalSnapshotConfig *UpdateLocalSnapshotConfig `json:"localSnapshotConfig,omitempty"`

	// Specifies the params to perform actions on replication snapshots taken by a Protection Group Run.
	ReplicationSnapshotConfig *UpdateReplicationSnapshotConfig `json:"replicationSnapshotConfig,omitempty"`

	// Specifies the params to perform actions on archival snapshots taken by a Protection Group Run.
	ArchivalSnapshotConfig *UpdateArchivalSnapshotConfig `json:"archivalSnapshotConfig,omitempty"`
}

// NewUpdateProtectionGroupRunParams : Instantiate UpdateProtectionGroupRunParams (Generic Model Constructor)
func (*BackupRecoveryV1) NewUpdateProtectionGroupRunParams(runID string) (_model *UpdateProtectionGroupRunParams, err error) {
	_model = &UpdateProtectionGroupRunParams{
		RunID: core.StringPtr(runID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalUpdateProtectionGroupRunParams unmarshals an instance of UpdateProtectionGroupRunParams from the specified map of raw messages.
func UnmarshalUpdateProtectionGroupRunParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateProtectionGroupRunParams)
	err = core.UnmarshalPrimitive(m, "runId", &obj.RunID)
	if err != nil {
		err = core.SDKErrorf(err, "", "runId-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "localSnapshotConfig", &obj.LocalSnapshotConfig, UnmarshalUpdateLocalSnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "localSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "replicationSnapshotConfig", &obj.ReplicationSnapshotConfig, UnmarshalUpdateReplicationSnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "replicationSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "archivalSnapshotConfig", &obj.ArchivalSnapshotConfig, UnmarshalUpdateArchivalSnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "archivalSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateProtectionGroupRunResponse : Specifies the response of update Protection Group Runs request.
type UpdateProtectionGroupRunResponse struct {
	// Specifies a list of ids of Protection Group Runs that are successfully updated.
	SuccessfulRunIds []string `json:"successfulRunIds,omitempty"`

	// Specifies a list of ids of Protection Group Runs that failed to update along with error details.
	FailedRuns []FailedRunDetails `json:"failedRuns,omitempty"`
}

// UnmarshalUpdateProtectionGroupRunResponse unmarshals an instance of UpdateProtectionGroupRunResponse from the specified map of raw messages.
func UnmarshalUpdateProtectionGroupRunResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateProtectionGroupRunResponse)
	err = core.UnmarshalPrimitive(m, "successfulRunIds", &obj.SuccessfulRunIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "successfulRunIds-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "failedRuns", &obj.FailedRuns, UnmarshalFailedRunDetails)
	if err != nil {
		err = core.SDKErrorf(err, "", "failedRuns-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateProtectionPolicyOptions : The UpdateProtectionPolicy options.
type UpdateProtectionPolicyOptions struct {
	// Specifies a unique id of the Protection Policy to update.
	ID *string `json:"id" validate:"required,ne="`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the name of the Protection Policy.
	Name *string `json:"name" validate:"required"`

	// Specifies the backup schedule and retentions of a Protection Policy.
	BackupPolicy *BackupPolicy `json:"backupPolicy" validate:"required"`

	// Specifies the description of the Protection Policy.
	Description *string `json:"description,omitempty"`

	// List of Blackout Windows. If specified, this field defines blackout periods when new Group Runs are not started. If
	// a Group Run has been scheduled but not yet executed and the blackout period starts, the behavior depends on the
	// policy field AbortInBlackoutPeriod.
	BlackoutWindow []BlackoutWindow `json:"blackoutWindow,omitempty"`

	// Specifies additional retention policies that should be applied to the backup snapshots. A backup snapshot will be
	// retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []ExtendedRetentionPolicy `json:"extendedRetention,omitempty"`

	// Specifies the replication, archival and cloud spin targets of Protection Policy.
	RemoteTargetPolicy *TargetsConfiguration `json:"remoteTargetPolicy,omitempty"`

	// Specifies the configuration for cascaded replications. Using cascaded replication, replication cluster(Rx) can
	// further replicate and archive the snapshot copies to further targets. Its recommended to create cascaded
	// configuration where protection group will be created.
	CascadedTargetsConfig []CascadedTargetConfiguration `json:"cascadedTargetsConfig,omitempty"`

	// Retry Options of a Protection Policy when a Protection Group run fails.
	RetryOptions *RetryOptions `json:"retryOptions,omitempty"`

	// This field is now deprecated. Please use the DataLockConfig in the backup retention.
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies the current policy verison. Policy version is incremented for optionally supporting new features and
	// differentialting across releases.
	Version *int64 `json:"version,omitempty"`

	// Specifies true if Calender Based Schedule is supported by client. Default value is assumed as false for this
	// feature.
	IsCBSEnabled *bool `json:"isCBSEnabled,omitempty"`

	// Specifies the last time this Policy was updated. If this is passed into a PUT request, then the backend will
	// validate that the timestamp passed in matches the time that the policy was actually last modified. If the two
	// timestamps do not match, then the request will be rejected with a stale error.
	LastModificationTimeUsecs *int64 `json:"lastModificationTimeUsecs,omitempty"`

	// Specifies the parent policy template id to which the policy is linked to.
	TemplateID *string `json:"templateId,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateProtectionPolicyOptions.DataLock property.
// This field is now deprecated. Please use the DataLockConfig in the backup retention.
const (
	UpdateProtectionPolicyOptions_DataLock_Administrative = "Administrative"
	UpdateProtectionPolicyOptions_DataLock_Compliance     = "Compliance"
)

// NewUpdateProtectionPolicyOptions : Instantiate UpdateProtectionPolicyOptions
func (*BackupRecoveryV1) NewUpdateProtectionPolicyOptions(id string, xIBMTenantID string, name string, backupPolicy *BackupPolicy) *UpdateProtectionPolicyOptions {
	return &UpdateProtectionPolicyOptions{
		ID:           core.StringPtr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Name:         core.StringPtr(name),
		BackupPolicy: backupPolicy,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateProtectionPolicyOptions) SetID(id string) *UpdateProtectionPolicyOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *UpdateProtectionPolicyOptions) SetXIBMTenantID(xIBMTenantID string) *UpdateProtectionPolicyOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateProtectionPolicyOptions) SetName(name string) *UpdateProtectionPolicyOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetBackupPolicy : Allow user to set BackupPolicy
func (_options *UpdateProtectionPolicyOptions) SetBackupPolicy(backupPolicy *BackupPolicy) *UpdateProtectionPolicyOptions {
	_options.BackupPolicy = backupPolicy
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateProtectionPolicyOptions) SetDescription(description string) *UpdateProtectionPolicyOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetBlackoutWindow : Allow user to set BlackoutWindow
func (_options *UpdateProtectionPolicyOptions) SetBlackoutWindow(blackoutWindow []BlackoutWindow) *UpdateProtectionPolicyOptions {
	_options.BlackoutWindow = blackoutWindow
	return _options
}

// SetExtendedRetention : Allow user to set ExtendedRetention
func (_options *UpdateProtectionPolicyOptions) SetExtendedRetention(extendedRetention []ExtendedRetentionPolicy) *UpdateProtectionPolicyOptions {
	_options.ExtendedRetention = extendedRetention
	return _options
}

// SetRemoteTargetPolicy : Allow user to set RemoteTargetPolicy
func (_options *UpdateProtectionPolicyOptions) SetRemoteTargetPolicy(remoteTargetPolicy *TargetsConfiguration) *UpdateProtectionPolicyOptions {
	_options.RemoteTargetPolicy = remoteTargetPolicy
	return _options
}

// SetCascadedTargetsConfig : Allow user to set CascadedTargetsConfig
func (_options *UpdateProtectionPolicyOptions) SetCascadedTargetsConfig(cascadedTargetsConfig []CascadedTargetConfiguration) *UpdateProtectionPolicyOptions {
	_options.CascadedTargetsConfig = cascadedTargetsConfig
	return _options
}

// SetRetryOptions : Allow user to set RetryOptions
func (_options *UpdateProtectionPolicyOptions) SetRetryOptions(retryOptions *RetryOptions) *UpdateProtectionPolicyOptions {
	_options.RetryOptions = retryOptions
	return _options
}

// SetDataLock : Allow user to set DataLock
func (_options *UpdateProtectionPolicyOptions) SetDataLock(dataLock string) *UpdateProtectionPolicyOptions {
	_options.DataLock = core.StringPtr(dataLock)
	return _options
}

// SetVersion : Allow user to set Version
func (_options *UpdateProtectionPolicyOptions) SetVersion(version int64) *UpdateProtectionPolicyOptions {
	_options.Version = core.Int64Ptr(version)
	return _options
}

// SetIsCBSEnabled : Allow user to set IsCBSEnabled
func (_options *UpdateProtectionPolicyOptions) SetIsCBSEnabled(isCBSEnabled bool) *UpdateProtectionPolicyOptions {
	_options.IsCBSEnabled = core.BoolPtr(isCBSEnabled)
	return _options
}

// SetLastModificationTimeUsecs : Allow user to set LastModificationTimeUsecs
func (_options *UpdateProtectionPolicyOptions) SetLastModificationTimeUsecs(lastModificationTimeUsecs int64) *UpdateProtectionPolicyOptions {
	_options.LastModificationTimeUsecs = core.Int64Ptr(lastModificationTimeUsecs)
	return _options
}

// SetTemplateID : Allow user to set TemplateID
func (_options *UpdateProtectionPolicyOptions) SetTemplateID(templateID string) *UpdateProtectionPolicyOptions {
	_options.TemplateID = core.StringPtr(templateID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateProtectionPolicyOptions) SetHeaders(param map[string]string) *UpdateProtectionPolicyOptions {
	options.Headers = param
	return options
}

// UpdateProtectionSourceRegistrationOptions : The UpdateProtectionSourceRegistration options.
type UpdateProtectionSourceRegistrationOptions struct {
	// Specifies the id of the Protection Source registration.
	ID *int64 `json:"id" validate:"required"`

	// Specifies the key to be used to encrypt the source credential. If includeSourceCredentials is set to true this key
	// must be specified.
	XIBMTenantID *string `json:"X-IBM-Tenant-Id" validate:"required"`

	// Specifies the environment type of the Protection Source.
	Environment *string `json:"environment" validate:"required"`

	// A user specified name for this source.
	Name *string `json:"name,omitempty"`

	// Specifies if credentials are encrypted by internal key.
	IsInternalEncrypted *bool `json:"isInternalEncrypted,omitempty"`

	// Specifies the key that user has encrypted the credential with.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// Specifies the id of the connection from where this source is reachable. This should only be set for a source being
	// registered by a tenant user.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// Specfies the list of connections for the source.
	Connections []ConnectionConfig `json:"connections,omitempty"`

	// Specifies the connector group id of connector groups.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Specifies the advanced configuration for a protection source.
	AdvancedConfigs []KeyValuePair `json:"advancedConfigs,omitempty"`

	// Specifies the id of the connection from where this source is reachable. This should only be set for a source being
	// registered by a tenant user. Also, this is the 'string' of connectionId. This property was added to accommodate for
	// ID values that exceed 2^53 - 1, which is the max value for which JS maintains precision.
	DataSourceConnectionID *string `json:"dataSourceConnectionId,omitempty"`

	// Specifies the end time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	LastModifiedTimestampUsecs *int64 `json:"lastModifiedTimestampUsecs,omitempty"`

	// Specifies parameters to register physical server.
	PhysicalParams *PhysicalSourceRegistrationParams `json:"physicalParams,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateProtectionSourceRegistrationOptions.Environment property.
// Specifies the environment type of the Protection Source.
const (
	UpdateProtectionSourceRegistrationOptions_Environment_Kphysical = "kPhysical"
	UpdateProtectionSourceRegistrationOptions_Environment_Ksql      = "kSQL"
)

// NewUpdateProtectionSourceRegistrationOptions : Instantiate UpdateProtectionSourceRegistrationOptions
func (*BackupRecoveryV1) NewUpdateProtectionSourceRegistrationOptions(id int64, xIBMTenantID string, environment string) *UpdateProtectionSourceRegistrationOptions {
	return &UpdateProtectionSourceRegistrationOptions{
		ID:           core.Int64Ptr(id),
		XIBMTenantID: core.StringPtr(xIBMTenantID),
		Environment:  core.StringPtr(environment),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateProtectionSourceRegistrationOptions) SetID(id int64) *UpdateProtectionSourceRegistrationOptions {
	_options.ID = core.Int64Ptr(id)
	return _options
}

// SetXIBMTenantID : Allow user to set XIBMTenantID
func (_options *UpdateProtectionSourceRegistrationOptions) SetXIBMTenantID(xIBMTenantID string) *UpdateProtectionSourceRegistrationOptions {
	_options.XIBMTenantID = core.StringPtr(xIBMTenantID)
	return _options
}

// SetEnvironment : Allow user to set Environment
func (_options *UpdateProtectionSourceRegistrationOptions) SetEnvironment(environment string) *UpdateProtectionSourceRegistrationOptions {
	_options.Environment = core.StringPtr(environment)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateProtectionSourceRegistrationOptions) SetName(name string) *UpdateProtectionSourceRegistrationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetIsInternalEncrypted : Allow user to set IsInternalEncrypted
func (_options *UpdateProtectionSourceRegistrationOptions) SetIsInternalEncrypted(isInternalEncrypted bool) *UpdateProtectionSourceRegistrationOptions {
	_options.IsInternalEncrypted = core.BoolPtr(isInternalEncrypted)
	return _options
}

// SetEncryptionKey : Allow user to set EncryptionKey
func (_options *UpdateProtectionSourceRegistrationOptions) SetEncryptionKey(encryptionKey string) *UpdateProtectionSourceRegistrationOptions {
	_options.EncryptionKey = core.StringPtr(encryptionKey)
	return _options
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *UpdateProtectionSourceRegistrationOptions) SetConnectionID(connectionID int64) *UpdateProtectionSourceRegistrationOptions {
	_options.ConnectionID = core.Int64Ptr(connectionID)
	return _options
}

// SetConnections : Allow user to set Connections
func (_options *UpdateProtectionSourceRegistrationOptions) SetConnections(connections []ConnectionConfig) *UpdateProtectionSourceRegistrationOptions {
	_options.Connections = connections
	return _options
}

// SetConnectorGroupID : Allow user to set ConnectorGroupID
func (_options *UpdateProtectionSourceRegistrationOptions) SetConnectorGroupID(connectorGroupID int64) *UpdateProtectionSourceRegistrationOptions {
	_options.ConnectorGroupID = core.Int64Ptr(connectorGroupID)
	return _options
}

// SetAdvancedConfigs : Allow user to set AdvancedConfigs
func (_options *UpdateProtectionSourceRegistrationOptions) SetAdvancedConfigs(advancedConfigs []KeyValuePair) *UpdateProtectionSourceRegistrationOptions {
	_options.AdvancedConfigs = advancedConfigs
	return _options
}

// SetDataSourceConnectionID : Allow user to set DataSourceConnectionID
func (_options *UpdateProtectionSourceRegistrationOptions) SetDataSourceConnectionID(dataSourceConnectionID string) *UpdateProtectionSourceRegistrationOptions {
	_options.DataSourceConnectionID = core.StringPtr(dataSourceConnectionID)
	return _options
}

// SetLastModifiedTimestampUsecs : Allow user to set LastModifiedTimestampUsecs
func (_options *UpdateProtectionSourceRegistrationOptions) SetLastModifiedTimestampUsecs(lastModifiedTimestampUsecs int64) *UpdateProtectionSourceRegistrationOptions {
	_options.LastModifiedTimestampUsecs = core.Int64Ptr(lastModifiedTimestampUsecs)
	return _options
}

// SetPhysicalParams : Allow user to set PhysicalParams
func (_options *UpdateProtectionSourceRegistrationOptions) SetPhysicalParams(physicalParams *PhysicalSourceRegistrationParams) *UpdateProtectionSourceRegistrationOptions {
	_options.PhysicalParams = physicalParams
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateProtectionSourceRegistrationOptions) SetHeaders(param map[string]string) *UpdateProtectionSourceRegistrationOptions {
	options.Headers = param
	return options
}

// UpdateReplicationSnapshotConfig : Specifies the params to perform actions on replication snapshots taken by a Protection Group Run.
type UpdateReplicationSnapshotConfig struct {
	// Specifies the new configuration about adding Replication Snapshot to existing Protection Group Run.
	NewSnapshotConfig []RunReplicationConfig `json:"newSnapshotConfig,omitempty"`

	// Specifies the configuration about updating an existing Replication Snapshot Run.
	UpdateExistingSnapshotConfig []UpdateExistingReplicationSnapshotConfig `json:"updateExistingSnapshotConfig,omitempty"`
}

// UnmarshalUpdateReplicationSnapshotConfig unmarshals an instance of UpdateReplicationSnapshotConfig from the specified map of raw messages.
func UnmarshalUpdateReplicationSnapshotConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateReplicationSnapshotConfig)
	err = core.UnmarshalModel(m, "newSnapshotConfig", &obj.NewSnapshotConfig, UnmarshalRunReplicationConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "newSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "updateExistingSnapshotConfig", &obj.UpdateExistingSnapshotConfig, UnmarshalUpdateExistingReplicationSnapshotConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "updateExistingSnapshotConfig-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// User : Specifies a user object.
type User struct {
	// Specifies the name of the user.
	Name *string `json:"name,omitempty"`

	// Specifies the sid of the user.
	Sid *string `json:"sid,omitempty"`

	// Specifies the domain of the user.
	Domain *string `json:"domain,omitempty"`
}

// UnmarshalUser unmarshals an instance of User from the specified map of raw messages.
func UnmarshalUser(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(User)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "sid", &obj.Sid)
	if err != nil {
		err = core.SDKErrorf(err, "", "sid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		err = core.SDKErrorf(err, "", "domain-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VssWriters : Specifies vss writer information about a Physical Protection Source.
type VssWriters struct {
	// If true, the writer will be excluded by default.
	IsWriterExcluded *bool `json:"isWriterExcluded,omitempty"`

	// Specifies the name of the writer.
	WriterName *bool `json:"writerName,omitempty"`
}

// UnmarshalVssWriters unmarshals an instance of VssWriters from the specified map of raw messages.
func UnmarshalVssWriters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VssWriters)
	err = core.UnmarshalPrimitive(m, "isWriterExcluded", &obj.IsWriterExcluded)
	if err != nil {
		err = core.SDKErrorf(err, "", "isWriterExcluded-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "writerName", &obj.WriterName)
	if err != nil {
		err = core.SDKErrorf(err, "", "writerName-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WeekSchedule : Specifies settings that define a schedule for a Protection Group runs to start on certain days of week.
type WeekSchedule struct {
	// Specifies a list of days of the week when to start Protection Group Runs. <br> Example: To run a Protection Group on
	// every Monday and Tuesday, set the schedule with following values: <br>  unit: 'Weeks' <br>  dayOfWeek:
	// ['Monday','Tuesday'].
	DayOfWeek []string `json:"dayOfWeek" validate:"required"`
}

// Constants associated with the WeekSchedule.DayOfWeek property.
const (
	WeekSchedule_DayOfWeek_Friday    = "Friday"
	WeekSchedule_DayOfWeek_Monday    = "Monday"
	WeekSchedule_DayOfWeek_Saturday  = "Saturday"
	WeekSchedule_DayOfWeek_Sunday    = "Sunday"
	WeekSchedule_DayOfWeek_Thursday  = "Thursday"
	WeekSchedule_DayOfWeek_Tuesday   = "Tuesday"
	WeekSchedule_DayOfWeek_Wednesday = "Wednesday"
)

// NewWeekSchedule : Instantiate WeekSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewWeekSchedule(dayOfWeek []string) (_model *WeekSchedule, err error) {
	_model = &WeekSchedule{
		DayOfWeek: dayOfWeek,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalWeekSchedule unmarshals an instance of WeekSchedule from the specified map of raw messages.
func UnmarshalWeekSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WeekSchedule)
	err = core.UnmarshalPrimitive(m, "dayOfWeek", &obj.DayOfWeek)
	if err != nil {
		err = core.SDKErrorf(err, "", "dayOfWeek-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkflowInterventionSpec : Specifies the intervention for each workflow type.
type WorkflowInterventionSpec struct {
	// Specifies the intervention type for ongoing tasks.
	Intervention *string `json:"intervention" validate:"required"`

	// Specifies the workflow type for which an intervention would be needed when maintenance mode begins.
	WorkflowType *string `json:"workflowType" validate:"required"`
}

// Constants associated with the WorkflowInterventionSpec.Intervention property.
// Specifies the intervention type for ongoing tasks.
const (
	WorkflowInterventionSpec_Intervention_Cancel         = "Cancel"
	WorkflowInterventionSpec_Intervention_Nointervention = "NoIntervention"
)

// Constants associated with the WorkflowInterventionSpec.WorkflowType property.
// Specifies the workflow type for which an intervention would be needed when maintenance mode begins.
const (
	WorkflowInterventionSpec_WorkflowType_Backuprun = "BackupRun"
)

// UnmarshalWorkflowInterventionSpec unmarshals an instance of WorkflowInterventionSpec from the specified map of raw messages.
func UnmarshalWorkflowInterventionSpec(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkflowInterventionSpec)
	err = core.UnmarshalPrimitive(m, "intervention", &obj.Intervention)
	if err != nil {
		err = core.SDKErrorf(err, "", "intervention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "workflowType", &obj.WorkflowType)
	if err != nil {
		err = core.SDKErrorf(err, "", "workflowType-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WormProperties : Specifies the WORM related properties for this archive.
type WormProperties struct {
	// Specifies whether this archive run is WORM compliant.
	IsArchiveWormCompliant *bool `json:"isArchiveWormCompliant,omitempty"`

	// Specifies reason of archive not being worm compliant.
	WormNonComplianceReason *string `json:"wormNonComplianceReason,omitempty"`

	// Specifies the time at which the WORM protection expires.
	WormExpiryTimeUsecs *int64 `json:"wormExpiryTimeUsecs,omitempty"`
}

// UnmarshalWormProperties unmarshals an instance of WormProperties from the specified map of raw messages.
func UnmarshalWormProperties(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WormProperties)
	err = core.UnmarshalPrimitive(m, "isArchiveWormCompliant", &obj.IsArchiveWormCompliant)
	if err != nil {
		err = core.SDKErrorf(err, "", "isArchiveWormCompliant-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "wormNonComplianceReason", &obj.WormNonComplianceReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "wormNonComplianceReason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "wormExpiryTimeUsecs", &obj.WormExpiryTimeUsecs)
	if err != nil {
		err = core.SDKErrorf(err, "", "wormExpiryTimeUsecs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// YearSchedule : Specifies settings that define a schedule for a Protection Group to run on specific year and specific day of that
// year.
type YearSchedule struct {
	// Specifies the day of the Year (such as 'First' or 'Last') in a Yearly Schedule. <br>This field is used to define the
	// day in the year to start the Protection Group Run. <br> Example: if 'dayOfYear' is set to 'First', a backup is
	// performed on the first day of every year. <br> Example: if 'dayOfYear' is set to 'Last', a backup is performed on
	// the last day of every year.
	DayOfYear *string `json:"dayOfYear" validate:"required"`
}

// Constants associated with the YearSchedule.DayOfYear property.
// Specifies the day of the Year (such as 'First' or 'Last') in a Yearly Schedule. <br>This field is used to define the
// day in the year to start the Protection Group Run. <br> Example: if 'dayOfYear' is set to 'First', a backup is
// performed on the first day of every year. <br> Example: if 'dayOfYear' is set to 'Last', a backup is performed on the
// last day of every year.
const (
	YearSchedule_DayOfYear_First = "First"
	YearSchedule_DayOfYear_Last  = "Last"
)

// NewYearSchedule : Instantiate YearSchedule (Generic Model Constructor)
func (*BackupRecoveryV1) NewYearSchedule(dayOfYear string) (_model *YearSchedule, err error) {
	_model = &YearSchedule{
		DayOfYear: core.StringPtr(dayOfYear),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalYearSchedule unmarshals an instance of YearSchedule from the specified map of raw messages.
func UnmarshalYearSchedule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(YearSchedule)
	err = core.UnmarshalPrimitive(m, "dayOfYear", &obj.DayOfYear)
	if err != nil {
		err = core.SDKErrorf(err, "", "dayOfYear-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
