/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.70.0-7df966bf-20230419-195904
 */

// Package eventnotificationsv1 : Operations and models for the EventNotificationsV1 service
package eventnotificationsv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"strconv"
	"time"

	common "github.com/IBM/event-notifications-go-admin-sdk/common"
	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
)

// EventNotificationsV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: 1.0
type EventNotificationsV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.event-notifications.cloud.ibm.com/event-notifications"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "event_notifications"

// EventNotificationsV1Options : Service options
type EventNotificationsV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewEventNotificationsV1UsingExternalConfig : constructs an instance of EventNotificationsV1 with passed in options and external configuration.
func NewEventNotificationsV1UsingExternalConfig(options *EventNotificationsV1Options) (eventNotifications *EventNotificationsV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	eventNotifications, err = NewEventNotificationsV1(options)
	if err != nil {
		return
	}

	err = eventNotifications.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = eventNotifications.Service.SetServiceURL(options.URL)
	}
	return
}

// NewEventNotificationsV1 : constructs an instance of EventNotificationsV1 with passed in options.
func NewEventNotificationsV1(options *EventNotificationsV1Options) (service *EventNotificationsV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &EventNotificationsV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "eventNotifications" suitable for processing requests.
func (eventNotifications *EventNotificationsV1) Clone() *EventNotificationsV1 {
	if core.IsNil(eventNotifications) {
		return nil
	}
	clone := *eventNotifications
	clone.Service = eventNotifications.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (eventNotifications *EventNotificationsV1) SetServiceURL(url string) error {
	return eventNotifications.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (eventNotifications *EventNotificationsV1) GetServiceURL() string {
	return eventNotifications.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (eventNotifications *EventNotificationsV1) SetDefaultHeaders(headers http.Header) {
	eventNotifications.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) SetEnableGzipCompression(enableGzip bool) {
	eventNotifications.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) GetEnableGzipCompression() bool {
	return eventNotifications.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (eventNotifications *EventNotificationsV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	eventNotifications.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (eventNotifications *EventNotificationsV1) DisableRetries() {
	eventNotifications.Service.DisableRetries()
}

// GetMetrics : Get metrics
// Get metrics.
func (eventNotifications *EventNotificationsV1) GetMetrics(getMetricsOptions *GetMetricsOptions) (result *Metrics, response *core.DetailedResponse, err error) {
	return eventNotifications.GetMetricsWithContext(context.Background(), getMetricsOptions)
}

// GetMetricsWithContext is an alternate form of the GetMetrics method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetMetricsWithContext(ctx context.Context, getMetricsOptions *GetMetricsOptions) (result *Metrics, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getMetricsOptions, "getMetricsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getMetricsOptions, "getMetricsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getMetricsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/metrics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getMetricsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetMetrics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("destination_type", fmt.Sprint(*getMetricsOptions.DestinationType))
	builder.AddQuery("gte", fmt.Sprint(*getMetricsOptions.Gte))
	builder.AddQuery("lte", fmt.Sprint(*getMetricsOptions.Lte))
	if getMetricsOptions.DestinationID != nil {
		builder.AddQuery("destination_id", fmt.Sprint(*getMetricsOptions.DestinationID))
	}
	if getMetricsOptions.SourceID != nil {
		builder.AddQuery("source_id", fmt.Sprint(*getMetricsOptions.SourceID))
	}
	if getMetricsOptions.EmailTo != nil {
		builder.AddQuery("email_to", fmt.Sprint(*getMetricsOptions.EmailTo))
	}
	if getMetricsOptions.NotificationID != nil {
		builder.AddQuery("notification_id", fmt.Sprint(*getMetricsOptions.NotificationID))
	}
	if getMetricsOptions.Subject != nil {
		builder.AddQuery("subject", fmt.Sprint(*getMetricsOptions.Subject))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMetrics)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// SendNotifications : Send a notification
// Send Notifications body from the instance. For more information about Event Notifications payload, see
// [here](https://cloud.ibm.com/docs/event-notifications?topic=event-notifications-en-spec-payload).
func (eventNotifications *EventNotificationsV1) SendNotifications(sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.SendNotificationsWithContext(context.Background(), sendNotificationsOptions)
}

// SendNotificationsWithContext is an alternate form of the SendNotifications method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) SendNotificationsWithContext(ctx context.Context, sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(sendNotificationsOptions, "sendNotificationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(sendNotificationsOptions, "sendNotificationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *sendNotificationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/notifications`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range sendNotificationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "SendNotifications")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	if sendNotificationsOptions.Body != nil {
		_, err = builder.SetBodyContentJSON(sendNotificationsOptions.Body)
		if err != nil {
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNotificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSources : Create a new API Source
// Create a new API Source.
func (eventNotifications *EventNotificationsV1) CreateSources(createSourcesOptions *CreateSourcesOptions) (result *SourceResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSourcesWithContext(context.Background(), createSourcesOptions)
}

// CreateSourcesWithContext is an alternate form of the CreateSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSourcesWithContext(ctx context.Context, createSourcesOptions *CreateSourcesOptions) (result *SourceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSourcesOptions, "createSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSourcesOptions, "createSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSourcesOptions.Name != nil {
		body["name"] = createSourcesOptions.Name
	}
	if createSourcesOptions.Description != nil {
		body["description"] = createSourcesOptions.Description
	}
	if createSourcesOptions.Enabled != nil {
		body["enabled"] = createSourcesOptions.Enabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSources : List all Sources
// List all Sources.
func (eventNotifications *EventNotificationsV1) ListSources(listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSourcesWithContext(context.Background(), listSourcesOptions)
}

// ListSourcesWithContext is an alternate form of the ListSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSourcesWithContext(ctx context.Context, listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSourcesOptions, "listSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSourcesOptions, "listSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSourcesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSourcesOptions.Limit))
	}
	if listSourcesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSourcesOptions.Offset))
	}
	if listSourcesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSourcesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSource : Get a Source
// Get a Source.
func (eventNotifications *EventNotificationsV1) GetSource(getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSourceWithContext(context.Background(), getSourceOptions)
}

// GetSourceWithContext is an alternate form of the GetSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSourceWithContext(ctx context.Context, getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSourceOptions, "getSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSourceOptions, "getSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSourceOptions.InstanceID,
		"id":          *getSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSource : Delete a Source
// Delete a Source.
func (eventNotifications *EventNotificationsV1) DeleteSource(deleteSourceOptions *DeleteSourceOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSourceWithContext(context.Background(), deleteSourceOptions)
}

// DeleteSourceWithContext is an alternate form of the DeleteSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSourceWithContext(ctx context.Context, deleteSourceOptions *DeleteSourceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSourceOptions, "deleteSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSourceOptions, "deleteSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSourceOptions.InstanceID,
		"id":          *deleteSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSource : Update details of a Source
// Update details of a Source.
func (eventNotifications *EventNotificationsV1) UpdateSource(updateSourceOptions *UpdateSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSourceWithContext(context.Background(), updateSourceOptions)
}

// UpdateSourceWithContext is an alternate form of the UpdateSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSourceWithContext(ctx context.Context, updateSourceOptions *UpdateSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSourceOptions, "updateSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSourceOptions, "updateSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSourceOptions.InstanceID,
		"id":          *updateSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSourceOptions.Name != nil {
		body["name"] = updateSourceOptions.Name
	}
	if updateSourceOptions.Description != nil {
		body["description"] = updateSourceOptions.Description
	}
	if updateSourceOptions.Enabled != nil {
		body["enabled"] = updateSourceOptions.Enabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTopic : Create a new Topic
// Create a new Topic.
func (eventNotifications *EventNotificationsV1) CreateTopic(createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTopicWithContext(context.Background(), createTopicOptions)
}

// CreateTopicWithContext is an alternate form of the CreateTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTopicWithContext(ctx context.Context, createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTopicOptions, "createTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTopicOptions, "createTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTopicOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTopicOptions.Name != nil {
		body["name"] = createTopicOptions.Name
	}
	if createTopicOptions.Description != nil {
		body["description"] = createTopicOptions.Description
	}
	if createTopicOptions.Sources != nil {
		body["sources"] = createTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTopics : List all Topics
// List all Topics.
func (eventNotifications *EventNotificationsV1) ListTopics(listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTopicsWithContext(context.Background(), listTopicsOptions)
}

// ListTopicsWithContext is an alternate form of the ListTopics method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTopicsWithContext(ctx context.Context, listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTopicsOptions, "listTopicsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTopicsOptions, "listTopicsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTopicsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTopicsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTopics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTopicsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTopicsOptions.Limit))
	}
	if listTopicsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTopicsOptions.Offset))
	}
	if listTopicsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTopicsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTopic : Get details of a Topic
// Get details of a Topic.
func (eventNotifications *EventNotificationsV1) GetTopic(getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.GetTopicWithContext(context.Background(), getTopicOptions)
}

// GetTopicWithContext is an alternate form of the GetTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetTopicWithContext(ctx context.Context, getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTopicOptions, "getTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTopicOptions, "getTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getTopicOptions.InstanceID,
		"id":          *getTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getTopicOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*getTopicOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTopic : Update details of a Topic
// Update details of a Topic.
func (eventNotifications *EventNotificationsV1) ReplaceTopic(replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceTopicWithContext(context.Background(), replaceTopicOptions)
}

// ReplaceTopicWithContext is an alternate form of the ReplaceTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceTopicWithContext(ctx context.Context, replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTopicOptions, "replaceTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTopicOptions, "replaceTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceTopicOptions.InstanceID,
		"id":          *replaceTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceTopicOptions.Name != nil {
		body["name"] = replaceTopicOptions.Name
	}
	if replaceTopicOptions.Description != nil {
		body["description"] = replaceTopicOptions.Description
	}
	if replaceTopicOptions.Sources != nil {
		body["sources"] = replaceTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTopic : Delete a Topic
// Delete a Topic.
func (eventNotifications *EventNotificationsV1) DeleteTopic(deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTopicWithContext(context.Background(), deleteTopicOptions)
}

// DeleteTopicWithContext is an alternate form of the DeleteTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTopicWithContext(ctx context.Context, deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTopicOptions, "deleteTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTopicOptions, "deleteTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTopicOptions.InstanceID,
		"id":          *deleteTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateTemplate : Create a new Template
// Create a new Template.
func (eventNotifications *EventNotificationsV1) CreateTemplate(createTemplateOptions *CreateTemplateOptions) (result *TemplateResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTemplateWithContext(context.Background(), createTemplateOptions)
}

// CreateTemplateWithContext is an alternate form of the CreateTemplate method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTemplateWithContext(ctx context.Context, createTemplateOptions *CreateTemplateOptions) (result *TemplateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTemplateOptions, "createTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTemplateOptions, "createTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTemplateOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/templates`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTemplateOptions.Name != nil {
		body["name"] = createTemplateOptions.Name
	}
	if createTemplateOptions.Type != nil {
		body["type"] = createTemplateOptions.Type
	}
	if createTemplateOptions.Params != nil {
		body["params"] = createTemplateOptions.Params
	}
	if createTemplateOptions.Description != nil {
		body["description"] = createTemplateOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTemplateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTemplates : List all templates
// List all Templates.
func (eventNotifications *EventNotificationsV1) ListTemplates(listTemplatesOptions *ListTemplatesOptions) (result *TemplateList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTemplatesWithContext(context.Background(), listTemplatesOptions)
}

// ListTemplatesWithContext is an alternate form of the ListTemplates method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTemplatesWithContext(ctx context.Context, listTemplatesOptions *ListTemplatesOptions) (result *TemplateList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTemplatesOptions, "listTemplatesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTemplatesOptions, "listTemplatesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTemplatesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/templates`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTemplatesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTemplates")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTemplatesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTemplatesOptions.Limit))
	}
	if listTemplatesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTemplatesOptions.Offset))
	}
	if listTemplatesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTemplatesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTemplateList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTemplate : Get details of a Template
// Get details of a Template.
func (eventNotifications *EventNotificationsV1) GetTemplate(getTemplateOptions *GetTemplateOptions) (result *Template, response *core.DetailedResponse, err error) {
	return eventNotifications.GetTemplateWithContext(context.Background(), getTemplateOptions)
}

// GetTemplateWithContext is an alternate form of the GetTemplate method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetTemplateWithContext(ctx context.Context, getTemplateOptions *GetTemplateOptions) (result *Template, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTemplateOptions, "getTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTemplateOptions, "getTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getTemplateOptions.InstanceID,
		"id":          *getTemplateOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/templates/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTemplate)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTemplate : Update details of a Template
// Update details of a Template.
func (eventNotifications *EventNotificationsV1) ReplaceTemplate(replaceTemplateOptions *ReplaceTemplateOptions) (result *Template, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceTemplateWithContext(context.Background(), replaceTemplateOptions)
}

// ReplaceTemplateWithContext is an alternate form of the ReplaceTemplate method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceTemplateWithContext(ctx context.Context, replaceTemplateOptions *ReplaceTemplateOptions) (result *Template, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTemplateOptions, "replaceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTemplateOptions, "replaceTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceTemplateOptions.InstanceID,
		"id":          *replaceTemplateOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/templates/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceTemplateOptions.Name != nil {
		body["name"] = replaceTemplateOptions.Name
	}
	if replaceTemplateOptions.Description != nil {
		body["description"] = replaceTemplateOptions.Description
	}
	if replaceTemplateOptions.Type != nil {
		body["type"] = replaceTemplateOptions.Type
	}
	if replaceTemplateOptions.Params != nil {
		body["params"] = replaceTemplateOptions.Params
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTemplate)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTemplate : Delete a Template
// Delete a Template.
func (eventNotifications *EventNotificationsV1) DeleteTemplate(deleteTemplateOptions *DeleteTemplateOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTemplateWithContext(context.Background(), deleteTemplateOptions)
}

// DeleteTemplateWithContext is an alternate form of the DeleteTemplate method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTemplateWithContext(ctx context.Context, deleteTemplateOptions *DeleteTemplateOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTemplateOptions, "deleteTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTemplateOptions, "deleteTemplateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTemplateOptions.InstanceID,
		"id":          *deleteTemplateOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/templates/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateDestination : Create a new Destination
// Create a new Destination.
func (eventNotifications *EventNotificationsV1) CreateDestination(createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateDestinationWithContext(context.Background(), createDestinationOptions)
}

// CreateDestinationWithContext is an alternate form of the CreateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateDestinationWithContext(ctx context.Context, createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDestinationOptions, "createDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDestinationOptions, "createDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createDestinationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddFormData("name", "", "", fmt.Sprint(*createDestinationOptions.Name))
	builder.AddFormData("type", "", "", fmt.Sprint(*createDestinationOptions.Type))
	if createDestinationOptions.Description != nil {
		builder.AddFormData("description", "", "", fmt.Sprint(*createDestinationOptions.Description))
	}
	if createDestinationOptions.CollectFailedEvents != nil {
		builder.AddFormData("collect_failed_events", "", "", fmt.Sprint(*createDestinationOptions.CollectFailedEvents))
	}
	if createDestinationOptions.Config != nil {
		builder.AddFormData("config", "", "application/json", createDestinationOptions.Config)
	}
	if createDestinationOptions.Certificate != nil {
		builder.AddFormData("certificate", "",
			core.StringNilMapper(createDestinationOptions.CertificateContentType), createDestinationOptions.Certificate)
	}
	if createDestinationOptions.Icon16x16 != nil {
		builder.AddFormData("icon_16x16", "",
			core.StringNilMapper(createDestinationOptions.Icon16x16ContentType), createDestinationOptions.Icon16x16)
	}
	if createDestinationOptions.Icon16x162x != nil {
		builder.AddFormData("icon_16x16_2x", "",
			core.StringNilMapper(createDestinationOptions.Icon16x162xContentType), createDestinationOptions.Icon16x162x)
	}
	if createDestinationOptions.Icon32x32 != nil {
		builder.AddFormData("icon_32x32", "",
			core.StringNilMapper(createDestinationOptions.Icon32x32ContentType), createDestinationOptions.Icon32x32)
	}
	if createDestinationOptions.Icon32x322x != nil {
		builder.AddFormData("icon_32x32_2x", "",
			core.StringNilMapper(createDestinationOptions.Icon32x322xContentType), createDestinationOptions.Icon32x322x)
	}
	if createDestinationOptions.Icon128x128 != nil {
		builder.AddFormData("icon_128x128", "",
			core.StringNilMapper(createDestinationOptions.Icon128x128ContentType), createDestinationOptions.Icon128x128)
	}
	if createDestinationOptions.Icon128x1282x != nil {
		builder.AddFormData("icon_128x128_2x", "",
			core.StringNilMapper(createDestinationOptions.Icon128x1282xContentType), createDestinationOptions.Icon128x1282x)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDestinations : List all Destinations
// List all Destinations.
func (eventNotifications *EventNotificationsV1) ListDestinations(listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationsWithContext(context.Background(), listDestinationsOptions)
}

// ListDestinationsWithContext is an alternate form of the ListDestinations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationsWithContext(ctx context.Context, listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationsOptions, "listDestinationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationsOptions, "listDestinationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationsOptions.Limit))
	}
	if listDestinationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationsOptions.Offset))
	}
	if listDestinationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestination : Get details of a Destination
// Get details of a Destination.
func (eventNotifications *EventNotificationsV1) GetDestination(getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationWithContext(context.Background(), getDestinationOptions)
}

// GetDestinationWithContext is an alternate form of the GetDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationWithContext(ctx context.Context, getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationOptions, "getDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationOptions, "getDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationOptions.InstanceID,
		"id":          *getDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDestination : Update details of a Destination
// Update details of a Destination.
func (eventNotifications *EventNotificationsV1) UpdateDestination(updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateDestinationWithContext(context.Background(), updateDestinationOptions)
}

// UpdateDestinationWithContext is an alternate form of the UpdateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateDestinationWithContext(ctx context.Context, updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDestinationOptions, "updateDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDestinationOptions, "updateDestinationOptions")
	if err != nil {
		return
	}
	if (updateDestinationOptions.Name == nil) && (updateDestinationOptions.Description == nil) && (updateDestinationOptions.CollectFailedEvents == nil) && (updateDestinationOptions.Config == nil) && (updateDestinationOptions.Certificate == nil) && (updateDestinationOptions.Icon16x16 == nil) && (updateDestinationOptions.Icon16x162x == nil) && (updateDestinationOptions.Icon32x32 == nil) && (updateDestinationOptions.Icon32x322x == nil) && (updateDestinationOptions.Icon128x128 == nil) && (updateDestinationOptions.Icon128x1282x == nil) {
		err = fmt.Errorf("at least one of name, description, collectFailedEvents, config, certificate, icon16x16, icon16x162x, icon32x32, icon32x322x, icon128x128, or icon128x1282x must be supplied")
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateDestinationOptions.InstanceID,
		"id":          *updateDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if updateDestinationOptions.Name != nil {
		builder.AddFormData("name", "", "", fmt.Sprint(*updateDestinationOptions.Name))
	}
	if updateDestinationOptions.Description != nil {
		builder.AddFormData("description", "", "", fmt.Sprint(*updateDestinationOptions.Description))
	}
	if updateDestinationOptions.CollectFailedEvents != nil {
		builder.AddFormData("collect_failed_events", "", "", fmt.Sprint(*updateDestinationOptions.CollectFailedEvents))
	}
	if updateDestinationOptions.Config != nil {
		builder.AddFormData("config", "", "application/json", updateDestinationOptions.Config)
	}
	if updateDestinationOptions.Certificate != nil {
		builder.AddFormData("certificate", "",
			core.StringNilMapper(updateDestinationOptions.CertificateContentType), updateDestinationOptions.Certificate)
	}
	if updateDestinationOptions.Icon16x16 != nil {
		builder.AddFormData("icon_16x16", "",
			core.StringNilMapper(updateDestinationOptions.Icon16x16ContentType), updateDestinationOptions.Icon16x16)
	}
	if updateDestinationOptions.Icon16x162x != nil {
		builder.AddFormData("icon_16x16_2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon16x162xContentType), updateDestinationOptions.Icon16x162x)
	}
	if updateDestinationOptions.Icon32x32 != nil {
		builder.AddFormData("icon_32x32", "",
			core.StringNilMapper(updateDestinationOptions.Icon32x32ContentType), updateDestinationOptions.Icon32x32)
	}
	if updateDestinationOptions.Icon32x322x != nil {
		builder.AddFormData("icon_32x32_2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon32x322xContentType), updateDestinationOptions.Icon32x322x)
	}
	if updateDestinationOptions.Icon128x128 != nil {
		builder.AddFormData("icon_128x128", "",
			core.StringNilMapper(updateDestinationOptions.Icon128x128ContentType), updateDestinationOptions.Icon128x128)
	}
	if updateDestinationOptions.Icon128x1282x != nil {
		builder.AddFormData("icon_128x128_2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon128x1282xContentType), updateDestinationOptions.Icon128x1282x)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDestination : Delete a Destination
// Delete a Destination.
func (eventNotifications *EventNotificationsV1) DeleteDestination(deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteDestinationWithContext(context.Background(), deleteDestinationOptions)
}

// DeleteDestinationWithContext is an alternate form of the DeleteDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteDestinationWithContext(ctx context.Context, deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDestinationOptions, "deleteDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDestinationOptions, "deleteDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteDestinationOptions.InstanceID,
		"id":          *deleteDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// GetEnabledCountries : Get enabled country details of SMS destination
// Get enabled country details of SMS destination.
func (eventNotifications *EventNotificationsV1) GetEnabledCountries(getEnabledCountriesOptions *GetEnabledCountriesOptions) (result *EnabledCountriesResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.GetEnabledCountriesWithContext(context.Background(), getEnabledCountriesOptions)
}

// GetEnabledCountriesWithContext is an alternate form of the GetEnabledCountries method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetEnabledCountriesWithContext(ctx context.Context, getEnabledCountriesOptions *GetEnabledCountriesOptions) (result *EnabledCountriesResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getEnabledCountriesOptions, "getEnabledCountriesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getEnabledCountriesOptions, "getEnabledCountriesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getEnabledCountriesOptions.InstanceID,
		"id":          *getEnabledCountriesOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/enabled_countries`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getEnabledCountriesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetEnabledCountries")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEnabledCountriesResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// TestDestination : Test a Destination
// Test a Destination.
func (eventNotifications *EventNotificationsV1) TestDestination(testDestinationOptions *TestDestinationOptions) (result *TestDestinationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.TestDestinationWithContext(context.Background(), testDestinationOptions)
}

// TestDestinationWithContext is an alternate form of the TestDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) TestDestinationWithContext(ctx context.Context, testDestinationOptions *TestDestinationOptions) (result *TestDestinationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(testDestinationOptions, "testDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(testDestinationOptions, "testDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *testDestinationOptions.InstanceID,
		"id":          *testDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/test`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range testDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "TestDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTestDestinationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVerifyDestination : Verify SPF and DKIM records of custom domain
// Verify SPF and DKIM records of custom domain.
func (eventNotifications *EventNotificationsV1) UpdateVerifyDestination(updateVerifyDestinationOptions *UpdateVerifyDestinationOptions) (result *VerificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateVerifyDestinationWithContext(context.Background(), updateVerifyDestinationOptions)
}

// UpdateVerifyDestinationWithContext is an alternate form of the UpdateVerifyDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateVerifyDestinationWithContext(ctx context.Context, updateVerifyDestinationOptions *UpdateVerifyDestinationOptions) (result *VerificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVerifyDestinationOptions, "updateVerifyDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVerifyDestinationOptions, "updateVerifyDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateVerifyDestinationOptions.InstanceID,
		"id":          *updateVerifyDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/verify`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVerifyDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateVerifyDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("type", fmt.Sprint(*updateVerifyDestinationOptions.Type))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVerificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTagsSubscription : Create a new tag subscription
// Create a new tag subscription.
func (eventNotifications *EventNotificationsV1) CreateTagsSubscription(createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTagsSubscriptionWithContext(context.Background(), createTagsSubscriptionOptions)
}

// CreateTagsSubscriptionWithContext is an alternate form of the CreateTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTagsSubscriptionWithContext(ctx context.Context, createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTagsSubscriptionOptions, "createTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTagsSubscriptionOptions, "createTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTagsSubscriptionOptions.InstanceID,
		"id":          *createTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTagsSubscriptionOptions.DeviceID != nil {
		body["device_id"] = createTagsSubscriptionOptions.DeviceID
	}
	if createTagsSubscriptionOptions.TagName != nil {
		body["tag_name"] = createTagsSubscriptionOptions.TagName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationTagsSubscriptionResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTagsSubscription : List all tag subscriptions
// List all tag subscriptions.
func (eventNotifications *EventNotificationsV1) ListTagsSubscription(listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTagsSubscriptionWithContext(context.Background(), listTagsSubscriptionOptions)
}

// ListTagsSubscriptionWithContext is an alternate form of the ListTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionWithContext(ctx context.Context, listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTagsSubscriptionOptions, "listTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTagsSubscriptionOptions, "listTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTagsSubscriptionOptions.InstanceID,
		"id":          *listTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*listTagsSubscriptionOptions.DeviceID))
	}
	if listTagsSubscriptionOptions.UserID != nil {
		builder.AddQuery("user_id", fmt.Sprint(*listTagsSubscriptionOptions.UserID))
	}
	if listTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*listTagsSubscriptionOptions.TagName))
	}
	if listTagsSubscriptionOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTagsSubscriptionOptions.Limit))
	}
	if listTagsSubscriptionOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTagsSubscriptionOptions.Offset))
	}
	if listTagsSubscriptionOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTagsSubscriptionOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTagsSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTagsSubscription : Delete a tag subscription
// Delete a tag subscription.
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscription(deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTagsSubscriptionWithContext(context.Background(), deleteTagsSubscriptionOptions)
}

// DeleteTagsSubscriptionWithContext is an alternate form of the DeleteTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscriptionWithContext(ctx context.Context, deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTagsSubscriptionOptions.InstanceID,
		"id":          *deleteTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	if deleteTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*deleteTagsSubscriptionOptions.DeviceID))
	}
	if deleteTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*deleteTagsSubscriptionOptions.TagName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateSubscription : Create a new Subscription
// Create a new Subscription.
func (eventNotifications *EventNotificationsV1) CreateSubscription(createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSubscriptionWithContext(context.Background(), createSubscriptionOptions)
}

// CreateSubscriptionWithContext is an alternate form of the CreateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSubscriptionWithContext(ctx context.Context, createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubscriptionOptions, "createSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubscriptionOptions, "createSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSubscriptionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSubscriptionOptions.Name != nil {
		body["name"] = createSubscriptionOptions.Name
	}
	if createSubscriptionOptions.DestinationID != nil {
		body["destination_id"] = createSubscriptionOptions.DestinationID
	}
	if createSubscriptionOptions.TopicID != nil {
		body["topic_id"] = createSubscriptionOptions.TopicID
	}
	if createSubscriptionOptions.Description != nil {
		body["description"] = createSubscriptionOptions.Description
	}
	if createSubscriptionOptions.Attributes != nil {
		body["attributes"] = createSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubscriptions : List all Subscriptions
// List all Subscriptions.
func (eventNotifications *EventNotificationsV1) ListSubscriptions(listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSubscriptionsWithContext(context.Background(), listSubscriptionsOptions)
}

// ListSubscriptionsWithContext is an alternate form of the ListSubscriptions method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSubscriptionsWithContext(ctx context.Context, listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubscriptionsOptions, "listSubscriptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubscriptionsOptions, "listSubscriptionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSubscriptionsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubscriptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSubscriptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSubscriptionsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSubscriptionsOptions.Offset))
	}
	if listSubscriptionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubscriptionsOptions.Limit))
	}
	if listSubscriptionsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSubscriptionsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubscription : Get details of a Subscription
// Get details of a Subscription.
func (eventNotifications *EventNotificationsV1) GetSubscription(getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSubscriptionWithContext(context.Background(), getSubscriptionOptions)
}

// GetSubscriptionWithContext is an alternate form of the GetSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSubscriptionWithContext(ctx context.Context, getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubscriptionOptions, "getSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubscriptionOptions, "getSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSubscriptionOptions.InstanceID,
		"id":          *getSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubscription : Delete a Subscription
// Delete a Subscription.
func (eventNotifications *EventNotificationsV1) DeleteSubscription(deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSubscriptionWithContext(context.Background(), deleteSubscriptionOptions)
}

// DeleteSubscriptionWithContext is an alternate form of the DeleteSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSubscriptionWithContext(ctx context.Context, deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubscriptionOptions, "deleteSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubscriptionOptions, "deleteSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSubscriptionOptions.InstanceID,
		"id":          *deleteSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSubscription : Update details of a Subscription
// Update details of a Subscription.
func (eventNotifications *EventNotificationsV1) UpdateSubscription(updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSubscriptionWithContext(context.Background(), updateSubscriptionOptions)
}

// UpdateSubscriptionWithContext is an alternate form of the UpdateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSubscriptionWithContext(ctx context.Context, updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubscriptionOptions, "updateSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubscriptionOptions, "updateSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSubscriptionOptions.InstanceID,
		"id":          *updateSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSubscriptionOptions.Name != nil {
		body["name"] = updateSubscriptionOptions.Name
	}
	if updateSubscriptionOptions.Description != nil {
		body["description"] = updateSubscriptionOptions.Description
	}
	if updateSubscriptionOptions.Attributes != nil {
		body["attributes"] = updateSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateIntegration : Create an Integration
// Create an Integration.
func (eventNotifications *EventNotificationsV1) CreateIntegration(createIntegrationOptions *CreateIntegrationOptions) (result *IntegrationCreateResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateIntegrationWithContext(context.Background(), createIntegrationOptions)
}

// CreateIntegrationWithContext is an alternate form of the CreateIntegration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateIntegrationWithContext(ctx context.Context, createIntegrationOptions *CreateIntegrationOptions) (result *IntegrationCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIntegrationOptions, "createIntegrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIntegrationOptions, "createIntegrationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createIntegrationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIntegrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateIntegration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createIntegrationOptions.Type != nil {
		body["type"] = createIntegrationOptions.Type
	}
	if createIntegrationOptions.Metadata != nil {
		body["metadata"] = createIntegrationOptions.Metadata
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationCreateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListIntegrations : List all Integrations
// List of all KMS Integrations.
func (eventNotifications *EventNotificationsV1) ListIntegrations(listIntegrationsOptions *ListIntegrationsOptions) (result *IntegrationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListIntegrationsWithContext(context.Background(), listIntegrationsOptions)
}

// ListIntegrationsWithContext is an alternate form of the ListIntegrations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListIntegrationsWithContext(ctx context.Context, listIntegrationsOptions *ListIntegrationsOptions) (result *IntegrationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listIntegrationsOptions, "listIntegrationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listIntegrationsOptions, "listIntegrationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listIntegrationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIntegrationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListIntegrations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listIntegrationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listIntegrationsOptions.Offset))
	}
	if listIntegrationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIntegrationsOptions.Limit))
	}
	if listIntegrationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listIntegrationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetIntegration : Get a single Integration
// Get a single KMS Integration.
func (eventNotifications *EventNotificationsV1) GetIntegration(getIntegrationOptions *GetIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.GetIntegrationWithContext(context.Background(), getIntegrationOptions)
}

// GetIntegrationWithContext is an alternate form of the GetIntegration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetIntegrationWithContext(ctx context.Context, getIntegrationOptions *GetIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIntegrationOptions, "getIntegrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIntegrationOptions, "getIntegrationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getIntegrationOptions.InstanceID,
		"id":          *getIntegrationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIntegrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetIntegration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationGetResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceIntegration : Update an existing Integration
// Update an existing Integration.
func (eventNotifications *EventNotificationsV1) ReplaceIntegration(replaceIntegrationOptions *ReplaceIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceIntegrationWithContext(context.Background(), replaceIntegrationOptions)
}

// ReplaceIntegrationWithContext is an alternate form of the ReplaceIntegration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceIntegrationWithContext(ctx context.Context, replaceIntegrationOptions *ReplaceIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceIntegrationOptions, "replaceIntegrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceIntegrationOptions, "replaceIntegrationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceIntegrationOptions.InstanceID,
		"id":          *replaceIntegrationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceIntegrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceIntegration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceIntegrationOptions.Type != nil {
		body["type"] = replaceIntegrationOptions.Type
	}
	if replaceIntegrationOptions.Metadata != nil {
		body["metadata"] = replaceIntegrationOptions.Metadata
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationGetResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSMTPConfiguration : Create a new SMTP Configuration
// Create a new SMTP Configuration.
func (eventNotifications *EventNotificationsV1) CreateSMTPConfiguration(createSMTPConfigurationOptions *CreateSMTPConfigurationOptions) (result *SMTPCreateResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSMTPConfigurationWithContext(context.Background(), createSMTPConfigurationOptions)
}

// CreateSMTPConfigurationWithContext is an alternate form of the CreateSMTPConfiguration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSMTPConfigurationWithContext(ctx context.Context, createSMTPConfigurationOptions *CreateSMTPConfigurationOptions) (result *SMTPCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSMTPConfigurationOptions, "createSMTPConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSMTPConfigurationOptions, "createSMTPConfigurationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSMTPConfigurationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSMTPConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSMTPConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSMTPConfigurationOptions.Name != nil {
		body["name"] = createSMTPConfigurationOptions.Name
	}
	if createSMTPConfigurationOptions.Domain != nil {
		body["domain"] = createSMTPConfigurationOptions.Domain
	}
	if createSMTPConfigurationOptions.Description != nil {
		body["description"] = createSMTPConfigurationOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPCreateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSMTPConfigurations : List all SMTP Configurations
// List all SMTP Configurations.
func (eventNotifications *EventNotificationsV1) ListSMTPConfigurations(listSMTPConfigurationsOptions *ListSMTPConfigurationsOptions) (result *SMTPConfigurationsList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSMTPConfigurationsWithContext(context.Background(), listSMTPConfigurationsOptions)
}

// ListSMTPConfigurationsWithContext is an alternate form of the ListSMTPConfigurations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSMTPConfigurationsWithContext(ctx context.Context, listSMTPConfigurationsOptions *ListSMTPConfigurationsOptions) (result *SMTPConfigurationsList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSMTPConfigurationsOptions, "listSMTPConfigurationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSMTPConfigurationsOptions, "listSMTPConfigurationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSMTPConfigurationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSMTPConfigurationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSMTPConfigurations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSMTPConfigurationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSMTPConfigurationsOptions.Limit))
	}
	if listSMTPConfigurationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSMTPConfigurationsOptions.Offset))
	}
	if listSMTPConfigurationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSMTPConfigurationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPConfigurationsList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSMTPUser : Create a new SMTP User
// Create a new SMTP User.
func (eventNotifications *EventNotificationsV1) CreateSMTPUser(createSMTPUserOptions *CreateSMTPUserOptions) (result *SMTPUserResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSMTPUserWithContext(context.Background(), createSMTPUserOptions)
}

// CreateSMTPUserWithContext is an alternate form of the CreateSMTPUser method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSMTPUserWithContext(ctx context.Context, createSMTPUserOptions *CreateSMTPUserOptions) (result *SMTPUserResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSMTPUserOptions, "createSMTPUserOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSMTPUserOptions, "createSMTPUserOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSMTPUserOptions.InstanceID,
		"id":          *createSMTPUserOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/users`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSMTPUserOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSMTPUser")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSMTPUserOptions.Description != nil {
		body["description"] = createSMTPUserOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPUserResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSMTPUsers : List all SMTP users
// List all SMTP users.
func (eventNotifications *EventNotificationsV1) ListSMTPUsers(listSMTPUsersOptions *ListSMTPUsersOptions) (result *SMTPUsersList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSMTPUsersWithContext(context.Background(), listSMTPUsersOptions)
}

// ListSMTPUsersWithContext is an alternate form of the ListSMTPUsers method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSMTPUsersWithContext(ctx context.Context, listSMTPUsersOptions *ListSMTPUsersOptions) (result *SMTPUsersList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSMTPUsersOptions, "listSMTPUsersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSMTPUsersOptions, "listSMTPUsersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSMTPUsersOptions.InstanceID,
		"id":          *listSMTPUsersOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/users`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSMTPUsersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSMTPUsers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSMTPUsersOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSMTPUsersOptions.Limit))
	}
	if listSMTPUsersOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSMTPUsersOptions.Offset))
	}
	if listSMTPUsersOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSMTPUsersOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPUsersList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSMTPConfiguration : Get details of a SMTP Configuration
// Get details of a SMTP Configuration.
func (eventNotifications *EventNotificationsV1) GetSMTPConfiguration(getSMTPConfigurationOptions *GetSMTPConfigurationOptions) (result *SMTPConfiguration, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSMTPConfigurationWithContext(context.Background(), getSMTPConfigurationOptions)
}

// GetSMTPConfigurationWithContext is an alternate form of the GetSMTPConfiguration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSMTPConfigurationWithContext(ctx context.Context, getSMTPConfigurationOptions *GetSMTPConfigurationOptions) (result *SMTPConfiguration, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSMTPConfigurationOptions, "getSMTPConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSMTPConfigurationOptions, "getSMTPConfigurationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSMTPConfigurationOptions.InstanceID,
		"id":          *getSMTPConfigurationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSMTPConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSMTPConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPConfiguration)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSMTPConfiguration : Update details of SMTP Configuration
// Update details of SMTP Configuration.
func (eventNotifications *EventNotificationsV1) UpdateSMTPConfiguration(updateSMTPConfigurationOptions *UpdateSMTPConfigurationOptions) (result *SMTPConfiguration, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSMTPConfigurationWithContext(context.Background(), updateSMTPConfigurationOptions)
}

// UpdateSMTPConfigurationWithContext is an alternate form of the UpdateSMTPConfiguration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSMTPConfigurationWithContext(ctx context.Context, updateSMTPConfigurationOptions *UpdateSMTPConfigurationOptions) (result *SMTPConfiguration, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSMTPConfigurationOptions, "updateSMTPConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSMTPConfigurationOptions, "updateSMTPConfigurationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSMTPConfigurationOptions.InstanceID,
		"id":          *updateSMTPConfigurationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSMTPConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSMTPConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSMTPConfigurationOptions.Name != nil {
		body["name"] = updateSMTPConfigurationOptions.Name
	}
	if updateSMTPConfigurationOptions.Description != nil {
		body["description"] = updateSMTPConfigurationOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPConfiguration)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSMTPConfiguration : Delete a SMTP Configuration
// Delete a SMTP Configuration.
func (eventNotifications *EventNotificationsV1) DeleteSMTPConfiguration(deleteSMTPConfigurationOptions *DeleteSMTPConfigurationOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSMTPConfigurationWithContext(context.Background(), deleteSMTPConfigurationOptions)
}

// DeleteSMTPConfigurationWithContext is an alternate form of the DeleteSMTPConfiguration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSMTPConfigurationWithContext(ctx context.Context, deleteSMTPConfigurationOptions *DeleteSMTPConfigurationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSMTPConfigurationOptions, "deleteSMTPConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSMTPConfigurationOptions, "deleteSMTPConfigurationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSMTPConfigurationOptions.InstanceID,
		"id":          *deleteSMTPConfigurationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSMTPConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSMTPConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// GetSMTPUser : Get details of a SMTP User
// Get details of a SMTP User.
func (eventNotifications *EventNotificationsV1) GetSMTPUser(getSMTPUserOptions *GetSMTPUserOptions) (result *SMTPUser, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSMTPUserWithContext(context.Background(), getSMTPUserOptions)
}

// GetSMTPUserWithContext is an alternate form of the GetSMTPUser method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSMTPUserWithContext(ctx context.Context, getSMTPUserOptions *GetSMTPUserOptions) (result *SMTPUser, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSMTPUserOptions, "getSMTPUserOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSMTPUserOptions, "getSMTPUserOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSMTPUserOptions.InstanceID,
		"id":          *getSMTPUserOptions.ID,
		"user_id":     *getSMTPUserOptions.UserID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/users/{user_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSMTPUserOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSMTPUser")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPUser)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateSMTPUser : Update details of a SMTP User
// Update details of a SMTP User.
func (eventNotifications *EventNotificationsV1) UpdateSMTPUser(updateSMTPUserOptions *UpdateSMTPUserOptions) (result *SMTPUser, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSMTPUserWithContext(context.Background(), updateSMTPUserOptions)
}

// UpdateSMTPUserWithContext is an alternate form of the UpdateSMTPUser method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSMTPUserWithContext(ctx context.Context, updateSMTPUserOptions *UpdateSMTPUserOptions) (result *SMTPUser, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSMTPUserOptions, "updateSMTPUserOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSMTPUserOptions, "updateSMTPUserOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSMTPUserOptions.InstanceID,
		"id":          *updateSMTPUserOptions.ID,
		"user_id":     *updateSMTPUserOptions.UserID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/users/{user_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSMTPUserOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSMTPUser")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSMTPUserOptions.Description != nil {
		body["description"] = updateSMTPUserOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPUser)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSMTPUser : Delete a SMTP user
// Delete a SMTP user.
func (eventNotifications *EventNotificationsV1) DeleteSMTPUser(deleteSMTPUserOptions *DeleteSMTPUserOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSMTPUserWithContext(context.Background(), deleteSMTPUserOptions)
}

// DeleteSMTPUserWithContext is an alternate form of the DeleteSMTPUser method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSMTPUserWithContext(ctx context.Context, deleteSMTPUserOptions *DeleteSMTPUserOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSMTPUserOptions, "deleteSMTPUserOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSMTPUserOptions, "deleteSMTPUserOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSMTPUserOptions.InstanceID,
		"id":          *deleteSMTPUserOptions.ID,
		"user_id":     *deleteSMTPUserOptions.UserID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/users/{user_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSMTPUserOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSMTPUser")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// GetSMTPAllowedIps : Get details of SMTP configuration allowed IPs
// Get details of SMTP configuration allowed IPs.
func (eventNotifications *EventNotificationsV1) GetSMTPAllowedIps(getSMTPAllowedIpsOptions *GetSMTPAllowedIpsOptions) (result *SMTPAllowedIPs, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSMTPAllowedIpsWithContext(context.Background(), getSMTPAllowedIpsOptions)
}

// GetSMTPAllowedIpsWithContext is an alternate form of the GetSMTPAllowedIps method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSMTPAllowedIpsWithContext(ctx context.Context, getSMTPAllowedIpsOptions *GetSMTPAllowedIpsOptions) (result *SMTPAllowedIPs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSMTPAllowedIpsOptions, "getSMTPAllowedIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSMTPAllowedIpsOptions, "getSMTPAllowedIpsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSMTPAllowedIpsOptions.InstanceID,
		"id":          *getSMTPAllowedIpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/allowed_ips`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSMTPAllowedIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSMTPAllowedIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPAllowedIPs)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateVerifySMTP : Verify SMTP configuration domain
// Verify SMTP configuration domain.
func (eventNotifications *EventNotificationsV1) UpdateVerifySMTP(updateVerifySMTPOptions *UpdateVerifySMTPOptions) (result *SMTPVerificationUpdateResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateVerifySMTPWithContext(context.Background(), updateVerifySMTPOptions)
}

// UpdateVerifySMTPWithContext is an alternate form of the UpdateVerifySMTP method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateVerifySMTPWithContext(ctx context.Context, updateVerifySMTPOptions *UpdateVerifySMTPOptions) (result *SMTPVerificationUpdateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVerifySMTPOptions, "updateVerifySMTPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVerifySMTPOptions, "updateVerifySMTPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateVerifySMTPOptions.InstanceID,
		"id":          *updateVerifySMTPOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/smtp/config/{id}/verify`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVerifySMTPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateVerifySMTP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("type", fmt.Sprint(*updateVerifySMTPOptions.Type))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSMTPVerificationUpdateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// Buckets : Bucket object.
type Buckets struct {
	// Total count.
	DocCount *int64 `json:"doc_count,omitempty"`

	// Timestamp.
	KeyAsString *strfmt.DateTime `json:"key_as_string,omitempty"`
}

// UnmarshalBuckets unmarshals an instance of Buckets from the specified map of raw messages.
func UnmarshalBuckets(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Buckets)
	err = core.UnmarshalPrimitive(m, "doc_count", &obj.DocCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_as_string", &obj.KeyAsString)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ChannelCreateAttributes : Payload describing a Slack Direct Message chennel configuration.
type ChannelCreateAttributes struct {
	// channel id.
	ID *string `json:"id" validate:"required"`
}

// NewChannelCreateAttributes : Instantiate ChannelCreateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewChannelCreateAttributes(id string) (_model *ChannelCreateAttributes, err error) {
	_model = &ChannelCreateAttributes{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalChannelCreateAttributes unmarshals an instance of ChannelCreateAttributes from the specified map of raw messages.
func UnmarshalChannelCreateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ChannelCreateAttributes)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ChannelUpdateAttributes : Payload describing a Slack Direct Message chennel configuration.
type ChannelUpdateAttributes struct {
	// channel id.
	ID *string `json:"id" validate:"required"`

	// The channel operation type.
	Operation *string `json:"operation" validate:"required"`
}

// Constants associated with the ChannelUpdateAttributes.Operation property.
// The channel operation type.
const (
	ChannelUpdateAttributesOperationAddConst    = "add"
	ChannelUpdateAttributesOperationRemoveConst = "remove"
)

// NewChannelUpdateAttributes : Instantiate ChannelUpdateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewChannelUpdateAttributes(id string, operation string) (_model *ChannelUpdateAttributes, err error) {
	_model = &ChannelUpdateAttributes{
		ID:        core.StringPtr(id),
		Operation: core.StringPtr(operation),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalChannelUpdateAttributes unmarshals an instance of ChannelUpdateAttributes from the specified map of raw messages.
func UnmarshalChannelUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ChannelUpdateAttributes)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operation", &obj.Operation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateDestinationOptions : The CreateDestination options.
type CreateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Destination name.
	Name *string `json:"name" validate:"required"`

	// The type of Destination Webhook.
	Type *string `json:"type" validate:"required"`

	// The Destination description.
	Description *string `json:"description,omitempty"`

	// Whether to collect the failed event in Cloud Object Storage bucket.
	CollectFailedEvents *bool `json:"collect_failed_events,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Certificate for APNS.
	Certificate io.ReadCloser `json:"certificate,omitempty"`

	// The content type of certificate.
	CertificateContentType *string `json:"certificate_content_type,omitempty"`

	// Safari icon 16x16.
	Icon16x16 io.ReadCloser `json:"icon_16x16,omitempty"`

	// The content type of icon16x16.
	Icon16x16ContentType *string `json:"icon_16x16_content_type,omitempty"`

	// Safari icon 16x16@2x.
	Icon16x162x io.ReadCloser `json:"icon_16x16_2x,omitempty"`

	// The content type of icon16x162x.
	Icon16x162xContentType *string `json:"icon_16x16_2x_content_type,omitempty"`

	// Safari icon 32x32.
	Icon32x32 io.ReadCloser `json:"icon_32x32,omitempty"`

	// The content type of icon32x32.
	Icon32x32ContentType *string `json:"icon_32x32_content_type,omitempty"`

	// Safari icon 32x32@2x.
	Icon32x322x io.ReadCloser `json:"icon_32x32_2x,omitempty"`

	// The content type of icon32x322x.
	Icon32x322xContentType *string `json:"icon_32x32_2x_content_type,omitempty"`

	// Safari icon 128x128.
	Icon128x128 io.ReadCloser `json:"icon_128x128,omitempty"`

	// The content type of icon128x128.
	Icon128x128ContentType *string `json:"icon_128x128_content_type,omitempty"`

	// Safari icon 128x128@2x.
	Icon128x1282x io.ReadCloser `json:"icon_128x128_2x,omitempty"`

	// The content type of icon128x1282x.
	Icon128x1282xContentType *string `json:"icon_128x128_2x_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDestinationOptions.Type property.
// The type of Destination Webhook.
const (
	CreateDestinationOptionsTypeIbmceConst       = "ibmce"
	CreateDestinationOptionsTypeIbmcfConst       = "ibmcf"
	CreateDestinationOptionsTypeIbmcosConst      = "ibmcos"
	CreateDestinationOptionsTypeMsteamsConst     = "msteams"
	CreateDestinationOptionsTypePagerdutyConst   = "pagerduty"
	CreateDestinationOptionsTypePushAndroidConst = "push_android"
	CreateDestinationOptionsTypePushChromeConst  = "push_chrome"
	CreateDestinationOptionsTypePushFirefoxConst = "push_firefox"
	CreateDestinationOptionsTypePushHuaweiConst  = "push_huawei"
	CreateDestinationOptionsTypePushIosConst     = "push_ios"
	CreateDestinationOptionsTypePushSafariConst  = "push_safari"
	CreateDestinationOptionsTypeSMTPCustomConst  = "smtp_custom"
	CreateDestinationOptionsTypeServicenowConst  = "servicenow"
	CreateDestinationOptionsTypeSlackConst       = "slack"
	CreateDestinationOptionsTypeSmsCustomConst   = "sms_custom"
	CreateDestinationOptionsTypeWebhookConst     = "webhook"
)

// NewCreateDestinationOptions : Instantiate CreateDestinationOptions
func (*EventNotificationsV1) NewCreateDestinationOptions(instanceID string, name string, typeVar string) *CreateDestinationOptions {
	return &CreateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateDestinationOptions) SetInstanceID(instanceID string) *CreateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDestinationOptions) SetName(name string) *CreateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateDestinationOptions) SetType(typeVar string) *CreateDestinationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateDestinationOptions) SetDescription(description string) *CreateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetCollectFailedEvents : Allow user to set CollectFailedEvents
func (_options *CreateDestinationOptions) SetCollectFailedEvents(collectFailedEvents bool) *CreateDestinationOptions {
	_options.CollectFailedEvents = core.BoolPtr(collectFailedEvents)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *CreateDestinationOptions) SetConfig(config *DestinationConfig) *CreateDestinationOptions {
	_options.Config = config
	return _options
}

// SetCertificate : Allow user to set Certificate
func (_options *CreateDestinationOptions) SetCertificate(certificate io.ReadCloser) *CreateDestinationOptions {
	_options.Certificate = certificate
	return _options
}

// SetCertificateContentType : Allow user to set CertificateContentType
func (_options *CreateDestinationOptions) SetCertificateContentType(certificateContentType string) *CreateDestinationOptions {
	_options.CertificateContentType = core.StringPtr(certificateContentType)
	return _options
}

// SetIcon16x16 : Allow user to set Icon16x16
func (_options *CreateDestinationOptions) SetIcon16x16(icon16x16 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon16x16 = icon16x16
	return _options
}

// SetIcon16x16ContentType : Allow user to set Icon16x16ContentType
func (_options *CreateDestinationOptions) SetIcon16x16ContentType(icon16x16ContentType string) *CreateDestinationOptions {
	_options.Icon16x16ContentType = core.StringPtr(icon16x16ContentType)
	return _options
}

// SetIcon16x162x : Allow user to set Icon16x162x
func (_options *CreateDestinationOptions) SetIcon16x162x(icon16x162x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon16x162x = icon16x162x
	return _options
}

// SetIcon16x162xContentType : Allow user to set Icon16x162xContentType
func (_options *CreateDestinationOptions) SetIcon16x162xContentType(icon16x162xContentType string) *CreateDestinationOptions {
	_options.Icon16x162xContentType = core.StringPtr(icon16x162xContentType)
	return _options
}

// SetIcon32x32 : Allow user to set Icon32x32
func (_options *CreateDestinationOptions) SetIcon32x32(icon32x32 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon32x32 = icon32x32
	return _options
}

// SetIcon32x32ContentType : Allow user to set Icon32x32ContentType
func (_options *CreateDestinationOptions) SetIcon32x32ContentType(icon32x32ContentType string) *CreateDestinationOptions {
	_options.Icon32x32ContentType = core.StringPtr(icon32x32ContentType)
	return _options
}

// SetIcon32x322x : Allow user to set Icon32x322x
func (_options *CreateDestinationOptions) SetIcon32x322x(icon32x322x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon32x322x = icon32x322x
	return _options
}

// SetIcon32x322xContentType : Allow user to set Icon32x322xContentType
func (_options *CreateDestinationOptions) SetIcon32x322xContentType(icon32x322xContentType string) *CreateDestinationOptions {
	_options.Icon32x322xContentType = core.StringPtr(icon32x322xContentType)
	return _options
}

// SetIcon128x128 : Allow user to set Icon128x128
func (_options *CreateDestinationOptions) SetIcon128x128(icon128x128 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon128x128 = icon128x128
	return _options
}

// SetIcon128x128ContentType : Allow user to set Icon128x128ContentType
func (_options *CreateDestinationOptions) SetIcon128x128ContentType(icon128x128ContentType string) *CreateDestinationOptions {
	_options.Icon128x128ContentType = core.StringPtr(icon128x128ContentType)
	return _options
}

// SetIcon128x1282x : Allow user to set Icon128x1282x
func (_options *CreateDestinationOptions) SetIcon128x1282x(icon128x1282x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon128x1282x = icon128x1282x
	return _options
}

// SetIcon128x1282xContentType : Allow user to set Icon128x1282xContentType
func (_options *CreateDestinationOptions) SetIcon128x1282xContentType(icon128x1282xContentType string) *CreateDestinationOptions {
	_options.Icon128x1282xContentType = core.StringPtr(icon128x1282xContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDestinationOptions) SetHeaders(param map[string]string) *CreateDestinationOptions {
	options.Headers = param
	return options
}

// CreateIntegrationOptions : The CreateIntegration options.
type CreateIntegrationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The type of Integration.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationCreateMetadata `json:"metadata" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIntegrationOptions.Type property.
// The type of Integration.
const (
	CreateIntegrationOptionsTypeCollectFailedEventsConst = "collect_failed_events"
)

// NewCreateIntegrationOptions : Instantiate CreateIntegrationOptions
func (*EventNotificationsV1) NewCreateIntegrationOptions(instanceID string, typeVar string, metadata *IntegrationCreateMetadata) *CreateIntegrationOptions {
	return &CreateIntegrationOptions{
		InstanceID: core.StringPtr(instanceID),
		Type:       core.StringPtr(typeVar),
		Metadata:   metadata,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateIntegrationOptions) SetInstanceID(instanceID string) *CreateIntegrationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateIntegrationOptions) SetType(typeVar string) *CreateIntegrationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetMetadata : Allow user to set Metadata
func (_options *CreateIntegrationOptions) SetMetadata(metadata *IntegrationCreateMetadata) *CreateIntegrationOptions {
	_options.Metadata = metadata
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIntegrationOptions) SetHeaders(param map[string]string) *CreateIntegrationOptions {
	options.Headers = param
	return options
}

// CreateSMTPConfigurationOptions : The CreateSMTPConfiguration options.
type CreateSMTPConfigurationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The name of SMTP configuration.
	Name *string `json:"name" validate:"required"`

	// Domain Name.
	Domain *string `json:"domain" validate:"required"`

	// The description of SMTP configuration.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSMTPConfigurationOptions : Instantiate CreateSMTPConfigurationOptions
func (*EventNotificationsV1) NewCreateSMTPConfigurationOptions(instanceID string, name string, domain string) *CreateSMTPConfigurationOptions {
	return &CreateSMTPConfigurationOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Domain:     core.StringPtr(domain),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSMTPConfigurationOptions) SetInstanceID(instanceID string) *CreateSMTPConfigurationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSMTPConfigurationOptions) SetName(name string) *CreateSMTPConfigurationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDomain : Allow user to set Domain
func (_options *CreateSMTPConfigurationOptions) SetDomain(domain string) *CreateSMTPConfigurationOptions {
	_options.Domain = core.StringPtr(domain)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSMTPConfigurationOptions) SetDescription(description string) *CreateSMTPConfigurationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSMTPConfigurationOptions) SetHeaders(param map[string]string) *CreateSMTPConfigurationOptions {
	options.Headers = param
	return options
}

// CreateSMTPUserOptions : The CreateSMTPUser options.
type CreateSMTPUserOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// The description of SMTP configuration.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSMTPUserOptions : Instantiate CreateSMTPUserOptions
func (*EventNotificationsV1) NewCreateSMTPUserOptions(instanceID string, id string) *CreateSMTPUserOptions {
	return &CreateSMTPUserOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSMTPUserOptions) SetInstanceID(instanceID string) *CreateSMTPUserOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateSMTPUserOptions) SetID(id string) *CreateSMTPUserOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSMTPUserOptions) SetDescription(description string) *CreateSMTPUserOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSMTPUserOptions) SetHeaders(param map[string]string) *CreateSMTPUserOptions {
	options.Headers = param
	return options
}

// CreateSourcesOptions : The CreateSources options.
type CreateSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSourcesOptions : Instantiate CreateSourcesOptions
func (*EventNotificationsV1) NewCreateSourcesOptions(instanceID string, name string, description string) *CreateSourcesOptions {
	return &CreateSourcesOptions{
		InstanceID:  core.StringPtr(instanceID),
		Name:        core.StringPtr(name),
		Description: core.StringPtr(description),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSourcesOptions) SetInstanceID(instanceID string) *CreateSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSourcesOptions) SetName(name string) *CreateSourcesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSourcesOptions) SetDescription(description string) *CreateSourcesOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *CreateSourcesOptions) SetEnabled(enabled bool) *CreateSourcesOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSourcesOptions) SetHeaders(param map[string]string) *CreateSourcesOptions {
	options.Headers = param
	return options
}

// CreateSubscriptionOptions : The CreateSubscription options.
type CreateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Subscription description.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionCreateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubscriptionOptions : Instantiate CreateSubscriptionOptions
func (*EventNotificationsV1) NewCreateSubscriptionOptions(instanceID string, name string, destinationID string, topicID string) *CreateSubscriptionOptions {
	return &CreateSubscriptionOptions{
		InstanceID:    core.StringPtr(instanceID),
		Name:          core.StringPtr(name),
		DestinationID: core.StringPtr(destinationID),
		TopicID:       core.StringPtr(topicID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSubscriptionOptions) SetInstanceID(instanceID string) *CreateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSubscriptionOptions) SetName(name string) *CreateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDestinationID : Allow user to set DestinationID
func (_options *CreateSubscriptionOptions) SetDestinationID(destinationID string) *CreateSubscriptionOptions {
	_options.DestinationID = core.StringPtr(destinationID)
	return _options
}

// SetTopicID : Allow user to set TopicID
func (_options *CreateSubscriptionOptions) SetTopicID(topicID string) *CreateSubscriptionOptions {
	_options.TopicID = core.StringPtr(topicID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSubscriptionOptions) SetDescription(description string) *CreateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *CreateSubscriptionOptions) SetAttributes(attributes SubscriptionCreateAttributesIntf) *CreateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubscriptionOptions) SetHeaders(param map[string]string) *CreateSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTagsSubscriptionOptions : The CreateTagsSubscription options.
type CreateTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTagsSubscriptionOptions : Instantiate CreateTagsSubscriptionOptions
func (*EventNotificationsV1) NewCreateTagsSubscriptionOptions(instanceID string, id string, deviceID string, tagName string) *CreateTagsSubscriptionOptions {
	return &CreateTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		DeviceID:   core.StringPtr(deviceID),
		TagName:    core.StringPtr(tagName),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTagsSubscriptionOptions) SetInstanceID(instanceID string) *CreateTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTagsSubscriptionOptions) SetID(id string) *CreateTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateTagsSubscriptionOptions) SetDeviceID(deviceID string) *CreateTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *CreateTagsSubscriptionOptions) SetTagName(tagName string) *CreateTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTagsSubscriptionOptions) SetHeaders(param map[string]string) *CreateTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTemplateOptions : The CreateTemplate options.
type CreateTemplateOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Message Template.
	Name *string `json:"name" validate:"required"`

	// The type of template.
	Type *string `json:"type" validate:"required"`

	Params TemplateConfigOneOfIntf `json:"params" validate:"required"`

	// The Template description.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTemplateOptions : Instantiate CreateTemplateOptions
func (*EventNotificationsV1) NewCreateTemplateOptions(instanceID string, name string, typeVar string, params TemplateConfigOneOfIntf) *CreateTemplateOptions {
	return &CreateTemplateOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Type:       core.StringPtr(typeVar),
		Params:     params,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTemplateOptions) SetInstanceID(instanceID string) *CreateTemplateOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTemplateOptions) SetName(name string) *CreateTemplateOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateTemplateOptions) SetType(typeVar string) *CreateTemplateOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetParams : Allow user to set Params
func (_options *CreateTemplateOptions) SetParams(params TemplateConfigOneOfIntf) *CreateTemplateOptions {
	_options.Params = params
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateTemplateOptions) SetDescription(description string) *CreateTemplateOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTemplateOptions) SetHeaders(param map[string]string) *CreateTemplateOptions {
	options.Headers = param
	return options
}

// CreateTopicOptions : The CreateTopic options.
type CreateTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []SourcesItems `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTopicOptions : Instantiate CreateTopicOptions
func (*EventNotificationsV1) NewCreateTopicOptions(instanceID string, name string) *CreateTopicOptions {
	return &CreateTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTopicOptions) SetInstanceID(instanceID string) *CreateTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTopicOptions) SetName(name string) *CreateTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateTopicOptions) SetDescription(description string) *CreateTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *CreateTopicOptions) SetSources(sources []SourcesItems) *CreateTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTopicOptions) SetHeaders(param map[string]string) *CreateTopicOptions {
	options.Headers = param
	return options
}

// DkimAttributes : The DKIM attributes.
type DkimAttributes struct {
	// dkim public key.
	PublicKey *string `json:"public_key,omitempty"`

	// dkim selector.
	Selector *string `json:"selector,omitempty"`

	// dkim verification.
	Verification *string `json:"verification,omitempty"`
}

// UnmarshalDkimAttributes unmarshals an instance of DkimAttributes from the specified map of raw messages.
func UnmarshalDkimAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DkimAttributes)
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "selector", &obj.Selector)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verification", &obj.Verification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteDestinationOptions : The DeleteDestination options.
type DeleteDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDestinationOptions : Instantiate DeleteDestinationOptions
func (*EventNotificationsV1) NewDeleteDestinationOptions(instanceID string, id string) *DeleteDestinationOptions {
	return &DeleteDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteDestinationOptions) SetInstanceID(instanceID string) *DeleteDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteDestinationOptions) SetID(id string) *DeleteDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDestinationOptions) SetHeaders(param map[string]string) *DeleteDestinationOptions {
	options.Headers = param
	return options
}

// DeleteSMTPConfigurationOptions : The DeleteSMTPConfiguration options.
type DeleteSMTPConfigurationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSMTPConfigurationOptions : Instantiate DeleteSMTPConfigurationOptions
func (*EventNotificationsV1) NewDeleteSMTPConfigurationOptions(instanceID string, id string) *DeleteSMTPConfigurationOptions {
	return &DeleteSMTPConfigurationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSMTPConfigurationOptions) SetInstanceID(instanceID string) *DeleteSMTPConfigurationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSMTPConfigurationOptions) SetID(id string) *DeleteSMTPConfigurationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSMTPConfigurationOptions) SetHeaders(param map[string]string) *DeleteSMTPConfigurationOptions {
	options.Headers = param
	return options
}

// DeleteSMTPUserOptions : The DeleteSMTPUser options.
type DeleteSMTPUserOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// UserID.
	UserID *string `json:"user_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSMTPUserOptions : Instantiate DeleteSMTPUserOptions
func (*EventNotificationsV1) NewDeleteSMTPUserOptions(instanceID string, id string, userID string) *DeleteSMTPUserOptions {
	return &DeleteSMTPUserOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		UserID:     core.StringPtr(userID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSMTPUserOptions) SetInstanceID(instanceID string) *DeleteSMTPUserOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSMTPUserOptions) SetID(id string) *DeleteSMTPUserOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *DeleteSMTPUserOptions) SetUserID(userID string) *DeleteSMTPUserOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSMTPUserOptions) SetHeaders(param map[string]string) *DeleteSMTPUserOptions {
	options.Headers = param
	return options
}

// DeleteSourceOptions : The DeleteSource options.
type DeleteSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSourceOptions : Instantiate DeleteSourceOptions
func (*EventNotificationsV1) NewDeleteSourceOptions(instanceID string, id string) *DeleteSourceOptions {
	return &DeleteSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSourceOptions) SetInstanceID(instanceID string) *DeleteSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSourceOptions) SetID(id string) *DeleteSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSourceOptions) SetHeaders(param map[string]string) *DeleteSourceOptions {
	options.Headers = param
	return options
}

// DeleteSubscriptionOptions : The DeleteSubscription options.
type DeleteSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubscriptionOptions : Instantiate DeleteSubscriptionOptions
func (*EventNotificationsV1) NewDeleteSubscriptionOptions(instanceID string, id string) *DeleteSubscriptionOptions {
	return &DeleteSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSubscriptionOptions) SetInstanceID(instanceID string) *DeleteSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSubscriptionOptions) SetID(id string) *DeleteSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubscriptionOptions) SetHeaders(param map[string]string) *DeleteSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTagsSubscriptionOptions : The DeleteTagsSubscription options.
type DeleteTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Device ID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTagsSubscriptionOptions : Instantiate DeleteTagsSubscriptionOptions
func (*EventNotificationsV1) NewDeleteTagsSubscriptionOptions(instanceID string, id string) *DeleteTagsSubscriptionOptions {
	return &DeleteTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTagsSubscriptionOptions) SetInstanceID(instanceID string) *DeleteTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTagsSubscriptionOptions) SetID(id string) *DeleteTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *DeleteTagsSubscriptionOptions) SetDeviceID(deviceID string) *DeleteTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *DeleteTagsSubscriptionOptions) SetTagName(tagName string) *DeleteTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTagsSubscriptionOptions) SetHeaders(param map[string]string) *DeleteTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTemplateOptions : The DeleteTemplate options.
type DeleteTemplateOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Template.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTemplateOptions : Instantiate DeleteTemplateOptions
func (*EventNotificationsV1) NewDeleteTemplateOptions(instanceID string, id string) *DeleteTemplateOptions {
	return &DeleteTemplateOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTemplateOptions) SetInstanceID(instanceID string) *DeleteTemplateOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTemplateOptions) SetID(id string) *DeleteTemplateOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTemplateOptions) SetHeaders(param map[string]string) *DeleteTemplateOptions {
	options.Headers = param
	return options
}

// DeleteTopicOptions : The DeleteTopic options.
type DeleteTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTopicOptions : Instantiate DeleteTopicOptions
func (*EventNotificationsV1) NewDeleteTopicOptions(instanceID string, id string) *DeleteTopicOptions {
	return &DeleteTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTopicOptions) SetInstanceID(instanceID string) *DeleteTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTopicOptions) SetID(id string) *DeleteTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTopicOptions) SetHeaders(param map[string]string) *DeleteTopicOptions {
	options.Headers = param
	return options
}

// Destination : Payload describing a destination get request.
type Destination struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type
	// Email/SMS/Webhook/FCM/Slack/MSTeams/PagerDuty/IBMCloudFunctions/IBMCodeEngine/ServiceNow/IBMCloudObjectStorage/Huawei.
	Type *string `json:"type" validate:"required"`

	// Whether to collect the failed event in Cloud Object Storage bucket.
	CollectFailedEvents *bool `json:"collect_failed_events,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`
}

// Constants associated with the Destination.Type property.
// Destination type
// Email/SMS/Webhook/FCM/Slack/MSTeams/PagerDuty/IBMCloudFunctions/IBMCodeEngine/ServiceNow/IBMCloudObjectStorage/Huawei.
const (
	DestinationTypeIbmceConst       = "ibmce"
	DestinationTypeIbmcfConst       = "ibmcf"
	DestinationTypeIbmcosConst      = "ibmcos"
	DestinationTypeMsteamsConst     = "msteams"
	DestinationTypePagerdutyConst   = "pagerduty"
	DestinationTypePushAndroidConst = "push_android"
	DestinationTypePushHuaweiConst  = "push_huawei"
	DestinationTypePushIosConst     = "push_ios"
	DestinationTypePushSafariConst  = "push_safari"
	DestinationTypeSMTPCustomConst  = "smtp_custom"
	DestinationTypeSMTPIBMConst     = "smtp_ibm"
	DestinationTypeServicenowConst  = "servicenow"
	DestinationTypeSlackConst       = "slack"
	DestinationTypeSmsCustomConst   = "sms_custom"
	DestinationTypeSmsIBMConst      = "sms_ibm"
	DestinationTypeWebhookConst     = "webhook"
)

// UnmarshalDestination unmarshals an instance of Destination from the specified map of raw messages.
func UnmarshalDestination(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Destination)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "collect_failed_events", &obj.CollectFailedEvents)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfig : Payload describing a destination configuration.
type DestinationConfig struct {
	Params DestinationConfigOneOfIntf `json:"params" validate:"required"`
}

// NewDestinationConfig : Instantiate DestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfig(params DestinationConfigOneOfIntf) (_model *DestinationConfig, err error) {
	_model = &DestinationConfig{
		Params: params,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalDestinationConfig unmarshals an instance of DestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfig)
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalDestinationConfigOneOf)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOf : DestinationConfigOneOf struct
// Models which "extend" this model:
// - DestinationConfigOneOfCustomDomainEmailDestinationConfig
// - DestinationConfigOneOfWebhookDestinationConfig
// - DestinationConfigOneOfCodeEngineDestinationConfig
// - DestinationConfigOneOfFcmDestinationConfig
// - DestinationConfigOneOfIosDestinationConfig
// - DestinationConfigOneOfChromeDestinationConfig
// - DestinationConfigOneOfFirefoxDestinationConfig
// - DestinationConfigOneOfSlackDestinationConfig
// - DestinationConfigOneOfSlackDirectMessageDestinationConfig
// - DestinationConfigOneOfSafariDestinationConfig
// - DestinationConfigOneOfMsTeamsDestinationConfig
// - DestinationConfigOneOfIBMCloudFunctionsDestinationConfig
// - DestinationConfigOneOfPagerDutyDestinationConfig
// - DestinationConfigOneOfServiceNowDestinationConfig
// - DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig
// - DestinationConfigOneOfHuaweiDestinationConfig
type DestinationConfigOneOf struct {
	// Email Domain.
	Domain *string `json:"domain,omitempty"`

	// The DKIM attributes.
	Dkim *DkimAttributes `json:"dkim,omitempty"`

	// The SPF attributes.
	Spf *SpfAttributes `json:"spf,omitempty"`

	// URL of webhook.
	URL *string `json:"url,omitempty"`

	// HTTP method of webhook.
	Verb *string `json:"verb,omitempty"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`

	// The code engine destination type.
	Type *string `json:"type,omitempty"`

	// CRN of the code engine project.
	ProjectCRN *string `json:"project_crn,omitempty"`

	// name of the code engine job.
	JobName *string `json:"job_name,omitempty"`

	// FCM server_key.
	// Deprecated: this field is deprecated and may be removed in a future release.
	ServerKey *string `json:"server_key,omitempty"`

	// FCM sender_id.
	// Deprecated: this field is deprecated and may be removed in a future release.
	SenderID *string `json:"sender_id,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`

	// FCM project_id.
	ProjectID *string `json:"project_id,omitempty"`

	// FCM private_key.
	PrivateKey *string `json:"private_key,omitempty"`

	// FCM client_email.
	ClientEmail *string `json:"client_email,omitempty"`

	// Authentication type (p8 or p12).
	CertType *string `json:"cert_type,omitempty"`

	// Sandbox mode for iOS destinations.
	IsSandbox *bool `json:"is_sandbox,omitempty"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password,omitempty"`

	// Key ID for token (Required when cert_type is p8).
	KeyID *string `json:"key_id,omitempty"`

	// Team ID for token (Required when cert_type is p8).
	TeamID *string `json:"team_id,omitempty"`

	// Bundle ID for token (Required when cert_type is p8).
	BundleID *string `json:"bundle_id,omitempty"`

	// FCM api_key.
	APIKey *string `json:"api_key,omitempty"`

	// Website url.
	WebsiteURL *string `json:"website_url,omitempty"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// Token of slack application.
	Token *string `json:"token,omitempty"`

	// Website url.
	WebsiteName *string `json:"website_name,omitempty"`

	// Website url.
	URLFormatString *string `json:"url_format_string,omitempty"`

	// Website url.
	WebsitePushID *string `json:"website_push_id,omitempty"`

	// Routing Key (Integration Key) for the team in PagerDuty account.
	RoutingKey *string `json:"routing_key,omitempty"`

	// ClientID for the ServiceNow account oauth.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret for the ServiceNow account oauth.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Username for ServiceNow account REST API.
	Username *string `json:"username,omitempty"`

	// Instance name for ServiceNow account.
	InstanceName *string `json:"instance_name,omitempty"`

	// Bucket Name for Cloud Object Storage.
	BucketName *string `json:"bucket_name,omitempty"`

	// Instance Id of Cloud Object Storage.
	InstanceID *string `json:"instance_id,omitempty"`

	// End Point of Cloud Object Storage.
	Endpoint *string `json:"endpoint,omitempty"`
}

// Constants associated with the DestinationConfigOneOf.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigOneOfVerbGetConst  = "get"
	DestinationConfigOneOfVerbPostConst = "post"
)

// Constants associated with the DestinationConfigOneOf.Type property.
// The code engine destination type.
const (
	DestinationConfigOneOfTypeApplicationConst = "application"
	DestinationConfigOneOfTypeJobConst         = "job"
)

func (*DestinationConfigOneOf) isaDestinationConfigOneOf() bool {
	return true
}

type DestinationConfigOneOfIntf interface {
	isaDestinationConfigOneOf() bool
}

// UnmarshalDestinationConfigOneOf unmarshals an instance of DestinationConfigOneOf from the specified map of raw messages.
func UnmarshalDestinationConfigOneOf(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOf)
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dkim", &obj.Dkim, UnmarshalDkimAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "spf", &obj.Spf, UnmarshalSpfAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "project_crn", &obj.ProjectCRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "job_name", &obj.JobName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "project_id", &obj.ProjectID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_key", &obj.PrivateKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_email", &obj.ClientEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_sandbox", &obj.IsSandbox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_id", &obj.KeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_id", &obj.TeamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bundle_id", &obj.BundleID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "token", &obj.Token)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_name", &obj.WebsiteName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_format_string", &obj.URLFormatString)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_push_id", &obj.WebsitePushID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_key", &obj.RoutingKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_id", &obj.ClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_secret", &obj.ClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_name", &obj.InstanceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bucket_name", &obj.BucketName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationList : Payload describing a destination list request.
type DestinationList struct {
	// Total number of destinations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destinations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of destinations.
	Destinations []DestinationListItem `json:"destinations" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalDestinationList unmarshals an instance of DestinationList from the specified map of raw messages.
func UnmarshalDestinationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "destinations", &obj.Destinations, UnmarshalDestinationListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *DestinationList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// DestinationListItem : Destination object.
type DestinationListItem struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type.
	Type *string `json:"type" validate:"required"`

	// Whether to collect the failed event in Cloud Object Storage bucket.
	CollectFailedEvents *bool `json:"collect_failed_events,omitempty"`

	// Subscription count.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// Names of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the DestinationListItem.Type property.
// Destination type.
const (
	DestinationListItemTypeIbmceConst       = "ibmce"
	DestinationListItemTypeIbmcfConst       = "ibmcf"
	DestinationListItemTypeIbmcosConst      = "ibmcos"
	DestinationListItemTypeMsteamsConst     = "msteams"
	DestinationListItemTypePagerdutyConst   = "pagerduty"
	DestinationListItemTypePushAndroidConst = "push_android"
	DestinationListItemTypePushHuaweiConst  = "push_huawei"
	DestinationListItemTypePushIosConst     = "push_ios"
	DestinationListItemTypePushSafariConst  = "push_safari"
	DestinationListItemTypeSMTPCustomConst  = "smtp_custom"
	DestinationListItemTypeSMTPIBMConst     = "smtp_ibm"
	DestinationListItemTypeServicenowConst  = "servicenow"
	DestinationListItemTypeSlackConst       = "slack"
	DestinationListItemTypeSmsCustomConst   = "sms_custom"
	DestinationListItemTypeSmsIBMConst      = "sms_ibm"
	DestinationListItemTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationListItem unmarshals an instance of DestinationListItem from the specified map of raw messages.
func UnmarshalDestinationListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "collect_failed_events", &obj.CollectFailedEvents)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationResponse : Payload describing a destination get request.
type DestinationResponse struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type.
	Type *string `json:"type" validate:"required"`

	// Whether to collect the failed event in Cloud Object Storage bucket.
	CollectFailedEvents *bool `json:"collect_failed_events,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config" validate:"required"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// Constants associated with the DestinationResponse.Type property.
// Destination type.
const (
	DestinationResponseTypeIbmceConst       = "ibmce"
	DestinationResponseTypeIbmcfConst       = "ibmcf"
	DestinationResponseTypeIbmcosConst      = "ibmcos"
	DestinationResponseTypeMsteamsConst     = "msteams"
	DestinationResponseTypePagerdutyConst   = "pagerduty"
	DestinationResponseTypePushAndroidConst = "push_android"
	DestinationResponseTypePushChromeConst  = "push_chrome"
	DestinationResponseTypePushFirefoxConst = "push_firefox"
	DestinationResponseTypePushHuaweiConst  = "push_huawei"
	DestinationResponseTypePushIosConst     = "push_ios"
	DestinationResponseTypePushSafariConst  = "push_safari"
	DestinationResponseTypeSMTPCustomConst  = "smtp_custom"
	DestinationResponseTypeServicenowConst  = "servicenow"
	DestinationResponseTypeSlackConst       = "slack"
	DestinationResponseTypeSmsCustomConst   = "sms_custom"
	DestinationResponseTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationResponse unmarshals an instance of DestinationResponse from the specified map of raw messages.
func UnmarshalDestinationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "collect_failed_events", &obj.CollectFailedEvents)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationTagsSubscriptionResponse : Payload describing a destination get request.
type DestinationTagsSubscriptionResponse struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalDestinationTagsSubscriptionResponse unmarshals an instance of DestinationTagsSubscriptionResponse from the specified map of raw messages.
func UnmarshalDestinationTagsSubscriptionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationTagsSubscriptionResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EnAuthAttributes : The en_authorization attributes.
type EnAuthAttributes struct {
	// en_authorization verification.
	Verification *string `json:"verification,omitempty"`
}

// UnmarshalEnAuthAttributes unmarshals an instance of EnAuthAttributes from the specified map of raw messages.
func UnmarshalEnAuthAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EnAuthAttributes)
	err = core.UnmarshalPrimitive(m, "verification", &obj.Verification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailAttributesResponseInvitedItems : EmailAttributesResponseInvitedItems struct
type EmailAttributesResponseInvitedItems struct {
	// email address.
	Email *string `json:"email,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// time of expiration.
	ExpiresAt *strfmt.DateTime `json:"expires_at,omitempty"`
}

// UnmarshalEmailAttributesResponseInvitedItems unmarshals an instance of EmailAttributesResponseInvitedItems from the specified map of raw messages.
func UnmarshalEmailAttributesResponseInvitedItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailAttributesResponseInvitedItems)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires_at", &obj.ExpiresAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailAttributesResponseSubscribedUnsubscribedItems : EmailAttributesResponseSubscribedUnsubscribedItems struct
type EmailAttributesResponseSubscribedUnsubscribedItems struct {
	// email address.
	Email *string `json:"email,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems unmarshals an instance of EmailAttributesResponseSubscribedUnsubscribedItems from the specified map of raw messages.
func UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailAttributesResponseSubscribedUnsubscribedItems)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EnabledCountriesResponse : Payload describing a custom SMS Configuration.
type EnabledCountriesResponse struct {
	// The SMS destination status.
	Status *string `json:"status" validate:"required"`

	// List enabled countries.
	EnabledCountries []SmsCountryConfig `json:"enabled_countries" validate:"required"`
}

// UnmarshalEnabledCountriesResponse unmarshals an instance of EnabledCountriesResponse from the specified map of raw messages.
func UnmarshalEnabledCountriesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EnabledCountriesResponse)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "enabled_countries", &obj.EnabledCountries, UnmarshalSmsCountryConfig)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDestinationOptions : The GetDestination options.
type GetDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationOptions : Instantiate GetDestinationOptions
func (*EventNotificationsV1) NewGetDestinationOptions(instanceID string, id string) *GetDestinationOptions {
	return &GetDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationOptions) SetInstanceID(instanceID string) *GetDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationOptions) SetID(id string) *GetDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationOptions) SetHeaders(param map[string]string) *GetDestinationOptions {
	options.Headers = param
	return options
}

// GetEnabledCountriesOptions : The GetEnabledCountries options.
type GetEnabledCountriesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetEnabledCountriesOptions : Instantiate GetEnabledCountriesOptions
func (*EventNotificationsV1) NewGetEnabledCountriesOptions(instanceID string, id string) *GetEnabledCountriesOptions {
	return &GetEnabledCountriesOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetEnabledCountriesOptions) SetInstanceID(instanceID string) *GetEnabledCountriesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetEnabledCountriesOptions) SetID(id string) *GetEnabledCountriesOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetEnabledCountriesOptions) SetHeaders(param map[string]string) *GetEnabledCountriesOptions {
	options.Headers = param
	return options
}

// GetIntegrationOptions : The GetIntegration options.
type GetIntegrationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for integration.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIntegrationOptions : Instantiate GetIntegrationOptions
func (*EventNotificationsV1) NewGetIntegrationOptions(instanceID string, id string) *GetIntegrationOptions {
	return &GetIntegrationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetIntegrationOptions) SetInstanceID(instanceID string) *GetIntegrationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetIntegrationOptions) SetID(id string) *GetIntegrationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetIntegrationOptions) SetHeaders(param map[string]string) *GetIntegrationOptions {
	options.Headers = param
	return options
}

// GetMetricsOptions : The GetMetrics options.
type GetMetricsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Destination type. Allowed values are [smtp_custom].
	DestinationType *string `json:"destination_type" validate:"required"`

	// GTE (greater than equal), start timestamp in UTC.
	Gte *string `json:"gte" validate:"required"`

	// LTE (less than equal), end timestamp in UTC.
	Lte *string `json:"lte" validate:"required"`

	// Unique identifier for Destination.
	DestinationID *string `json:"destination_id,omitempty"`

	// Unique identifier for Source.
	SourceID *string `json:"source_id,omitempty"`

	// Receiver email id.
	EmailTo *string `json:"email_to,omitempty"`

	// Notification Id.
	NotificationID *string `json:"notification_id,omitempty"`

	// Email subject.
	Subject *string `json:"subject,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the GetMetricsOptions.DestinationType property.
// Destination type. Allowed values are [smtp_custom].
const (
	GetMetricsOptionsDestinationTypeSMTPCustomConst = "smtp_custom"
)

// NewGetMetricsOptions : Instantiate GetMetricsOptions
func (*EventNotificationsV1) NewGetMetricsOptions(instanceID string, destinationType string, gte string, lte string) *GetMetricsOptions {
	return &GetMetricsOptions{
		InstanceID:      core.StringPtr(instanceID),
		DestinationType: core.StringPtr(destinationType),
		Gte:             core.StringPtr(gte),
		Lte:             core.StringPtr(lte),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetMetricsOptions) SetInstanceID(instanceID string) *GetMetricsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetDestinationType : Allow user to set DestinationType
func (_options *GetMetricsOptions) SetDestinationType(destinationType string) *GetMetricsOptions {
	_options.DestinationType = core.StringPtr(destinationType)
	return _options
}

// SetGte : Allow user to set Gte
func (_options *GetMetricsOptions) SetGte(gte string) *GetMetricsOptions {
	_options.Gte = core.StringPtr(gte)
	return _options
}

// SetLte : Allow user to set Lte
func (_options *GetMetricsOptions) SetLte(lte string) *GetMetricsOptions {
	_options.Lte = core.StringPtr(lte)
	return _options
}

// SetDestinationID : Allow user to set DestinationID
func (_options *GetMetricsOptions) SetDestinationID(destinationID string) *GetMetricsOptions {
	_options.DestinationID = core.StringPtr(destinationID)
	return _options
}

// SetSourceID : Allow user to set SourceID
func (_options *GetMetricsOptions) SetSourceID(sourceID string) *GetMetricsOptions {
	_options.SourceID = core.StringPtr(sourceID)
	return _options
}

// SetEmailTo : Allow user to set EmailTo
func (_options *GetMetricsOptions) SetEmailTo(emailTo string) *GetMetricsOptions {
	_options.EmailTo = core.StringPtr(emailTo)
	return _options
}

// SetNotificationID : Allow user to set NotificationID
func (_options *GetMetricsOptions) SetNotificationID(notificationID string) *GetMetricsOptions {
	_options.NotificationID = core.StringPtr(notificationID)
	return _options
}

// SetSubject : Allow user to set Subject
func (_options *GetMetricsOptions) SetSubject(subject string) *GetMetricsOptions {
	_options.Subject = core.StringPtr(subject)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetMetricsOptions) SetHeaders(param map[string]string) *GetMetricsOptions {
	options.Headers = param
	return options
}

// GetSMTPAllowedIpsOptions : The GetSMTPAllowedIps options.
type GetSMTPAllowedIpsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSMTPAllowedIpsOptions : Instantiate GetSMTPAllowedIpsOptions
func (*EventNotificationsV1) NewGetSMTPAllowedIpsOptions(instanceID string, id string) *GetSMTPAllowedIpsOptions {
	return &GetSMTPAllowedIpsOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSMTPAllowedIpsOptions) SetInstanceID(instanceID string) *GetSMTPAllowedIpsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSMTPAllowedIpsOptions) SetID(id string) *GetSMTPAllowedIpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSMTPAllowedIpsOptions) SetHeaders(param map[string]string) *GetSMTPAllowedIpsOptions {
	options.Headers = param
	return options
}

// GetSMTPConfigurationOptions : The GetSMTPConfiguration options.
type GetSMTPConfigurationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSMTPConfigurationOptions : Instantiate GetSMTPConfigurationOptions
func (*EventNotificationsV1) NewGetSMTPConfigurationOptions(instanceID string, id string) *GetSMTPConfigurationOptions {
	return &GetSMTPConfigurationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSMTPConfigurationOptions) SetInstanceID(instanceID string) *GetSMTPConfigurationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSMTPConfigurationOptions) SetID(id string) *GetSMTPConfigurationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSMTPConfigurationOptions) SetHeaders(param map[string]string) *GetSMTPConfigurationOptions {
	options.Headers = param
	return options
}

// GetSMTPUserOptions : The GetSMTPUser options.
type GetSMTPUserOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// UserID.
	UserID *string `json:"user_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSMTPUserOptions : Instantiate GetSMTPUserOptions
func (*EventNotificationsV1) NewGetSMTPUserOptions(instanceID string, id string, userID string) *GetSMTPUserOptions {
	return &GetSMTPUserOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		UserID:     core.StringPtr(userID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSMTPUserOptions) SetInstanceID(instanceID string) *GetSMTPUserOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSMTPUserOptions) SetID(id string) *GetSMTPUserOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *GetSMTPUserOptions) SetUserID(userID string) *GetSMTPUserOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSMTPUserOptions) SetHeaders(param map[string]string) *GetSMTPUserOptions {
	options.Headers = param
	return options
}

// GetSourceOptions : The GetSource options.
type GetSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSourceOptions : Instantiate GetSourceOptions
func (*EventNotificationsV1) NewGetSourceOptions(instanceID string, id string) *GetSourceOptions {
	return &GetSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSourceOptions) SetInstanceID(instanceID string) *GetSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSourceOptions) SetID(id string) *GetSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSourceOptions) SetHeaders(param map[string]string) *GetSourceOptions {
	options.Headers = param
	return options
}

// GetSubscriptionOptions : The GetSubscription options.
type GetSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubscriptionOptions : Instantiate GetSubscriptionOptions
func (*EventNotificationsV1) NewGetSubscriptionOptions(instanceID string, id string) *GetSubscriptionOptions {
	return &GetSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSubscriptionOptions) SetInstanceID(instanceID string) *GetSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSubscriptionOptions) SetID(id string) *GetSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubscriptionOptions) SetHeaders(param map[string]string) *GetSubscriptionOptions {
	options.Headers = param
	return options
}

// GetTemplateOptions : The GetTemplate options.
type GetTemplateOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Template.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTemplateOptions : Instantiate GetTemplateOptions
func (*EventNotificationsV1) NewGetTemplateOptions(instanceID string, id string) *GetTemplateOptions {
	return &GetTemplateOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetTemplateOptions) SetInstanceID(instanceID string) *GetTemplateOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTemplateOptions) SetID(id string) *GetTemplateOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTemplateOptions) SetHeaders(param map[string]string) *GetTemplateOptions {
	options.Headers = param
	return options
}

// GetTopicOptions : The GetTopic options.
type GetTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Include sub topics.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTopicOptions : Instantiate GetTopicOptions
func (*EventNotificationsV1) NewGetTopicOptions(instanceID string, id string) *GetTopicOptions {
	return &GetTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetTopicOptions) SetInstanceID(instanceID string) *GetTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTopicOptions) SetID(id string) *GetTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInclude : Allow user to set Include
func (_options *GetTopicOptions) SetInclude(include string) *GetTopicOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTopicOptions) SetHeaders(param map[string]string) *GetTopicOptions {
	options.Headers = param
	return options
}

// Histrogram : Payload describing histogram.
type Histrogram struct {
	// List of buckets.
	Buckets []Buckets `json:"buckets,omitempty"`
}

// UnmarshalHistrogram unmarshals an instance of Histrogram from the specified map of raw messages.
func UnmarshalHistrogram(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Histrogram)
	err = core.UnmarshalModel(m, "buckets", &obj.Buckets, UnmarshalBuckets)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationCreateMetadata : Integration Metadata object.
type IntegrationCreateMetadata struct {
	// URL for Cloud Object storage.
	Endpoint *string `json:"endpoint" validate:"required"`

	// CRN of the Cloud Object Storage instance.
	CRN *string `json:"crn" validate:"required"`

	// Cloud Object Storage bucket name.
	BucketName *string `json:"bucket_name" validate:"required"`
}

// NewIntegrationCreateMetadata : Instantiate IntegrationCreateMetadata (Generic Model Constructor)
func (*EventNotificationsV1) NewIntegrationCreateMetadata(endpoint string, crn string, bucketName string) (_model *IntegrationCreateMetadata, err error) {
	_model = &IntegrationCreateMetadata{
		Endpoint:   core.StringPtr(endpoint),
		CRN:        core.StringPtr(crn),
		BucketName: core.StringPtr(bucketName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalIntegrationCreateMetadata unmarshals an instance of IntegrationCreateMetadata from the specified map of raw messages.
func UnmarshalIntegrationCreateMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationCreateMetadata)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bucket_name", &obj.BucketName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationCreateResponse : Integration create response object.
type IntegrationCreateResponse struct {
	// ID of the integration.
	ID *strfmt.UUID `json:"id" validate:"required"`

	// Integration type. Allowed values collect_failed_events.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationCreateMetadata `json:"metadata" validate:"required"`

	// Creation time of an integration.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalIntegrationCreateResponse unmarshals an instance of IntegrationCreateResponse from the specified map of raw messages.
func UnmarshalIntegrationCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationCreateResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalIntegrationCreateMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationGetResponse : Integration response object.
type IntegrationGetResponse struct {
	// ID of the integration.
	ID *strfmt.UUID `json:"id" validate:"required"`

	// Integration type. Allowed values are kms and hs-crypto.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationMetadata `json:"metadata" validate:"required"`

	// Creation time of an integration.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Last update time of an integration.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalIntegrationGetResponse unmarshals an instance of IntegrationGetResponse from the specified map of raw messages.
func UnmarshalIntegrationGetResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationGetResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalIntegrationMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationList : all Integrations response object.
type IntegrationList struct {
	// Number of integrations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show integrations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of integrations.
	Integrations []IntegrationListItem `json:"integrations" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalIntegrationList unmarshals an instance of IntegrationList from the specified map of raw messages.
func UnmarshalIntegrationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "integrations", &obj.Integrations, UnmarshalIntegrationListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *IntegrationList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// IntegrationListItem : all Integrations response object.
type IntegrationListItem struct {
	// ID of the integration.
	ID *strfmt.UUID `json:"id" validate:"required"`

	// Integration type. Allowed values are kms and hs-crypto.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationMetadata `json:"metadata" validate:"required"`

	// Creation time of an integration.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Update time of an integration.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalIntegrationListItem unmarshals an instance of IntegrationListItem from the specified map of raw messages.
func UnmarshalIntegrationListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalIntegrationMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationMetadata : Integration Metadata object.
type IntegrationMetadata struct {
	// KMS url for key management or url for COS bucket.
	Endpoint *string `json:"endpoint" validate:"required"`

	// CRN of the KMS/COS instance.
	CRN *string `json:"crn" validate:"required"`

	// Root Key ID of KMS.
	RootKeyID *string `json:"root_key_id,omitempty"`

	// cloud object storage bucket name.
	BucketName *string `json:"bucket_name,omitempty"`
}

// NewIntegrationMetadata : Instantiate IntegrationMetadata (Generic Model Constructor)
func (*EventNotificationsV1) NewIntegrationMetadata(endpoint string, crn string) (_model *IntegrationMetadata, err error) {
	_model = &IntegrationMetadata{
		Endpoint: core.StringPtr(endpoint),
		CRN:      core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalIntegrationMetadata unmarshals an instance of IntegrationMetadata from the specified map of raw messages.
func UnmarshalIntegrationMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationMetadata)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "root_key_id", &obj.RootKeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bucket_name", &obj.BucketName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListDestinationsOptions : The ListDestinations options.
type ListDestinationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationsOptions : Instantiate ListDestinationsOptions
func (*EventNotificationsV1) NewListDestinationsOptions(instanceID string) *ListDestinationsOptions {
	return &ListDestinationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationsOptions) SetInstanceID(instanceID string) *ListDestinationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationsOptions) SetLimit(limit int64) *ListDestinationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationsOptions) SetOffset(offset int64) *ListDestinationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationsOptions) SetSearch(search string) *ListDestinationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationsOptions) SetHeaders(param map[string]string) *ListDestinationsOptions {
	options.Headers = param
	return options
}

// ListIntegrationsOptions : The ListIntegrations options.
type ListIntegrationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIntegrationsOptions : Instantiate ListIntegrationsOptions
func (*EventNotificationsV1) NewListIntegrationsOptions(instanceID string) *ListIntegrationsOptions {
	return &ListIntegrationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListIntegrationsOptions) SetInstanceID(instanceID string) *ListIntegrationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListIntegrationsOptions) SetOffset(offset int64) *ListIntegrationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListIntegrationsOptions) SetLimit(limit int64) *ListIntegrationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListIntegrationsOptions) SetSearch(search string) *ListIntegrationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListIntegrationsOptions) SetHeaders(param map[string]string) *ListIntegrationsOptions {
	options.Headers = param
	return options
}

// ListSMTPConfigurationsOptions : The ListSMTPConfigurations options.
type ListSMTPConfigurationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSMTPConfigurationsOptions : Instantiate ListSMTPConfigurationsOptions
func (*EventNotificationsV1) NewListSMTPConfigurationsOptions(instanceID string) *ListSMTPConfigurationsOptions {
	return &ListSMTPConfigurationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSMTPConfigurationsOptions) SetInstanceID(instanceID string) *ListSMTPConfigurationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSMTPConfigurationsOptions) SetLimit(limit int64) *ListSMTPConfigurationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSMTPConfigurationsOptions) SetOffset(offset int64) *ListSMTPConfigurationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSMTPConfigurationsOptions) SetSearch(search string) *ListSMTPConfigurationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSMTPConfigurationsOptions) SetHeaders(param map[string]string) *ListSMTPConfigurationsOptions {
	options.Headers = param
	return options
}

// ListSMTPUsersOptions : The ListSMTPUsers options.
type ListSMTPUsersOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSMTPUsersOptions : Instantiate ListSMTPUsersOptions
func (*EventNotificationsV1) NewListSMTPUsersOptions(instanceID string, id string) *ListSMTPUsersOptions {
	return &ListSMTPUsersOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSMTPUsersOptions) SetInstanceID(instanceID string) *ListSMTPUsersOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListSMTPUsersOptions) SetID(id string) *ListSMTPUsersOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSMTPUsersOptions) SetLimit(limit int64) *ListSMTPUsersOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSMTPUsersOptions) SetOffset(offset int64) *ListSMTPUsersOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSMTPUsersOptions) SetSearch(search string) *ListSMTPUsersOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSMTPUsersOptions) SetHeaders(param map[string]string) *ListSMTPUsersOptions {
	options.Headers = param
	return options
}

// ListSourcesOptions : The ListSources options.
type ListSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSourcesOptions : Instantiate ListSourcesOptions
func (*EventNotificationsV1) NewListSourcesOptions(instanceID string) *ListSourcesOptions {
	return &ListSourcesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSourcesOptions) SetInstanceID(instanceID string) *ListSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSourcesOptions) SetLimit(limit int64) *ListSourcesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSourcesOptions) SetOffset(offset int64) *ListSourcesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSourcesOptions) SetSearch(search string) *ListSourcesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSourcesOptions) SetHeaders(param map[string]string) *ListSourcesOptions {
	options.Headers = param
	return options
}

// ListSubscriptionsOptions : The ListSubscriptions options.
type ListSubscriptionsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubscriptionsOptions : Instantiate ListSubscriptionsOptions
func (*EventNotificationsV1) NewListSubscriptionsOptions(instanceID string) *ListSubscriptionsOptions {
	return &ListSubscriptionsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSubscriptionsOptions) SetInstanceID(instanceID string) *ListSubscriptionsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSubscriptionsOptions) SetOffset(offset int64) *ListSubscriptionsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubscriptionsOptions) SetLimit(limit int64) *ListSubscriptionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSubscriptionsOptions) SetSearch(search string) *ListSubscriptionsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubscriptionsOptions) SetHeaders(param map[string]string) *ListSubscriptionsOptions {
	options.Headers = param
	return options
}

// ListTagsSubscriptionOptions : The ListTagsSubscription options.
type ListTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Device ID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// UserID of the destination.
	UserID *string `json:"user_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTagsSubscriptionOptions : Instantiate ListTagsSubscriptionOptions
func (*EventNotificationsV1) NewListTagsSubscriptionOptions(instanceID string, id string) *ListTagsSubscriptionOptions {
	return &ListTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTagsSubscriptionOptions) SetInstanceID(instanceID string) *ListTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTagsSubscriptionOptions) SetID(id string) *ListTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTagsSubscriptionOptions) SetDeviceID(deviceID string) *ListTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *ListTagsSubscriptionOptions) SetUserID(userID string) *ListTagsSubscriptionOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *ListTagsSubscriptionOptions) SetTagName(tagName string) *ListTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTagsSubscriptionOptions) SetLimit(limit int64) *ListTagsSubscriptionOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTagsSubscriptionOptions) SetOffset(offset int64) *ListTagsSubscriptionOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTagsSubscriptionOptions) SetSearch(search string) *ListTagsSubscriptionOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTagsSubscriptionOptions) SetHeaders(param map[string]string) *ListTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// ListTemplatesOptions : The ListTemplates options.
type ListTemplatesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTemplatesOptions : Instantiate ListTemplatesOptions
func (*EventNotificationsV1) NewListTemplatesOptions(instanceID string) *ListTemplatesOptions {
	return &ListTemplatesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTemplatesOptions) SetInstanceID(instanceID string) *ListTemplatesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTemplatesOptions) SetLimit(limit int64) *ListTemplatesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTemplatesOptions) SetOffset(offset int64) *ListTemplatesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTemplatesOptions) SetSearch(search string) *ListTemplatesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTemplatesOptions) SetHeaders(param map[string]string) *ListTemplatesOptions {
	options.Headers = param
	return options
}

// ListTopicsOptions : The ListTopics options.
type ListTopicsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTopicsOptions : Instantiate ListTopicsOptions
func (*EventNotificationsV1) NewListTopicsOptions(instanceID string) *ListTopicsOptions {
	return &ListTopicsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTopicsOptions) SetInstanceID(instanceID string) *ListTopicsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTopicsOptions) SetLimit(limit int64) *ListTopicsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTopicsOptions) SetOffset(offset int64) *ListTopicsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTopicsOptions) SetSearch(search string) *ListTopicsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTopicsOptions) SetHeaders(param map[string]string) *ListTopicsOptions {
	options.Headers = param
	return options
}

// Metric : Payload describing metrics request.
type Metric struct {
	// key.
	Key *string `json:"key,omitempty"`

	// doc count.
	DocCount *int64 `json:"doc_count,omitempty"`

	// Payload describing histogram.
	Histogram *Histrogram `json:"histogram,omitempty"`
}

// Constants associated with the Metric.Key property.
// key.
const (
	MetricKeyBouncedConst   = "bounced"
	MetricKeyDeferredConst  = "deferred"
	MetricKeyOpenedConst    = "opened"
	MetricKeySubmittedConst = "submitted"
	MetricKeySuccessConst   = "success"
)

// UnmarshalMetric unmarshals an instance of Metric from the specified map of raw messages.
func UnmarshalMetric(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Metric)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "doc_count", &obj.DocCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "histogram", &obj.Histogram, UnmarshalHistrogram)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Metrics : Payload describing a metrics.
type Metrics struct {
	// array of metrics.
	Metrics []Metric `json:"metrics" validate:"required"`
}

// UnmarshalMetrics unmarshals an instance of Metrics from the specified map of raw messages.
func UnmarshalMetrics(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Metrics)
	err = core.UnmarshalModel(m, "metrics", &obj.Metrics, UnmarshalMetric)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationCreate : Payload describing a notification create request.
type NotificationCreate struct {
	// The version of the notification specification.
	Specversion *string `json:"specversion" validate:"required"`

	// The time notification was created.
	Time *strfmt.DateTime `json:"time,omitempty"`

	// The unique identifier of the notification.
	ID *string `json:"id" validate:"required"`

	// The source of notifications.
	Source *string `json:"source" validate:"required"`

	// The notifications type.
	Type *string `json:"type" validate:"required"`

	// The severity of the notification.
	Ibmenseverity *string `json:"ibmenseverity,omitempty"`

	// The source id of the notification.
	Ibmensourceid *string `json:"ibmensourceid" validate:"required"`

	// Default short text for the message.
	Ibmendefaultshort *string `json:"ibmendefaultshort" validate:"required"`

	// Default long text for the message.
	Ibmendefaultlong *string `json:"ibmendefaultlong" validate:"required"`

	// The subject of the notification.
	Ibmensubject *string `json:"ibmensubject,omitempty"`

	// The template id Array of string.
	Ibmentemplates *string `json:"ibmentemplates,omitempty"`

	// The email id string.
	Ibmenmailto *string `json:"ibmenmailto,omitempty"`

	// The slack channel id/member id stringified array.
	Ibmenslackto *string `json:"ibmenslackto,omitempty"`

	// The SMS number string.
	Ibmensmsto *string `json:"ibmensmsto,omitempty"`

	// The html body of notification.
	Ibmenhtmlbody *string `json:"ibmenhtmlbody,omitempty"`

	// The subject of the notification.
	Subject *string `json:"subject,omitempty"`

	// Stringified MMS Attachment JSON.
	Ibmenmms *string `json:"ibmenmms,omitempty"`

	// The payload for webhook notification.
	Data map[string]interface{} `json:"data,omitempty"`

	// The notification content type.
	Datacontenttype *string `json:"datacontenttype,omitempty"`

	// If platforms or tags or user_ids is used then do not use fcm_devices / apns_devices / chrome_devices /
	// firefox_devices / safari_devices with it. Value should be stringified.
	Ibmenpushto *string `json:"ibmenpushto,omitempty"`

	// Payload describing a notification FCM body. Value should be stringified.
	Ibmenfcmbody *string `json:"ibmenfcmbody,omitempty"`

	// Payload describing a notification APNs body. Value should be stringified.
	Ibmenapnsbody *string `json:"ibmenapnsbody,omitempty"`

	// Headers for iOS notification. Value should be stringified.
	Ibmenapnsheaders *string `json:"ibmenapnsheaders,omitempty"`

	// Notification payload for Chrome. Value should be stringified.
	Ibmenchromebody *string `json:"ibmenchromebody,omitempty"`

	// Headers for a Chrome notification. Value should be stringified.
	Ibmenchromeheaders *string `json:"ibmenchromeheaders,omitempty"`

	// Notification payload for Firefox. Value should be stringified.
	Ibmenfirefoxbody *string `json:"ibmenfirefoxbody,omitempty"`

	// Headers for a Firefox notification. Value should be stringified.
	Ibmenfirefoxheaders *string `json:"ibmenfirefoxheaders,omitempty"`

	// Payload describing a notification Huawei body. Value should be stringified.
	Ibmenhuaweibody *string `json:"ibmenhuaweibody,omitempty"`

	// Payload describing a notification Safari body. Value should be stringified.
	Ibmensafaribody *string `json:"ibmensafaribody,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// NewNotificationCreate : Instantiate NotificationCreate (Generic Model Constructor)
func (*EventNotificationsV1) NewNotificationCreate(specversion string, id string, source string, typeVar string, ibmensourceid string, ibmendefaultshort string, ibmendefaultlong string) (_model *NotificationCreate, err error) {
	_model = &NotificationCreate{
		Specversion:       core.StringPtr(specversion),
		ID:                core.StringPtr(id),
		Source:            core.StringPtr(source),
		Type:              core.StringPtr(typeVar),
		Ibmensourceid:     core.StringPtr(ibmensourceid),
		Ibmendefaultshort: core.StringPtr(ibmendefaultshort),
		Ibmendefaultlong:  core.StringPtr(ibmendefaultlong),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// SetProperty allows the user to set an arbitrary property on an instance of NotificationCreate
func (o *NotificationCreate) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of NotificationCreate
func (o *NotificationCreate) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of NotificationCreate
func (o *NotificationCreate) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of NotificationCreate
func (o *NotificationCreate) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of NotificationCreate
func (o *NotificationCreate) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Specversion != nil {
		m["specversion"] = o.Specversion
	}
	if o.Time != nil {
		m["time"] = o.Time
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Source != nil {
		m["source"] = o.Source
	}
	if o.Type != nil {
		m["type"] = o.Type
	}
	if o.Ibmenseverity != nil {
		m["ibmenseverity"] = o.Ibmenseverity
	}
	if o.Ibmensourceid != nil {
		m["ibmensourceid"] = o.Ibmensourceid
	}
	if o.Ibmendefaultshort != nil {
		m["ibmendefaultshort"] = o.Ibmendefaultshort
	}
	if o.Ibmendefaultlong != nil {
		m["ibmendefaultlong"] = o.Ibmendefaultlong
	}
	if o.Ibmensubject != nil {
		m["ibmensubject"] = o.Ibmensubject
	}
	if o.Ibmentemplates != nil {
		m["ibmentemplates"] = o.Ibmentemplates
	}
	if o.Ibmenmailto != nil {
		m["ibmenmailto"] = o.Ibmenmailto
	}
	if o.Ibmenslackto != nil {
		m["ibmenslackto"] = o.Ibmenslackto
	}
	if o.Ibmensmsto != nil {
		m["ibmensmsto"] = o.Ibmensmsto
	}
	if o.Ibmenhtmlbody != nil {
		m["ibmenhtmlbody"] = o.Ibmenhtmlbody
	}
	if o.Subject != nil {
		m["subject"] = o.Subject
	}
	if o.Ibmenmms != nil {
		m["ibmenmms"] = o.Ibmenmms
	}
	if o.Data != nil {
		m["data"] = o.Data
	}
	if o.Datacontenttype != nil {
		m["datacontenttype"] = o.Datacontenttype
	}
	if o.Ibmenpushto != nil {
		m["ibmenpushto"] = o.Ibmenpushto
	}
	if o.Ibmenfcmbody != nil {
		m["ibmenfcmbody"] = o.Ibmenfcmbody
	}
	if o.Ibmenapnsbody != nil {
		m["ibmenapnsbody"] = o.Ibmenapnsbody
	}
	if o.Ibmenapnsheaders != nil {
		m["ibmenapnsheaders"] = o.Ibmenapnsheaders
	}
	if o.Ibmenchromebody != nil {
		m["ibmenchromebody"] = o.Ibmenchromebody
	}
	if o.Ibmenchromeheaders != nil {
		m["ibmenchromeheaders"] = o.Ibmenchromeheaders
	}
	if o.Ibmenfirefoxbody != nil {
		m["ibmenfirefoxbody"] = o.Ibmenfirefoxbody
	}
	if o.Ibmenfirefoxheaders != nil {
		m["ibmenfirefoxheaders"] = o.Ibmenfirefoxheaders
	}
	if o.Ibmenhuaweibody != nil {
		m["ibmenhuaweibody"] = o.Ibmenhuaweibody
	}
	if o.Ibmensafaribody != nil {
		m["ibmensafaribody"] = o.Ibmensafaribody
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalNotificationCreate unmarshals an instance of NotificationCreate from the specified map of raw messages.
func UnmarshalNotificationCreate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationCreate)
	err = core.UnmarshalPrimitive(m, "specversion", &obj.Specversion)
	if err != nil {
		return
	}
	delete(m, "specversion")
	err = core.UnmarshalPrimitive(m, "time", &obj.Time)
	if err != nil {
		return
	}
	delete(m, "time")
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	delete(m, "source")
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	delete(m, "type")
	err = core.UnmarshalPrimitive(m, "ibmenseverity", &obj.Ibmenseverity)
	if err != nil {
		return
	}
	delete(m, "ibmenseverity")
	err = core.UnmarshalPrimitive(m, "ibmensourceid", &obj.Ibmensourceid)
	if err != nil {
		return
	}
	delete(m, "ibmensourceid")
	err = core.UnmarshalPrimitive(m, "ibmendefaultshort", &obj.Ibmendefaultshort)
	if err != nil {
		return
	}
	delete(m, "ibmendefaultshort")
	err = core.UnmarshalPrimitive(m, "ibmendefaultlong", &obj.Ibmendefaultlong)
	if err != nil {
		return
	}
	delete(m, "ibmendefaultlong")
	err = core.UnmarshalPrimitive(m, "ibmensubject", &obj.Ibmensubject)
	if err != nil {
		return
	}
	delete(m, "ibmensubject")
	err = core.UnmarshalPrimitive(m, "ibmentemplates", &obj.Ibmentemplates)
	if err != nil {
		return
	}
	delete(m, "ibmentemplates")
	err = core.UnmarshalPrimitive(m, "ibmenmailto", &obj.Ibmenmailto)
	if err != nil {
		return
	}
	delete(m, "ibmenmailto")
	err = core.UnmarshalPrimitive(m, "ibmenslackto", &obj.Ibmenslackto)
	if err != nil {
		return
	}
	delete(m, "ibmenslackto")
	err = core.UnmarshalPrimitive(m, "ibmensmsto", &obj.Ibmensmsto)
	if err != nil {
		return
	}
	delete(m, "ibmensmsto")
	err = core.UnmarshalPrimitive(m, "ibmenhtmlbody", &obj.Ibmenhtmlbody)
	if err != nil {
		return
	}
	delete(m, "ibmenhtmlbody")
	err = core.UnmarshalPrimitive(m, "subject", &obj.Subject)
	if err != nil {
		return
	}
	delete(m, "subject")
	err = core.UnmarshalPrimitive(m, "ibmenmms", &obj.Ibmenmms)
	if err != nil {
		return
	}
	delete(m, "ibmenmms")
	err = core.UnmarshalPrimitive(m, "data", &obj.Data)
	if err != nil {
		return
	}
	delete(m, "data")
	err = core.UnmarshalPrimitive(m, "datacontenttype", &obj.Datacontenttype)
	if err != nil {
		return
	}
	delete(m, "datacontenttype")
	err = core.UnmarshalPrimitive(m, "ibmenpushto", &obj.Ibmenpushto)
	if err != nil {
		return
	}
	delete(m, "ibmenpushto")
	err = core.UnmarshalPrimitive(m, "ibmenfcmbody", &obj.Ibmenfcmbody)
	if err != nil {
		return
	}
	delete(m, "ibmenfcmbody")
	err = core.UnmarshalPrimitive(m, "ibmenapnsbody", &obj.Ibmenapnsbody)
	if err != nil {
		return
	}
	delete(m, "ibmenapnsbody")
	err = core.UnmarshalPrimitive(m, "ibmenapnsheaders", &obj.Ibmenapnsheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenapnsheaders")
	err = core.UnmarshalPrimitive(m, "ibmenchromebody", &obj.Ibmenchromebody)
	if err != nil {
		return
	}
	delete(m, "ibmenchromebody")
	err = core.UnmarshalPrimitive(m, "ibmenchromeheaders", &obj.Ibmenchromeheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenchromeheaders")
	err = core.UnmarshalPrimitive(m, "ibmenfirefoxbody", &obj.Ibmenfirefoxbody)
	if err != nil {
		return
	}
	delete(m, "ibmenfirefoxbody")
	err = core.UnmarshalPrimitive(m, "ibmenfirefoxheaders", &obj.Ibmenfirefoxheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenfirefoxheaders")
	err = core.UnmarshalPrimitive(m, "ibmenhuaweibody", &obj.Ibmenhuaweibody)
	if err != nil {
		return
	}
	delete(m, "ibmenhuaweibody")
	err = core.UnmarshalPrimitive(m, "ibmensafaribody", &obj.Ibmensafaribody)
	if err != nil {
		return
	}
	delete(m, "ibmensafaribody")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationResponse : Payload describing a notifications response.
type NotificationResponse struct {
	// Notification ID.
	NotificationID *string `json:"notification_id,omitempty"`
}

// UnmarshalNotificationResponse unmarshals an instance of NotificationResponse from the specified map of raw messages.
func UnmarshalNotificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationResponse)
	err = core.UnmarshalPrimitive(m, "notification_id", &obj.NotificationID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PageHrefResponse : Response having URL of the page.
type PageHrefResponse struct {
	// URL to the page.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPageHrefResponse unmarshals an instance of PageHrefResponse from the specified map of raw messages.
func UnmarshalPageHrefResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PageHrefResponse)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceIntegrationOptions : The ReplaceIntegration options.
type ReplaceIntegrationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for integration.
	ID *string `json:"id" validate:"required,ne="`

	// Integration type. Allowed values are kms and hs-crypto.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationMetadata `json:"metadata" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceIntegrationOptions : Instantiate ReplaceIntegrationOptions
func (*EventNotificationsV1) NewReplaceIntegrationOptions(instanceID string, id string, typeVar string, metadata *IntegrationMetadata) *ReplaceIntegrationOptions {
	return &ReplaceIntegrationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		Type:       core.StringPtr(typeVar),
		Metadata:   metadata,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceIntegrationOptions) SetInstanceID(instanceID string) *ReplaceIntegrationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceIntegrationOptions) SetID(id string) *ReplaceIntegrationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *ReplaceIntegrationOptions) SetType(typeVar string) *ReplaceIntegrationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetMetadata : Allow user to set Metadata
func (_options *ReplaceIntegrationOptions) SetMetadata(metadata *IntegrationMetadata) *ReplaceIntegrationOptions {
	_options.Metadata = metadata
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceIntegrationOptions) SetHeaders(param map[string]string) *ReplaceIntegrationOptions {
	options.Headers = param
	return options
}

// ReplaceTemplateOptions : The ReplaceTemplate options.
type ReplaceTemplateOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Template.
	ID *string `json:"id" validate:"required,ne="`

	// Template name.
	Name *string `json:"name,omitempty"`

	// Template description.
	Description *string `json:"description,omitempty"`

	// The type of template.
	Type *string `json:"type,omitempty"`

	Params TemplateConfigOneOfIntf `json:"params,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTemplateOptions : Instantiate ReplaceTemplateOptions
func (*EventNotificationsV1) NewReplaceTemplateOptions(instanceID string, id string) *ReplaceTemplateOptions {
	return &ReplaceTemplateOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceTemplateOptions) SetInstanceID(instanceID string) *ReplaceTemplateOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTemplateOptions) SetID(id string) *ReplaceTemplateOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *ReplaceTemplateOptions) SetName(name string) *ReplaceTemplateOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *ReplaceTemplateOptions) SetDescription(description string) *ReplaceTemplateOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetType : Allow user to set Type
func (_options *ReplaceTemplateOptions) SetType(typeVar string) *ReplaceTemplateOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetParams : Allow user to set Params
func (_options *ReplaceTemplateOptions) SetParams(params TemplateConfigOneOfIntf) *ReplaceTemplateOptions {
	_options.Params = params
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTemplateOptions) SetHeaders(param map[string]string) *ReplaceTemplateOptions {
	options.Headers = param
	return options
}

// ReplaceTopicOptions : The ReplaceTopic options.
type ReplaceTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name,omitempty"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []SourcesItems `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTopicOptions : Instantiate ReplaceTopicOptions
func (*EventNotificationsV1) NewReplaceTopicOptions(instanceID string, id string) *ReplaceTopicOptions {
	return &ReplaceTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceTopicOptions) SetInstanceID(instanceID string) *ReplaceTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTopicOptions) SetID(id string) *ReplaceTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *ReplaceTopicOptions) SetName(name string) *ReplaceTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *ReplaceTopicOptions) SetDescription(description string) *ReplaceTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *ReplaceTopicOptions) SetSources(sources []SourcesItems) *ReplaceTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTopicOptions) SetHeaders(param map[string]string) *ReplaceTopicOptions {
	options.Headers = param
	return options
}

// Rules : Rule object.
type Rules struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter,omitempty"`
}

// NewRules : Instantiate Rules (Generic Model Constructor)
func (*EventNotificationsV1) NewRules(eventTypeFilter string) (_model *Rules, err error) {
	_model = &Rules{
		EventTypeFilter: core.StringPtr(eventTypeFilter),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalRules unmarshals an instance of Rules from the specified map of raw messages.
func UnmarshalRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Rules)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RulesGet : Rule object.
type RulesGet struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Autogenerated rule ID.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalRulesGet unmarshals an instance of RulesGet from the specified map of raw messages.
func UnmarshalRulesGet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RulesGet)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SmsAttributesItems : The sms attributes.
type SmsAttributesItems struct {
	// Phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalSmsAttributesItems unmarshals an instance of SmsAttributesItems from the specified map of raw messages.
func UnmarshalSmsAttributesItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SmsAttributesItems)
	err = core.UnmarshalPrimitive(m, "phone_number", &obj.PhoneNumber)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SmsCountryConfig : Payload describing a country Configuration.
type SmsCountryConfig struct {
	// Phone number.
	Number *string `json:"number" validate:"required"`

	// List of Countries.
	Country []string `json:"country" validate:"required"`
}

// UnmarshalSmsCountryConfig unmarshals an instance of SmsCountryConfig from the specified map of raw messages.
func UnmarshalSmsCountryConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SmsCountryConfig)
	err = core.UnmarshalPrimitive(m, "number", &obj.Number)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "country", &obj.Country)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SmsInviteAttributesItems : The sms attributes.
type SmsInviteAttributesItems struct {
	// Phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// time of expiration.
	ExpiresAt *strfmt.DateTime `json:"expires_at,omitempty"`
}

// UnmarshalSmsInviteAttributesItems unmarshals an instance of SmsInviteAttributesItems from the specified map of raw messages.
func UnmarshalSmsInviteAttributesItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SmsInviteAttributesItems)
	err = core.UnmarshalPrimitive(m, "phone_number", &obj.PhoneNumber)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires_at", &obj.ExpiresAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPAllowedIPs : Payload describing a SMTP allowed Ips.
type SMTPAllowedIPs struct {
	// The SMTP allowed Ips.
	Subnets []string `json:"subnets" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalSMTPAllowedIPs unmarshals an instance of SMTPAllowedIPs from the specified map of raw messages.
func UnmarshalSMTPAllowedIPs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPAllowedIPs)
	err = core.UnmarshalPrimitive(m, "subnets", &obj.Subnets)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPConfig : Payload describing a SMTP configuration.
type SMTPConfig struct {
	// The SMTP DKIM attributes.
	Dkim *SmtpdkimAttributes `json:"dkim,omitempty"`

	// The en_authorization attributes.
	EnAuthorization *EnAuthAttributes `json:"en_authorization,omitempty"`

	// The SPF attributes.
	Spf *SpfAttributes `json:"spf,omitempty"`
}

// UnmarshalSMTPConfig unmarshals an instance of SMTPConfig from the specified map of raw messages.
func UnmarshalSMTPConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPConfig)
	err = core.UnmarshalModel(m, "dkim", &obj.Dkim, UnmarshalSmtpdkimAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "en_authorization", &obj.EnAuthorization, UnmarshalEnAuthAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "spf", &obj.Spf, UnmarshalSpfAttributes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPConfiguration : Payload describing a SMTP List response.
type SMTPConfiguration struct {
	// SMTP ID.
	ID *string `json:"id" validate:"required"`

	// SMTP name.
	Name *string `json:"name" validate:"required"`

	// SMTP description.
	Description *string `json:"description,omitempty"`

	// Domain Name.
	Domain *string `json:"domain" validate:"required"`

	// Payload describing a SMTP configuration.
	Config *SMTPConfig `json:"config" validate:"required"`

	// Created time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalSMTPConfiguration unmarshals an instance of SMTPConfiguration from the specified map of raw messages.
func UnmarshalSMTPConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPConfiguration)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalSMTPConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPConfigurationsList : Payload describing a SMTP Configurations list.
type SMTPConfigurationsList struct {
	// Total number of SMTP configurations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show configurations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of SMTP Configurations.
	SMTPConfigurations []SMTPConfiguration `json:"smtp_configurations" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalSMTPConfigurationsList unmarshals an instance of SMTPConfigurationsList from the specified map of raw messages.
func UnmarshalSMTPConfigurationsList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPConfigurationsList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "smtp_configurations", &obj.SMTPConfigurations, UnmarshalSMTPConfiguration)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SMTPConfigurationsList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// SMTPCreateResponse : Payload describing a SMTP create response.
type SMTPCreateResponse struct {
	// SMTP ID.
	ID *string `json:"id" validate:"required"`

	// SMTP name.
	Name *string `json:"name" validate:"required"`

	// SMTP description.
	Description *string `json:"description,omitempty"`

	// Domain Name.
	Domain *string `json:"domain" validate:"required"`

	// Payload describing a SMTP configuration.
	Config *SMTPConfig `json:"config" validate:"required"`

	// Created time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalSMTPCreateResponse unmarshals an instance of SMTPCreateResponse from the specified map of raw messages.
func UnmarshalSMTPCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPCreateResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalSMTPConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SmtpdkimAttributes : The SMTP DKIM attributes.
type SmtpdkimAttributes struct {
	// DKIM text name.
	TxtName *string `json:"txt_name,omitempty"`

	// DKIM text value.
	TxtValue *string `json:"txt_value,omitempty"`

	// DKIM verification.
	Verification *string `json:"verification,omitempty"`
}

// UnmarshalSmtpdkimAttributes unmarshals an instance of SmtpdkimAttributes from the specified map of raw messages.
func UnmarshalSmtpdkimAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SmtpdkimAttributes)
	err = core.UnmarshalPrimitive(m, "txt_name", &obj.TxtName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "txt_value", &obj.TxtValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verification", &obj.Verification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPUser : Payload describing a SMTP User.
type SMTPUser struct {
	// Id.
	ID *string `json:"id" validate:"required"`

	// SMTP confg Id.
	SMTPConfigID *string `json:"smtp_config_id" validate:"required"`

	// SMTP User description.
	Description *string `json:"description" validate:"required"`

	// Domain Name.
	Domain *string `json:"domain" validate:"required"`

	// SMTP user name.
	Username *string `json:"username" validate:"required"`

	// Updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalSMTPUser unmarshals an instance of SMTPUser from the specified map of raw messages.
func UnmarshalSMTPUser(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPUser)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "smtp_config_id", &obj.SMTPConfigID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPUserResponse : Payload describing a SMTP User create response.
type SMTPUserResponse struct {
	// SMTP Id.
	ID *string `json:"id" validate:"required"`

	// SMTP User description.
	Description *string `json:"description,omitempty"`

	// Domain Name.
	Domain *string `json:"domain,omitempty"`

	// SMTP confg Id.
	SMTPConfigID *string `json:"smtp_config_id" validate:"required"`

	// SMTP user name.
	Username *string `json:"username" validate:"required"`

	// password.
	Password *string `json:"password" validate:"required"`

	// Created time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalSMTPUserResponse unmarshals an instance of SMTPUserResponse from the specified map of raw messages.
func UnmarshalSMTPUserResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPUserResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "smtp_config_id", &obj.SMTPConfigID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPUsersList : Payload describing a SMTP users list request.
type SMTPUsersList struct {
	// Total number of destinations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destinations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of users.
	Users []SMTPUser `json:"users" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalSMTPUsersList unmarshals an instance of SMTPUsersList from the specified map of raw messages.
func UnmarshalSMTPUsersList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPUsersList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "users", &obj.Users, UnmarshalSMTPUser)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SMTPUsersList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// SMTPVerificationResponse : verification object.
type SMTPVerificationResponse struct {
	// verification type.
	Type *string `json:"type" validate:"required"`

	// verification status.
	Verification *string `json:"verification" validate:"required"`
}

// UnmarshalSMTPVerificationResponse unmarshals an instance of SMTPVerificationResponse from the specified map of raw messages.
func UnmarshalSMTPVerificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPVerificationResponse)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verification", &obj.Verification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SMTPVerificationUpdateResponse : Payload describing SMTP verification response.
type SMTPVerificationUpdateResponse struct {
	// SMTP verification status.
	Status []SMTPVerificationResponse `json:"status" validate:"required"`
}

// UnmarshalSMTPVerificationUpdateResponse unmarshals an instance of SMTPVerificationUpdateResponse from the specified map of raw messages.
func UnmarshalSMTPVerificationUpdateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SMTPVerificationUpdateResponse)
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalSMTPVerificationResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SpfAttributes : The SPF attributes.
type SpfAttributes struct {
	// spf text name.
	TxtName *string `json:"txt_name,omitempty"`

	// spf text value.
	TxtValue *string `json:"txt_value,omitempty"`

	// spf verification.
	Verification *string `json:"verification,omitempty"`
}

// UnmarshalSpfAttributes unmarshals an instance of SpfAttributes from the specified map of raw messages.
func UnmarshalSpfAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SpfAttributes)
	err = core.UnmarshalPrimitive(m, "txt_name", &obj.TxtName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "txt_value", &obj.TxtValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verification", &obj.Verification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SendNotificationsOptions : The SendNotifications options.
type SendNotificationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Payload describing a notification create request.
	Body *NotificationCreate `json:"body,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSendNotificationsOptions : Instantiate SendNotificationsOptions
func (*EventNotificationsV1) NewSendNotificationsOptions(instanceID string) *SendNotificationsOptions {
	return &SendNotificationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *SendNotificationsOptions) SetInstanceID(instanceID string) *SendNotificationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *SendNotificationsOptions) SetBody(body *NotificationCreate) *SendNotificationsOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SendNotificationsOptions) SetHeaders(param map[string]string) *SendNotificationsOptions {
	options.Headers = param
	return options
}

// Source : Payload describing a source generate request.
type Source struct {
	// The id of the source.
	ID *string `json:"id" validate:"required"`

	// The name of the source.
	Name *string `json:"name" validate:"required"`

	// The description of the source.
	Description *string `json:"description" validate:"required"`

	// The status of the source.
	Enabled *bool `json:"enabled" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// The last updated time of the source.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`

	// The names of the topics.
	TopicNames []string `json:"topic_names" validate:"required"`
}

// UnmarshalSource unmarshals an instance of Source from the specified map of raw messages.
func UnmarshalSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Source)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_names", &obj.TopicNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceList : Payload describing a source list request.
type SourceList struct {
	// Number of sources.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show sources.
	Limit *int64 `json:"limit" validate:"required"`

	// List of sources.
	Sources []SourceListItem `json:"sources" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalSourceList unmarshals an instance of SourceList from the specified map of raw messages.
func UnmarshalSourceList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourceListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SourceList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// SourceListItem : Payload describing a source list item.
type SourceListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the last update.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`
}

// UnmarshalSourceListItem unmarshals an instance of SourceListItem from the specified map of raw messages.
func UnmarshalSourceListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceResponse : Payload describing a source.
type SourceResponse struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalSourceResponse unmarshals an instance of SourceResponse from the specified map of raw messages.
func UnmarshalSourceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesItems : SourcesItems struct
type SourcesItems struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// List of rules.
	Rules []Rules `json:"rules" validate:"required"`
}

// NewSourcesItems : Instantiate SourcesItems (Generic Model Constructor)
func (*EventNotificationsV1) NewSourcesItems(id string, rules []Rules) (_model *SourcesItems, err error) {
	_model = &SourcesItems{
		ID:    core.StringPtr(id),
		Rules: rules,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalSourcesItems unmarshals an instance of SourcesItems from the specified map of raw messages.
func UnmarshalSourcesItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesItems)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRules)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesListItems : Payload describing a source list item.
type SourcesListItems struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// List of rules.
	Rules []RulesGet `json:"rules,omitempty"`
}

// UnmarshalSourcesListItems unmarshals an instance of SourcesListItems from the specified map of raw messages.
func UnmarshalSourcesListItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesListItems)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRulesGet)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subscription : Subscription object.
type Subscription struct {
	// Subscription ID.
	ID *string `json:"id" validate:"required"`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Subscription description.
	Description *string `json:"description" validate:"required"`

	// Last updated time.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// From Email ID (it will be displayed only in case of smtp_ibm destination type).
	From *string `json:"from,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// The destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// The destination name.
	DestinationName *string `json:"destination_name" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Topic name.
	TopicName *string `json:"topic_name" validate:"required"`

	Attributes SubscriptionAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the Subscription.DestinationType property.
// The type of destination.
const (
	SubscriptionDestinationTypeIbmceConst       = "ibmce"
	SubscriptionDestinationTypeIbmcfConst       = "ibmcf"
	SubscriptionDestinationTypeIbmcosConst      = "ibmcos"
	SubscriptionDestinationTypeMsteamsConst     = "msteams"
	SubscriptionDestinationTypePagerdutyConst   = "pagerduty"
	SubscriptionDestinationTypePushAndroidConst = "push_android"
	SubscriptionDestinationTypePushChromeConst  = "push_chrome"
	SubscriptionDestinationTypePushFirefoxConst = "push_firefox"
	SubscriptionDestinationTypePushHuaweiConst  = "push_huawei"
	SubscriptionDestinationTypePushIosConst     = "push_ios"
	SubscriptionDestinationTypePushSafariConst  = "push_safari"
	SubscriptionDestinationTypeSMTPCustomConst  = "smtp_custom"
	SubscriptionDestinationTypeSMTPIBMConst     = "smtp_ibm"
	SubscriptionDestinationTypeServicenowConst  = "servicenow"
	SubscriptionDestinationTypeSlackConst       = "slack"
	SubscriptionDestinationTypeSmsCustomConst   = "sms_custom"
	SubscriptionDestinationTypeSmsIBMConst      = "sms_ibm"
	SubscriptionDestinationTypeWebhookConst     = "webhook"
)

// SetProperty allows the user to set an arbitrary property on an instance of Subscription
func (o *Subscription) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Subscription
func (o *Subscription) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Subscription
func (o *Subscription) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Subscription
func (o *Subscription) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Subscription
func (o *Subscription) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Description != nil {
		m["description"] = o.Description
	}
	if o.UpdatedAt != nil {
		m["updated_at"] = o.UpdatedAt
	}
	if o.From != nil {
		m["from"] = o.From
	}
	if o.DestinationType != nil {
		m["destination_type"] = o.DestinationType
	}
	if o.DestinationID != nil {
		m["destination_id"] = o.DestinationID
	}
	if o.DestinationName != nil {
		m["destination_name"] = o.DestinationName
	}
	if o.TopicID != nil {
		m["topic_id"] = o.TopicID
	}
	if o.TopicName != nil {
		m["topic_name"] = o.TopicName
	}
	if o.Attributes != nil {
		m["attributes"] = o.Attributes
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscription unmarshals an instance of Subscription from the specified map of raw messages.
func UnmarshalSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subscription)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	delete(m, "description")
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	delete(m, "updated_at")
	err = core.UnmarshalPrimitive(m, "from", &obj.From)
	if err != nil {
		return
	}
	delete(m, "from")
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	delete(m, "destination_type")
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	delete(m, "destination_id")
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	delete(m, "destination_name")
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	delete(m, "topic_id")
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	delete(m, "topic_name")
	err = core.UnmarshalModel(m, "attributes", &obj.Attributes, UnmarshalSubscriptionAttributes)
	if err != nil {
		return
	}
	delete(m, "attributes")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributes : SubscriptionAttributes struct
// Models which "extend" this model:
// - SubscriptionAttributesSmsAttributesResponse
// - SubscriptionAttributesCustomSmsAttributesResponse
// - SubscriptionAttributesEmailAttributesResponse
// - SubscriptionAttributesCustomEmailAttributesResponse
// - SubscriptionAttributesWebhookAttributesResponse
// - SubscriptionAttributesSlackAttributesResponse
// - SubscriptionAttributesSlackDirectMessageAttributesResponse
// - SubscriptionAttributesServiceNowAttributesResponse
type SubscriptionAttributes struct {
	// The subscribed list.
	Subscribed []SmsAttributesItems `json:"subscribed,omitempty"`

	// The unsubscribe list.
	Unsubscribed []SmsAttributesItems `json:"unsubscribed,omitempty"`

	// The SMS numder string.
	Invited []SmsInviteAttributesItems `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// The email from.
	FromEmail *string `json:"from_email,omitempty"`

	// The templete id for notification.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// The templete id for invitation.
	TemplateIDInvitation *string `json:"template_id_invitation,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for Slack Notification.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// List of channels.
	Channels []ChannelCreateAttributes `json:"channels,omitempty"`

	// Assigned name from ServiceNow account.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Assigned group name from ServiceNow account.
	AssignmentGroup *string `json:"assignment_group,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributes) isaSubscriptionAttributes() bool {
	return true
}

type SubscriptionAttributesIntf interface {
	isaSubscriptionAttributes() bool
	SetProperty(key string, value interface{})
	SetProperties(m map[string]interface{})
	GetProperty(key string) interface{}
	GetProperties() map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributes
func (o *SubscriptionAttributes) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	if o.ReplyToMail != nil {
		m["reply_to_mail"] = o.ReplyToMail
	}
	if o.ReplyToName != nil {
		m["reply_to_name"] = o.ReplyToName
	}
	if o.FromName != nil {
		m["from_name"] = o.FromName
	}
	if o.FromEmail != nil {
		m["from_email"] = o.FromEmail
	}
	if o.TemplateIDNotification != nil {
		m["template_id_notification"] = o.TemplateIDNotification
	}
	if o.TemplateIDInvitation != nil {
		m["template_id_invitation"] = o.TemplateIDInvitation
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AttachmentColor != nil {
		m["attachment_color"] = o.AttachmentColor
	}
	if o.Channels != nil {
		m["channels"] = o.Channels
	}
	if o.AssignedTo != nil {
		m["assigned_to"] = o.AssignedTo
	}
	if o.AssignmentGroup != nil {
		m["assignment_group"] = o.AssignmentGroup
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributes unmarshals an instance of SubscriptionAttributes from the specified map of raw messages.
func UnmarshalSubscriptionAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributes)
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalSmsInviteAttributesItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	delete(m, "reply_to_mail")
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	delete(m, "reply_to_name")
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	delete(m, "from_name")
	err = core.UnmarshalPrimitive(m, "from_email", &obj.FromEmail)
	if err != nil {
		return
	}
	delete(m, "from_email")
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	delete(m, "template_id_notification")
	err = core.UnmarshalPrimitive(m, "template_id_invitation", &obj.TemplateIDInvitation)
	if err != nil {
		return
	}
	delete(m, "template_id_invitation")
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	delete(m, "attachment_color")
	err = core.UnmarshalModel(m, "channels", &obj.Channels, UnmarshalChannelCreateAttributes)
	if err != nil {
		return
	}
	delete(m, "channels")
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	delete(m, "assigned_to")
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	delete(m, "assignment_group")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributes : SubscriptionCreateAttributes struct
// Models which "extend" this model:
// - SubscriptionCreateAttributesSmsAttributes
// - SubscriptionCreateAttributesEmailAttributes
// - SubscriptionCreateAttributesCustomSmsAttributes
// - SubscriptionCreateAttributesCustomEmailAttributes
// - SubscriptionCreateAttributesWebhookAttributes
// - SubscriptionCreateAttributesFcmAttributes
// - SubscriptionCreateAttributesSlackAttributes
// - SubscriptionCreateAttributesSlackDirectMessageAttributes
// - SubscriptionCreateAttributesServiceNowAttributes
type SubscriptionCreateAttributes struct {
	// The sms id string.
	Invited []string `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// The email from.
	FromEmail *string `json:"from_email,omitempty"`

	// The templete id for notification.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// The templete id for invitation.
	TemplateIDInvitation *string `json:"template_id_invitation,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// List of channels.
	Channels []ChannelCreateAttributes `json:"channels,omitempty"`

	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionCreateAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

type SubscriptionCreateAttributesIntf interface {
	isaSubscriptionCreateAttributes() bool
}

// UnmarshalSubscriptionCreateAttributes unmarshals an instance of SubscriptionCreateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_email", &obj.FromEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_invitation", &obj.TemplateIDInvitation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "channels", &obj.Channels, UnmarshalChannelCreateAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionList : Subscription list object.
type SubscriptionList struct {
	// Number of subscriptions.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalSubscriptionList unmarshals an instance of SubscriptionList from the specified map of raw messages.
func UnmarshalSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SubscriptionList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// SubscriptionListItem : Subscription list item.
type SubscriptionListItem struct {
	// ID of the subscription.
	ID *string `json:"id" validate:"required"`

	// Name of the subscription.
	Name *string `json:"name" validate:"required"`

	// Description of the subscription.
	Description *string `json:"description" validate:"required"`

	// ID of the destination.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Name of the destination.
	DestinationName *string `json:"destination_name,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// ID of the topic.
	TopicID *string `json:"topic_id" validate:"required"`

	// Name of the topic.
	TopicName *string `json:"topic_name,omitempty"`

	// Last updated time of the subscription.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the SubscriptionListItem.DestinationType property.
// The type of destination.
const (
	SubscriptionListItemDestinationTypeIbmceConst       = "ibmce"
	SubscriptionListItemDestinationTypeIbmcfConst       = "ibmcf"
	SubscriptionListItemDestinationTypeIbmcosConst      = "ibmcos"
	SubscriptionListItemDestinationTypeMsteamsConst     = "msteams"
	SubscriptionListItemDestinationTypePagerdutyConst   = "pagerduty"
	SubscriptionListItemDestinationTypePushAndroidConst = "push_android"
	SubscriptionListItemDestinationTypePushChromeConst  = "push_chrome"
	SubscriptionListItemDestinationTypePushFirefoxConst = "push_firefox"
	SubscriptionListItemDestinationTypePushHuaweiConst  = "push_huawei"
	SubscriptionListItemDestinationTypePushIosConst     = "push_ios"
	SubscriptionListItemDestinationTypePushSafariConst  = "push_safari"
	SubscriptionListItemDestinationTypeSMTPCustomConst  = "smtp_custom"
	SubscriptionListItemDestinationTypeSMTPIBMConst     = "smtp_ibm"
	SubscriptionListItemDestinationTypeServicenowConst  = "servicenow"
	SubscriptionListItemDestinationTypeSlackConst       = "slack"
	SubscriptionListItemDestinationTypeSmsCustomConst   = "sms_custom"
	SubscriptionListItemDestinationTypeSmsIBMConst      = "sms_ibm"
	SubscriptionListItemDestinationTypeWebhookConst     = "webhook"
)

// UnmarshalSubscriptionListItem unmarshals an instance of SubscriptionListItem from the specified map of raw messages.
func UnmarshalSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributes : SubscriptionUpdateAttributes struct
// Models which "extend" this model:
// - SubscriptionUpdateAttributesSmsUpdateAttributes
// - SubscriptionUpdateAttributesEmailUpdateAttributes
// - SubscriptionUpdateAttributesCustomSmsUpdateAttributes
// - SubscriptionUpdateAttributesCustomEmailUpdateAttributes
// - SubscriptionUpdateAttributesWebhookAttributes
// - SubscriptionUpdateAttributesSlackAttributes
// - SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes
// - SubscriptionUpdateAttributesServiceNowAttributes
type SubscriptionUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// The email from.
	FromEmail *string `json:"from_email,omitempty"`

	// The templete id for notification.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// The templete id for invitation.
	TemplateIDInvitation *string `json:"template_id_invitation,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// List of channels.
	Channels []ChannelUpdateAttributes `json:"channels,omitempty"`

	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

type SubscriptionUpdateAttributesIntf interface {
	isaSubscriptionUpdateAttributes() bool
}

// UnmarshalSubscriptionUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_email", &obj.FromEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_invitation", &obj.TemplateIDInvitation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "channels", &obj.Channels, UnmarshalChannelUpdateAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagsSubscriptionList : Payload describing a tags list request.
type TagsSubscriptionList struct {
	// Total number of tags.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show tags.
	Limit *int64 `json:"limit" validate:"required"`

	// List of tags.
	TagSubscriptions []TagsSubscriptionListItem `json:"tag_subscriptions" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalTagsSubscriptionList unmarshals an instance of TagsSubscriptionList from the specified map of raw messages.
func UnmarshalTagsSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tag_subscriptions", &obj.TagSubscriptions, UnmarshalTagsSubscriptionListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TagsSubscriptionList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// TagsSubscriptionListItem : Tags subscription object.
type TagsSubscriptionListItem struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalTagsSubscriptionListItem unmarshals an instance of TagsSubscriptionListItem from the specified map of raw messages.
func UnmarshalTagsSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Template : Template object.
type Template struct {
	// Template ID.
	ID *string `json:"id" validate:"required"`

	// Template name.
	Name *string `json:"name" validate:"required"`

	// Template description.
	Description *string `json:"description" validate:"required"`

	// The type of template.
	Type *string `json:"type" validate:"required"`

	// Subscription count.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// Names of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalTemplate unmarshals an instance of Template from the specified map of raw messages.
func UnmarshalTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Template)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TemplateConfigOneOf : TemplateConfigOneOf struct
// Models which "extend" this model:
// - TemplateConfigOneOfEmailTemplateConfig
// - TemplateConfigOneOfSlackTemplateConfig
type TemplateConfigOneOf struct {
	// Template body.
	Body *string `json:"body,omitempty"`

	// The template subject.
	Subject *string `json:"subject,omitempty"`
}

func (*TemplateConfigOneOf) isaTemplateConfigOneOf() bool {
	return true
}

type TemplateConfigOneOfIntf interface {
	isaTemplateConfigOneOf() bool
}

// UnmarshalTemplateConfigOneOf unmarshals an instance of TemplateConfigOneOf from the specified map of raw messages.
func UnmarshalTemplateConfigOneOf(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TemplateConfigOneOf)
	err = core.UnmarshalPrimitive(m, "body", &obj.Body)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subject", &obj.Subject)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TemplateList : Payload describing a template list request.
type TemplateList struct {
	// Total number of templates.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show templates.
	Limit *int64 `json:"limit" validate:"required"`

	// List of templates.
	Templates []Template `json:"templates" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalTemplateList unmarshals an instance of TemplateList from the specified map of raw messages.
func UnmarshalTemplateList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TemplateList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "templates", &obj.Templates, UnmarshalTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TemplateList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// TemplateResponse : Payload describing a template get request.
type TemplateResponse struct {
	// Template ID.
	ID *string `json:"id" validate:"required"`

	// Template name.
	Name *string `json:"name" validate:"required"`

	// Template description.
	Description *string `json:"description,omitempty"`

	// The type of template.
	Type *string `json:"type" validate:"required"`

	Params TemplateConfigOneOfIntf `json:"params" validate:"required"`

	// Created time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalTemplateResponse unmarshals an instance of TemplateResponse from the specified map of raw messages.
func UnmarshalTemplateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TemplateResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalTemplateConfigOneOf)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TestDestinationOptions : The TestDestination options.
type TestDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewTestDestinationOptions : Instantiate TestDestinationOptions
func (*EventNotificationsV1) NewTestDestinationOptions(instanceID string, id string) *TestDestinationOptions {
	return &TestDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *TestDestinationOptions) SetInstanceID(instanceID string) *TestDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *TestDestinationOptions) SetID(id string) *TestDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *TestDestinationOptions) SetHeaders(param map[string]string) *TestDestinationOptions {
	options.Headers = param
	return options
}

// TestDestinationResponse : Destination test object.
type TestDestinationResponse struct {
	// test destiantion status.
	Status *string `json:"status" validate:"required"`
}

// UnmarshalTestDestinationResponse unmarshals an instance of TestDestinationResponse from the specified map of raw messages.
func UnmarshalTestDestinationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TestDestinationResponse)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Topic : Topic object.
type Topic struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of sources.
	Sources []SourcesListItems `json:"sources" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalTopic unmarshals an instance of Topic from the specified map of raw messages.
func UnmarshalTopic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Topic)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourcesListItems)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicList : Topic list object.
type TopicList struct {
	// Number of topics.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of topics.
	Topics []TopicsListItem `json:"topics" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalTopicList unmarshals an instance of TopicList from the specified map of raw messages.
func UnmarshalTopicList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "topics", &obj.Topics, UnmarshalTopicsListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TopicList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// TopicResponse : Topic object.
type TopicResponse struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Last time the topic was updated.
	CreatedAt *string `json:"created_at" validate:"required"`
}

// UnmarshalTopicResponse unmarshals an instance of TopicResponse from the specified map of raw messages.
func UnmarshalTopicResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicsListItem : Topic list item object.
type TopicsListItem struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of source names.
	SourcesNames []string `json:"sources_names" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`
}

// UnmarshalTopicsListItem unmarshals an instance of TopicsListItem from the specified map of raw messages.
func UnmarshalTopicsListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicsListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sources_names", &obj.SourcesNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateAttributesInvited : The email ids or phone numbers.
type UpdateAttributesInvited struct {
	// The email ids or phone numbers to be invited.
	Add []string `json:"add,omitempty"`

	// The email ids or phone numbers for removal.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalUpdateAttributesInvited unmarshals an instance of UpdateAttributesInvited from the specified map of raw messages.
func UnmarshalUpdateAttributesInvited(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateAttributesInvited)
	err = core.UnmarshalPrimitive(m, "add", &obj.Add)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateAttributesSubscribed : The email ids or phone numbers.
type UpdateAttributesSubscribed struct {
	// The email ids or phone numbers to be unsubscribed.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalUpdateAttributesSubscribed unmarshals an instance of UpdateAttributesSubscribed from the specified map of raw messages.
func UnmarshalUpdateAttributesSubscribed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateAttributesSubscribed)
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateAttributesUnsubscribed : The email ids or phone numbers.
type UpdateAttributesUnsubscribed struct {
	// The email ids or phone numbers to be unsubscribed.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalUpdateAttributesUnsubscribed unmarshals an instance of UpdateAttributesUnsubscribed from the specified map of raw messages.
func UnmarshalUpdateAttributesUnsubscribed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateAttributesUnsubscribed)
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateDestinationOptions : The UpdateDestination options.
type UpdateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Destination name.
	Name *string `json:"name,omitempty"`

	// Destination description.
	Description *string `json:"description,omitempty"`

	// Whether to collect the failed event in Cloud Object Storage bucket.
	CollectFailedEvents *bool `json:"collect_failed_events,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Certificate for APNS.
	Certificate io.ReadCloser `json:"certificate,omitempty"`

	// The content type of certificate.
	CertificateContentType *string `json:"certificate_content_type,omitempty"`

	// Safari icon 16x16.
	Icon16x16 io.ReadCloser `json:"icon_16x16,omitempty"`

	// The content type of icon16x16.
	Icon16x16ContentType *string `json:"icon_16x16_content_type,omitempty"`

	// Safari icon 16x16@2x.
	Icon16x162x io.ReadCloser `json:"icon_16x16_2x,omitempty"`

	// The content type of icon16x162x.
	Icon16x162xContentType *string `json:"icon_16x16_2x_content_type,omitempty"`

	// Safari icon 32x32.
	Icon32x32 io.ReadCloser `json:"icon_32x32,omitempty"`

	// The content type of icon32x32.
	Icon32x32ContentType *string `json:"icon_32x32_content_type,omitempty"`

	// Safari icon 32x32@2x.
	Icon32x322x io.ReadCloser `json:"icon_32x32_2x,omitempty"`

	// The content type of icon32x322x.
	Icon32x322xContentType *string `json:"icon_32x32_2x_content_type,omitempty"`

	// Safari icon 128x128.
	Icon128x128 io.ReadCloser `json:"icon_128x128,omitempty"`

	// The content type of icon128x128.
	Icon128x128ContentType *string `json:"icon_128x128_content_type,omitempty"`

	// Safari icon 128x128@2x.
	Icon128x1282x io.ReadCloser `json:"icon_128x128_2x,omitempty"`

	// The content type of icon128x1282x.
	Icon128x1282xContentType *string `json:"icon_128x128_2x_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDestinationOptions : Instantiate UpdateDestinationOptions
func (*EventNotificationsV1) NewUpdateDestinationOptions(instanceID string, id string) *UpdateDestinationOptions {
	return &UpdateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateDestinationOptions) SetInstanceID(instanceID string) *UpdateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateDestinationOptions) SetID(id string) *UpdateDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateDestinationOptions) SetName(name string) *UpdateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateDestinationOptions) SetDescription(description string) *UpdateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetCollectFailedEvents : Allow user to set CollectFailedEvents
func (_options *UpdateDestinationOptions) SetCollectFailedEvents(collectFailedEvents bool) *UpdateDestinationOptions {
	_options.CollectFailedEvents = core.BoolPtr(collectFailedEvents)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *UpdateDestinationOptions) SetConfig(config *DestinationConfig) *UpdateDestinationOptions {
	_options.Config = config
	return _options
}

// SetCertificate : Allow user to set Certificate
func (_options *UpdateDestinationOptions) SetCertificate(certificate io.ReadCloser) *UpdateDestinationOptions {
	_options.Certificate = certificate
	return _options
}

// SetCertificateContentType : Allow user to set CertificateContentType
func (_options *UpdateDestinationOptions) SetCertificateContentType(certificateContentType string) *UpdateDestinationOptions {
	_options.CertificateContentType = core.StringPtr(certificateContentType)
	return _options
}

// SetIcon16x16 : Allow user to set Icon16x16
func (_options *UpdateDestinationOptions) SetIcon16x16(icon16x16 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon16x16 = icon16x16
	return _options
}

// SetIcon16x16ContentType : Allow user to set Icon16x16ContentType
func (_options *UpdateDestinationOptions) SetIcon16x16ContentType(icon16x16ContentType string) *UpdateDestinationOptions {
	_options.Icon16x16ContentType = core.StringPtr(icon16x16ContentType)
	return _options
}

// SetIcon16x162x : Allow user to set Icon16x162x
func (_options *UpdateDestinationOptions) SetIcon16x162x(icon16x162x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon16x162x = icon16x162x
	return _options
}

// SetIcon16x162xContentType : Allow user to set Icon16x162xContentType
func (_options *UpdateDestinationOptions) SetIcon16x162xContentType(icon16x162xContentType string) *UpdateDestinationOptions {
	_options.Icon16x162xContentType = core.StringPtr(icon16x162xContentType)
	return _options
}

// SetIcon32x32 : Allow user to set Icon32x32
func (_options *UpdateDestinationOptions) SetIcon32x32(icon32x32 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon32x32 = icon32x32
	return _options
}

// SetIcon32x32ContentType : Allow user to set Icon32x32ContentType
func (_options *UpdateDestinationOptions) SetIcon32x32ContentType(icon32x32ContentType string) *UpdateDestinationOptions {
	_options.Icon32x32ContentType = core.StringPtr(icon32x32ContentType)
	return _options
}

// SetIcon32x322x : Allow user to set Icon32x322x
func (_options *UpdateDestinationOptions) SetIcon32x322x(icon32x322x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon32x322x = icon32x322x
	return _options
}

// SetIcon32x322xContentType : Allow user to set Icon32x322xContentType
func (_options *UpdateDestinationOptions) SetIcon32x322xContentType(icon32x322xContentType string) *UpdateDestinationOptions {
	_options.Icon32x322xContentType = core.StringPtr(icon32x322xContentType)
	return _options
}

// SetIcon128x128 : Allow user to set Icon128x128
func (_options *UpdateDestinationOptions) SetIcon128x128(icon128x128 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon128x128 = icon128x128
	return _options
}

// SetIcon128x128ContentType : Allow user to set Icon128x128ContentType
func (_options *UpdateDestinationOptions) SetIcon128x128ContentType(icon128x128ContentType string) *UpdateDestinationOptions {
	_options.Icon128x128ContentType = core.StringPtr(icon128x128ContentType)
	return _options
}

// SetIcon128x1282x : Allow user to set Icon128x1282x
func (_options *UpdateDestinationOptions) SetIcon128x1282x(icon128x1282x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon128x1282x = icon128x1282x
	return _options
}

// SetIcon128x1282xContentType : Allow user to set Icon128x1282xContentType
func (_options *UpdateDestinationOptions) SetIcon128x1282xContentType(icon128x1282xContentType string) *UpdateDestinationOptions {
	_options.Icon128x1282xContentType = core.StringPtr(icon128x1282xContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDestinationOptions) SetHeaders(param map[string]string) *UpdateDestinationOptions {
	options.Headers = param
	return options
}

// UpdateSMTPConfigurationOptions : The UpdateSMTPConfiguration options.
type UpdateSMTPConfigurationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// SMTP name.
	Name *string `json:"name,omitempty"`

	// SMTP description.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSMTPConfigurationOptions : Instantiate UpdateSMTPConfigurationOptions
func (*EventNotificationsV1) NewUpdateSMTPConfigurationOptions(instanceID string, id string) *UpdateSMTPConfigurationOptions {
	return &UpdateSMTPConfigurationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSMTPConfigurationOptions) SetInstanceID(instanceID string) *UpdateSMTPConfigurationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSMTPConfigurationOptions) SetID(id string) *UpdateSMTPConfigurationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSMTPConfigurationOptions) SetName(name string) *UpdateSMTPConfigurationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSMTPConfigurationOptions) SetDescription(description string) *UpdateSMTPConfigurationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSMTPConfigurationOptions) SetHeaders(param map[string]string) *UpdateSMTPConfigurationOptions {
	options.Headers = param
	return options
}

// UpdateSMTPUserOptions : The UpdateSMTPUser options.
type UpdateSMTPUserOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// UserID.
	UserID *string `json:"user_id" validate:"required,ne="`

	// SMTP user description.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSMTPUserOptions : Instantiate UpdateSMTPUserOptions
func (*EventNotificationsV1) NewUpdateSMTPUserOptions(instanceID string, id string, userID string) *UpdateSMTPUserOptions {
	return &UpdateSMTPUserOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		UserID:     core.StringPtr(userID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSMTPUserOptions) SetInstanceID(instanceID string) *UpdateSMTPUserOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSMTPUserOptions) SetID(id string) *UpdateSMTPUserOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *UpdateSMTPUserOptions) SetUserID(userID string) *UpdateSMTPUserOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSMTPUserOptions) SetDescription(description string) *UpdateSMTPUserOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSMTPUserOptions) SetHeaders(param map[string]string) *UpdateSMTPUserOptions {
	options.Headers = param
	return options
}

// UpdateSourceOptions : The UpdateSource options.
type UpdateSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the source.
	Name *string `json:"name,omitempty"`

	// Description of the source.
	Description *string `json:"description,omitempty"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSourceOptions : Instantiate UpdateSourceOptions
func (*EventNotificationsV1) NewUpdateSourceOptions(instanceID string, id string) *UpdateSourceOptions {
	return &UpdateSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSourceOptions) SetInstanceID(instanceID string) *UpdateSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSourceOptions) SetID(id string) *UpdateSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSourceOptions) SetName(name string) *UpdateSourceOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSourceOptions) SetDescription(description string) *UpdateSourceOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *UpdateSourceOptions) SetEnabled(enabled bool) *UpdateSourceOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSourceOptions) SetHeaders(param map[string]string) *UpdateSourceOptions {
	options.Headers = param
	return options
}

// UpdateSubscriptionOptions : The UpdateSubscription options.
type UpdateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the subscription.
	Name *string `json:"name,omitempty"`

	// Description of the subscription.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionUpdateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubscriptionOptions : Instantiate UpdateSubscriptionOptions
func (*EventNotificationsV1) NewUpdateSubscriptionOptions(instanceID string, id string) *UpdateSubscriptionOptions {
	return &UpdateSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSubscriptionOptions) SetInstanceID(instanceID string) *UpdateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSubscriptionOptions) SetID(id string) *UpdateSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSubscriptionOptions) SetName(name string) *UpdateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSubscriptionOptions) SetDescription(description string) *UpdateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *UpdateSubscriptionOptions) SetAttributes(attributes SubscriptionUpdateAttributesIntf) *UpdateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubscriptionOptions) SetHeaders(param map[string]string) *UpdateSubscriptionOptions {
	options.Headers = param
	return options
}

// UpdateVerifyDestinationOptions : The UpdateVerifyDestination options.
type UpdateVerifyDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Verification type.
	Type *string `json:"type" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVerifyDestinationOptions : Instantiate UpdateVerifyDestinationOptions
func (*EventNotificationsV1) NewUpdateVerifyDestinationOptions(instanceID string, id string, typeVar string) *UpdateVerifyDestinationOptions {
	return &UpdateVerifyDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateVerifyDestinationOptions) SetInstanceID(instanceID string) *UpdateVerifyDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVerifyDestinationOptions) SetID(id string) *UpdateVerifyDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *UpdateVerifyDestinationOptions) SetType(typeVar string) *UpdateVerifyDestinationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVerifyDestinationOptions) SetHeaders(param map[string]string) *UpdateVerifyDestinationOptions {
	options.Headers = param
	return options
}

// UpdateVerifySMTPOptions : The UpdateVerifySMTP options.
type UpdateVerifySMTPOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for SMTP.
	ID *string `json:"id" validate:"required,ne="`

	// SMTP verification type.
	Type *string `json:"type" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVerifySMTPOptions : Instantiate UpdateVerifySMTPOptions
func (*EventNotificationsV1) NewUpdateVerifySMTPOptions(instanceID string, id string, typeVar string) *UpdateVerifySMTPOptions {
	return &UpdateVerifySMTPOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateVerifySMTPOptions) SetInstanceID(instanceID string) *UpdateVerifySMTPOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateVerifySMTPOptions) SetID(id string) *UpdateVerifySMTPOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *UpdateVerifySMTPOptions) SetType(typeVar string) *UpdateVerifySMTPOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVerifySMTPOptions) SetHeaders(param map[string]string) *UpdateVerifySMTPOptions {
	options.Headers = param
	return options
}

// VerificationResponse : Destination verification object.
type VerificationResponse struct {
	// verification type.
	Type *string `json:"type" validate:"required"`

	// verification status.
	Verification *string `json:"verification" validate:"required"`
}

// UnmarshalVerificationResponse unmarshals an instance of VerificationResponse from the specified map of raw messages.
func UnmarshalVerificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VerificationResponse)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verification", &obj.Verification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfChromeDestinationConfig : Payload describing a Chrome destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfChromeDestinationConfig struct {
	// FCM api_key.
	APIKey *string `json:"api_key" validate:"required"`

	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfChromeDestinationConfig : Instantiate DestinationConfigOneOfChromeDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfChromeDestinationConfig(apiKey string, websiteURL string) (_model *DestinationConfigOneOfChromeDestinationConfig, err error) {
	_model = &DestinationConfigOneOfChromeDestinationConfig{
		APIKey:     core.StringPtr(apiKey),
		WebsiteURL: core.StringPtr(websiteURL),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfChromeDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfChromeDestinationConfig unmarshals an instance of DestinationConfigOneOfChromeDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfChromeDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfChromeDestinationConfig)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfCodeEngineDestinationConfig : Payload describing a code engine destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfCodeEngineDestinationConfig struct {
	// URL of code engine.
	URL *string `json:"url,omitempty"`

	// HTTP method of code engine.
	Verb *string `json:"verb,omitempty"`

	// The code engine destination type.
	Type *string `json:"type" validate:"required"`

	// CRN of the code engine project.
	ProjectCRN *string `json:"project_crn,omitempty"`

	// name of the code engine job.
	JobName *string `json:"job_name,omitempty"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigOneOfCodeEngineDestinationConfig.Verb property.
// HTTP method of code engine.
const (
	DestinationConfigOneOfCodeEngineDestinationConfigVerbGetConst  = "get"
	DestinationConfigOneOfCodeEngineDestinationConfigVerbPostConst = "post"
)

// Constants associated with the DestinationConfigOneOfCodeEngineDestinationConfig.Type property.
// The code engine destination type.
const (
	DestinationConfigOneOfCodeEngineDestinationConfigTypeApplicationConst = "application"
	DestinationConfigOneOfCodeEngineDestinationConfigTypeJobConst         = "job"
)

// NewDestinationConfigOneOfCodeEngineDestinationConfig : Instantiate DestinationConfigOneOfCodeEngineDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfCodeEngineDestinationConfig(typeVar string) (_model *DestinationConfigOneOfCodeEngineDestinationConfig, err error) {
	_model = &DestinationConfigOneOfCodeEngineDestinationConfig{
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfCodeEngineDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfCodeEngineDestinationConfig unmarshals an instance of DestinationConfigOneOfCodeEngineDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfCodeEngineDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfCodeEngineDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "project_crn", &obj.ProjectCRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "job_name", &obj.JobName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfCustomDomainEmailDestinationConfig : Payload describing a custom Domain Email destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfCustomDomainEmailDestinationConfig struct {
	// Email Domain.
	Domain *string `json:"domain" validate:"required"`

	// The DKIM attributes.
	Dkim *DkimAttributes `json:"dkim,omitempty"`

	// The SPF attributes.
	Spf *SpfAttributes `json:"spf,omitempty"`
}

// NewDestinationConfigOneOfCustomDomainEmailDestinationConfig : Instantiate DestinationConfigOneOfCustomDomainEmailDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfCustomDomainEmailDestinationConfig(domain string) (_model *DestinationConfigOneOfCustomDomainEmailDestinationConfig, err error) {
	_model = &DestinationConfigOneOfCustomDomainEmailDestinationConfig{
		Domain: core.StringPtr(domain),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfCustomDomainEmailDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfCustomDomainEmailDestinationConfig unmarshals an instance of DestinationConfigOneOfCustomDomainEmailDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfCustomDomainEmailDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfCustomDomainEmailDestinationConfig)
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dkim", &obj.Dkim, UnmarshalDkimAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "spf", &obj.Spf, UnmarshalSpfAttributes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfFcmDestinationConfig : Payload describing an FCM destination configuration. project_id, private_key and client_email for FCM HTTP v1 APIs.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfFcmDestinationConfig struct {
	// FCM server_key.
	// Deprecated: this field is deprecated and may be removed in a future release.
	ServerKey *string `json:"server_key,omitempty"`

	// FCM sender_id.
	// Deprecated: this field is deprecated and may be removed in a future release.
	SenderID *string `json:"sender_id,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`

	// FCM project_id.
	ProjectID *string `json:"project_id,omitempty"`

	// FCM private_key.
	PrivateKey *string `json:"private_key,omitempty"`

	// FCM client_email.
	ClientEmail *string `json:"client_email,omitempty"`
}

func (*DestinationConfigOneOfFcmDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfFcmDestinationConfig unmarshals an instance of DestinationConfigOneOfFcmDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfFcmDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfFcmDestinationConfig)
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "project_id", &obj.ProjectID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_key", &obj.PrivateKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_email", &obj.ClientEmail)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfFirefoxDestinationConfig : Payload describing a Firefox destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfFirefoxDestinationConfig struct {
	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfFirefoxDestinationConfig : Instantiate DestinationConfigOneOfFirefoxDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfFirefoxDestinationConfig(websiteURL string) (_model *DestinationConfigOneOfFirefoxDestinationConfig, err error) {
	_model = &DestinationConfigOneOfFirefoxDestinationConfig{
		WebsiteURL: core.StringPtr(websiteURL),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfFirefoxDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfFirefoxDestinationConfig unmarshals an instance of DestinationConfigOneOfFirefoxDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfFirefoxDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfFirefoxDestinationConfig)
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfHuaweiDestinationConfig : Payload describing a Huawei destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfHuaweiDestinationConfig struct {
	// ClientID for the Huawei account oauth.
	ClientID *string `json:"client_id" validate:"required"`

	// ClientSecret for the Huawei account oauth.
	ClientSecret *string `json:"client_secret" validate:"required"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfHuaweiDestinationConfig : Instantiate DestinationConfigOneOfHuaweiDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfHuaweiDestinationConfig(clientID string, clientSecret string) (_model *DestinationConfigOneOfHuaweiDestinationConfig, err error) {
	_model = &DestinationConfigOneOfHuaweiDestinationConfig{
		ClientID:     core.StringPtr(clientID),
		ClientSecret: core.StringPtr(clientSecret),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfHuaweiDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfHuaweiDestinationConfig unmarshals an instance of DestinationConfigOneOfHuaweiDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfHuaweiDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfHuaweiDestinationConfig)
	err = core.UnmarshalPrimitive(m, "client_id", &obj.ClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_secret", &obj.ClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfIBMCloudFunctionsDestinationConfig : Payload describing an IBM Cloud Functions destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfIBMCloudFunctionsDestinationConfig struct {
	// URL of IBM Cloud Functions Trigger EndPoint.
	URL *string `json:"url" validate:"required"`

	// API Key with access of IBM Cloud Functions IAM Namespace.
	APIKey *string `json:"api_key,omitempty"`
}

// NewDestinationConfigOneOfIBMCloudFunctionsDestinationConfig : Instantiate DestinationConfigOneOfIBMCloudFunctionsDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfIBMCloudFunctionsDestinationConfig(url string) (_model *DestinationConfigOneOfIBMCloudFunctionsDestinationConfig, err error) {
	_model = &DestinationConfigOneOfIBMCloudFunctionsDestinationConfig{
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfIBMCloudFunctionsDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfIBMCloudFunctionsDestinationConfig unmarshals an instance of DestinationConfigOneOfIBMCloudFunctionsDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfIBMCloudFunctionsDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfIBMCloudFunctionsDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig : Payload describing a Cloud Object Storage destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig struct {
	// Bucket Name for Cloud Object Storage.
	BucketName *string `json:"bucket_name" validate:"required"`

	// Instance Id of Cloud Object Storage.
	InstanceID *string `json:"instance_id" validate:"required"`

	// End Point of Cloud Object Storage.
	Endpoint *string `json:"endpoint" validate:"required"`
}

// NewDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig : Instantiate DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig(bucketName string, instanceID string, endpoint string) (_model *DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig, err error) {
	_model = &DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig{
		BucketName: core.StringPtr(bucketName),
		InstanceID: core.StringPtr(instanceID),
		Endpoint:   core.StringPtr(endpoint),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig unmarshals an instance of DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig)
	err = core.UnmarshalPrimitive(m, "bucket_name", &obj.BucketName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfIosDestinationConfig : Payload describing an iOS destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfIosDestinationConfig struct {
	// Authentication type (p8 or p12).
	CertType *string `json:"cert_type" validate:"required"`

	// Sandbox mode for iOS destinations.
	IsSandbox *bool `json:"is_sandbox" validate:"required"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password,omitempty"`

	// Key ID for token (Required when cert_type is p8).
	KeyID *string `json:"key_id,omitempty"`

	// Team ID for token (Required when cert_type is p8).
	TeamID *string `json:"team_id,omitempty"`

	// Bundle ID for token (Required when cert_type is p8).
	BundleID *string `json:"bundle_id,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfIosDestinationConfig : Instantiate DestinationConfigOneOfIosDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfIosDestinationConfig(certType string, isSandbox bool) (_model *DestinationConfigOneOfIosDestinationConfig, err error) {
	_model = &DestinationConfigOneOfIosDestinationConfig{
		CertType:  core.StringPtr(certType),
		IsSandbox: core.BoolPtr(isSandbox),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfIosDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfIosDestinationConfig unmarshals an instance of DestinationConfigOneOfIosDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfIosDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfIosDestinationConfig)
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_sandbox", &obj.IsSandbox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_id", &obj.KeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_id", &obj.TeamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bundle_id", &obj.BundleID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfMsTeamsDestinationConfig : Payload describing a MS Teams destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfMsTeamsDestinationConfig struct {
	// URL of MS Teams Incoming Notifications.
	URL *string `json:"url" validate:"required"`
}

// NewDestinationConfigOneOfMsTeamsDestinationConfig : Instantiate DestinationConfigOneOfMsTeamsDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfMsTeamsDestinationConfig(url string) (_model *DestinationConfigOneOfMsTeamsDestinationConfig, err error) {
	_model = &DestinationConfigOneOfMsTeamsDestinationConfig{
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfMsTeamsDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfMsTeamsDestinationConfig unmarshals an instance of DestinationConfigOneOfMsTeamsDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfMsTeamsDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfMsTeamsDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfPagerDutyDestinationConfig : Payload describing a PagerDuty destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfPagerDutyDestinationConfig struct {
	// API Key for the PagerDuty account.
	APIKey *string `json:"api_key" validate:"required"`

	// Routing Key (Integration Key) for the team in PagerDuty account.
	RoutingKey *string `json:"routing_key" validate:"required"`
}

// NewDestinationConfigOneOfPagerDutyDestinationConfig : Instantiate DestinationConfigOneOfPagerDutyDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfPagerDutyDestinationConfig(apiKey string, routingKey string) (_model *DestinationConfigOneOfPagerDutyDestinationConfig, err error) {
	_model = &DestinationConfigOneOfPagerDutyDestinationConfig{
		APIKey:     core.StringPtr(apiKey),
		RoutingKey: core.StringPtr(routingKey),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfPagerDutyDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfPagerDutyDestinationConfig unmarshals an instance of DestinationConfigOneOfPagerDutyDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfPagerDutyDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfPagerDutyDestinationConfig)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_key", &obj.RoutingKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfSafariDestinationConfig : Payload describing a Safari destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfSafariDestinationConfig struct {
	// Authentication type p12.
	CertType *string `json:"cert_type" validate:"required"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password" validate:"required"`

	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Website url.
	WebsiteName *string `json:"website_name" validate:"required"`

	// Website url.
	URLFormatString *string `json:"url_format_string" validate:"required"`

	// Website url.
	WebsitePushID *string `json:"website_push_id" validate:"required"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfSafariDestinationConfig : Instantiate DestinationConfigOneOfSafariDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfSafariDestinationConfig(certType string, password string, websiteURL string, websiteName string, urlFormatString string, websitePushID string) (_model *DestinationConfigOneOfSafariDestinationConfig, err error) {
	_model = &DestinationConfigOneOfSafariDestinationConfig{
		CertType:        core.StringPtr(certType),
		Password:        core.StringPtr(password),
		WebsiteURL:      core.StringPtr(websiteURL),
		WebsiteName:     core.StringPtr(websiteName),
		URLFormatString: core.StringPtr(urlFormatString),
		WebsitePushID:   core.StringPtr(websitePushID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfSafariDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfSafariDestinationConfig unmarshals an instance of DestinationConfigOneOfSafariDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfSafariDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfSafariDestinationConfig)
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_name", &obj.WebsiteName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_format_string", &obj.URLFormatString)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_push_id", &obj.WebsitePushID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfServiceNowDestinationConfig : Payload describing a ServiceNow destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfServiceNowDestinationConfig struct {
	// ClientID for the ServiceNow account oauth.
	ClientID *string `json:"client_id" validate:"required"`

	// ClientSecret for the ServiceNow account oauth.
	ClientSecret *string `json:"client_secret" validate:"required"`

	// Username for ServiceNow account REST API.
	Username *string `json:"username" validate:"required"`

	// Password for ServiceNow account REST API.
	Password *string `json:"password" validate:"required"`

	// Instance name for ServiceNow account.
	InstanceName *string `json:"instance_name" validate:"required"`
}

// NewDestinationConfigOneOfServiceNowDestinationConfig : Instantiate DestinationConfigOneOfServiceNowDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfServiceNowDestinationConfig(clientID string, clientSecret string, username string, password string, instanceName string) (_model *DestinationConfigOneOfServiceNowDestinationConfig, err error) {
	_model = &DestinationConfigOneOfServiceNowDestinationConfig{
		ClientID:     core.StringPtr(clientID),
		ClientSecret: core.StringPtr(clientSecret),
		Username:     core.StringPtr(username),
		Password:     core.StringPtr(password),
		InstanceName: core.StringPtr(instanceName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfServiceNowDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfServiceNowDestinationConfig unmarshals an instance of DestinationConfigOneOfServiceNowDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfServiceNowDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfServiceNowDestinationConfig)
	err = core.UnmarshalPrimitive(m, "client_id", &obj.ClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_secret", &obj.ClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_name", &obj.InstanceName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfSlackDestinationConfig : Payload describing a Slack webhook destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfSlackDestinationConfig struct {
	// URL of Slack Incoming Notifications.
	URL *string `json:"url" validate:"required"`

	// The Slack Destination type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DestinationConfigOneOfSlackDestinationConfig.Type property.
// The Slack Destination type.
const (
	DestinationConfigOneOfSlackDestinationConfigTypeIncomingWebhookConst = "incoming_webhook"
)

// NewDestinationConfigOneOfSlackDestinationConfig : Instantiate DestinationConfigOneOfSlackDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfSlackDestinationConfig(url string, typeVar string) (_model *DestinationConfigOneOfSlackDestinationConfig, err error) {
	_model = &DestinationConfigOneOfSlackDestinationConfig{
		URL:  core.StringPtr(url),
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfSlackDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfSlackDestinationConfig unmarshals an instance of DestinationConfigOneOfSlackDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfSlackDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfSlackDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfSlackDirectMessageDestinationConfig : Payload describing a Slack direct message destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfSlackDirectMessageDestinationConfig struct {
	// Token of slack application.
	Token *string `json:"token" validate:"required"`

	// The Slack Destination type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DestinationConfigOneOfSlackDirectMessageDestinationConfig.Type property.
// The Slack Destination type.
const (
	DestinationConfigOneOfSlackDirectMessageDestinationConfigTypeDirectMessageConst = "direct_message"
)

// NewDestinationConfigOneOfSlackDirectMessageDestinationConfig : Instantiate DestinationConfigOneOfSlackDirectMessageDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfSlackDirectMessageDestinationConfig(token string, typeVar string) (_model *DestinationConfigOneOfSlackDirectMessageDestinationConfig, err error) {
	_model = &DestinationConfigOneOfSlackDirectMessageDestinationConfig{
		Token: core.StringPtr(token),
		Type:  core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfSlackDirectMessageDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfSlackDirectMessageDestinationConfig unmarshals an instance of DestinationConfigOneOfSlackDirectMessageDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfSlackDirectMessageDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfSlackDirectMessageDestinationConfig)
	err = core.UnmarshalPrimitive(m, "token", &obj.Token)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfWebhookDestinationConfig : Payload describing a webhook destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfWebhookDestinationConfig struct {
	// URL of webhook.
	URL *string `json:"url" validate:"required"`

	// HTTP method of webhook.
	Verb *string `json:"verb" validate:"required"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigOneOfWebhookDestinationConfig.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigOneOfWebhookDestinationConfigVerbGetConst  = "get"
	DestinationConfigOneOfWebhookDestinationConfigVerbPostConst = "post"
)

// NewDestinationConfigOneOfWebhookDestinationConfig : Instantiate DestinationConfigOneOfWebhookDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfWebhookDestinationConfig(url string, verb string) (_model *DestinationConfigOneOfWebhookDestinationConfig, err error) {
	_model = &DestinationConfigOneOfWebhookDestinationConfig{
		URL:  core.StringPtr(url),
		Verb: core.StringPtr(verb),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfWebhookDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfWebhookDestinationConfig unmarshals an instance of DestinationConfigOneOfWebhookDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfWebhookDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfWebhookDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesCustomEmailAttributesResponse : The attributes reponse for an email destination.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesCustomEmailAttributesResponse struct {
	// The email id string.
	Invited []EmailAttributesResponseInvitedItems `json:"invited,omitempty"`

	// The unsubscribe list.
	Subscribed []EmailAttributesResponseSubscribedUnsubscribedItems `json:"subscribed,omitempty"`

	// The subscribed list.
	Unsubscribed []EmailAttributesResponseSubscribedUnsubscribedItems `json:"unsubscribed,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email from.
	FromEmail *string `json:"from_email" validate:"required"`

	// The templete id for notification.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// The templete id for invitation.
	TemplateIDInvitation *string `json:"template_id_invitation,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesCustomEmailAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesCustomEmailAttributesResponse
func (o *SubscriptionAttributesCustomEmailAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesCustomEmailAttributesResponse
func (o *SubscriptionAttributesCustomEmailAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesCustomEmailAttributesResponse
func (o *SubscriptionAttributesCustomEmailAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesCustomEmailAttributesResponse
func (o *SubscriptionAttributesCustomEmailAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesCustomEmailAttributesResponse
func (o *SubscriptionAttributesCustomEmailAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	if o.ReplyToMail != nil {
		m["reply_to_mail"] = o.ReplyToMail
	}
	if o.ReplyToName != nil {
		m["reply_to_name"] = o.ReplyToName
	}
	if o.FromName != nil {
		m["from_name"] = o.FromName
	}
	if o.FromEmail != nil {
		m["from_email"] = o.FromEmail
	}
	if o.TemplateIDNotification != nil {
		m["template_id_notification"] = o.TemplateIDNotification
	}
	if o.TemplateIDInvitation != nil {
		m["template_id_invitation"] = o.TemplateIDInvitation
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesCustomEmailAttributesResponse unmarshals an instance of SubscriptionAttributesCustomEmailAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesCustomEmailAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesCustomEmailAttributesResponse)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalEmailAttributesResponseInvitedItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	delete(m, "reply_to_mail")
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	delete(m, "reply_to_name")
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	delete(m, "from_name")
	err = core.UnmarshalPrimitive(m, "from_email", &obj.FromEmail)
	if err != nil {
		return
	}
	delete(m, "from_email")
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	delete(m, "template_id_notification")
	err = core.UnmarshalPrimitive(m, "template_id_invitation", &obj.TemplateIDInvitation)
	if err != nil {
		return
	}
	delete(m, "template_id_invitation")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesCustomSmsAttributesResponse : Custom SMS attributes object.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesCustomSmsAttributesResponse struct {
	// The subscribed list.
	Subscribed []SmsAttributesItems `json:"subscribed,omitempty"`

	// The unsubscribe list.
	Unsubscribed []SmsAttributesItems `json:"unsubscribed,omitempty"`

	// The SMS number string.
	Invited []SmsInviteAttributesItems `json:"invited,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesCustomSmsAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesCustomSmsAttributesResponse
func (o *SubscriptionAttributesCustomSmsAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesCustomSmsAttributesResponse
func (o *SubscriptionAttributesCustomSmsAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesCustomSmsAttributesResponse
func (o *SubscriptionAttributesCustomSmsAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesCustomSmsAttributesResponse
func (o *SubscriptionAttributesCustomSmsAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesCustomSmsAttributesResponse
func (o *SubscriptionAttributesCustomSmsAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesCustomSmsAttributesResponse unmarshals an instance of SubscriptionAttributesCustomSmsAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesCustomSmsAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesCustomSmsAttributesResponse)
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalSmsInviteAttributesItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesEmailAttributesResponse : The attributes reponse for an email destination.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesEmailAttributesResponse struct {
	// The email id string.
	Invited []EmailAttributesResponseInvitedItems `json:"invited,omitempty"`

	// The unsubscribe list.
	Subscribed []EmailAttributesResponseSubscribedUnsubscribedItems `json:"subscribed,omitempty"`

	// The subscribed list.
	Unsubscribed []EmailAttributesResponseSubscribedUnsubscribedItems `json:"unsubscribed,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesEmailAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	if o.ReplyToMail != nil {
		m["reply_to_mail"] = o.ReplyToMail
	}
	if o.ReplyToName != nil {
		m["reply_to_name"] = o.ReplyToName
	}
	if o.FromName != nil {
		m["from_name"] = o.FromName
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesEmailAttributesResponse unmarshals an instance of SubscriptionAttributesEmailAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesEmailAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesEmailAttributesResponse)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalEmailAttributesResponseInvitedItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	delete(m, "reply_to_mail")
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	delete(m, "reply_to_name")
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	delete(m, "from_name")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSmsAttributesResponse : SMS attributes object.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSmsAttributesResponse struct {
	// The subscribed list.
	Subscribed []SmsAttributesItems `json:"subscribed,omitempty"`

	// The unsubscribe list.
	Unsubscribed []SmsAttributesItems `json:"unsubscribed,omitempty"`

	// The SMS numder string.
	Invited []SmsInviteAttributesItems `json:"invited,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSmsAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSmsAttributesResponse unmarshals an instance of SubscriptionAttributesSmsAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSmsAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSmsAttributesResponse)
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalSmsInviteAttributesItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesServiceNowAttributesResponse : The attributes for a ServiceNow notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesServiceNowAttributesResponse struct {
	// Assigned name from ServiceNow account.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Assigned group name from ServiceNow account.
	AssignmentGroup *string `json:"assignment_group,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesServiceNowAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.AssignedTo != nil {
		m["assigned_to"] = o.AssignedTo
	}
	if o.AssignmentGroup != nil {
		m["assignment_group"] = o.AssignmentGroup
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesServiceNowAttributesResponse unmarshals an instance of SubscriptionAttributesServiceNowAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesServiceNowAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesServiceNowAttributesResponse)
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	delete(m, "assigned_to")
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	delete(m, "assignment_group")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSlackAttributesResponse : The attributes for a Slack notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSlackAttributesResponse struct {
	// Attachment Color for Slack Notification.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// ID of Base64 converted JSON Slack Blocks w/o Handlebars.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSlackAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.AttachmentColor != nil {
		m["attachment_color"] = o.AttachmentColor
	}
	if o.TemplateIDNotification != nil {
		m["template_id_notification"] = o.TemplateIDNotification
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSlackAttributesResponse unmarshals an instance of SubscriptionAttributesSlackAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSlackAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSlackAttributesResponse)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	delete(m, "attachment_color")
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	delete(m, "template_id_notification")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSlackDirectMessageAttributesResponse : The attributes for a slack direct message.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSlackDirectMessageAttributesResponse struct {
	// List of channels.
	Channels []ChannelCreateAttributes `json:"channels,omitempty"`

	// ID of Base64 converted JSON Slack Blocks w/o Handlebars.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSlackDirectMessageAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSlackDirectMessageAttributesResponse
func (o *SubscriptionAttributesSlackDirectMessageAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSlackDirectMessageAttributesResponse
func (o *SubscriptionAttributesSlackDirectMessageAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSlackDirectMessageAttributesResponse
func (o *SubscriptionAttributesSlackDirectMessageAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSlackDirectMessageAttributesResponse
func (o *SubscriptionAttributesSlackDirectMessageAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSlackDirectMessageAttributesResponse
func (o *SubscriptionAttributesSlackDirectMessageAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Channels != nil {
		m["channels"] = o.Channels
	}
	if o.TemplateIDNotification != nil {
		m["template_id_notification"] = o.TemplateIDNotification
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSlackDirectMessageAttributesResponse unmarshals an instance of SubscriptionAttributesSlackDirectMessageAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSlackDirectMessageAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSlackDirectMessageAttributesResponse)
	err = core.UnmarshalModel(m, "channels", &obj.Channels, UnmarshalChannelCreateAttributes)
	if err != nil {
		return
	}
	delete(m, "channels")
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	delete(m, "template_id_notification")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesWebhookAttributesResponse : The attributes for a webhook notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesWebhookAttributesResponse struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesWebhookAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesWebhookAttributesResponse unmarshals an instance of SubscriptionAttributesWebhookAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesWebhookAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesWebhookAttributesResponse)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesCustomEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesCustomEmailAttributes struct {
	// The email id string.
	Invited []string `json:"invited" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email from.
	FromEmail *string `json:"from_email" validate:"required"`

	// The templete id for notification.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// The templete id for invitation.
	TemplateIDInvitation *string `json:"template_id_invitation,omitempty"`
}

// NewSubscriptionCreateAttributesCustomEmailAttributes : Instantiate SubscriptionCreateAttributesCustomEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesCustomEmailAttributes(invited []string, addNotificationPayload bool, replyToMail string, replyToName string, fromName string, fromEmail string) (_model *SubscriptionCreateAttributesCustomEmailAttributes, err error) {
	_model = &SubscriptionCreateAttributesCustomEmailAttributes{
		Invited:                invited,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
		FromEmail:              core.StringPtr(fromEmail),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesCustomEmailAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesCustomEmailAttributes unmarshals an instance of SubscriptionCreateAttributesCustomEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesCustomEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesCustomEmailAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_email", &obj.FromEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_invitation", &obj.TemplateIDInvitation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesCustomSmsAttributes : The attributes for an custom sms notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesCustomSmsAttributes struct {
	// The sms id string.
	Invited []string `json:"invited" validate:"required"`
}

// NewSubscriptionCreateAttributesCustomSmsAttributes : Instantiate SubscriptionCreateAttributesCustomSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesCustomSmsAttributes(invited []string) (_model *SubscriptionCreateAttributesCustomSmsAttributes, err error) {
	_model = &SubscriptionCreateAttributesCustomSmsAttributes{
		Invited: invited,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesCustomSmsAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesCustomSmsAttributes unmarshals an instance of SubscriptionCreateAttributesCustomSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesCustomSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesCustomSmsAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesEmailAttributes struct {
	// The email id string.
	Invited []string `json:"invited" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`
}

// NewSubscriptionCreateAttributesEmailAttributes : Instantiate SubscriptionCreateAttributesEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesEmailAttributes(invited []string, addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionCreateAttributesEmailAttributes, err error) {
	_model = &SubscriptionCreateAttributesEmailAttributes{
		Invited:                invited,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesEmailAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesEmailAttributes unmarshals an instance of SubscriptionCreateAttributesEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesEmailAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesFcmAttributes : The attributes for an FCM notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesFcmAttributes struct {
}

func (*SubscriptionCreateAttributesFcmAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesFcmAttributes unmarshals an instance of SubscriptionCreateAttributesFcmAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesFcmAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesFcmAttributes)
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSmsAttributes : The attributes for an sms notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSmsAttributes struct {
	// The sms id string.
	Invited []string `json:"invited" validate:"required"`
}

// NewSubscriptionCreateAttributesSmsAttributes : Instantiate SubscriptionCreateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesSmsAttributes(invited []string) (_model *SubscriptionCreateAttributesSmsAttributes, err error) {
	_model = &SubscriptionCreateAttributesSmsAttributes{
		Invited: invited,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesSmsAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSmsAttributes unmarshals an instance of SubscriptionCreateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesServiceNowAttributes : The attributes for a ServiceNow notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesServiceNowAttributes struct {
	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionCreateAttributesServiceNowAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesServiceNowAttributes unmarshals an instance of SubscriptionCreateAttributesServiceNowAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesServiceNowAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesServiceNowAttributes)
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSlackAttributes : The attributes for a slack notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSlackAttributes struct {
	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// ID of Base64 converted JSON Slack Blocks w/o Handlebars.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`
}

func (*SubscriptionCreateAttributesSlackAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSlackAttributes unmarshals an instance of SubscriptionCreateAttributesSlackAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSlackAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSlackAttributes)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSlackDirectMessageAttributes : The attributes for a slack direct message.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSlackDirectMessageAttributes struct {
	// List of channels.
	Channels []ChannelCreateAttributes `json:"channels,omitempty"`

	// ID of Base64 converted JSON Slack Blocks w/o Handlebars.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`
}

func (*SubscriptionCreateAttributesSlackDirectMessageAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSlackDirectMessageAttributes unmarshals an instance of SubscriptionCreateAttributesSlackDirectMessageAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSlackDirectMessageAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSlackDirectMessageAttributes)
	err = core.UnmarshalModel(m, "channels", &obj.Channels, UnmarshalChannelCreateAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionCreateAttributesWebhookAttributes : Instantiate SubscriptionCreateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionCreateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionCreateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesWebhookAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesWebhookAttributes unmarshals an instance of SubscriptionCreateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesCustomEmailUpdateAttributes : The attributes for an email notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesCustomEmailUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email from.
	FromEmail *string `json:"from_email" validate:"required"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`

	// The templete id for notification.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`

	// The templete id for invitation.
	TemplateIDInvitation *string `json:"template_id_invitation,omitempty"`
}

// NewSubscriptionUpdateAttributesCustomEmailUpdateAttributes : Instantiate SubscriptionUpdateAttributesCustomEmailUpdateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesCustomEmailUpdateAttributes(addNotificationPayload bool, replyToMail string, replyToName string, fromName string, fromEmail string) (_model *SubscriptionUpdateAttributesCustomEmailUpdateAttributes, err error) {
	_model = &SubscriptionUpdateAttributesCustomEmailUpdateAttributes{
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
		FromEmail:              core.StringPtr(fromEmail),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesCustomEmailUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesCustomEmailUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesCustomEmailUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesCustomEmailUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesCustomEmailUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_email", &obj.FromEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_invitation", &obj.TemplateIDInvitation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesCustomSmsUpdateAttributes : SMS attributes object.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesCustomSmsUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

func (*SubscriptionUpdateAttributesCustomSmsUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesCustomSmsUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesCustomSmsUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesCustomSmsUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesCustomSmsUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesEmailUpdateAttributes : The attributes for an email notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesEmailUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

// NewSubscriptionUpdateAttributesEmailUpdateAttributes : Instantiate SubscriptionUpdateAttributesEmailUpdateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesEmailUpdateAttributes(addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionUpdateAttributesEmailUpdateAttributes, err error) {
	_model = &SubscriptionUpdateAttributesEmailUpdateAttributes{
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesEmailUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesEmailUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesEmailUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSmsUpdateAttributes : SMS attributes object.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSmsUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

func (*SubscriptionUpdateAttributesSmsUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSmsUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesSmsUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSmsUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSmsUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesServiceNowAttributes : The attributes for a ServiceNow notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesServiceNowAttributes struct {
	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionUpdateAttributesServiceNowAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesServiceNowAttributes unmarshals an instance of SubscriptionUpdateAttributesServiceNowAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesServiceNowAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesServiceNowAttributes)
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSlackAttributes : The attributes for a slack notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSlackAttributes struct {
	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// ID of Base64 converted JSON Slack Blocks w/o Handlebars.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`
}

func (*SubscriptionUpdateAttributesSlackAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSlackAttributes unmarshals an instance of SubscriptionUpdateAttributesSlackAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSlackAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSlackAttributes)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes : The attributes for a slack direct message.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes struct {
	// List of channels.
	Channels []ChannelUpdateAttributes `json:"channels,omitempty"`

	// ID of Base64 converted JSON Slack Blocks w/o Handlebars.
	TemplateIDNotification *string `json:"template_id_notification,omitempty"`
}

func (*SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes)
	err = core.UnmarshalModel(m, "channels", &obj.Channels, UnmarshalChannelUpdateAttributes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template_id_notification", &obj.TemplateIDNotification)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionUpdateAttributesWebhookAttributes : Instantiate SubscriptionUpdateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionUpdateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionUpdateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesWebhookAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesWebhookAttributes unmarshals an instance of SubscriptionUpdateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TemplateConfigOneOfEmailTemplateConfig : Payload describing an email template configuration.
// This model "extends" TemplateConfigOneOf
type TemplateConfigOneOfEmailTemplateConfig struct {
	// Template body.
	Body *string `json:"body" validate:"required"`

	// The template subject.
	Subject *string `json:"subject,omitempty"`
}

// NewTemplateConfigOneOfEmailTemplateConfig : Instantiate TemplateConfigOneOfEmailTemplateConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewTemplateConfigOneOfEmailTemplateConfig(body string) (_model *TemplateConfigOneOfEmailTemplateConfig, err error) {
	_model = &TemplateConfigOneOfEmailTemplateConfig{
		Body: core.StringPtr(body),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*TemplateConfigOneOfEmailTemplateConfig) isaTemplateConfigOneOf() bool {
	return true
}

// UnmarshalTemplateConfigOneOfEmailTemplateConfig unmarshals an instance of TemplateConfigOneOfEmailTemplateConfig from the specified map of raw messages.
func UnmarshalTemplateConfigOneOfEmailTemplateConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TemplateConfigOneOfEmailTemplateConfig)
	err = core.UnmarshalPrimitive(m, "body", &obj.Body)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subject", &obj.Subject)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TemplateConfigOneOfSlackTemplateConfig : Payload describing a slack template configuration.
// This model "extends" TemplateConfigOneOf
type TemplateConfigOneOfSlackTemplateConfig struct {
	// Template body.
	Body *string `json:"body" validate:"required"`
}

// NewTemplateConfigOneOfSlackTemplateConfig : Instantiate TemplateConfigOneOfSlackTemplateConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewTemplateConfigOneOfSlackTemplateConfig(body string) (_model *TemplateConfigOneOfSlackTemplateConfig, err error) {
	_model = &TemplateConfigOneOfSlackTemplateConfig{
		Body: core.StringPtr(body),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*TemplateConfigOneOfSlackTemplateConfig) isaTemplateConfigOneOf() bool {
	return true
}

// UnmarshalTemplateConfigOneOfSlackTemplateConfig unmarshals an instance of TemplateConfigOneOfSlackTemplateConfig from the specified map of raw messages.
func UnmarshalTemplateConfigOneOfSlackTemplateConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TemplateConfigOneOfSlackTemplateConfig)
	err = core.UnmarshalPrimitive(m, "body", &obj.Body)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesPager can be used to simplify the use of the "ListSources" method.
type SourcesPager struct {
	hasNext     bool
	options     *ListSourcesOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewSourcesPager returns a new SourcesPager instance.
func (eventNotifications *EventNotificationsV1) NewSourcesPager(options *ListSourcesOptions) (pager *SourcesPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListSourcesOptions = *options
	pager = &SourcesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SourcesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SourcesPager) GetNextWithContext(ctx context.Context) (page []SourceListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListSourcesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Sources

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SourcesPager) GetAllWithContext(ctx context.Context) (allItems []SourceListItem, err error) {
	for pager.HasNext() {
		var nextPage []SourceListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SourcesPager) GetNext() (page []SourceListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SourcesPager) GetAll() (allItems []SourceListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// TopicsPager can be used to simplify the use of the "ListTopics" method.
type TopicsPager struct {
	hasNext     bool
	options     *ListTopicsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewTopicsPager returns a new TopicsPager instance.
func (eventNotifications *EventNotificationsV1) NewTopicsPager(options *ListTopicsOptions) (pager *TopicsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListTopicsOptions = *options
	pager = &TopicsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TopicsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TopicsPager) GetNextWithContext(ctx context.Context) (page []TopicsListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListTopicsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Topics

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TopicsPager) GetAllWithContext(ctx context.Context) (allItems []TopicsListItem, err error) {
	for pager.HasNext() {
		var nextPage []TopicsListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TopicsPager) GetNext() (page []TopicsListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TopicsPager) GetAll() (allItems []TopicsListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// TemplatesPager can be used to simplify the use of the "ListTemplates" method.
type TemplatesPager struct {
	hasNext     bool
	options     *ListTemplatesOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewTemplatesPager returns a new TemplatesPager instance.
func (eventNotifications *EventNotificationsV1) NewTemplatesPager(options *ListTemplatesOptions) (pager *TemplatesPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListTemplatesOptions = *options
	pager = &TemplatesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TemplatesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TemplatesPager) GetNextWithContext(ctx context.Context) (page []Template, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListTemplatesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Templates

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TemplatesPager) GetAllWithContext(ctx context.Context) (allItems []Template, err error) {
	for pager.HasNext() {
		var nextPage []Template
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TemplatesPager) GetNext() (page []Template, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TemplatesPager) GetAll() (allItems []Template, err error) {
	return pager.GetAllWithContext(context.Background())
}

// DestinationsPager can be used to simplify the use of the "ListDestinations" method.
type DestinationsPager struct {
	hasNext     bool
	options     *ListDestinationsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewDestinationsPager returns a new DestinationsPager instance.
func (eventNotifications *EventNotificationsV1) NewDestinationsPager(options *ListDestinationsOptions) (pager *DestinationsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListDestinationsOptions = *options
	pager = &DestinationsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *DestinationsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *DestinationsPager) GetNextWithContext(ctx context.Context) (page []DestinationListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListDestinationsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Destinations

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *DestinationsPager) GetAllWithContext(ctx context.Context) (allItems []DestinationListItem, err error) {
	for pager.HasNext() {
		var nextPage []DestinationListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *DestinationsPager) GetNext() (page []DestinationListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *DestinationsPager) GetAll() (allItems []DestinationListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// TagsSubscriptionPager can be used to simplify the use of the "ListTagsSubscription" method.
type TagsSubscriptionPager struct {
	hasNext     bool
	options     *ListTagsSubscriptionOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewTagsSubscriptionPager returns a new TagsSubscriptionPager instance.
func (eventNotifications *EventNotificationsV1) NewTagsSubscriptionPager(options *ListTagsSubscriptionOptions) (pager *TagsSubscriptionPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListTagsSubscriptionOptions = *options
	pager = &TagsSubscriptionPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TagsSubscriptionPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TagsSubscriptionPager) GetNextWithContext(ctx context.Context) (page []TagsSubscriptionListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListTagsSubscriptionWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.TagSubscriptions

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TagsSubscriptionPager) GetAllWithContext(ctx context.Context) (allItems []TagsSubscriptionListItem, err error) {
	for pager.HasNext() {
		var nextPage []TagsSubscriptionListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TagsSubscriptionPager) GetNext() (page []TagsSubscriptionListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TagsSubscriptionPager) GetAll() (allItems []TagsSubscriptionListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SubscriptionsPager can be used to simplify the use of the "ListSubscriptions" method.
type SubscriptionsPager struct {
	hasNext     bool
	options     *ListSubscriptionsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewSubscriptionsPager returns a new SubscriptionsPager instance.
func (eventNotifications *EventNotificationsV1) NewSubscriptionsPager(options *ListSubscriptionsOptions) (pager *SubscriptionsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListSubscriptionsOptions = *options
	pager = &SubscriptionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SubscriptionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SubscriptionsPager) GetNextWithContext(ctx context.Context) (page []SubscriptionListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListSubscriptionsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Subscriptions

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SubscriptionsPager) GetAllWithContext(ctx context.Context) (allItems []SubscriptionListItem, err error) {
	for pager.HasNext() {
		var nextPage []SubscriptionListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SubscriptionsPager) GetNext() (page []SubscriptionListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SubscriptionsPager) GetAll() (allItems []SubscriptionListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// IntegrationsPager can be used to simplify the use of the "ListIntegrations" method.
type IntegrationsPager struct {
	hasNext     bool
	options     *ListIntegrationsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewIntegrationsPager returns a new IntegrationsPager instance.
func (eventNotifications *EventNotificationsV1) NewIntegrationsPager(options *ListIntegrationsOptions) (pager *IntegrationsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListIntegrationsOptions = *options
	pager = &IntegrationsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *IntegrationsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *IntegrationsPager) GetNextWithContext(ctx context.Context) (page []IntegrationListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListIntegrationsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Integrations

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *IntegrationsPager) GetAllWithContext(ctx context.Context) (allItems []IntegrationListItem, err error) {
	for pager.HasNext() {
		var nextPage []IntegrationListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *IntegrationsPager) GetNext() (page []IntegrationListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *IntegrationsPager) GetAll() (allItems []IntegrationListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SMTPConfigurationsPager can be used to simplify the use of the "ListSMTPConfigurations" method.
type SMTPConfigurationsPager struct {
	hasNext     bool
	options     *ListSMTPConfigurationsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewSMTPConfigurationsPager returns a new SMTPConfigurationsPager instance.
func (eventNotifications *EventNotificationsV1) NewSMTPConfigurationsPager(options *ListSMTPConfigurationsOptions) (pager *SMTPConfigurationsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListSMTPConfigurationsOptions = *options
	pager = &SMTPConfigurationsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SMTPConfigurationsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SMTPConfigurationsPager) GetNextWithContext(ctx context.Context) (page []SMTPConfiguration, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListSMTPConfigurationsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.SMTPConfigurations

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SMTPConfigurationsPager) GetAllWithContext(ctx context.Context) (allItems []SMTPConfiguration, err error) {
	for pager.HasNext() {
		var nextPage []SMTPConfiguration
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SMTPConfigurationsPager) GetNext() (page []SMTPConfiguration, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SMTPConfigurationsPager) GetAll() (allItems []SMTPConfiguration, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SMTPUsersPager can be used to simplify the use of the "ListSMTPUsers" method.
type SMTPUsersPager struct {
	hasNext     bool
	options     *ListSMTPUsersOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewSMTPUsersPager returns a new SMTPUsersPager instance.
func (eventNotifications *EventNotificationsV1) NewSMTPUsersPager(options *ListSMTPUsersOptions) (pager *SMTPUsersPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListSMTPUsersOptions = *options
	pager = &SMTPUsersPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SMTPUsersPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SMTPUsersPager) GetNextWithContext(ctx context.Context) (page []SMTPUser, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListSMTPUsersWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Users

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SMTPUsersPager) GetAllWithContext(ctx context.Context) (allItems []SMTPUser, err error) {
	for pager.HasNext() {
		var nextPage []SMTPUser
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SMTPUsersPager) GetNext() (page []SMTPUser, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SMTPUsersPager) GetAll() (allItems []SMTPUser, err error) {
	return pager.GetAllWithContext(context.Background())
}
