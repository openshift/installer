/**
 * (C) Copyright IBM Corp. 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.54.0-af6d2126-20220803-151219
 */

// Package eventnotificationsv1 : Operations and models for the EventNotificationsV1 service
package eventnotificationsv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"strconv"
	"time"

	common "github.com/IBM/event-notifications-go-admin-sdk/common"
	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
)

// EventNotificationsV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: 1.0
type EventNotificationsV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.event-notifications.cloud.ibm.com/event-notifications"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "event_notifications"

// EventNotificationsV1Options : Service options
type EventNotificationsV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewEventNotificationsV1UsingExternalConfig : constructs an instance of EventNotificationsV1 with passed in options and external configuration.
func NewEventNotificationsV1UsingExternalConfig(options *EventNotificationsV1Options) (eventNotifications *EventNotificationsV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	eventNotifications, err = NewEventNotificationsV1(options)
	if err != nil {
		return
	}

	err = eventNotifications.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = eventNotifications.Service.SetServiceURL(options.URL)
	}
	return
}

// NewEventNotificationsV1 : constructs an instance of EventNotificationsV1 with passed in options.
func NewEventNotificationsV1(options *EventNotificationsV1Options) (service *EventNotificationsV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &EventNotificationsV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "eventNotifications" suitable for processing requests.
func (eventNotifications *EventNotificationsV1) Clone() *EventNotificationsV1 {
	if core.IsNil(eventNotifications) {
		return nil
	}
	clone := *eventNotifications
	clone.Service = eventNotifications.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (eventNotifications *EventNotificationsV1) SetServiceURL(url string) error {
	return eventNotifications.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (eventNotifications *EventNotificationsV1) GetServiceURL() string {
	return eventNotifications.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (eventNotifications *EventNotificationsV1) SetDefaultHeaders(headers http.Header) {
	eventNotifications.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) SetEnableGzipCompression(enableGzip bool) {
	eventNotifications.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) GetEnableGzipCompression() bool {
	return eventNotifications.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (eventNotifications *EventNotificationsV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	eventNotifications.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (eventNotifications *EventNotificationsV1) DisableRetries() {
	eventNotifications.Service.DisableRetries()
}

// SendNotifications : Send a notification
// Send Notifications body from the instance. For more information about Event Notifications payload, see
// [here](https://cloud.ibm.com/docs/event-notifications?topic=event-notifications-en-spec-payload).
func (eventNotifications *EventNotificationsV1) SendNotifications(sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.SendNotificationsWithContext(context.Background(), sendNotificationsOptions)
}

// SendNotificationsWithContext is an alternate form of the SendNotifications method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) SendNotificationsWithContext(ctx context.Context, sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(sendNotificationsOptions, "sendNotificationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(sendNotificationsOptions, "sendNotificationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *sendNotificationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/notifications`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range sendNotificationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "SendNotifications")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	if sendNotificationsOptions.Body != nil {
		_, err = builder.SetBodyContentJSON(sendNotificationsOptions.Body)
		if err != nil {
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNotificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// SendBulkNotifications : Send Bulk notification
func (eventNotifications *EventNotificationsV1) SendBulkNotifications(sendBulkNotificationsOptions *SendBulkNotificationsOptions) (result *BulkNotificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.SendBulkNotificationsWithContext(context.Background(), sendBulkNotificationsOptions)
}

// SendBulkNotificationsWithContext is an alternate form of the SendBulkNotifications method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) SendBulkNotificationsWithContext(ctx context.Context, sendBulkNotificationsOptions *SendBulkNotificationsOptions) (result *BulkNotificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(sendBulkNotificationsOptions, "sendBulkNotificationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(sendBulkNotificationsOptions, "sendBulkNotificationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *sendBulkNotificationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/notifications/bulk`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range sendBulkNotificationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "SendBulkNotifications")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if sendBulkNotificationsOptions.BulkMessages != nil {
		body["bulk_messages"] = sendBulkNotificationsOptions.BulkMessages
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBulkNotificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateSources : Create a new API Source
// Create a new API Source.
func (eventNotifications *EventNotificationsV1) CreateSources(createSourcesOptions *CreateSourcesOptions) (result *SourceResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSourcesWithContext(context.Background(), createSourcesOptions)
}

// CreateSourcesWithContext is an alternate form of the CreateSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSourcesWithContext(ctx context.Context, createSourcesOptions *CreateSourcesOptions) (result *SourceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSourcesOptions, "createSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSourcesOptions, "createSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSourcesOptions.Name != nil {
		body["name"] = createSourcesOptions.Name
	}
	if createSourcesOptions.Description != nil {
		body["description"] = createSourcesOptions.Description
	}
	if createSourcesOptions.Enabled != nil {
		body["enabled"] = createSourcesOptions.Enabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSources : List all Sources
// List all Sources.
func (eventNotifications *EventNotificationsV1) ListSources(listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSourcesWithContext(context.Background(), listSourcesOptions)
}

// ListSourcesWithContext is an alternate form of the ListSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSourcesWithContext(ctx context.Context, listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSourcesOptions, "listSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSourcesOptions, "listSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSourcesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSourcesOptions.Limit))
	}
	if listSourcesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSourcesOptions.Offset))
	}
	if listSourcesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSourcesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSource : Get a Source
// Get a Source.
func (eventNotifications *EventNotificationsV1) GetSource(getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSourceWithContext(context.Background(), getSourceOptions)
}

// GetSourceWithContext is an alternate form of the GetSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSourceWithContext(ctx context.Context, getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSourceOptions, "getSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSourceOptions, "getSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSourceOptions.InstanceID,
		"id":          *getSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSource : Delete a Source
// Delete a Source.
func (eventNotifications *EventNotificationsV1) DeleteSource(deleteSourceOptions *DeleteSourceOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSourceWithContext(context.Background(), deleteSourceOptions)
}

// DeleteSourceWithContext is an alternate form of the DeleteSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSourceWithContext(ctx context.Context, deleteSourceOptions *DeleteSourceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSourceOptions, "deleteSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSourceOptions, "deleteSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSourceOptions.InstanceID,
		"id":          *deleteSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSource : Update details of a Source
// Update details of a Source.
func (eventNotifications *EventNotificationsV1) UpdateSource(updateSourceOptions *UpdateSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSourceWithContext(context.Background(), updateSourceOptions)
}

// UpdateSourceWithContext is an alternate form of the UpdateSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSourceWithContext(ctx context.Context, updateSourceOptions *UpdateSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSourceOptions, "updateSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSourceOptions, "updateSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSourceOptions.InstanceID,
		"id":          *updateSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSourceOptions.Name != nil {
		body["name"] = updateSourceOptions.Name
	}
	if updateSourceOptions.Description != nil {
		body["description"] = updateSourceOptions.Description
	}
	if updateSourceOptions.Enabled != nil {
		body["enabled"] = updateSourceOptions.Enabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTopic : Create a new Topic
// Create a new Topic.
func (eventNotifications *EventNotificationsV1) CreateTopic(createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTopicWithContext(context.Background(), createTopicOptions)
}

// CreateTopicWithContext is an alternate form of the CreateTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTopicWithContext(ctx context.Context, createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTopicOptions, "createTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTopicOptions, "createTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTopicOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTopicOptions.Name != nil {
		body["name"] = createTopicOptions.Name
	}
	if createTopicOptions.Description != nil {
		body["description"] = createTopicOptions.Description
	}
	if createTopicOptions.Sources != nil {
		body["sources"] = createTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTopics : List all Topics
// List all Topics.
func (eventNotifications *EventNotificationsV1) ListTopics(listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTopicsWithContext(context.Background(), listTopicsOptions)
}

// ListTopicsWithContext is an alternate form of the ListTopics method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTopicsWithContext(ctx context.Context, listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTopicsOptions, "listTopicsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTopicsOptions, "listTopicsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTopicsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTopicsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTopics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTopicsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTopicsOptions.Limit))
	}
	if listTopicsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTopicsOptions.Offset))
	}
	if listTopicsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTopicsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTopic : Get details of a Topic
// Get details of a Topic.
func (eventNotifications *EventNotificationsV1) GetTopic(getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.GetTopicWithContext(context.Background(), getTopicOptions)
}

// GetTopicWithContext is an alternate form of the GetTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetTopicWithContext(ctx context.Context, getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTopicOptions, "getTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTopicOptions, "getTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getTopicOptions.InstanceID,
		"id":          *getTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getTopicOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*getTopicOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTopic : Update details of a Topic
// Update details of a Topic.
func (eventNotifications *EventNotificationsV1) ReplaceTopic(replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceTopicWithContext(context.Background(), replaceTopicOptions)
}

// ReplaceTopicWithContext is an alternate form of the ReplaceTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceTopicWithContext(ctx context.Context, replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTopicOptions, "replaceTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTopicOptions, "replaceTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceTopicOptions.InstanceID,
		"id":          *replaceTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceTopicOptions.Name != nil {
		body["name"] = replaceTopicOptions.Name
	}
	if replaceTopicOptions.Description != nil {
		body["description"] = replaceTopicOptions.Description
	}
	if replaceTopicOptions.Sources != nil {
		body["sources"] = replaceTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTopic : Delete a Topic
// Delete a Topic.
func (eventNotifications *EventNotificationsV1) DeleteTopic(deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTopicWithContext(context.Background(), deleteTopicOptions)
}

// DeleteTopicWithContext is an alternate form of the DeleteTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTopicWithContext(ctx context.Context, deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTopicOptions, "deleteTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTopicOptions, "deleteTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTopicOptions.InstanceID,
		"id":          *deleteTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateDestination : Create a new Destination
// Create a new Destination.
func (eventNotifications *EventNotificationsV1) CreateDestination(createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateDestinationWithContext(context.Background(), createDestinationOptions)
}

// CreateDestinationWithContext is an alternate form of the CreateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateDestinationWithContext(ctx context.Context, createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDestinationOptions, "createDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDestinationOptions, "createDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createDestinationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddFormData("name", "", "", fmt.Sprint(*createDestinationOptions.Name))
	builder.AddFormData("type", "", "", fmt.Sprint(*createDestinationOptions.Type))
	if createDestinationOptions.Description != nil {
		builder.AddFormData("description", "", "", fmt.Sprint(*createDestinationOptions.Description))
	}
	if createDestinationOptions.Config != nil {
		builder.AddFormData("config", "", "application/json", createDestinationOptions.Config)
	}
	if createDestinationOptions.Certificate != nil {
		builder.AddFormData("certificate", "",
			core.StringNilMapper(createDestinationOptions.CertificateContentType), createDestinationOptions.Certificate)
	}
	if createDestinationOptions.Icon16x16 != nil {
		builder.AddFormData("icon_16x16", "",
			core.StringNilMapper(createDestinationOptions.Icon16x16ContentType), createDestinationOptions.Icon16x16)
	}
	if createDestinationOptions.Icon16x162x != nil {
		builder.AddFormData("icon_16x16_2x", "",
			core.StringNilMapper(createDestinationOptions.Icon16x162xContentType), createDestinationOptions.Icon16x162x)
	}
	if createDestinationOptions.Icon32x32 != nil {
		builder.AddFormData("icon_32x32", "",
			core.StringNilMapper(createDestinationOptions.Icon32x32ContentType), createDestinationOptions.Icon32x32)
	}
	if createDestinationOptions.Icon32x322x != nil {
		builder.AddFormData("icon_32x32_2x", "",
			core.StringNilMapper(createDestinationOptions.Icon32x322xContentType), createDestinationOptions.Icon32x322x)
	}
	if createDestinationOptions.Icon128x128 != nil {
		builder.AddFormData("icon_128x128", "",
			core.StringNilMapper(createDestinationOptions.Icon128x128ContentType), createDestinationOptions.Icon128x128)
	}
	if createDestinationOptions.Icon128x1282x != nil {
		builder.AddFormData("icon_128x128_2x", "",
			core.StringNilMapper(createDestinationOptions.Icon128x1282xContentType), createDestinationOptions.Icon128x1282x)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDestinations : List all Destinations
// List all Destinations.
func (eventNotifications *EventNotificationsV1) ListDestinations(listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationsWithContext(context.Background(), listDestinationsOptions)
}

// ListDestinationsWithContext is an alternate form of the ListDestinations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationsWithContext(ctx context.Context, listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationsOptions, "listDestinationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationsOptions, "listDestinationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationsOptions.Limit))
	}
	if listDestinationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationsOptions.Offset))
	}
	if listDestinationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestination : Get details of a Destination
// Get details of a Destination.
func (eventNotifications *EventNotificationsV1) GetDestination(getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationWithContext(context.Background(), getDestinationOptions)
}

// GetDestinationWithContext is an alternate form of the GetDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationWithContext(ctx context.Context, getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationOptions, "getDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationOptions, "getDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationOptions.InstanceID,
		"id":          *getDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDestination : Update details of a Destination
// Update details of a Destination.
func (eventNotifications *EventNotificationsV1) UpdateDestination(updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateDestinationWithContext(context.Background(), updateDestinationOptions)
}

// UpdateDestinationWithContext is an alternate form of the UpdateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateDestinationWithContext(ctx context.Context, updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDestinationOptions, "updateDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDestinationOptions, "updateDestinationOptions")
	if err != nil {
		return
	}
	if (updateDestinationOptions.Name == nil) && (updateDestinationOptions.Description == nil) && (updateDestinationOptions.Config == nil) && (updateDestinationOptions.Certificate == nil) && (updateDestinationOptions.Icon16x16 == nil) && (updateDestinationOptions.Icon16x162x == nil) && (updateDestinationOptions.Icon32x32 == nil) && (updateDestinationOptions.Icon32x322x == nil) && (updateDestinationOptions.Icon128x128 == nil) && (updateDestinationOptions.Icon128x1282x == nil) {
		err = fmt.Errorf("at least one of name, description, config, certificate, icon16x16, icon16x162x, icon32x32, icon32x322x, icon128x128, or icon128x1282x must be supplied")
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateDestinationOptions.InstanceID,
		"id":          *updateDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if updateDestinationOptions.Name != nil {
		builder.AddFormData("name", "", "", fmt.Sprint(*updateDestinationOptions.Name))
	}
	if updateDestinationOptions.Description != nil {
		builder.AddFormData("description", "", "", fmt.Sprint(*updateDestinationOptions.Description))
	}
	if updateDestinationOptions.Config != nil {
		builder.AddFormData("config", "", "application/json", updateDestinationOptions.Config)
	}
	if updateDestinationOptions.Certificate != nil {
		builder.AddFormData("certificate", "",
			core.StringNilMapper(updateDestinationOptions.CertificateContentType), updateDestinationOptions.Certificate)
	}
	if updateDestinationOptions.Icon16x16 != nil {
		builder.AddFormData("icon_16x16", "",
			core.StringNilMapper(updateDestinationOptions.Icon16x16ContentType), updateDestinationOptions.Icon16x16)
	}
	if updateDestinationOptions.Icon16x162x != nil {
		builder.AddFormData("icon_16x16_2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon16x162xContentType), updateDestinationOptions.Icon16x162x)
	}
	if updateDestinationOptions.Icon32x32 != nil {
		builder.AddFormData("icon_32x32", "",
			core.StringNilMapper(updateDestinationOptions.Icon32x32ContentType), updateDestinationOptions.Icon32x32)
	}
	if updateDestinationOptions.Icon32x322x != nil {
		builder.AddFormData("icon_32x32_2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon32x322xContentType), updateDestinationOptions.Icon32x322x)
	}
	if updateDestinationOptions.Icon128x128 != nil {
		builder.AddFormData("icon_128x128", "",
			core.StringNilMapper(updateDestinationOptions.Icon128x128ContentType), updateDestinationOptions.Icon128x128)
	}
	if updateDestinationOptions.Icon128x1282x != nil {
		builder.AddFormData("icon_128x128_2x", "",
			core.StringNilMapper(updateDestinationOptions.Icon128x1282xContentType), updateDestinationOptions.Icon128x1282x)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDestination : Delete a Destination
// Delete a Destination.
func (eventNotifications *EventNotificationsV1) DeleteDestination(deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteDestinationWithContext(context.Background(), deleteDestinationOptions)
}

// DeleteDestinationWithContext is an alternate form of the DeleteDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteDestinationWithContext(ctx context.Context, deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDestinationOptions, "deleteDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDestinationOptions, "deleteDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteDestinationOptions.InstanceID,
		"id":          *deleteDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateTagsSubscription : Create a new tag subscription
// Create a new tag subscription.
func (eventNotifications *EventNotificationsV1) CreateTagsSubscription(createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTagsSubscriptionWithContext(context.Background(), createTagsSubscriptionOptions)
}

// CreateTagsSubscriptionWithContext is an alternate form of the CreateTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTagsSubscriptionWithContext(ctx context.Context, createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTagsSubscriptionOptions, "createTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTagsSubscriptionOptions, "createTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTagsSubscriptionOptions.InstanceID,
		"id":          *createTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTagsSubscriptionOptions.DeviceID != nil {
		body["device_id"] = createTagsSubscriptionOptions.DeviceID
	}
	if createTagsSubscriptionOptions.TagName != nil {
		body["tag_name"] = createTagsSubscriptionOptions.TagName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationTagsSubscriptionResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTagsSubscription : List all tag subscriptions
// List all tag subscriptions.
func (eventNotifications *EventNotificationsV1) ListTagsSubscription(listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTagsSubscriptionWithContext(context.Background(), listTagsSubscriptionOptions)
}

// ListTagsSubscriptionWithContext is an alternate form of the ListTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionWithContext(ctx context.Context, listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTagsSubscriptionOptions, "listTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTagsSubscriptionOptions, "listTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTagsSubscriptionOptions.InstanceID,
		"id":          *listTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*listTagsSubscriptionOptions.DeviceID))
	}
	if listTagsSubscriptionOptions.UserID != nil {
		builder.AddQuery("user_id", fmt.Sprint(*listTagsSubscriptionOptions.UserID))
	}
	if listTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*listTagsSubscriptionOptions.TagName))
	}
	if listTagsSubscriptionOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTagsSubscriptionOptions.Limit))
	}
	if listTagsSubscriptionOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTagsSubscriptionOptions.Offset))
	}
	if listTagsSubscriptionOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTagsSubscriptionOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTagsSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTagsSubscription : Delete a tag subscription
// Delete a tag subscription.
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscription(deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTagsSubscriptionWithContext(context.Background(), deleteTagsSubscriptionOptions)
}

// DeleteTagsSubscriptionWithContext is an alternate form of the DeleteTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscriptionWithContext(ctx context.Context, deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTagsSubscriptionOptions.InstanceID,
		"id":          *deleteTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	if deleteTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*deleteTagsSubscriptionOptions.DeviceID))
	}
	if deleteTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*deleteTagsSubscriptionOptions.TagName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateSubscription : Create a new Subscription
// Create a new Subscription.
func (eventNotifications *EventNotificationsV1) CreateSubscription(createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSubscriptionWithContext(context.Background(), createSubscriptionOptions)
}

// CreateSubscriptionWithContext is an alternate form of the CreateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSubscriptionWithContext(ctx context.Context, createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubscriptionOptions, "createSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubscriptionOptions, "createSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSubscriptionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSubscriptionOptions.Name != nil {
		body["name"] = createSubscriptionOptions.Name
	}
	if createSubscriptionOptions.DestinationID != nil {
		body["destination_id"] = createSubscriptionOptions.DestinationID
	}
	if createSubscriptionOptions.TopicID != nil {
		body["topic_id"] = createSubscriptionOptions.TopicID
	}
	if createSubscriptionOptions.Description != nil {
		body["description"] = createSubscriptionOptions.Description
	}
	if createSubscriptionOptions.Attributes != nil {
		body["attributes"] = createSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubscriptions : List all Subscriptions
// List all Subscriptions.
func (eventNotifications *EventNotificationsV1) ListSubscriptions(listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSubscriptionsWithContext(context.Background(), listSubscriptionsOptions)
}

// ListSubscriptionsWithContext is an alternate form of the ListSubscriptions method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSubscriptionsWithContext(ctx context.Context, listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubscriptionsOptions, "listSubscriptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubscriptionsOptions, "listSubscriptionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSubscriptionsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubscriptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSubscriptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSubscriptionsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSubscriptionsOptions.Offset))
	}
	if listSubscriptionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubscriptionsOptions.Limit))
	}
	if listSubscriptionsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSubscriptionsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubscription : Get details of a Subscription
// Get details of a Subscription.
func (eventNotifications *EventNotificationsV1) GetSubscription(getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSubscriptionWithContext(context.Background(), getSubscriptionOptions)
}

// GetSubscriptionWithContext is an alternate form of the GetSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSubscriptionWithContext(ctx context.Context, getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubscriptionOptions, "getSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubscriptionOptions, "getSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSubscriptionOptions.InstanceID,
		"id":          *getSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubscription : Delete a Subscription
// Delete a Subscription.
func (eventNotifications *EventNotificationsV1) DeleteSubscription(deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSubscriptionWithContext(context.Background(), deleteSubscriptionOptions)
}

// DeleteSubscriptionWithContext is an alternate form of the DeleteSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSubscriptionWithContext(ctx context.Context, deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubscriptionOptions, "deleteSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubscriptionOptions, "deleteSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSubscriptionOptions.InstanceID,
		"id":          *deleteSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSubscription : Update details of a Subscription
// Update details of a Subscription.
func (eventNotifications *EventNotificationsV1) UpdateSubscription(updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSubscriptionWithContext(context.Background(), updateSubscriptionOptions)
}

// UpdateSubscriptionWithContext is an alternate form of the UpdateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSubscriptionWithContext(ctx context.Context, updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubscriptionOptions, "updateSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubscriptionOptions, "updateSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSubscriptionOptions.InstanceID,
		"id":          *updateSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSubscriptionOptions.Name != nil {
		body["name"] = updateSubscriptionOptions.Name
	}
	if updateSubscriptionOptions.Description != nil {
		body["description"] = updateSubscriptionOptions.Description
	}
	if updateSubscriptionOptions.Attributes != nil {
		body["attributes"] = updateSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListIntegrations : List all Integrations
// List of all KMS Integrations.
func (eventNotifications *EventNotificationsV1) ListIntegrations(listIntegrationsOptions *ListIntegrationsOptions) (result *IntegrationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListIntegrationsWithContext(context.Background(), listIntegrationsOptions)
}

// ListIntegrationsWithContext is an alternate form of the ListIntegrations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListIntegrationsWithContext(ctx context.Context, listIntegrationsOptions *ListIntegrationsOptions) (result *IntegrationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listIntegrationsOptions, "listIntegrationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listIntegrationsOptions, "listIntegrationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listIntegrationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIntegrationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListIntegrations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listIntegrationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listIntegrationsOptions.Offset))
	}
	if listIntegrationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIntegrationsOptions.Limit))
	}
	if listIntegrationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listIntegrationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetIntegration : Get a single Integration
// Get a single KMS Integration.
func (eventNotifications *EventNotificationsV1) GetIntegration(getIntegrationOptions *GetIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.GetIntegrationWithContext(context.Background(), getIntegrationOptions)
}

// GetIntegrationWithContext is an alternate form of the GetIntegration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetIntegrationWithContext(ctx context.Context, getIntegrationOptions *GetIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIntegrationOptions, "getIntegrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIntegrationOptions, "getIntegrationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getIntegrationOptions.InstanceID,
		"id":          *getIntegrationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIntegrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetIntegration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationGetResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceIntegration : Update an existing Integration
// Update an existing KMS Integration.
func (eventNotifications *EventNotificationsV1) ReplaceIntegration(replaceIntegrationOptions *ReplaceIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceIntegrationWithContext(context.Background(), replaceIntegrationOptions)
}

// ReplaceIntegrationWithContext is an alternate form of the ReplaceIntegration method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceIntegrationWithContext(ctx context.Context, replaceIntegrationOptions *ReplaceIntegrationOptions) (result *IntegrationGetResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceIntegrationOptions, "replaceIntegrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceIntegrationOptions, "replaceIntegrationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceIntegrationOptions.InstanceID,
		"id":          *replaceIntegrationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/integrations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceIntegrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceIntegration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceIntegrationOptions.Type != nil {
		body["type"] = replaceIntegrationOptions.Type
	}
	if replaceIntegrationOptions.Metadata != nil {
		body["metadata"] = replaceIntegrationOptions.Metadata
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIntegrationGetResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// BulkNotificationResponse : Payload describing a notifications response.
type BulkNotificationResponse struct {
	// Bulk Notification ID.
	BulkNotificationID *string `json:"bulk_notification_id,omitempty"`

	// List of Notifications.
	BulkMessages []interface{} `json:"bulk_messages,omitempty"`
}

// UnmarshalBulkNotificationResponse unmarshals an instance of BulkNotificationResponse from the specified map of raw messages.
func UnmarshalBulkNotificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BulkNotificationResponse)
	err = core.UnmarshalPrimitive(m, "bulk_notification_id", &obj.BulkNotificationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bulk_messages", &obj.BulkMessages)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateDestinationOptions : The CreateDestination options.
type CreateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Destination name.
	Name *string `json:"name" validate:"required"`

	// The type of Destination Webhook.
	Type *string `json:"type" validate:"required"`

	// The Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Certificate for APNS.
	Certificate io.ReadCloser `json:"certificate,omitempty"`

	// The content type of certificate.
	CertificateContentType *string `json:"certificate_content_type,omitempty"`

	// Safari icon 16x16.
	Icon16x16 io.ReadCloser `json:"icon_16x16,omitempty"`

	// The content type of icon16x16.
	Icon16x16ContentType *string `json:"icon_16x16_content_type,omitempty"`

	// Safari icon 16x16@2x.
	Icon16x162x io.ReadCloser `json:"icon_16x16_2x,omitempty"`

	// The content type of icon16x162x.
	Icon16x162xContentType *string `json:"icon_16x16_2x_content_type,omitempty"`

	// Safari icon 32x32.
	Icon32x32 io.ReadCloser `json:"icon_32x32,omitempty"`

	// The content type of icon32x32.
	Icon32x32ContentType *string `json:"icon_32x32_content_type,omitempty"`

	// Safari icon 32x32@2x.
	Icon32x322x io.ReadCloser `json:"icon_32x32_2x,omitempty"`

	// The content type of icon32x322x.
	Icon32x322xContentType *string `json:"icon_32x32_2x_content_type,omitempty"`

	// Safari icon 128x128.
	Icon128x128 io.ReadCloser `json:"icon_128x128,omitempty"`

	// The content type of icon128x128.
	Icon128x128ContentType *string `json:"icon_128x128_content_type,omitempty"`

	// Safari icon 128x128@2x.
	Icon128x1282x io.ReadCloser `json:"icon_128x128_2x,omitempty"`

	// The content type of icon128x1282x.
	Icon128x1282xContentType *string `json:"icon_128x128_2x_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDestinationOptions.Type property.
// The type of Destination Webhook.
const (
	CreateDestinationOptionsTypeIbmceConst       = "ibmce"
	CreateDestinationOptionsTypeIbmcfConst       = "ibmcf"
	CreateDestinationOptionsTypeIbmcosConst      = "ibmcos"
	CreateDestinationOptionsTypeMsteamsConst     = "msteams"
	CreateDestinationOptionsTypePagerdutyConst   = "pagerduty"
	CreateDestinationOptionsTypePushAndroidConst = "push_android"
	CreateDestinationOptionsTypePushChromeConst  = "push_chrome"
	CreateDestinationOptionsTypePushFirefoxConst = "push_firefox"
	CreateDestinationOptionsTypePushHuaweiConst  = "push_huawei"
	CreateDestinationOptionsTypePushIosConst     = "push_ios"
	CreateDestinationOptionsTypePushSafariConst  = "push_safari"
	CreateDestinationOptionsTypeServicenowConst  = "servicenow"
	CreateDestinationOptionsTypeSlackConst       = "slack"
	CreateDestinationOptionsTypeWebhookConst     = "webhook"
)

// NewCreateDestinationOptions : Instantiate CreateDestinationOptions
func (*EventNotificationsV1) NewCreateDestinationOptions(instanceID string, name string, typeVar string) *CreateDestinationOptions {
	return &CreateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateDestinationOptions) SetInstanceID(instanceID string) *CreateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDestinationOptions) SetName(name string) *CreateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateDestinationOptions) SetType(typeVar string) *CreateDestinationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateDestinationOptions) SetDescription(description string) *CreateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *CreateDestinationOptions) SetConfig(config *DestinationConfig) *CreateDestinationOptions {
	_options.Config = config
	return _options
}

// SetCertificate : Allow user to set Certificate
func (_options *CreateDestinationOptions) SetCertificate(certificate io.ReadCloser) *CreateDestinationOptions {
	_options.Certificate = certificate
	return _options
}

// SetCertificateContentType : Allow user to set CertificateContentType
func (_options *CreateDestinationOptions) SetCertificateContentType(certificateContentType string) *CreateDestinationOptions {
	_options.CertificateContentType = core.StringPtr(certificateContentType)
	return _options
}

// SetIcon16x16 : Allow user to set Icon16x16
func (_options *CreateDestinationOptions) SetIcon16x16(icon16x16 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon16x16 = icon16x16
	return _options
}

// SetIcon16x16ContentType : Allow user to set Icon16x16ContentType
func (_options *CreateDestinationOptions) SetIcon16x16ContentType(icon16x16ContentType string) *CreateDestinationOptions {
	_options.Icon16x16ContentType = core.StringPtr(icon16x16ContentType)
	return _options
}

// SetIcon16x162x : Allow user to set Icon16x162x
func (_options *CreateDestinationOptions) SetIcon16x162x(icon16x162x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon16x162x = icon16x162x
	return _options
}

// SetIcon16x162xContentType : Allow user to set Icon16x162xContentType
func (_options *CreateDestinationOptions) SetIcon16x162xContentType(icon16x162xContentType string) *CreateDestinationOptions {
	_options.Icon16x162xContentType = core.StringPtr(icon16x162xContentType)
	return _options
}

// SetIcon32x32 : Allow user to set Icon32x32
func (_options *CreateDestinationOptions) SetIcon32x32(icon32x32 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon32x32 = icon32x32
	return _options
}

// SetIcon32x32ContentType : Allow user to set Icon32x32ContentType
func (_options *CreateDestinationOptions) SetIcon32x32ContentType(icon32x32ContentType string) *CreateDestinationOptions {
	_options.Icon32x32ContentType = core.StringPtr(icon32x32ContentType)
	return _options
}

// SetIcon32x322x : Allow user to set Icon32x322x
func (_options *CreateDestinationOptions) SetIcon32x322x(icon32x322x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon32x322x = icon32x322x
	return _options
}

// SetIcon32x322xContentType : Allow user to set Icon32x322xContentType
func (_options *CreateDestinationOptions) SetIcon32x322xContentType(icon32x322xContentType string) *CreateDestinationOptions {
	_options.Icon32x322xContentType = core.StringPtr(icon32x322xContentType)
	return _options
}

// SetIcon128x128 : Allow user to set Icon128x128
func (_options *CreateDestinationOptions) SetIcon128x128(icon128x128 io.ReadCloser) *CreateDestinationOptions {
	_options.Icon128x128 = icon128x128
	return _options
}

// SetIcon128x128ContentType : Allow user to set Icon128x128ContentType
func (_options *CreateDestinationOptions) SetIcon128x128ContentType(icon128x128ContentType string) *CreateDestinationOptions {
	_options.Icon128x128ContentType = core.StringPtr(icon128x128ContentType)
	return _options
}

// SetIcon128x1282x : Allow user to set Icon128x1282x
func (_options *CreateDestinationOptions) SetIcon128x1282x(icon128x1282x io.ReadCloser) *CreateDestinationOptions {
	_options.Icon128x1282x = icon128x1282x
	return _options
}

// SetIcon128x1282xContentType : Allow user to set Icon128x1282xContentType
func (_options *CreateDestinationOptions) SetIcon128x1282xContentType(icon128x1282xContentType string) *CreateDestinationOptions {
	_options.Icon128x1282xContentType = core.StringPtr(icon128x1282xContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDestinationOptions) SetHeaders(param map[string]string) *CreateDestinationOptions {
	options.Headers = param
	return options
}

// CreateSourcesOptions : The CreateSources options.
type CreateSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSourcesOptions : Instantiate CreateSourcesOptions
func (*EventNotificationsV1) NewCreateSourcesOptions(instanceID string, name string, description string) *CreateSourcesOptions {
	return &CreateSourcesOptions{
		InstanceID:  core.StringPtr(instanceID),
		Name:        core.StringPtr(name),
		Description: core.StringPtr(description),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSourcesOptions) SetInstanceID(instanceID string) *CreateSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSourcesOptions) SetName(name string) *CreateSourcesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSourcesOptions) SetDescription(description string) *CreateSourcesOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *CreateSourcesOptions) SetEnabled(enabled bool) *CreateSourcesOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSourcesOptions) SetHeaders(param map[string]string) *CreateSourcesOptions {
	options.Headers = param
	return options
}

// CreateSubscriptionOptions : The CreateSubscription options.
type CreateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Subscription description.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionCreateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubscriptionOptions : Instantiate CreateSubscriptionOptions
func (*EventNotificationsV1) NewCreateSubscriptionOptions(instanceID string, name string, destinationID string, topicID string) *CreateSubscriptionOptions {
	return &CreateSubscriptionOptions{
		InstanceID:    core.StringPtr(instanceID),
		Name:          core.StringPtr(name),
		DestinationID: core.StringPtr(destinationID),
		TopicID:       core.StringPtr(topicID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSubscriptionOptions) SetInstanceID(instanceID string) *CreateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSubscriptionOptions) SetName(name string) *CreateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDestinationID : Allow user to set DestinationID
func (_options *CreateSubscriptionOptions) SetDestinationID(destinationID string) *CreateSubscriptionOptions {
	_options.DestinationID = core.StringPtr(destinationID)
	return _options
}

// SetTopicID : Allow user to set TopicID
func (_options *CreateSubscriptionOptions) SetTopicID(topicID string) *CreateSubscriptionOptions {
	_options.TopicID = core.StringPtr(topicID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSubscriptionOptions) SetDescription(description string) *CreateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *CreateSubscriptionOptions) SetAttributes(attributes SubscriptionCreateAttributesIntf) *CreateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubscriptionOptions) SetHeaders(param map[string]string) *CreateSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTagsSubscriptionOptions : The CreateTagsSubscription options.
type CreateTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTagsSubscriptionOptions : Instantiate CreateTagsSubscriptionOptions
func (*EventNotificationsV1) NewCreateTagsSubscriptionOptions(instanceID string, id string, deviceID string, tagName string) *CreateTagsSubscriptionOptions {
	return &CreateTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		DeviceID:   core.StringPtr(deviceID),
		TagName:    core.StringPtr(tagName),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTagsSubscriptionOptions) SetInstanceID(instanceID string) *CreateTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTagsSubscriptionOptions) SetID(id string) *CreateTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateTagsSubscriptionOptions) SetDeviceID(deviceID string) *CreateTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *CreateTagsSubscriptionOptions) SetTagName(tagName string) *CreateTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTagsSubscriptionOptions) SetHeaders(param map[string]string) *CreateTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTopicOptions : The CreateTopic options.
type CreateTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []SourcesItems `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTopicOptions : Instantiate CreateTopicOptions
func (*EventNotificationsV1) NewCreateTopicOptions(instanceID string, name string) *CreateTopicOptions {
	return &CreateTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTopicOptions) SetInstanceID(instanceID string) *CreateTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTopicOptions) SetName(name string) *CreateTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateTopicOptions) SetDescription(description string) *CreateTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *CreateTopicOptions) SetSources(sources []SourcesItems) *CreateTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTopicOptions) SetHeaders(param map[string]string) *CreateTopicOptions {
	options.Headers = param
	return options
}

// DeleteDestinationOptions : The DeleteDestination options.
type DeleteDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDestinationOptions : Instantiate DeleteDestinationOptions
func (*EventNotificationsV1) NewDeleteDestinationOptions(instanceID string, id string) *DeleteDestinationOptions {
	return &DeleteDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteDestinationOptions) SetInstanceID(instanceID string) *DeleteDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteDestinationOptions) SetID(id string) *DeleteDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDestinationOptions) SetHeaders(param map[string]string) *DeleteDestinationOptions {
	options.Headers = param
	return options
}

// DeleteSourceOptions : The DeleteSource options.
type DeleteSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSourceOptions : Instantiate DeleteSourceOptions
func (*EventNotificationsV1) NewDeleteSourceOptions(instanceID string, id string) *DeleteSourceOptions {
	return &DeleteSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSourceOptions) SetInstanceID(instanceID string) *DeleteSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSourceOptions) SetID(id string) *DeleteSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSourceOptions) SetHeaders(param map[string]string) *DeleteSourceOptions {
	options.Headers = param
	return options
}

// DeleteSubscriptionOptions : The DeleteSubscription options.
type DeleteSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubscriptionOptions : Instantiate DeleteSubscriptionOptions
func (*EventNotificationsV1) NewDeleteSubscriptionOptions(instanceID string, id string) *DeleteSubscriptionOptions {
	return &DeleteSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSubscriptionOptions) SetInstanceID(instanceID string) *DeleteSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSubscriptionOptions) SetID(id string) *DeleteSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubscriptionOptions) SetHeaders(param map[string]string) *DeleteSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTagsSubscriptionOptions : The DeleteTagsSubscription options.
type DeleteTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Device ID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTagsSubscriptionOptions : Instantiate DeleteTagsSubscriptionOptions
func (*EventNotificationsV1) NewDeleteTagsSubscriptionOptions(instanceID string, id string) *DeleteTagsSubscriptionOptions {
	return &DeleteTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTagsSubscriptionOptions) SetInstanceID(instanceID string) *DeleteTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTagsSubscriptionOptions) SetID(id string) *DeleteTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *DeleteTagsSubscriptionOptions) SetDeviceID(deviceID string) *DeleteTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *DeleteTagsSubscriptionOptions) SetTagName(tagName string) *DeleteTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTagsSubscriptionOptions) SetHeaders(param map[string]string) *DeleteTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTopicOptions : The DeleteTopic options.
type DeleteTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTopicOptions : Instantiate DeleteTopicOptions
func (*EventNotificationsV1) NewDeleteTopicOptions(instanceID string, id string) *DeleteTopicOptions {
	return &DeleteTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTopicOptions) SetInstanceID(instanceID string) *DeleteTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTopicOptions) SetID(id string) *DeleteTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTopicOptions) SetHeaders(param map[string]string) *DeleteTopicOptions {
	options.Headers = param
	return options
}

// Destination : Payload describing a destination get request.
type Destination struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type
	// Email/SMS/Webhook/FCM/Slack/MSTeams/PagerDuty/IBMCloudFunctions/IBMCodeEngine/ServiceNow/IBMCloudObjectStorage/Huawei.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`
}

// Constants associated with the Destination.Type property.
// Destination type
// Email/SMS/Webhook/FCM/Slack/MSTeams/PagerDuty/IBMCloudFunctions/IBMCodeEngine/ServiceNow/IBMCloudObjectStorage/Huawei.
const (
	DestinationTypeIbmceConst       = "ibmce"
	DestinationTypeIbmcfConst       = "ibmcf"
	DestinationTypeIbmcosConst      = "ibmcos"
	DestinationTypeMsteamsConst     = "msteams"
	DestinationTypePagerdutyConst   = "pagerduty"
	DestinationTypePushAndroidConst = "push_android"
	DestinationTypePushHuaweiConst  = "push_huawei"
	DestinationTypePushIosConst     = "push_ios"
	DestinationTypePushSafariConst  = "push_safari"
	DestinationTypeSMTPIBMConst     = "smtp_ibm"
	DestinationTypeServicenowConst  = "servicenow"
	DestinationTypeSlackConst       = "slack"
	DestinationTypeSmsIBMConst      = "sms_ibm"
	DestinationTypeWebhookConst     = "webhook"
)

// UnmarshalDestination unmarshals an instance of Destination from the specified map of raw messages.
func UnmarshalDestination(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Destination)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfig : Payload describing a destination configuration.
type DestinationConfig struct {
	Params DestinationConfigOneOfIntf `json:"params" validate:"required"`
}

// NewDestinationConfig : Instantiate DestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfig(params DestinationConfigOneOfIntf) (_model *DestinationConfig, err error) {
	_model = &DestinationConfig{
		Params: params,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalDestinationConfig unmarshals an instance of DestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfig)
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalDestinationConfigOneOf)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOf : DestinationConfigOneOf struct
// Models which "extend" this model:
// - DestinationConfigOneOfWebhookDestinationConfig
// - DestinationConfigOneOfFcmDestinationConfig
// - DestinationConfigOneOfIosDestinationConfig
// - DestinationConfigOneOfChromeDestinationConfig
// - DestinationConfigOneOfFirefoxDestinationConfig
// - DestinationConfigOneOfSlackDestinationConfig
// - DestinationConfigOneOfSafariDestinationConfig
// - DestinationConfigOneOfMsTeamsDestinationConfig
// - DestinationConfigOneOfIBMCloudFunctionsDestinationConfig
// - DestinationConfigOneOfPagerDutyDestinationConfig
// - DestinationConfigOneOfServiceNowDestinationConfig
// - DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig
// - DestinationConfigOneOfHuaweiDestinationConfig
type DestinationConfigOneOf struct {
	// URL of webhook.
	URL *string `json:"url,omitempty"`

	// HTTP method of webhook.
	Verb *string `json:"verb,omitempty"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`

	// FCM server_key.
	ServerKey *string `json:"server_key,omitempty"`

	// FCM sender_id.
	SenderID *string `json:"sender_id,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`

	// FCM project_id.
	ProjectID *string `json:"project_id,omitempty"`

	// FCM private_key.
	PrivateKey *string `json:"private_key,omitempty"`

	// FCM client_email.
	ClientEmail *string `json:"client_email,omitempty"`

	// Authentication type (p8 or p12).
	CertType *string `json:"cert_type,omitempty"`

	// Sandbox mode for iOS destinations.
	IsSandbox *bool `json:"is_sandbox,omitempty"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password,omitempty"`

	// Key ID for token (Required when cert_type is p8).
	KeyID *string `json:"key_id,omitempty"`

	// Team ID for token (Required when cert_type is p8).
	TeamID *string `json:"team_id,omitempty"`

	// Bundle ID for token (Required when cert_type is p8).
	BundleID *string `json:"bundle_id,omitempty"`

	// FCM api_key.
	APIKey *string `json:"api_key,omitempty"`

	// Website url.
	WebsiteURL *string `json:"website_url,omitempty"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// Website url.
	WebsiteName *string `json:"website_name,omitempty"`

	// Website url.
	URLFormatString *string `json:"url_format_string,omitempty"`

	// Website url.
	WebsitePushID *string `json:"website_push_id,omitempty"`

	// Routing Key (Integration Key) for the team in PagerDuty account.
	RoutingKey *string `json:"routing_key,omitempty"`

	// ClientID for the ServiceNow account oauth.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret for the ServiceNow account oauth.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Username for ServiceNow account REST API.
	Username *string `json:"username,omitempty"`

	// Instance name for ServiceNow account.
	InstanceName *string `json:"instance_name,omitempty"`

	// Bucket Name for Cloud Object Storage.
	BucketName *string `json:"bucket_name,omitempty"`

	// Instance Id of Cloud Object Storage.
	InstanceID *string `json:"instance_id,omitempty"`

	// End Point of Cloud Object Storage.
	Endpoint *string `json:"endpoint,omitempty"`
}

// Constants associated with the DestinationConfigOneOf.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigOneOfVerbGetConst  = "get"
	DestinationConfigOneOfVerbPostConst = "post"
)

func (*DestinationConfigOneOf) isaDestinationConfigOneOf() bool {
	return true
}

type DestinationConfigOneOfIntf interface {
	isaDestinationConfigOneOf() bool
}

// UnmarshalDestinationConfigOneOf unmarshals an instance of DestinationConfigOneOf from the specified map of raw messages.
func UnmarshalDestinationConfigOneOf(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOf)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "project_id", &obj.ProjectID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_key", &obj.PrivateKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_email", &obj.ClientEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_sandbox", &obj.IsSandbox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_id", &obj.KeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_id", &obj.TeamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bundle_id", &obj.BundleID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_name", &obj.WebsiteName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_format_string", &obj.URLFormatString)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_push_id", &obj.WebsitePushID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_key", &obj.RoutingKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_id", &obj.ClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_secret", &obj.ClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_name", &obj.InstanceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bucket_name", &obj.BucketName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationList : Payload describing a destination list request.
type DestinationList struct {
	// Total number of destinations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destinations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of destinations.
	Destinations []DestinationListItem `json:"destinations" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalDestinationList unmarshals an instance of DestinationList from the specified map of raw messages.
func UnmarshalDestinationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "destinations", &obj.Destinations, UnmarshalDestinationListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *DestinationList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// DestinationListItem : Destination object.
type DestinationListItem struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type.
	Type *string `json:"type" validate:"required"`

	// Subscription count.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// Names of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the DestinationListItem.Type property.
// Destination type.
const (
	DestinationListItemTypeIbmceConst       = "ibmce"
	DestinationListItemTypeIbmcfConst       = "ibmcf"
	DestinationListItemTypeIbmcosConst      = "ibmcos"
	DestinationListItemTypeMsteamsConst     = "msteams"
	DestinationListItemTypePagerdutyConst   = "pagerduty"
	DestinationListItemTypePushAndroidConst = "push_android"
	DestinationListItemTypePushHuaweiConst  = "push_huawei"
	DestinationListItemTypePushIosConst     = "push_ios"
	DestinationListItemTypePushSafariConst  = "push_safari"
	DestinationListItemTypeSMTPIBMConst     = "smtp_ibm"
	DestinationListItemTypeServicenowConst  = "servicenow"
	DestinationListItemTypeSlackConst       = "slack"
	DestinationListItemTypeSmsIBMConst      = "sms_ibm"
	DestinationListItemTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationListItem unmarshals an instance of DestinationListItem from the specified map of raw messages.
func UnmarshalDestinationListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationResponse : Payload describing a destination get request.
type DestinationResponse struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config" validate:"required"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// Constants associated with the DestinationResponse.Type property.
// Destination type.
const (
	DestinationResponseTypeIbmceConst       = "ibmce"
	DestinationResponseTypeIbmcfConst       = "ibmcf"
	DestinationResponseTypeIbmcosConst      = "ibmcos"
	DestinationResponseTypeMsteamsConst     = "msteams"
	DestinationResponseTypePagerdutyConst   = "pagerduty"
	DestinationResponseTypePushAndroidConst = "push_android"
	DestinationResponseTypePushChromeConst  = "push_chrome"
	DestinationResponseTypePushFirefoxConst = "push_firefox"
	DestinationResponseTypePushHuaweiConst  = "push_huawei"
	DestinationResponseTypePushIosConst     = "push_ios"
	DestinationResponseTypePushSafariConst  = "push_safari"
	DestinationResponseTypeServicenowConst  = "servicenow"
	DestinationResponseTypeSlackConst       = "slack"
	DestinationResponseTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationResponse unmarshals an instance of DestinationResponse from the specified map of raw messages.
func UnmarshalDestinationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationTagsSubscriptionResponse : Payload describing a destination get request.
type DestinationTagsSubscriptionResponse struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalDestinationTagsSubscriptionResponse unmarshals an instance of DestinationTagsSubscriptionResponse from the specified map of raw messages.
func UnmarshalDestinationTagsSubscriptionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationTagsSubscriptionResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailAttributesResponseInvitedItems : EmailAttributesResponseInvitedItems struct
type EmailAttributesResponseInvitedItems struct {
	// email address.
	Email *string `json:"email,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// time of expiration.
	ExpiresAt *strfmt.DateTime `json:"expires_at,omitempty"`
}

// UnmarshalEmailAttributesResponseInvitedItems unmarshals an instance of EmailAttributesResponseInvitedItems from the specified map of raw messages.
func UnmarshalEmailAttributesResponseInvitedItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailAttributesResponseInvitedItems)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires_at", &obj.ExpiresAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailAttributesResponseSubscribedUnsubscribedItems : EmailAttributesResponseSubscribedUnsubscribedItems struct
type EmailAttributesResponseSubscribedUnsubscribedItems struct {
	// email address.
	Email *string `json:"email,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems unmarshals an instance of EmailAttributesResponseSubscribedUnsubscribedItems from the specified map of raw messages.
func UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailAttributesResponseSubscribedUnsubscribedItems)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDestinationOptions : The GetDestination options.
type GetDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationOptions : Instantiate GetDestinationOptions
func (*EventNotificationsV1) NewGetDestinationOptions(instanceID string, id string) *GetDestinationOptions {
	return &GetDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationOptions) SetInstanceID(instanceID string) *GetDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationOptions) SetID(id string) *GetDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationOptions) SetHeaders(param map[string]string) *GetDestinationOptions {
	options.Headers = param
	return options
}

// GetIntegrationOptions : The GetIntegration options.
type GetIntegrationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for integration.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIntegrationOptions : Instantiate GetIntegrationOptions
func (*EventNotificationsV1) NewGetIntegrationOptions(instanceID string, id string) *GetIntegrationOptions {
	return &GetIntegrationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetIntegrationOptions) SetInstanceID(instanceID string) *GetIntegrationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetIntegrationOptions) SetID(id string) *GetIntegrationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetIntegrationOptions) SetHeaders(param map[string]string) *GetIntegrationOptions {
	options.Headers = param
	return options
}

// GetSourceOptions : The GetSource options.
type GetSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSourceOptions : Instantiate GetSourceOptions
func (*EventNotificationsV1) NewGetSourceOptions(instanceID string, id string) *GetSourceOptions {
	return &GetSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSourceOptions) SetInstanceID(instanceID string) *GetSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSourceOptions) SetID(id string) *GetSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSourceOptions) SetHeaders(param map[string]string) *GetSourceOptions {
	options.Headers = param
	return options
}

// GetSubscriptionOptions : The GetSubscription options.
type GetSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubscriptionOptions : Instantiate GetSubscriptionOptions
func (*EventNotificationsV1) NewGetSubscriptionOptions(instanceID string, id string) *GetSubscriptionOptions {
	return &GetSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSubscriptionOptions) SetInstanceID(instanceID string) *GetSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSubscriptionOptions) SetID(id string) *GetSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubscriptionOptions) SetHeaders(param map[string]string) *GetSubscriptionOptions {
	options.Headers = param
	return options
}

// GetTopicOptions : The GetTopic options.
type GetTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Include sub topics.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTopicOptions : Instantiate GetTopicOptions
func (*EventNotificationsV1) NewGetTopicOptions(instanceID string, id string) *GetTopicOptions {
	return &GetTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetTopicOptions) SetInstanceID(instanceID string) *GetTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTopicOptions) SetID(id string) *GetTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInclude : Allow user to set Include
func (_options *GetTopicOptions) SetInclude(include string) *GetTopicOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTopicOptions) SetHeaders(param map[string]string) *GetTopicOptions {
	options.Headers = param
	return options
}

// IntegrationGetResponse : Integration response object.
type IntegrationGetResponse struct {
	// ID of the integration.
	ID *strfmt.UUID `json:"id" validate:"required"`

	// Integration type. Allowed values are kms and hs-crypto.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationMetadata `json:"metadata" validate:"required"`

	// Creation time of an integration.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Last update time of an integration.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalIntegrationGetResponse unmarshals an instance of IntegrationGetResponse from the specified map of raw messages.
func UnmarshalIntegrationGetResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationGetResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalIntegrationMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationList : all Integrations response object.
type IntegrationList struct {
	// Number of integrations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show integrations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of integrations.
	Integrations []IntegrationListItem `json:"integrations" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalIntegrationList unmarshals an instance of IntegrationList from the specified map of raw messages.
func UnmarshalIntegrationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "integrations", &obj.Integrations, UnmarshalIntegrationListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *IntegrationList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// IntegrationListItem : all Integrations response object.
type IntegrationListItem struct {
	// ID of the integration.
	ID *strfmt.UUID `json:"id" validate:"required"`

	// Integration type. Allowed values are kms and hs-crypto.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationMetadata `json:"metadata" validate:"required"`

	// Creation time of an integration.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Update time of an integration.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalIntegrationListItem unmarshals an instance of IntegrationListItem from the specified map of raw messages.
func UnmarshalIntegrationListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalIntegrationMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IntegrationMetadata : Integration Metadata object.
type IntegrationMetadata struct {
	// KMS url for key management.
	Endpoint *string `json:"endpoint" validate:"required"`

	// CRN of the KMS instance.
	CRN *string `json:"crn" validate:"required"`

	// Root Key ID of KMS.
	RootKeyID *string `json:"root_key_id" validate:"required"`
}

// NewIntegrationMetadata : Instantiate IntegrationMetadata (Generic Model Constructor)
func (*EventNotificationsV1) NewIntegrationMetadata(endpoint string, crn string, rootKeyID string) (_model *IntegrationMetadata, err error) {
	_model = &IntegrationMetadata{
		Endpoint:  core.StringPtr(endpoint),
		CRN:       core.StringPtr(crn),
		RootKeyID: core.StringPtr(rootKeyID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalIntegrationMetadata unmarshals an instance of IntegrationMetadata from the specified map of raw messages.
func UnmarshalIntegrationMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IntegrationMetadata)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "root_key_id", &obj.RootKeyID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListDestinationsOptions : The ListDestinations options.
type ListDestinationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationsOptions : Instantiate ListDestinationsOptions
func (*EventNotificationsV1) NewListDestinationsOptions(instanceID string) *ListDestinationsOptions {
	return &ListDestinationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationsOptions) SetInstanceID(instanceID string) *ListDestinationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationsOptions) SetLimit(limit int64) *ListDestinationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationsOptions) SetOffset(offset int64) *ListDestinationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationsOptions) SetSearch(search string) *ListDestinationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationsOptions) SetHeaders(param map[string]string) *ListDestinationsOptions {
	options.Headers = param
	return options
}

// ListIntegrationsOptions : The ListIntegrations options.
type ListIntegrationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIntegrationsOptions : Instantiate ListIntegrationsOptions
func (*EventNotificationsV1) NewListIntegrationsOptions(instanceID string) *ListIntegrationsOptions {
	return &ListIntegrationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListIntegrationsOptions) SetInstanceID(instanceID string) *ListIntegrationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListIntegrationsOptions) SetOffset(offset int64) *ListIntegrationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListIntegrationsOptions) SetLimit(limit int64) *ListIntegrationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListIntegrationsOptions) SetSearch(search string) *ListIntegrationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListIntegrationsOptions) SetHeaders(param map[string]string) *ListIntegrationsOptions {
	options.Headers = param
	return options
}

// ListSourcesOptions : The ListSources options.
type ListSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSourcesOptions : Instantiate ListSourcesOptions
func (*EventNotificationsV1) NewListSourcesOptions(instanceID string) *ListSourcesOptions {
	return &ListSourcesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSourcesOptions) SetInstanceID(instanceID string) *ListSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSourcesOptions) SetLimit(limit int64) *ListSourcesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSourcesOptions) SetOffset(offset int64) *ListSourcesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSourcesOptions) SetSearch(search string) *ListSourcesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSourcesOptions) SetHeaders(param map[string]string) *ListSourcesOptions {
	options.Headers = param
	return options
}

// ListSubscriptionsOptions : The ListSubscriptions options.
type ListSubscriptionsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubscriptionsOptions : Instantiate ListSubscriptionsOptions
func (*EventNotificationsV1) NewListSubscriptionsOptions(instanceID string) *ListSubscriptionsOptions {
	return &ListSubscriptionsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSubscriptionsOptions) SetInstanceID(instanceID string) *ListSubscriptionsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSubscriptionsOptions) SetOffset(offset int64) *ListSubscriptionsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubscriptionsOptions) SetLimit(limit int64) *ListSubscriptionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSubscriptionsOptions) SetSearch(search string) *ListSubscriptionsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubscriptionsOptions) SetHeaders(param map[string]string) *ListSubscriptionsOptions {
	options.Headers = param
	return options
}

// ListTagsSubscriptionOptions : The ListTagsSubscription options.
type ListTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Device ID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// UserID of the destination.
	UserID *string `json:"user_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTagsSubscriptionOptions : Instantiate ListTagsSubscriptionOptions
func (*EventNotificationsV1) NewListTagsSubscriptionOptions(instanceID string, id string) *ListTagsSubscriptionOptions {
	return &ListTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTagsSubscriptionOptions) SetInstanceID(instanceID string) *ListTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTagsSubscriptionOptions) SetID(id string) *ListTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTagsSubscriptionOptions) SetDeviceID(deviceID string) *ListTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *ListTagsSubscriptionOptions) SetUserID(userID string) *ListTagsSubscriptionOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *ListTagsSubscriptionOptions) SetTagName(tagName string) *ListTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTagsSubscriptionOptions) SetLimit(limit int64) *ListTagsSubscriptionOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTagsSubscriptionOptions) SetOffset(offset int64) *ListTagsSubscriptionOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTagsSubscriptionOptions) SetSearch(search string) *ListTagsSubscriptionOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTagsSubscriptionOptions) SetHeaders(param map[string]string) *ListTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// ListTopicsOptions : The ListTopics options.
type ListTopicsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTopicsOptions : Instantiate ListTopicsOptions
func (*EventNotificationsV1) NewListTopicsOptions(instanceID string) *ListTopicsOptions {
	return &ListTopicsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTopicsOptions) SetInstanceID(instanceID string) *ListTopicsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTopicsOptions) SetLimit(limit int64) *ListTopicsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTopicsOptions) SetOffset(offset int64) *ListTopicsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTopicsOptions) SetSearch(search string) *ListTopicsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTopicsOptions) SetHeaders(param map[string]string) *ListTopicsOptions {
	options.Headers = param
	return options
}

// NotificationCreate : Payload describing a notification create request.
type NotificationCreate struct {
	// The version of the notification specification.
	Specversion *string `json:"specversion" validate:"required"`

	// The time notification was created.
	Time *strfmt.DateTime `json:"time,omitempty"`

	// The unique identifier of the notification.
	ID *string `json:"id" validate:"required"`

	// The source of notifications.
	Source *string `json:"source" validate:"required"`

	// The notifications type.
	Type *string `json:"type" validate:"required"`

	// The severity of the notification.
	Ibmenseverity *string `json:"ibmenseverity,omitempty"`

	// The source id of the notification.
	Ibmensourceid *string `json:"ibmensourceid" validate:"required"`

	// Default short text for the message.
	Ibmendefaultshort *string `json:"ibmendefaultshort" validate:"required"`

	// Default long text for the message.
	Ibmendefaultlong *string `json:"ibmendefaultlong" validate:"required"`

	// The subject of the notification.
	Subject *string `json:"subject,omitempty"`

	// The payload for webhook notification.
	Data map[string]interface{} `json:"data,omitempty"`

	// The notification content type.
	Datacontenttype *string `json:"datacontenttype,omitempty"`

	// If platforms or tags or user_ids is used then do not use fcm_devices / apns_devices / chrome_devices /
	// firefox_devices / safari_devices with it. Value should be stringified.
	Ibmenpushto *string `json:"ibmenpushto,omitempty"`

	// Payload describing a notification FCM body. Value should be stringified.
	Ibmenfcmbody *string `json:"ibmenfcmbody,omitempty"`

	// Payload describing a notification APNs body. Value should be stringified.
	Ibmenapnsbody *string `json:"ibmenapnsbody,omitempty"`

	// Headers for iOS notification. Value should be stringified.
	Ibmenapnsheaders *string `json:"ibmenapnsheaders,omitempty"`

	// Notification payload for Chrome. Value should be stringified.
	Ibmenchromebody *string `json:"ibmenchromebody,omitempty"`

	// Headers for a Chrome notification. Value should be stringified.
	Ibmenchromeheaders *string `json:"ibmenchromeheaders,omitempty"`

	// Notification payload for Firefox. Value should be stringified.
	Ibmenfirefoxbody *string `json:"ibmenfirefoxbody,omitempty"`

	// Headers for a Firefox notification. Value should be stringified.
	Ibmenfirefoxheaders *string `json:"ibmenfirefoxheaders,omitempty"`

	// Payload describing a notification Huawei body. Value should be stringified.
	Ibmenhuaweibody *string `json:"ibmenhuaweibody,omitempty"`

	// Payload describing a notification Safari body. Value should be stringified.
	Ibmensafaribody *string `json:"ibmensafaribody,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// NewNotificationCreate : Instantiate NotificationCreate (Generic Model Constructor)
func (*EventNotificationsV1) NewNotificationCreate(specversion string, id string, source string, typeVar string, ibmensourceid string, ibmendefaultshort string, ibmendefaultlong string) (_model *NotificationCreate, err error) {
	_model = &NotificationCreate{
		Specversion:       core.StringPtr(specversion),
		ID:                core.StringPtr(id),
		Source:            core.StringPtr(source),
		Type:              core.StringPtr(typeVar),
		Ibmensourceid:     core.StringPtr(ibmensourceid),
		Ibmendefaultshort: core.StringPtr(ibmendefaultshort),
		Ibmendefaultlong:  core.StringPtr(ibmendefaultlong),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// SetProperty allows the user to set an arbitrary property on an instance of NotificationCreate
func (o *NotificationCreate) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of NotificationCreate
func (o *NotificationCreate) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of NotificationCreate
func (o *NotificationCreate) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of NotificationCreate
func (o *NotificationCreate) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of NotificationCreate
func (o *NotificationCreate) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Specversion != nil {
		m["specversion"] = o.Specversion
	}
	if o.Time != nil {
		m["time"] = o.Time
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Source != nil {
		m["source"] = o.Source
	}
	if o.Type != nil {
		m["type"] = o.Type
	}
	if o.Ibmenseverity != nil {
		m["ibmenseverity"] = o.Ibmenseverity
	}
	if o.Ibmensourceid != nil {
		m["ibmensourceid"] = o.Ibmensourceid
	}
	if o.Ibmendefaultshort != nil {
		m["ibmendefaultshort"] = o.Ibmendefaultshort
	}
	if o.Ibmendefaultlong != nil {
		m["ibmendefaultlong"] = o.Ibmendefaultlong
	}
	if o.Subject != nil {
		m["subject"] = o.Subject
	}
	if o.Data != nil {
		m["data"] = o.Data
	}
	if o.Datacontenttype != nil {
		m["datacontenttype"] = o.Datacontenttype
	}
	if o.Ibmenpushto != nil {
		m["ibmenpushto"] = o.Ibmenpushto
	}
	if o.Ibmenfcmbody != nil {
		m["ibmenfcmbody"] = o.Ibmenfcmbody
	}
	if o.Ibmenapnsbody != nil {
		m["ibmenapnsbody"] = o.Ibmenapnsbody
	}
	if o.Ibmenapnsheaders != nil {
		m["ibmenapnsheaders"] = o.Ibmenapnsheaders
	}
	if o.Ibmenchromebody != nil {
		m["ibmenchromebody"] = o.Ibmenchromebody
	}
	if o.Ibmenchromeheaders != nil {
		m["ibmenchromeheaders"] = o.Ibmenchromeheaders
	}
	if o.Ibmenfirefoxbody != nil {
		m["ibmenfirefoxbody"] = o.Ibmenfirefoxbody
	}
	if o.Ibmenfirefoxheaders != nil {
		m["ibmenfirefoxheaders"] = o.Ibmenfirefoxheaders
	}
	if o.Ibmenhuaweibody != nil {
		m["ibmenhuaweibody"] = o.Ibmenhuaweibody
	}
	if o.Ibmensafaribody != nil {
		m["ibmensafaribody"] = o.Ibmensafaribody
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalNotificationCreate unmarshals an instance of NotificationCreate from the specified map of raw messages.
func UnmarshalNotificationCreate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationCreate)
	err = core.UnmarshalPrimitive(m, "specversion", &obj.Specversion)
	if err != nil {
		return
	}
	delete(m, "specversion")
	err = core.UnmarshalPrimitive(m, "time", &obj.Time)
	if err != nil {
		return
	}
	delete(m, "time")
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	delete(m, "source")
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	delete(m, "type")
	err = core.UnmarshalPrimitive(m, "ibmenseverity", &obj.Ibmenseverity)
	if err != nil {
		return
	}
	delete(m, "ibmenseverity")
	err = core.UnmarshalPrimitive(m, "ibmensourceid", &obj.Ibmensourceid)
	if err != nil {
		return
	}
	delete(m, "ibmensourceid")
	err = core.UnmarshalPrimitive(m, "ibmendefaultshort", &obj.Ibmendefaultshort)
	if err != nil {
		return
	}
	delete(m, "ibmendefaultshort")
	err = core.UnmarshalPrimitive(m, "ibmendefaultlong", &obj.Ibmendefaultlong)
	if err != nil {
		return
	}
	delete(m, "ibmendefaultlong")
	err = core.UnmarshalPrimitive(m, "subject", &obj.Subject)
	if err != nil {
		return
	}
	delete(m, "subject")
	err = core.UnmarshalPrimitive(m, "data", &obj.Data)
	if err != nil {
		return
	}
	delete(m, "data")
	err = core.UnmarshalPrimitive(m, "datacontenttype", &obj.Datacontenttype)
	if err != nil {
		return
	}
	delete(m, "datacontenttype")
	err = core.UnmarshalPrimitive(m, "ibmenpushto", &obj.Ibmenpushto)
	if err != nil {
		return
	}
	delete(m, "ibmenpushto")
	err = core.UnmarshalPrimitive(m, "ibmenfcmbody", &obj.Ibmenfcmbody)
	if err != nil {
		return
	}
	delete(m, "ibmenfcmbody")
	err = core.UnmarshalPrimitive(m, "ibmenapnsbody", &obj.Ibmenapnsbody)
	if err != nil {
		return
	}
	delete(m, "ibmenapnsbody")
	err = core.UnmarshalPrimitive(m, "ibmenapnsheaders", &obj.Ibmenapnsheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenapnsheaders")
	err = core.UnmarshalPrimitive(m, "ibmenchromebody", &obj.Ibmenchromebody)
	if err != nil {
		return
	}
	delete(m, "ibmenchromebody")
	err = core.UnmarshalPrimitive(m, "ibmenchromeheaders", &obj.Ibmenchromeheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenchromeheaders")
	err = core.UnmarshalPrimitive(m, "ibmenfirefoxbody", &obj.Ibmenfirefoxbody)
	if err != nil {
		return
	}
	delete(m, "ibmenfirefoxbody")
	err = core.UnmarshalPrimitive(m, "ibmenfirefoxheaders", &obj.Ibmenfirefoxheaders)
	if err != nil {
		return
	}
	delete(m, "ibmenfirefoxheaders")
	err = core.UnmarshalPrimitive(m, "ibmenhuaweibody", &obj.Ibmenhuaweibody)
	if err != nil {
		return
	}
	delete(m, "ibmenhuaweibody")
	err = core.UnmarshalPrimitive(m, "ibmensafaribody", &obj.Ibmensafaribody)
	if err != nil {
		return
	}
	delete(m, "ibmensafaribody")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationResponse : Payload describing a notifications response.
type NotificationResponse struct {
	// Notification ID.
	NotificationID *string `json:"notification_id,omitempty"`
}

// UnmarshalNotificationResponse unmarshals an instance of NotificationResponse from the specified map of raw messages.
func UnmarshalNotificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationResponse)
	err = core.UnmarshalPrimitive(m, "notification_id", &obj.NotificationID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PageHrefResponse : Response having URL of the page.
type PageHrefResponse struct {
	// URL to the page.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPageHrefResponse unmarshals an instance of PageHrefResponse from the specified map of raw messages.
func UnmarshalPageHrefResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PageHrefResponse)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceIntegrationOptions : The ReplaceIntegration options.
type ReplaceIntegrationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for integration.
	ID *string `json:"id" validate:"required,ne="`

	// Integration type. Allowed values are kms and hs-crypto.
	Type *string `json:"type" validate:"required"`

	// Integration Metadata object.
	Metadata *IntegrationMetadata `json:"metadata" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceIntegrationOptions : Instantiate ReplaceIntegrationOptions
func (*EventNotificationsV1) NewReplaceIntegrationOptions(instanceID string, id string, typeVar string, metadata *IntegrationMetadata) *ReplaceIntegrationOptions {
	return &ReplaceIntegrationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		Type:       core.StringPtr(typeVar),
		Metadata:   metadata,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceIntegrationOptions) SetInstanceID(instanceID string) *ReplaceIntegrationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceIntegrationOptions) SetID(id string) *ReplaceIntegrationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *ReplaceIntegrationOptions) SetType(typeVar string) *ReplaceIntegrationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetMetadata : Allow user to set Metadata
func (_options *ReplaceIntegrationOptions) SetMetadata(metadata *IntegrationMetadata) *ReplaceIntegrationOptions {
	_options.Metadata = metadata
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceIntegrationOptions) SetHeaders(param map[string]string) *ReplaceIntegrationOptions {
	options.Headers = param
	return options
}

// ReplaceTopicOptions : The ReplaceTopic options.
type ReplaceTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name,omitempty"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []SourcesItems `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTopicOptions : Instantiate ReplaceTopicOptions
func (*EventNotificationsV1) NewReplaceTopicOptions(instanceID string, id string) *ReplaceTopicOptions {
	return &ReplaceTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceTopicOptions) SetInstanceID(instanceID string) *ReplaceTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTopicOptions) SetID(id string) *ReplaceTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *ReplaceTopicOptions) SetName(name string) *ReplaceTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *ReplaceTopicOptions) SetDescription(description string) *ReplaceTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *ReplaceTopicOptions) SetSources(sources []SourcesItems) *ReplaceTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTopicOptions) SetHeaders(param map[string]string) *ReplaceTopicOptions {
	options.Headers = param
	return options
}

// Rules : Rule object.
type Rules struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter,omitempty"`
}

// NewRules : Instantiate Rules (Generic Model Constructor)
func (*EventNotificationsV1) NewRules(eventTypeFilter string) (_model *Rules, err error) {
	_model = &Rules{
		EventTypeFilter: core.StringPtr(eventTypeFilter),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalRules unmarshals an instance of Rules from the specified map of raw messages.
func UnmarshalRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Rules)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RulesGet : Rule object.
type RulesGet struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Autogenerated rule ID.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalRulesGet unmarshals an instance of RulesGet from the specified map of raw messages.
func UnmarshalRulesGet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RulesGet)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SmsAttributesItems : The sms attributes.
type SmsAttributesItems struct {
	// Phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalSmsAttributesItems unmarshals an instance of SmsAttributesItems from the specified map of raw messages.
func UnmarshalSmsAttributesItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SmsAttributesItems)
	err = core.UnmarshalPrimitive(m, "phone_number", &obj.PhoneNumber)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SmsInviteAttributesItems : The sms attributes.
type SmsInviteAttributesItems struct {
	// Phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// time of expiration.
	ExpiresAt *strfmt.DateTime `json:"expires_at,omitempty"`
}

// UnmarshalSmsInviteAttributesItems unmarshals an instance of SmsInviteAttributesItems from the specified map of raw messages.
func UnmarshalSmsInviteAttributesItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SmsInviteAttributesItems)
	err = core.UnmarshalPrimitive(m, "phone_number", &obj.PhoneNumber)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires_at", &obj.ExpiresAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SendBulkNotificationsOptions : The SendBulkNotifications options.
type SendBulkNotificationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// List of notifications body.
	BulkMessages []NotificationCreate `json:"bulk_messages,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSendBulkNotificationsOptions : Instantiate SendBulkNotificationsOptions
func (*EventNotificationsV1) NewSendBulkNotificationsOptions(instanceID string) *SendBulkNotificationsOptions {
	return &SendBulkNotificationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *SendBulkNotificationsOptions) SetInstanceID(instanceID string) *SendBulkNotificationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBulkMessages : Allow user to set BulkMessages
func (_options *SendBulkNotificationsOptions) SetBulkMessages(bulkMessages []NotificationCreate) *SendBulkNotificationsOptions {
	_options.BulkMessages = bulkMessages
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SendBulkNotificationsOptions) SetHeaders(param map[string]string) *SendBulkNotificationsOptions {
	options.Headers = param
	return options
}

// SendNotificationsOptions : The SendNotifications options.
type SendNotificationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Payload describing a notification create request.
	Body *NotificationCreate `json:"body,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSendNotificationsOptions : Instantiate SendNotificationsOptions
func (*EventNotificationsV1) NewSendNotificationsOptions(instanceID string) *SendNotificationsOptions {
	return &SendNotificationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *SendNotificationsOptions) SetInstanceID(instanceID string) *SendNotificationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *SendNotificationsOptions) SetBody(body *NotificationCreate) *SendNotificationsOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SendNotificationsOptions) SetHeaders(param map[string]string) *SendNotificationsOptions {
	options.Headers = param
	return options
}

// Source : Payload describing a source generate request.
type Source struct {
	// The id of the source.
	ID *string `json:"id" validate:"required"`

	// The name of the source.
	Name *string `json:"name" validate:"required"`

	// The description of the source.
	Description *string `json:"description" validate:"required"`

	// The status of the source.
	Enabled *bool `json:"enabled" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// The last updated time of the source.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`

	// The names of the topics.
	TopicNames []string `json:"topic_names" validate:"required"`
}

// UnmarshalSource unmarshals an instance of Source from the specified map of raw messages.
func UnmarshalSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Source)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_names", &obj.TopicNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceList : Payload describing a source list request.
type SourceList struct {
	// Number of sources.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show sources.
	Limit *int64 `json:"limit" validate:"required"`

	// List of sources.
	Sources []SourceListItem `json:"sources" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalSourceList unmarshals an instance of SourceList from the specified map of raw messages.
func UnmarshalSourceList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourceListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SourceList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// SourceListItem : Payload describing a source list item.
type SourceListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the last update.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`
}

// UnmarshalSourceListItem unmarshals an instance of SourceListItem from the specified map of raw messages.
func UnmarshalSourceListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceResponse : Payload describing a source.
type SourceResponse struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalSourceResponse unmarshals an instance of SourceResponse from the specified map of raw messages.
func UnmarshalSourceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesItems : SourcesItems struct
type SourcesItems struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// List of rules.
	Rules []Rules `json:"rules" validate:"required"`
}

// NewSourcesItems : Instantiate SourcesItems (Generic Model Constructor)
func (*EventNotificationsV1) NewSourcesItems(id string, rules []Rules) (_model *SourcesItems, err error) {
	_model = &SourcesItems{
		ID:    core.StringPtr(id),
		Rules: rules,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalSourcesItems unmarshals an instance of SourcesItems from the specified map of raw messages.
func UnmarshalSourcesItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesItems)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRules)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesListItems : Payload describing a source list item.
type SourcesListItems struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// List of rules.
	Rules []RulesGet `json:"rules,omitempty"`
}

// UnmarshalSourcesListItems unmarshals an instance of SourcesListItems from the specified map of raw messages.
func UnmarshalSourcesListItems(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesListItems)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRulesGet)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subscription : Subscription object.
type Subscription struct {
	// Subscription ID.
	ID *string `json:"id" validate:"required"`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Subscription description.
	Description *string `json:"description" validate:"required"`

	// Last updated time.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// From Email ID (it will be displayed only in case of smtp_ibm destination type).
	From *string `json:"from,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// The destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// The destination name.
	DestinationName *string `json:"destination_name" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Topic name.
	TopicName *string `json:"topic_name" validate:"required"`

	Attributes SubscriptionAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the Subscription.DestinationType property.
// The type of destination.
const (
	SubscriptionDestinationTypeIbmceConst       = "ibmce"
	SubscriptionDestinationTypeIbmcfConst       = "ibmcf"
	SubscriptionDestinationTypeIbmcosConst      = "ibmcos"
	SubscriptionDestinationTypeMsteamsConst     = "msteams"
	SubscriptionDestinationTypePagerdutyConst   = "pagerduty"
	SubscriptionDestinationTypePushAndroidConst = "push_android"
	SubscriptionDestinationTypePushChromeConst  = "push_chrome"
	SubscriptionDestinationTypePushFirefoxConst = "push_firefox"
	SubscriptionDestinationTypePushHuaweiConst  = "push_huawei"
	SubscriptionDestinationTypePushIosConst     = "push_ios"
	SubscriptionDestinationTypePushSafariConst  = "push_safari"
	SubscriptionDestinationTypeSMTPIBMConst     = "smtp_ibm"
	SubscriptionDestinationTypeServicenowConst  = "servicenow"
	SubscriptionDestinationTypeSlackConst       = "slack"
	SubscriptionDestinationTypeSmsIBMConst      = "sms_ibm"
	SubscriptionDestinationTypeWebhookConst     = "webhook"
)

// SetProperty allows the user to set an arbitrary property on an instance of Subscription
func (o *Subscription) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Subscription
func (o *Subscription) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Subscription
func (o *Subscription) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Subscription
func (o *Subscription) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Subscription
func (o *Subscription) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Description != nil {
		m["description"] = o.Description
	}
	if o.UpdatedAt != nil {
		m["updated_at"] = o.UpdatedAt
	}
	if o.From != nil {
		m["from"] = o.From
	}
	if o.DestinationType != nil {
		m["destination_type"] = o.DestinationType
	}
	if o.DestinationID != nil {
		m["destination_id"] = o.DestinationID
	}
	if o.DestinationName != nil {
		m["destination_name"] = o.DestinationName
	}
	if o.TopicID != nil {
		m["topic_id"] = o.TopicID
	}
	if o.TopicName != nil {
		m["topic_name"] = o.TopicName
	}
	if o.Attributes != nil {
		m["attributes"] = o.Attributes
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscription unmarshals an instance of Subscription from the specified map of raw messages.
func UnmarshalSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subscription)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	delete(m, "description")
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	delete(m, "updated_at")
	err = core.UnmarshalPrimitive(m, "from", &obj.From)
	if err != nil {
		return
	}
	delete(m, "from")
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	delete(m, "destination_type")
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	delete(m, "destination_id")
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	delete(m, "destination_name")
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	delete(m, "topic_id")
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	delete(m, "topic_name")
	err = core.UnmarshalModel(m, "attributes", &obj.Attributes, UnmarshalSubscriptionAttributes)
	if err != nil {
		return
	}
	delete(m, "attributes")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributes : SubscriptionAttributes struct
// Models which "extend" this model:
// - SubscriptionAttributesSmsAttributesResponse
// - SubscriptionAttributesEmailAttributesResponse
// - SubscriptionAttributesWebhookAttributesResponse
// - SubscriptionAttributesSlackAttributesResponse
// - SubscriptionAttributesServiceNowAttributesResponse
type SubscriptionAttributes struct {
	// The subscribed list.
	Subscribed []SmsAttributesItems `json:"subscribed,omitempty"`

	// The unsubscribe list.
	Unsubscribed []SmsAttributesItems `json:"unsubscribed,omitempty"`

	// The email id string.
	Invited []SmsInviteAttributesItems `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for Slack Notification.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// Assigned name from ServiceNow account.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Assigned group name from ServiceNow account.
	AssignmentGroup *string `json:"assignment_group,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributes) isaSubscriptionAttributes() bool {
	return true
}

type SubscriptionAttributesIntf interface {
	isaSubscriptionAttributes() bool
	SetProperty(key string, value interface{})
	SetProperties(m map[string]interface{})
	GetProperty(key string) interface{}
	GetProperties() map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributes
func (o *SubscriptionAttributes) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	if o.ReplyToMail != nil {
		m["reply_to_mail"] = o.ReplyToMail
	}
	if o.ReplyToName != nil {
		m["reply_to_name"] = o.ReplyToName
	}
	if o.FromName != nil {
		m["from_name"] = o.FromName
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AttachmentColor != nil {
		m["attachment_color"] = o.AttachmentColor
	}
	if o.AssignedTo != nil {
		m["assigned_to"] = o.AssignedTo
	}
	if o.AssignmentGroup != nil {
		m["assignment_group"] = o.AssignmentGroup
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributes unmarshals an instance of SubscriptionAttributes from the specified map of raw messages.
func UnmarshalSubscriptionAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributes)
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalSmsInviteAttributesItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	delete(m, "reply_to_mail")
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	delete(m, "reply_to_name")
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	delete(m, "from_name")
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	delete(m, "attachment_color")
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	delete(m, "assigned_to")
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	delete(m, "assignment_group")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributes : SubscriptionCreateAttributes struct
// Models which "extend" this model:
// - SubscriptionCreateAttributesSmsAttributes
// - SubscriptionCreateAttributesEmailAttributes
// - SubscriptionCreateAttributesWebhookAttributes
// - SubscriptionCreateAttributesFcmAttributes
// - SubscriptionCreateAttributesSlackAttributes
// - SubscriptionCreateAttributesServiceNowAttributes
type SubscriptionCreateAttributes struct {
	// The sms id string.
	Invited []string `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionCreateAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

type SubscriptionCreateAttributesIntf interface {
	isaSubscriptionCreateAttributes() bool
}

// UnmarshalSubscriptionCreateAttributes unmarshals an instance of SubscriptionCreateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionList : Subscription list object.
type SubscriptionList struct {
	// Number of subscriptions.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalSubscriptionList unmarshals an instance of SubscriptionList from the specified map of raw messages.
func UnmarshalSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *SubscriptionList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// SubscriptionListItem : Subscription list item.
type SubscriptionListItem struct {
	// ID of the subscription.
	ID *string `json:"id" validate:"required"`

	// Name of the subscription.
	Name *string `json:"name" validate:"required"`

	// Description of the subscription.
	Description *string `json:"description" validate:"required"`

	// ID of the destination.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Name of the destination.
	DestinationName *string `json:"destination_name,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// ID of the topic.
	TopicID *string `json:"topic_id" validate:"required"`

	// Name of the topic.
	TopicName *string `json:"topic_name,omitempty"`

	// Last updated time of the subscription.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the SubscriptionListItem.DestinationType property.
// The type of destination.
const (
	SubscriptionListItemDestinationTypeIbmceConst       = "ibmce"
	SubscriptionListItemDestinationTypeIbmcfConst       = "ibmcf"
	SubscriptionListItemDestinationTypeIbmcosConst      = "ibmcos"
	SubscriptionListItemDestinationTypeMsteamsConst     = "msteams"
	SubscriptionListItemDestinationTypePagerdutyConst   = "pagerduty"
	SubscriptionListItemDestinationTypePushAndroidConst = "push_android"
	SubscriptionListItemDestinationTypePushChromeConst  = "push_chrome"
	SubscriptionListItemDestinationTypePushFirefoxConst = "push_firefox"
	SubscriptionListItemDestinationTypePushHuaweiConst  = "push_huawei"
	SubscriptionListItemDestinationTypePushIosConst     = "push_ios"
	SubscriptionListItemDestinationTypePushSafariConst  = "push_safari"
	SubscriptionListItemDestinationTypeSMTPIBMConst     = "smtp_ibm"
	SubscriptionListItemDestinationTypeServicenowConst  = "servicenow"
	SubscriptionListItemDestinationTypeSlackConst       = "slack"
	SubscriptionListItemDestinationTypeSmsIBMConst      = "sms_ibm"
	SubscriptionListItemDestinationTypeWebhookConst     = "webhook"
)

// UnmarshalSubscriptionListItem unmarshals an instance of SubscriptionListItem from the specified map of raw messages.
func UnmarshalSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributes : SubscriptionUpdateAttributes struct
// Models which "extend" this model:
// - SubscriptionUpdateAttributesSmsUpdateAttributes
// - SubscriptionUpdateAttributesEmailUpdateAttributes
// - SubscriptionUpdateAttributesWebhookAttributes
// - SubscriptionUpdateAttributesSlackAttributes
// - SubscriptionUpdateAttributesServiceNowAttributes
type SubscriptionUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

type SubscriptionUpdateAttributesIntf interface {
	isaSubscriptionUpdateAttributes() bool
}

// UnmarshalSubscriptionUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagsSubscriptionList : Payload describing a tags list request.
type TagsSubscriptionList struct {
	// Total number of tags.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show tags.
	Limit *int64 `json:"limit" validate:"required"`

	// List of tags.
	TagSubscriptions []TagsSubscriptionListItem `json:"tag_subscriptions" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalTagsSubscriptionList unmarshals an instance of TagsSubscriptionList from the specified map of raw messages.
func UnmarshalTagsSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tag_subscriptions", &obj.TagSubscriptions, UnmarshalTagsSubscriptionListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TagsSubscriptionList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// TagsSubscriptionListItem : Tags subscription object.
type TagsSubscriptionListItem struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalTagsSubscriptionListItem unmarshals an instance of TagsSubscriptionListItem from the specified map of raw messages.
func UnmarshalTagsSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Topic : Topic object.
type Topic struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of sources.
	Sources []SourcesListItems `json:"sources" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalTopic unmarshals an instance of Topic from the specified map of raw messages.
func UnmarshalTopic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Topic)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourcesListItems)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicList : Topic list object.
type TopicList struct {
	// Number of topics.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of topics.
	Topics []TopicsListItem `json:"topics" validate:"required"`

	// Response having URL of the page.
	First *PageHrefResponse `json:"first,omitempty"`

	// Response having URL of the page.
	Previous *PageHrefResponse `json:"previous,omitempty"`

	// Response having URL of the page.
	Next *PageHrefResponse `json:"next,omitempty"`
}

// UnmarshalTopicList unmarshals an instance of TopicList from the specified map of raw messages.
func UnmarshalTopicList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "topics", &obj.Topics, UnmarshalTopicsListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "previous", &obj.Previous, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPageHrefResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TopicList) GetNextOffset() (*int64, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	offset, err := core.GetQueryParam(resp.Next.Href, "offset")
	if err != nil || offset == nil {
		return nil, err
	}
	var offsetValue int64
	offsetValue, err = strconv.ParseInt(*offset, 10, 64)
	if err != nil {
		return nil, err
	}
	return core.Int64Ptr(offsetValue), nil
}

// TopicResponse : Topic object.
type TopicResponse struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Last time the topic was updated.
	CreatedAt *string `json:"created_at" validate:"required"`
}

// UnmarshalTopicResponse unmarshals an instance of TopicResponse from the specified map of raw messages.
func UnmarshalTopicResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicsListItem : Topic list item object.
type TopicsListItem struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of source names.
	SourcesNames []string `json:"sources_names" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`
}

// UnmarshalTopicsListItem unmarshals an instance of TopicsListItem from the specified map of raw messages.
func UnmarshalTopicsListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicsListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sources_names", &obj.SourcesNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateAttributesInvited : The email ids or phone numbers.
type UpdateAttributesInvited struct {
	// The email ids or phone numbers to be invited.
	Add []string `json:"add,omitempty"`

	// The email ids or phone numbers for removal.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalUpdateAttributesInvited unmarshals an instance of UpdateAttributesInvited from the specified map of raw messages.
func UnmarshalUpdateAttributesInvited(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateAttributesInvited)
	err = core.UnmarshalPrimitive(m, "add", &obj.Add)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateAttributesSubscribed : The email ids or phone numbers.
type UpdateAttributesSubscribed struct {
	// The email ids or phone numbers to be unsubscribed.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalUpdateAttributesSubscribed unmarshals an instance of UpdateAttributesSubscribed from the specified map of raw messages.
func UnmarshalUpdateAttributesSubscribed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateAttributesSubscribed)
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateAttributesUnsubscribed : The email ids or phone numbers.
type UpdateAttributesUnsubscribed struct {
	// The email ids or phone numbers to be unsubscribed.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalUpdateAttributesUnsubscribed unmarshals an instance of UpdateAttributesUnsubscribed from the specified map of raw messages.
func UnmarshalUpdateAttributesUnsubscribed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateAttributesUnsubscribed)
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateDestinationOptions : The UpdateDestination options.
type UpdateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Destination name.
	Name *string `json:"name,omitempty"`

	// Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Certificate for APNS.
	Certificate io.ReadCloser `json:"certificate,omitempty"`

	// The content type of certificate.
	CertificateContentType *string `json:"certificate_content_type,omitempty"`

	// Safari icon 16x16.
	Icon16x16 io.ReadCloser `json:"icon_16x16,omitempty"`

	// The content type of icon16x16.
	Icon16x16ContentType *string `json:"icon_16x16_content_type,omitempty"`

	// Safari icon 16x16@2x.
	Icon16x162x io.ReadCloser `json:"icon_16x16_2x,omitempty"`

	// The content type of icon16x162x.
	Icon16x162xContentType *string `json:"icon_16x16_2x_content_type,omitempty"`

	// Safari icon 32x32.
	Icon32x32 io.ReadCloser `json:"icon_32x32,omitempty"`

	// The content type of icon32x32.
	Icon32x32ContentType *string `json:"icon_32x32_content_type,omitempty"`

	// Safari icon 32x32@2x.
	Icon32x322x io.ReadCloser `json:"icon_32x32_2x,omitempty"`

	// The content type of icon32x322x.
	Icon32x322xContentType *string `json:"icon_32x32_2x_content_type,omitempty"`

	// Safari icon 128x128.
	Icon128x128 io.ReadCloser `json:"icon_128x128,omitempty"`

	// The content type of icon128x128.
	Icon128x128ContentType *string `json:"icon_128x128_content_type,omitempty"`

	// Safari icon 128x128@2x.
	Icon128x1282x io.ReadCloser `json:"icon_128x128_2x,omitempty"`

	// The content type of icon128x1282x.
	Icon128x1282xContentType *string `json:"icon_128x128_2x_content_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDestinationOptions : Instantiate UpdateDestinationOptions
func (*EventNotificationsV1) NewUpdateDestinationOptions(instanceID string, id string) *UpdateDestinationOptions {
	return &UpdateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateDestinationOptions) SetInstanceID(instanceID string) *UpdateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateDestinationOptions) SetID(id string) *UpdateDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateDestinationOptions) SetName(name string) *UpdateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateDestinationOptions) SetDescription(description string) *UpdateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *UpdateDestinationOptions) SetConfig(config *DestinationConfig) *UpdateDestinationOptions {
	_options.Config = config
	return _options
}

// SetCertificate : Allow user to set Certificate
func (_options *UpdateDestinationOptions) SetCertificate(certificate io.ReadCloser) *UpdateDestinationOptions {
	_options.Certificate = certificate
	return _options
}

// SetCertificateContentType : Allow user to set CertificateContentType
func (_options *UpdateDestinationOptions) SetCertificateContentType(certificateContentType string) *UpdateDestinationOptions {
	_options.CertificateContentType = core.StringPtr(certificateContentType)
	return _options
}

// SetIcon16x16 : Allow user to set Icon16x16
func (_options *UpdateDestinationOptions) SetIcon16x16(icon16x16 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon16x16 = icon16x16
	return _options
}

// SetIcon16x16ContentType : Allow user to set Icon16x16ContentType
func (_options *UpdateDestinationOptions) SetIcon16x16ContentType(icon16x16ContentType string) *UpdateDestinationOptions {
	_options.Icon16x16ContentType = core.StringPtr(icon16x16ContentType)
	return _options
}

// SetIcon16x162x : Allow user to set Icon16x162x
func (_options *UpdateDestinationOptions) SetIcon16x162x(icon16x162x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon16x162x = icon16x162x
	return _options
}

// SetIcon16x162xContentType : Allow user to set Icon16x162xContentType
func (_options *UpdateDestinationOptions) SetIcon16x162xContentType(icon16x162xContentType string) *UpdateDestinationOptions {
	_options.Icon16x162xContentType = core.StringPtr(icon16x162xContentType)
	return _options
}

// SetIcon32x32 : Allow user to set Icon32x32
func (_options *UpdateDestinationOptions) SetIcon32x32(icon32x32 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon32x32 = icon32x32
	return _options
}

// SetIcon32x32ContentType : Allow user to set Icon32x32ContentType
func (_options *UpdateDestinationOptions) SetIcon32x32ContentType(icon32x32ContentType string) *UpdateDestinationOptions {
	_options.Icon32x32ContentType = core.StringPtr(icon32x32ContentType)
	return _options
}

// SetIcon32x322x : Allow user to set Icon32x322x
func (_options *UpdateDestinationOptions) SetIcon32x322x(icon32x322x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon32x322x = icon32x322x
	return _options
}

// SetIcon32x322xContentType : Allow user to set Icon32x322xContentType
func (_options *UpdateDestinationOptions) SetIcon32x322xContentType(icon32x322xContentType string) *UpdateDestinationOptions {
	_options.Icon32x322xContentType = core.StringPtr(icon32x322xContentType)
	return _options
}

// SetIcon128x128 : Allow user to set Icon128x128
func (_options *UpdateDestinationOptions) SetIcon128x128(icon128x128 io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon128x128 = icon128x128
	return _options
}

// SetIcon128x128ContentType : Allow user to set Icon128x128ContentType
func (_options *UpdateDestinationOptions) SetIcon128x128ContentType(icon128x128ContentType string) *UpdateDestinationOptions {
	_options.Icon128x128ContentType = core.StringPtr(icon128x128ContentType)
	return _options
}

// SetIcon128x1282x : Allow user to set Icon128x1282x
func (_options *UpdateDestinationOptions) SetIcon128x1282x(icon128x1282x io.ReadCloser) *UpdateDestinationOptions {
	_options.Icon128x1282x = icon128x1282x
	return _options
}

// SetIcon128x1282xContentType : Allow user to set Icon128x1282xContentType
func (_options *UpdateDestinationOptions) SetIcon128x1282xContentType(icon128x1282xContentType string) *UpdateDestinationOptions {
	_options.Icon128x1282xContentType = core.StringPtr(icon128x1282xContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDestinationOptions) SetHeaders(param map[string]string) *UpdateDestinationOptions {
	options.Headers = param
	return options
}

// UpdateSourceOptions : The UpdateSource options.
type UpdateSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the source.
	Name *string `json:"name,omitempty"`

	// Description of the source.
	Description *string `json:"description,omitempty"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSourceOptions : Instantiate UpdateSourceOptions
func (*EventNotificationsV1) NewUpdateSourceOptions(instanceID string, id string) *UpdateSourceOptions {
	return &UpdateSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSourceOptions) SetInstanceID(instanceID string) *UpdateSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSourceOptions) SetID(id string) *UpdateSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSourceOptions) SetName(name string) *UpdateSourceOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSourceOptions) SetDescription(description string) *UpdateSourceOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *UpdateSourceOptions) SetEnabled(enabled bool) *UpdateSourceOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSourceOptions) SetHeaders(param map[string]string) *UpdateSourceOptions {
	options.Headers = param
	return options
}

// UpdateSubscriptionOptions : The UpdateSubscription options.
type UpdateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the subscription.
	Name *string `json:"name,omitempty"`

	// Description of the subscription.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionUpdateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubscriptionOptions : Instantiate UpdateSubscriptionOptions
func (*EventNotificationsV1) NewUpdateSubscriptionOptions(instanceID string, id string) *UpdateSubscriptionOptions {
	return &UpdateSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSubscriptionOptions) SetInstanceID(instanceID string) *UpdateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSubscriptionOptions) SetID(id string) *UpdateSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSubscriptionOptions) SetName(name string) *UpdateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSubscriptionOptions) SetDescription(description string) *UpdateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *UpdateSubscriptionOptions) SetAttributes(attributes SubscriptionUpdateAttributesIntf) *UpdateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubscriptionOptions) SetHeaders(param map[string]string) *UpdateSubscriptionOptions {
	options.Headers = param
	return options
}

// DestinationConfigOneOfChromeDestinationConfig : Payload describing a Chrome destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfChromeDestinationConfig struct {
	// FCM api_key.
	APIKey *string `json:"api_key" validate:"required"`

	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfChromeDestinationConfig : Instantiate DestinationConfigOneOfChromeDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfChromeDestinationConfig(apiKey string, websiteURL string) (_model *DestinationConfigOneOfChromeDestinationConfig, err error) {
	_model = &DestinationConfigOneOfChromeDestinationConfig{
		APIKey:     core.StringPtr(apiKey),
		WebsiteURL: core.StringPtr(websiteURL),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfChromeDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfChromeDestinationConfig unmarshals an instance of DestinationConfigOneOfChromeDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfChromeDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfChromeDestinationConfig)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfFcmDestinationConfig : Payload describing an FCM destination configuration. project_id, private_key and client_email for FCM HTTP v1 APIs.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfFcmDestinationConfig struct {
	// FCM server_key.
	ServerKey *string `json:"server_key,omitempty"`

	// FCM sender_id.
	SenderID *string `json:"sender_id,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`

	// FCM project_id.
	ProjectID *string `json:"project_id,omitempty"`

	// FCM private_key.
	PrivateKey *string `json:"private_key,omitempty"`

	// FCM client_email.
	ClientEmail *string `json:"client_email,omitempty"`
}

func (*DestinationConfigOneOfFcmDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfFcmDestinationConfig unmarshals an instance of DestinationConfigOneOfFcmDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfFcmDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfFcmDestinationConfig)
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "project_id", &obj.ProjectID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_key", &obj.PrivateKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_email", &obj.ClientEmail)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfFirefoxDestinationConfig : Payload describing a Firefox destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfFirefoxDestinationConfig struct {
	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Chrome VAPID public key.
	PublicKey *string `json:"public_key,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfFirefoxDestinationConfig : Instantiate DestinationConfigOneOfFirefoxDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfFirefoxDestinationConfig(websiteURL string) (_model *DestinationConfigOneOfFirefoxDestinationConfig, err error) {
	_model = &DestinationConfigOneOfFirefoxDestinationConfig{
		WebsiteURL: core.StringPtr(websiteURL),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfFirefoxDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfFirefoxDestinationConfig unmarshals an instance of DestinationConfigOneOfFirefoxDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfFirefoxDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfFirefoxDestinationConfig)
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfHuaweiDestinationConfig : Payload describing a Huawei destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfHuaweiDestinationConfig struct {
	// ClientID for the Huawei account oauth.
	ClientID *string `json:"client_id" validate:"required"`

	// ClientSecret for the Huawei account oauth.
	ClientSecret *string `json:"client_secret" validate:"required"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfHuaweiDestinationConfig : Instantiate DestinationConfigOneOfHuaweiDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfHuaweiDestinationConfig(clientID string, clientSecret string) (_model *DestinationConfigOneOfHuaweiDestinationConfig, err error) {
	_model = &DestinationConfigOneOfHuaweiDestinationConfig{
		ClientID:     core.StringPtr(clientID),
		ClientSecret: core.StringPtr(clientSecret),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfHuaweiDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfHuaweiDestinationConfig unmarshals an instance of DestinationConfigOneOfHuaweiDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfHuaweiDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfHuaweiDestinationConfig)
	err = core.UnmarshalPrimitive(m, "client_id", &obj.ClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_secret", &obj.ClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfIBMCloudFunctionsDestinationConfig : Payload describing an IBM Cloud Functions destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfIBMCloudFunctionsDestinationConfig struct {
	// URL of IBM Cloud Functions Trigger EndPoint.
	URL *string `json:"url" validate:"required"`

	// API Key with access of IBM Cloud Functions IAM Namespace.
	APIKey *string `json:"api_key,omitempty"`
}

// NewDestinationConfigOneOfIBMCloudFunctionsDestinationConfig : Instantiate DestinationConfigOneOfIBMCloudFunctionsDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfIBMCloudFunctionsDestinationConfig(url string) (_model *DestinationConfigOneOfIBMCloudFunctionsDestinationConfig, err error) {
	_model = &DestinationConfigOneOfIBMCloudFunctionsDestinationConfig{
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfIBMCloudFunctionsDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfIBMCloudFunctionsDestinationConfig unmarshals an instance of DestinationConfigOneOfIBMCloudFunctionsDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfIBMCloudFunctionsDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfIBMCloudFunctionsDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig : Payload describing a Cloud Object Storage destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig struct {
	// Bucket Name for Cloud Object Storage.
	BucketName *string `json:"bucket_name" validate:"required"`

	// Instance Id of Cloud Object Storage.
	InstanceID *string `json:"instance_id" validate:"required"`

	// End Point of Cloud Object Storage.
	Endpoint *string `json:"endpoint" validate:"required"`
}

// NewDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig : Instantiate DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig(bucketName string, instanceID string, endpoint string) (_model *DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig, err error) {
	_model = &DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig{
		BucketName: core.StringPtr(bucketName),
		InstanceID: core.StringPtr(instanceID),
		Endpoint:   core.StringPtr(endpoint),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig unmarshals an instance of DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfIBMCloudObjectStorageDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig)
	err = core.UnmarshalPrimitive(m, "bucket_name", &obj.BucketName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfIosDestinationConfig : Payload describing an iOS destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfIosDestinationConfig struct {
	// Authentication type (p8 or p12).
	CertType *string `json:"cert_type" validate:"required"`

	// Sandbox mode for iOS destinations.
	IsSandbox *bool `json:"is_sandbox" validate:"required"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password,omitempty"`

	// Key ID for token (Required when cert_type is p8).
	KeyID *string `json:"key_id,omitempty"`

	// Team ID for token (Required when cert_type is p8).
	TeamID *string `json:"team_id,omitempty"`

	// Bundle ID for token (Required when cert_type is p8).
	BundleID *string `json:"bundle_id,omitempty"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfIosDestinationConfig : Instantiate DestinationConfigOneOfIosDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfIosDestinationConfig(certType string, isSandbox bool) (_model *DestinationConfigOneOfIosDestinationConfig, err error) {
	_model = &DestinationConfigOneOfIosDestinationConfig{
		CertType:  core.StringPtr(certType),
		IsSandbox: core.BoolPtr(isSandbox),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfIosDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfIosDestinationConfig unmarshals an instance of DestinationConfigOneOfIosDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfIosDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfIosDestinationConfig)
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_sandbox", &obj.IsSandbox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_id", &obj.KeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_id", &obj.TeamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bundle_id", &obj.BundleID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfMsTeamsDestinationConfig : Payload describing a MS Teams destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfMsTeamsDestinationConfig struct {
	// URL of MS Teams Incoming Notifications.
	URL *string `json:"url" validate:"required"`
}

// NewDestinationConfigOneOfMsTeamsDestinationConfig : Instantiate DestinationConfigOneOfMsTeamsDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfMsTeamsDestinationConfig(url string) (_model *DestinationConfigOneOfMsTeamsDestinationConfig, err error) {
	_model = &DestinationConfigOneOfMsTeamsDestinationConfig{
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfMsTeamsDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfMsTeamsDestinationConfig unmarshals an instance of DestinationConfigOneOfMsTeamsDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfMsTeamsDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfMsTeamsDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfPagerDutyDestinationConfig : Payload describing a PagerDuty destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfPagerDutyDestinationConfig struct {
	// API Key for the PagerDuty account.
	APIKey *string `json:"api_key" validate:"required"`

	// Routing Key (Integration Key) for the team in PagerDuty account.
	RoutingKey *string `json:"routing_key" validate:"required"`
}

// NewDestinationConfigOneOfPagerDutyDestinationConfig : Instantiate DestinationConfigOneOfPagerDutyDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfPagerDutyDestinationConfig(apiKey string, routingKey string) (_model *DestinationConfigOneOfPagerDutyDestinationConfig, err error) {
	_model = &DestinationConfigOneOfPagerDutyDestinationConfig{
		APIKey:     core.StringPtr(apiKey),
		RoutingKey: core.StringPtr(routingKey),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfPagerDutyDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfPagerDutyDestinationConfig unmarshals an instance of DestinationConfigOneOfPagerDutyDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfPagerDutyDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfPagerDutyDestinationConfig)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routing_key", &obj.RoutingKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfSafariDestinationConfig : Payload describing a Safari destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfSafariDestinationConfig struct {
	// Authentication type p12.
	CertType *string `json:"cert_type" validate:"required"`

	// Password for certificate (Required when cert_type is p12).
	Password *string `json:"password" validate:"required"`

	// Website url.
	WebsiteURL *string `json:"website_url" validate:"required"`

	// Website url.
	WebsiteName *string `json:"website_name" validate:"required"`

	// Website url.
	URLFormatString *string `json:"url_format_string" validate:"required"`

	// Website url.
	WebsitePushID *string `json:"website_push_id" validate:"required"`

	// If pre prod enabled.
	PreProd *bool `json:"pre_prod,omitempty"`
}

// NewDestinationConfigOneOfSafariDestinationConfig : Instantiate DestinationConfigOneOfSafariDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfSafariDestinationConfig(certType string, password string, websiteURL string, websiteName string, urlFormatString string, websitePushID string) (_model *DestinationConfigOneOfSafariDestinationConfig, err error) {
	_model = &DestinationConfigOneOfSafariDestinationConfig{
		CertType:        core.StringPtr(certType),
		Password:        core.StringPtr(password),
		WebsiteURL:      core.StringPtr(websiteURL),
		WebsiteName:     core.StringPtr(websiteName),
		URLFormatString: core.StringPtr(urlFormatString),
		WebsitePushID:   core.StringPtr(websitePushID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfSafariDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfSafariDestinationConfig unmarshals an instance of DestinationConfigOneOfSafariDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfSafariDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfSafariDestinationConfig)
	err = core.UnmarshalPrimitive(m, "cert_type", &obj.CertType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_url", &obj.WebsiteURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_name", &obj.WebsiteName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_format_string", &obj.URLFormatString)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "website_push_id", &obj.WebsitePushID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pre_prod", &obj.PreProd)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfServiceNowDestinationConfig : Payload describing a ServiceNow destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfServiceNowDestinationConfig struct {
	// ClientID for the ServiceNow account oauth.
	ClientID *string `json:"client_id" validate:"required"`

	// ClientSecret for the ServiceNow account oauth.
	ClientSecret *string `json:"client_secret" validate:"required"`

	// Username for ServiceNow account REST API.
	Username *string `json:"username" validate:"required"`

	// Password for ServiceNow account REST API.
	Password *string `json:"password" validate:"required"`

	// Instance name for ServiceNow account.
	InstanceName *string `json:"instance_name" validate:"required"`
}

// NewDestinationConfigOneOfServiceNowDestinationConfig : Instantiate DestinationConfigOneOfServiceNowDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfServiceNowDestinationConfig(clientID string, clientSecret string, username string, password string, instanceName string) (_model *DestinationConfigOneOfServiceNowDestinationConfig, err error) {
	_model = &DestinationConfigOneOfServiceNowDestinationConfig{
		ClientID:     core.StringPtr(clientID),
		ClientSecret: core.StringPtr(clientSecret),
		Username:     core.StringPtr(username),
		Password:     core.StringPtr(password),
		InstanceName: core.StringPtr(instanceName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfServiceNowDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfServiceNowDestinationConfig unmarshals an instance of DestinationConfigOneOfServiceNowDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfServiceNowDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfServiceNowDestinationConfig)
	err = core.UnmarshalPrimitive(m, "client_id", &obj.ClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "client_secret", &obj.ClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "password", &obj.Password)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_name", &obj.InstanceName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfSlackDestinationConfig : Payload describing a Slack destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfSlackDestinationConfig struct {
	// URL of Slack Incoming Notifications.
	URL *string `json:"url" validate:"required"`
}

// NewDestinationConfigOneOfSlackDestinationConfig : Instantiate DestinationConfigOneOfSlackDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfSlackDestinationConfig(url string) (_model *DestinationConfigOneOfSlackDestinationConfig, err error) {
	_model = &DestinationConfigOneOfSlackDestinationConfig{
		URL: core.StringPtr(url),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfSlackDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfSlackDestinationConfig unmarshals an instance of DestinationConfigOneOfSlackDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfSlackDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfSlackDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigOneOfWebhookDestinationConfig : Payload describing a webhook destination configuration.
// This model "extends" DestinationConfigOneOf
type DestinationConfigOneOfWebhookDestinationConfig struct {
	// URL of webhook.
	URL *string `json:"url" validate:"required"`

	// HTTP method of webhook.
	Verb *string `json:"verb" validate:"required"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigOneOfWebhookDestinationConfig.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigOneOfWebhookDestinationConfigVerbGetConst  = "get"
	DestinationConfigOneOfWebhookDestinationConfigVerbPostConst = "post"
)

// NewDestinationConfigOneOfWebhookDestinationConfig : Instantiate DestinationConfigOneOfWebhookDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigOneOfWebhookDestinationConfig(url string, verb string) (_model *DestinationConfigOneOfWebhookDestinationConfig, err error) {
	_model = &DestinationConfigOneOfWebhookDestinationConfig{
		URL:  core.StringPtr(url),
		Verb: core.StringPtr(verb),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigOneOfWebhookDestinationConfig) isaDestinationConfigOneOf() bool {
	return true
}

// UnmarshalDestinationConfigOneOfWebhookDestinationConfig unmarshals an instance of DestinationConfigOneOfWebhookDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigOneOfWebhookDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigOneOfWebhookDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesEmailAttributesResponse : The attributes reponse for an email destination.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesEmailAttributesResponse struct {
	// The email id string.
	Invited []EmailAttributesResponseInvitedItems `json:"invited,omitempty"`

	// The unsubscribe list.
	Subscribed []EmailAttributesResponseSubscribedUnsubscribedItems `json:"subscribed,omitempty"`

	// The subscribed list.
	Unsubscribed []EmailAttributesResponseSubscribedUnsubscribedItems `json:"unsubscribed,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesEmailAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	if o.ReplyToMail != nil {
		m["reply_to_mail"] = o.ReplyToMail
	}
	if o.ReplyToName != nil {
		m["reply_to_name"] = o.ReplyToName
	}
	if o.FromName != nil {
		m["from_name"] = o.FromName
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesEmailAttributesResponse unmarshals an instance of SubscriptionAttributesEmailAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesEmailAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesEmailAttributesResponse)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalEmailAttributesResponseInvitedItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailAttributesResponseSubscribedUnsubscribedItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	delete(m, "reply_to_mail")
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	delete(m, "reply_to_name")
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	delete(m, "from_name")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSmsAttributesResponse : SMS attributes object.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSmsAttributesResponse struct {
	// The subscribed list.
	Subscribed []SmsAttributesItems `json:"subscribed,omitempty"`

	// The unsubscribe list.
	Unsubscribed []SmsAttributesItems `json:"unsubscribed,omitempty"`

	// The email id string.
	Invited []SmsInviteAttributesItems `json:"invited,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSmsAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Subscribed != nil {
		m["subscribed"] = o.Subscribed
	}
	if o.Unsubscribed != nil {
		m["unsubscribed"] = o.Unsubscribed
	}
	if o.Invited != nil {
		m["invited"] = o.Invited
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSmsAttributesResponse unmarshals an instance of SubscriptionAttributesSmsAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSmsAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSmsAttributesResponse)
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "subscribed")
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalSmsAttributesItems)
	if err != nil {
		return
	}
	delete(m, "unsubscribed")
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalSmsInviteAttributesItems)
	if err != nil {
		return
	}
	delete(m, "invited")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesServiceNowAttributesResponse : The attributes for a ServiceNow notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesServiceNowAttributesResponse struct {
	// Assigned name from ServiceNow account.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Assigned group name from ServiceNow account.
	AssignmentGroup *string `json:"assignment_group,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesServiceNowAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesServiceNowAttributesResponse
func (o *SubscriptionAttributesServiceNowAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.AssignedTo != nil {
		m["assigned_to"] = o.AssignedTo
	}
	if o.AssignmentGroup != nil {
		m["assignment_group"] = o.AssignmentGroup
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesServiceNowAttributesResponse unmarshals an instance of SubscriptionAttributesServiceNowAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesServiceNowAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesServiceNowAttributesResponse)
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	delete(m, "assigned_to")
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	delete(m, "assignment_group")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSlackAttributesResponse : The attributes for a Slack notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSlackAttributesResponse struct {
	// Attachment Color for Slack Notification.
	AttachmentColor *string `json:"attachment_color,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSlackAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSlackAttributesResponse
func (o *SubscriptionAttributesSlackAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.AttachmentColor != nil {
		m["attachment_color"] = o.AttachmentColor
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSlackAttributesResponse unmarshals an instance of SubscriptionAttributesSlackAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSlackAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSlackAttributesResponse)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	delete(m, "attachment_color")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesWebhookAttributesResponse : The attributes for a webhook notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesWebhookAttributesResponse struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesWebhookAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesWebhookAttributesResponse unmarshals an instance of SubscriptionAttributesWebhookAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesWebhookAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesWebhookAttributesResponse)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesEmailAttributes struct {
	// The email id string.
	Invited []string `json:"invited" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`
}

// NewSubscriptionCreateAttributesEmailAttributes : Instantiate SubscriptionCreateAttributesEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesEmailAttributes(invited []string, addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionCreateAttributesEmailAttributes, err error) {
	_model = &SubscriptionCreateAttributesEmailAttributes{
		Invited:                invited,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesEmailAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesEmailAttributes unmarshals an instance of SubscriptionCreateAttributesEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesEmailAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesFcmAttributes : The attributes for an FCM notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesFcmAttributes struct {
}

func (*SubscriptionCreateAttributesFcmAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesFcmAttributes unmarshals an instance of SubscriptionCreateAttributesFcmAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesFcmAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesFcmAttributes)
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSmsAttributes : The attributes for an sms notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSmsAttributes struct {
	// The sms id string.
	Invited []string `json:"invited" validate:"required"`
}

// NewSubscriptionCreateAttributesSmsAttributes : Instantiate SubscriptionCreateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesSmsAttributes(invited []string) (_model *SubscriptionCreateAttributesSmsAttributes, err error) {
	_model = &SubscriptionCreateAttributesSmsAttributes{
		Invited: invited,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesSmsAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSmsAttributes unmarshals an instance of SubscriptionCreateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesServiceNowAttributes : The attributes for a ServiceNow notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesServiceNowAttributes struct {
	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionCreateAttributesServiceNowAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesServiceNowAttributes unmarshals an instance of SubscriptionCreateAttributesServiceNowAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesServiceNowAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesServiceNowAttributes)
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSlackAttributes : The attributes for a slack notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSlackAttributes struct {
	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`
}

func (*SubscriptionCreateAttributesSlackAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSlackAttributes unmarshals an instance of SubscriptionCreateAttributesSlackAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSlackAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSlackAttributes)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionCreateAttributesWebhookAttributes : Instantiate SubscriptionCreateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionCreateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionCreateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesWebhookAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesWebhookAttributes unmarshals an instance of SubscriptionCreateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesEmailUpdateAttributes : The attributes for an email notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesEmailUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

// NewSubscriptionUpdateAttributesEmailUpdateAttributes : Instantiate SubscriptionUpdateAttributesEmailUpdateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesEmailUpdateAttributes(addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionUpdateAttributesEmailUpdateAttributes, err error) {
	_model = &SubscriptionUpdateAttributesEmailUpdateAttributes{
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesEmailUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesEmailUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesEmailUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSmsUpdateAttributes : SMS attributes object.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSmsUpdateAttributes struct {
	// The email ids or phone numbers.
	Invited *UpdateAttributesInvited `json:"invited,omitempty"`

	// The email ids or phone numbers.
	Subscribed *UpdateAttributesSubscribed `json:"subscribed,omitempty"`

	// The email ids or phone numbers.
	Unsubscribed *UpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

func (*SubscriptionUpdateAttributesSmsUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSmsUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesSmsUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSmsUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSmsUpdateAttributes)
	err = core.UnmarshalModel(m, "invited", &obj.Invited, UnmarshalUpdateAttributesInvited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscribed", &obj.Subscribed, UnmarshalUpdateAttributesSubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesServiceNowAttributes : The attributes for a ServiceNow notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesServiceNowAttributes struct {
	// Name of user ServiceNow incident will be assigned to.
	AssignedTo *string `json:"assigned_to,omitempty"`

	// Group Name to which incident will be assigned to.
	AssignmentGroup *string `json:"assignment_group,omitempty"`
}

func (*SubscriptionUpdateAttributesServiceNowAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesServiceNowAttributes unmarshals an instance of SubscriptionUpdateAttributesServiceNowAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesServiceNowAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesServiceNowAttributes)
	err = core.UnmarshalPrimitive(m, "assigned_to", &obj.AssignedTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "assignment_group", &obj.AssignmentGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSlackAttributes : The attributes for a slack notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSlackAttributes struct {
	// Attachment Color for the slack message.
	AttachmentColor *string `json:"attachment_color,omitempty"`
}

func (*SubscriptionUpdateAttributesSlackAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSlackAttributes unmarshals an instance of SubscriptionUpdateAttributesSlackAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSlackAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSlackAttributes)
	err = core.UnmarshalPrimitive(m, "attachment_color", &obj.AttachmentColor)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionUpdateAttributesWebhookAttributes : Instantiate SubscriptionUpdateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionUpdateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionUpdateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesWebhookAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesWebhookAttributes unmarshals an instance of SubscriptionUpdateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesPager can be used to simplify the use of the "ListSources" method.
type SourcesPager struct {
	hasNext     bool
	options     *ListSourcesOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewSourcesPager returns a new SourcesPager instance.
func (eventNotifications *EventNotificationsV1) NewSourcesPager(options *ListSourcesOptions) (pager *SourcesPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListSourcesOptions = *options
	pager = &SourcesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SourcesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SourcesPager) GetNextWithContext(ctx context.Context) (page []SourceListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListSourcesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Sources

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SourcesPager) GetAllWithContext(ctx context.Context) (allItems []SourceListItem, err error) {
	for pager.HasNext() {
		var nextPage []SourceListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SourcesPager) GetNext() (page []SourceListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SourcesPager) GetAll() (allItems []SourceListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// TopicsPager can be used to simplify the use of the "ListTopics" method.
type TopicsPager struct {
	hasNext     bool
	options     *ListTopicsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewTopicsPager returns a new TopicsPager instance.
func (eventNotifications *EventNotificationsV1) NewTopicsPager(options *ListTopicsOptions) (pager *TopicsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListTopicsOptions = *options
	pager = &TopicsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TopicsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TopicsPager) GetNextWithContext(ctx context.Context) (page []TopicsListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListTopicsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Topics

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TopicsPager) GetAllWithContext(ctx context.Context) (allItems []TopicsListItem, err error) {
	for pager.HasNext() {
		var nextPage []TopicsListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TopicsPager) GetNext() (page []TopicsListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TopicsPager) GetAll() (allItems []TopicsListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// DestinationsPager can be used to simplify the use of the "ListDestinations" method.
type DestinationsPager struct {
	hasNext     bool
	options     *ListDestinationsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewDestinationsPager returns a new DestinationsPager instance.
func (eventNotifications *EventNotificationsV1) NewDestinationsPager(options *ListDestinationsOptions) (pager *DestinationsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListDestinationsOptions = *options
	pager = &DestinationsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *DestinationsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *DestinationsPager) GetNextWithContext(ctx context.Context) (page []DestinationListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListDestinationsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Destinations

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *DestinationsPager) GetAllWithContext(ctx context.Context) (allItems []DestinationListItem, err error) {
	for pager.HasNext() {
		var nextPage []DestinationListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *DestinationsPager) GetNext() (page []DestinationListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *DestinationsPager) GetAll() (allItems []DestinationListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// TagsSubscriptionPager can be used to simplify the use of the "ListTagsSubscription" method.
type TagsSubscriptionPager struct {
	hasNext     bool
	options     *ListTagsSubscriptionOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewTagsSubscriptionPager returns a new TagsSubscriptionPager instance.
func (eventNotifications *EventNotificationsV1) NewTagsSubscriptionPager(options *ListTagsSubscriptionOptions) (pager *TagsSubscriptionPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListTagsSubscriptionOptions = *options
	pager = &TagsSubscriptionPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TagsSubscriptionPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TagsSubscriptionPager) GetNextWithContext(ctx context.Context) (page []TagsSubscriptionListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListTagsSubscriptionWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.TagSubscriptions

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TagsSubscriptionPager) GetAllWithContext(ctx context.Context) (allItems []TagsSubscriptionListItem, err error) {
	for pager.HasNext() {
		var nextPage []TagsSubscriptionListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TagsSubscriptionPager) GetNext() (page []TagsSubscriptionListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TagsSubscriptionPager) GetAll() (allItems []TagsSubscriptionListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// SubscriptionsPager can be used to simplify the use of the "ListSubscriptions" method.
type SubscriptionsPager struct {
	hasNext     bool
	options     *ListSubscriptionsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewSubscriptionsPager returns a new SubscriptionsPager instance.
func (eventNotifications *EventNotificationsV1) NewSubscriptionsPager(options *ListSubscriptionsOptions) (pager *SubscriptionsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListSubscriptionsOptions = *options
	pager = &SubscriptionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *SubscriptionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *SubscriptionsPager) GetNextWithContext(ctx context.Context) (page []SubscriptionListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListSubscriptionsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Subscriptions

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *SubscriptionsPager) GetAllWithContext(ctx context.Context) (allItems []SubscriptionListItem, err error) {
	for pager.HasNext() {
		var nextPage []SubscriptionListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *SubscriptionsPager) GetNext() (page []SubscriptionListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *SubscriptionsPager) GetAll() (allItems []SubscriptionListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}

// IntegrationsPager can be used to simplify the use of the "ListIntegrations" method.
type IntegrationsPager struct {
	hasNext     bool
	options     *ListIntegrationsOptions
	client      *EventNotificationsV1
	pageContext struct {
		next *int64
	}
}

// NewIntegrationsPager returns a new IntegrationsPager instance.
func (eventNotifications *EventNotificationsV1) NewIntegrationsPager(options *ListIntegrationsOptions) (pager *IntegrationsPager, err error) {
	if options.Offset != nil && *options.Offset != 0 {
		err = fmt.Errorf("the 'options.Offset' field should not be set")
		return
	}

	var optionsCopy ListIntegrationsOptions = *options
	pager = &IntegrationsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  eventNotifications,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *IntegrationsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *IntegrationsPager) GetNextWithContext(ctx context.Context) (page []IntegrationListItem, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Offset = pager.pageContext.next

	result, _, err := pager.client.ListIntegrationsWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *int64
	if result.Next != nil {
		var offset *int64
		offset, err = core.GetQueryParamAsInt(result.Next.Href, "offset")
		if err != nil {
			err = fmt.Errorf("error retrieving 'offset' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = offset
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Integrations

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *IntegrationsPager) GetAllWithContext(ctx context.Context) (allItems []IntegrationListItem, err error) {
	for pager.HasNext() {
		var nextPage []IntegrationListItem
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *IntegrationsPager) GetNext() (page []IntegrationListItem, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *IntegrationsPager) GetAll() (allItems []IntegrationListItem, err error) {
	return pager.GetAllWithContext(context.Background())
}
