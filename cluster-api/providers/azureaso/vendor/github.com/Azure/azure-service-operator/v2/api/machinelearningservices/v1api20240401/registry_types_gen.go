// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/registries.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/registries/{registryName}
type Registry struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Registry_Spec                  `json:"spec,omitempty"`
	Status            RegistryTrackedResource_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Registry{}

// GetConditions returns the conditions of the resource
func (registry *Registry) GetConditions() conditions.Conditions {
	return registry.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (registry *Registry) SetConditions(conditions conditions.Conditions) {
	registry.Status.Conditions = conditions
}

var _ conversion.Convertible = &Registry{}

// ConvertFrom populates our Registry from the provided hub Registry
func (registry *Registry) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Registry)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/Registry but received %T instead", hub)
	}

	return registry.AssignProperties_From_Registry(source)
}

// ConvertTo populates the provided hub Registry from our Registry
func (registry *Registry) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Registry)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/Registry but received %T instead", hub)
	}

	return registry.AssignProperties_To_Registry(destination)
}

// +kubebuilder:webhook:path=/mutate-machinelearningservices-azure-com-v1api20240401-registry,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=registries,verbs=create;update,versions=v1api20240401,name=default.v1api20240401.registries.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Registry{}

// Default applies defaults to the Registry resource
func (registry *Registry) Default() {
	registry.defaultImpl()
	var temp any = registry
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (registry *Registry) defaultAzureName() {
	if registry.Spec.AzureName == "" {
		registry.Spec.AzureName = registry.Name
	}
}

// defaultImpl applies the code generated defaults to the Registry resource
func (registry *Registry) defaultImpl() { registry.defaultAzureName() }

var _ configmaps.Exporter = &Registry{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (registry *Registry) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if registry.Spec.OperatorSpec == nil {
		return nil
	}
	return registry.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Registry{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (registry *Registry) SecretDestinationExpressions() []*core.DestinationExpression {
	if registry.Spec.OperatorSpec == nil {
		return nil
	}
	return registry.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Registry{}

// InitializeSpec initializes the spec for this resource from the given status
func (registry *Registry) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*RegistryTrackedResource_STATUS); ok {
		return registry.Spec.Initialize_From_RegistryTrackedResource_STATUS(s)
	}

	return fmt.Errorf("expected Status of type RegistryTrackedResource_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesConfigExporter = &Registry{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (registry *Registry) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(registry.Namespace)
	if registry.Spec.OperatorSpec != nil && registry.Spec.OperatorSpec.ConfigMaps != nil {
		if registry.Status.DiscoveryUrl != nil {
			collector.AddValue(registry.Spec.OperatorSpec.ConfigMaps.DiscoveryUrl, *registry.Status.DiscoveryUrl)
		}
	}
	if registry.Spec.OperatorSpec != nil && registry.Spec.OperatorSpec.ConfigMaps != nil {
		if registry.Status.MlFlowRegistryUri != nil {
			collector.AddValue(registry.Spec.OperatorSpec.ConfigMaps.MlFlowRegistryUri, *registry.Status.MlFlowRegistryUri)
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &Registry{}

// AzureName returns the Azure name of the resource
func (registry *Registry) AzureName() string {
	return registry.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-04-01"
func (registry Registry) GetAPIVersion() string {
	return "2024-04-01"
}

// GetResourceScope returns the scope of the resource
func (registry *Registry) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (registry *Registry) GetSpec() genruntime.ConvertibleSpec {
	return &registry.Spec
}

// GetStatus returns the status of this resource
func (registry *Registry) GetStatus() genruntime.ConvertibleStatus {
	return &registry.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (registry *Registry) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/registries"
func (registry *Registry) GetType() string {
	return "Microsoft.MachineLearningServices/registries"
}

// NewEmptyStatus returns a new empty (blank) status
func (registry *Registry) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &RegistryTrackedResource_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (registry *Registry) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(registry.Spec)
	return registry.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (registry *Registry) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*RegistryTrackedResource_STATUS); ok {
		registry.Status = *st
		return nil
	}

	// Convert status to required version
	var st RegistryTrackedResource_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	registry.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-machinelearningservices-azure-com-v1api20240401-registry,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=registries,verbs=create;update,versions=v1api20240401,name=validate.v1api20240401.registries.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Registry{}

// ValidateCreate validates the creation of the resource
func (registry *Registry) ValidateCreate() (admission.Warnings, error) {
	validations := registry.createValidations()
	var temp any = registry
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (registry *Registry) ValidateDelete() (admission.Warnings, error) {
	validations := registry.deleteValidations()
	var temp any = registry
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (registry *Registry) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := registry.updateValidations()
	var temp any = registry
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (registry *Registry) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){registry.validateResourceReferences, registry.validateOwnerReference, registry.validateSecretDestinations, registry.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (registry *Registry) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (registry *Registry) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return registry.validateResourceReferences()
		},
		registry.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return registry.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return registry.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return registry.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (registry *Registry) validateConfigMapDestinations() (admission.Warnings, error) {
	if registry.Spec.OperatorSpec == nil {
		return nil, nil
	}
	var toValidate []*genruntime.ConfigMapDestination
	if registry.Spec.OperatorSpec.ConfigMaps != nil {
		toValidate = []*genruntime.ConfigMapDestination{
			registry.Spec.OperatorSpec.ConfigMaps.DiscoveryUrl,
			registry.Spec.OperatorSpec.ConfigMaps.MlFlowRegistryUri,
		}
	}
	return configmaps.ValidateDestinations(registry, toValidate, registry.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (registry *Registry) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(registry)
}

// validateResourceReferences validates all resource references
func (registry *Registry) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&registry.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (registry *Registry) validateSecretDestinations() (admission.Warnings, error) {
	if registry.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(registry, nil, registry.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (registry *Registry) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Registry)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, registry)
}

// AssignProperties_From_Registry populates our Registry from the provided source Registry
func (registry *Registry) AssignProperties_From_Registry(source *storage.Registry) error {

	// ObjectMeta
	registry.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Registry_Spec
	err := spec.AssignProperties_From_Registry_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Registry_Spec() to populate field Spec")
	}
	registry.Spec = spec

	// Status
	var status RegistryTrackedResource_STATUS
	err = status.AssignProperties_From_RegistryTrackedResource_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_RegistryTrackedResource_STATUS() to populate field Status")
	}
	registry.Status = status

	// No error
	return nil
}

// AssignProperties_To_Registry populates the provided destination Registry from our Registry
func (registry *Registry) AssignProperties_To_Registry(destination *storage.Registry) error {

	// ObjectMeta
	destination.ObjectMeta = *registry.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Registry_Spec
	err := registry.Spec.AssignProperties_To_Registry_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Registry_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.RegistryTrackedResource_STATUS
	err = registry.Status.AssignProperties_To_RegistryTrackedResource_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_RegistryTrackedResource_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (registry *Registry) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: registry.Spec.OriginalVersion(),
		Kind:    "Registry",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/registries.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/registries/{registryName}
type RegistryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Registry `json:"items"`
}

// +kubebuilder:validation:Enum={"2024-04-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-04-01")

type Registry_Spec struct {
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9][a-zA-Z0-9\\-_]{2,32}$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DiscoveryUrl: Discovery URL for the Registry
	DiscoveryUrl *string `json:"discoveryUrl,omitempty"`

	// Identity: Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// IntellectualPropertyPublisher: IntellectualPropertyPublisher for the registry
	IntellectualPropertyPublisher *string `json:"intellectualPropertyPublisher,omitempty"`

	// Kind: Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// ManagedResourceGroup: ResourceId of the managed RG if the registry has system created resources
	ManagedResourceGroup *ArmResourceId `json:"managedResourceGroup,omitempty"`

	// MlFlowRegistryUri: MLFlow Registry URI for the Registry
	MlFlowRegistryUri *string `json:"mlFlowRegistryUri,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *RegistryOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PublicNetworkAccess: Is the Registry accessible from the internet?
	// Possible values: "Enabled" or "Disabled"
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RegionDetails: Details of each region the registry is in
	RegionDetails []RegistryRegionArmDetails `json:"regionDetails,omitempty"`

	// RegistryPrivateEndpointConnections: Private endpoint connections info used for pending connections in private link portal
	RegistryPrivateEndpointConnections []RegistryPrivateEndpointConnection `json:"registryPrivateEndpointConnections,omitempty"`

	// Sku: Sku details required for ARM contract for Autoscaling.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Registry_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registry *Registry_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registry == nil {
		return nil, nil
	}
	result := &arm.Registry_Spec{}

	// Set property "Identity":
	if registry.Identity != nil {
		identity_ARM, err := (*registry.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Kind":
	if registry.Kind != nil {
		kind := *registry.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if registry.Location != nil {
		location := *registry.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if registry.DiscoveryUrl != nil ||
		registry.IntellectualPropertyPublisher != nil ||
		registry.ManagedResourceGroup != nil ||
		registry.MlFlowRegistryUri != nil ||
		registry.PublicNetworkAccess != nil ||
		registry.RegionDetails != nil ||
		registry.RegistryPrivateEndpointConnections != nil {
		result.Properties = &arm.RegistrySpec{}
	}
	if registry.DiscoveryUrl != nil {
		discoveryUrl := *registry.DiscoveryUrl
		result.Properties.DiscoveryUrl = &discoveryUrl
	}
	if registry.IntellectualPropertyPublisher != nil {
		intellectualPropertyPublisher := *registry.IntellectualPropertyPublisher
		result.Properties.IntellectualPropertyPublisher = &intellectualPropertyPublisher
	}
	if registry.ManagedResourceGroup != nil {
		managedResourceGroup_ARM, err := (*registry.ManagedResourceGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedResourceGroup := *managedResourceGroup_ARM.(*arm.ArmResourceId)
		result.Properties.ManagedResourceGroup = &managedResourceGroup
	}
	if registry.MlFlowRegistryUri != nil {
		mlFlowRegistryUri := *registry.MlFlowRegistryUri
		result.Properties.MlFlowRegistryUri = &mlFlowRegistryUri
	}
	if registry.PublicNetworkAccess != nil {
		publicNetworkAccess := *registry.PublicNetworkAccess
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	for _, item := range registry.RegionDetails {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RegionDetails = append(result.Properties.RegionDetails, *item_ARM.(*arm.RegistryRegionArmDetails))
	}
	for _, item := range registry.RegistryPrivateEndpointConnections {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RegistryPrivateEndpointConnections = append(result.Properties.RegistryPrivateEndpointConnections, *item_ARM.(*arm.RegistryPrivateEndpointConnection))
	}

	// Set property "Sku":
	if registry.Sku != nil {
		sku_ARM, err := (*registry.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if registry.Tags != nil {
		result.Tags = make(map[string]string, len(registry.Tags))
		for key, value := range registry.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registry *Registry_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Registry_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registry *Registry_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Registry_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Registry_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	registry.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DiscoveryUrl":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiscoveryUrl != nil {
			discoveryUrl := *typedInput.Properties.DiscoveryUrl
			registry.DiscoveryUrl = &discoveryUrl
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		registry.Identity = &identity
	}

	// Set property "IntellectualPropertyPublisher":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntellectualPropertyPublisher != nil {
			intellectualPropertyPublisher := *typedInput.Properties.IntellectualPropertyPublisher
			registry.IntellectualPropertyPublisher = &intellectualPropertyPublisher
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		registry.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		registry.Location = &location
	}

	// Set property "ManagedResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedResourceGroup != nil {
			var managedResourceGroup1 ArmResourceId
			err := managedResourceGroup1.PopulateFromARM(owner, *typedInput.Properties.ManagedResourceGroup)
			if err != nil {
				return err
			}
			managedResourceGroup := managedResourceGroup1
			registry.ManagedResourceGroup = &managedResourceGroup
		}
	}

	// Set property "MlFlowRegistryUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MlFlowRegistryUri != nil {
			mlFlowRegistryUri := *typedInput.Properties.MlFlowRegistryUri
			registry.MlFlowRegistryUri = &mlFlowRegistryUri
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	registry.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			registry.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RegionDetails":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RegionDetails {
			var item1 RegistryRegionArmDetails
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			registry.RegionDetails = append(registry.RegionDetails, item1)
		}
	}

	// Set property "RegistryPrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RegistryPrivateEndpointConnections {
			var item1 RegistryPrivateEndpointConnection
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			registry.RegistryPrivateEndpointConnections = append(registry.RegistryPrivateEndpointConnections, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		registry.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		registry.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			registry.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Registry_Spec{}

// ConvertSpecFrom populates our Registry_Spec from the provided source
func (registry *Registry_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Registry_Spec)
	if ok {
		// Populate our instance from source
		return registry.AssignProperties_From_Registry_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Registry_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = registry.AssignProperties_From_Registry_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Registry_Spec
func (registry *Registry_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Registry_Spec)
	if ok {
		// Populate destination from our instance
		return registry.AssignProperties_To_Registry_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Registry_Spec{}
	err := registry.AssignProperties_To_Registry_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Registry_Spec populates our Registry_Spec from the provided source Registry_Spec
func (registry *Registry_Spec) AssignProperties_From_Registry_Spec(source *storage.Registry_Spec) error {

	// AzureName
	registry.AzureName = source.AzureName

	// DiscoveryUrl
	registry.DiscoveryUrl = genruntime.ClonePointerToString(source.DiscoveryUrl)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		registry.Identity = &identity
	} else {
		registry.Identity = nil
	}

	// IntellectualPropertyPublisher
	registry.IntellectualPropertyPublisher = genruntime.ClonePointerToString(source.IntellectualPropertyPublisher)

	// Kind
	registry.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	registry.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedResourceGroup
	if source.ManagedResourceGroup != nil {
		var managedResourceGroup ArmResourceId
		err := managedResourceGroup.AssignProperties_From_ArmResourceId(source.ManagedResourceGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId() to populate field ManagedResourceGroup")
		}
		registry.ManagedResourceGroup = &managedResourceGroup
	} else {
		registry.ManagedResourceGroup = nil
	}

	// MlFlowRegistryUri
	registry.MlFlowRegistryUri = genruntime.ClonePointerToString(source.MlFlowRegistryUri)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec RegistryOperatorSpec
		err := operatorSpec.AssignProperties_From_RegistryOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RegistryOperatorSpec() to populate field OperatorSpec")
		}
		registry.OperatorSpec = &operatorSpec
	} else {
		registry.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		registry.Owner = &owner
	} else {
		registry.Owner = nil
	}

	// PublicNetworkAccess
	registry.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RegionDetails
	if source.RegionDetails != nil {
		regionDetailList := make([]RegistryRegionArmDetails, len(source.RegionDetails))
		for regionDetailIndex, regionDetailItem := range source.RegionDetails {
			// Shadow the loop variable to avoid aliasing
			regionDetailItem := regionDetailItem
			var regionDetail RegistryRegionArmDetails
			err := regionDetail.AssignProperties_From_RegistryRegionArmDetails(&regionDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RegistryRegionArmDetails() to populate field RegionDetails")
			}
			regionDetailList[regionDetailIndex] = regionDetail
		}
		registry.RegionDetails = regionDetailList
	} else {
		registry.RegionDetails = nil
	}

	// RegistryPrivateEndpointConnections
	if source.RegistryPrivateEndpointConnections != nil {
		registryPrivateEndpointConnectionList := make([]RegistryPrivateEndpointConnection, len(source.RegistryPrivateEndpointConnections))
		for registryPrivateEndpointConnectionIndex, registryPrivateEndpointConnectionItem := range source.RegistryPrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			registryPrivateEndpointConnectionItem := registryPrivateEndpointConnectionItem
			var registryPrivateEndpointConnection RegistryPrivateEndpointConnection
			err := registryPrivateEndpointConnection.AssignProperties_From_RegistryPrivateEndpointConnection(&registryPrivateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RegistryPrivateEndpointConnection() to populate field RegistryPrivateEndpointConnections")
			}
			registryPrivateEndpointConnectionList[registryPrivateEndpointConnectionIndex] = registryPrivateEndpointConnection
		}
		registry.RegistryPrivateEndpointConnections = registryPrivateEndpointConnectionList
	} else {
		registry.RegistryPrivateEndpointConnections = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		registry.Sku = &sku
	} else {
		registry.Sku = nil
	}

	// Tags
	registry.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Registry_Spec populates the provided destination Registry_Spec from our Registry_Spec
func (registry *Registry_Spec) AssignProperties_To_Registry_Spec(destination *storage.Registry_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = registry.AzureName

	// DiscoveryUrl
	destination.DiscoveryUrl = genruntime.ClonePointerToString(registry.DiscoveryUrl)

	// Identity
	if registry.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := registry.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IntellectualPropertyPublisher
	destination.IntellectualPropertyPublisher = genruntime.ClonePointerToString(registry.IntellectualPropertyPublisher)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(registry.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(registry.Location)

	// ManagedResourceGroup
	if registry.ManagedResourceGroup != nil {
		var managedResourceGroup storage.ArmResourceId
		err := registry.ManagedResourceGroup.AssignProperties_To_ArmResourceId(&managedResourceGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId() to populate field ManagedResourceGroup")
		}
		destination.ManagedResourceGroup = &managedResourceGroup
	} else {
		destination.ManagedResourceGroup = nil
	}

	// MlFlowRegistryUri
	destination.MlFlowRegistryUri = genruntime.ClonePointerToString(registry.MlFlowRegistryUri)

	// OperatorSpec
	if registry.OperatorSpec != nil {
		var operatorSpec storage.RegistryOperatorSpec
		err := registry.OperatorSpec.AssignProperties_To_RegistryOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RegistryOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = registry.OriginalVersion()

	// Owner
	if registry.Owner != nil {
		owner := registry.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(registry.PublicNetworkAccess)

	// RegionDetails
	if registry.RegionDetails != nil {
		regionDetailList := make([]storage.RegistryRegionArmDetails, len(registry.RegionDetails))
		for regionDetailIndex, regionDetailItem := range registry.RegionDetails {
			// Shadow the loop variable to avoid aliasing
			regionDetailItem := regionDetailItem
			var regionDetail storage.RegistryRegionArmDetails
			err := regionDetailItem.AssignProperties_To_RegistryRegionArmDetails(&regionDetail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RegistryRegionArmDetails() to populate field RegionDetails")
			}
			regionDetailList[regionDetailIndex] = regionDetail
		}
		destination.RegionDetails = regionDetailList
	} else {
		destination.RegionDetails = nil
	}

	// RegistryPrivateEndpointConnections
	if registry.RegistryPrivateEndpointConnections != nil {
		registryPrivateEndpointConnectionList := make([]storage.RegistryPrivateEndpointConnection, len(registry.RegistryPrivateEndpointConnections))
		for registryPrivateEndpointConnectionIndex, registryPrivateEndpointConnectionItem := range registry.RegistryPrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			registryPrivateEndpointConnectionItem := registryPrivateEndpointConnectionItem
			var registryPrivateEndpointConnection storage.RegistryPrivateEndpointConnection
			err := registryPrivateEndpointConnectionItem.AssignProperties_To_RegistryPrivateEndpointConnection(&registryPrivateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RegistryPrivateEndpointConnection() to populate field RegistryPrivateEndpointConnections")
			}
			registryPrivateEndpointConnectionList[registryPrivateEndpointConnectionIndex] = registryPrivateEndpointConnection
		}
		destination.RegistryPrivateEndpointConnections = registryPrivateEndpointConnectionList
	} else {
		destination.RegistryPrivateEndpointConnections = nil
	}

	// Sku
	if registry.Sku != nil {
		var sku storage.Sku
		err := registry.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(registry.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RegistryTrackedResource_STATUS populates our Registry_Spec from the provided source RegistryTrackedResource_STATUS
func (registry *Registry_Spec) Initialize_From_RegistryTrackedResource_STATUS(source *RegistryTrackedResource_STATUS) error {

	// DiscoveryUrl
	registry.DiscoveryUrl = genruntime.ClonePointerToString(source.DiscoveryUrl)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		registry.Identity = &identity
	} else {
		registry.Identity = nil
	}

	// IntellectualPropertyPublisher
	registry.IntellectualPropertyPublisher = genruntime.ClonePointerToString(source.IntellectualPropertyPublisher)

	// Kind
	registry.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	registry.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedResourceGroup
	if source.ManagedResourceGroup != nil {
		var managedResourceGroup ArmResourceId
		err := managedResourceGroup.Initialize_From_ArmResourceId_STATUS(source.ManagedResourceGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ArmResourceId_STATUS() to populate field ManagedResourceGroup")
		}
		registry.ManagedResourceGroup = &managedResourceGroup
	} else {
		registry.ManagedResourceGroup = nil
	}

	// MlFlowRegistryUri
	registry.MlFlowRegistryUri = genruntime.ClonePointerToString(source.MlFlowRegistryUri)

	// PublicNetworkAccess
	registry.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RegionDetails
	if source.RegionDetails != nil {
		regionDetailList := make([]RegistryRegionArmDetails, len(source.RegionDetails))
		for regionDetailIndex, regionDetailItem := range source.RegionDetails {
			// Shadow the loop variable to avoid aliasing
			regionDetailItem := regionDetailItem
			var regionDetail RegistryRegionArmDetails
			err := regionDetail.Initialize_From_RegistryRegionArmDetails_STATUS(&regionDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_RegistryRegionArmDetails_STATUS() to populate field RegionDetails")
			}
			regionDetailList[regionDetailIndex] = regionDetail
		}
		registry.RegionDetails = regionDetailList
	} else {
		registry.RegionDetails = nil
	}

	// RegistryPrivateEndpointConnections
	if source.RegistryPrivateEndpointConnections != nil {
		registryPrivateEndpointConnectionList := make([]RegistryPrivateEndpointConnection, len(source.RegistryPrivateEndpointConnections))
		for registryPrivateEndpointConnectionIndex, registryPrivateEndpointConnectionItem := range source.RegistryPrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			registryPrivateEndpointConnectionItem := registryPrivateEndpointConnectionItem
			var registryPrivateEndpointConnection RegistryPrivateEndpointConnection
			err := registryPrivateEndpointConnection.Initialize_From_RegistryPrivateEndpointConnection_STATUS(&registryPrivateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_RegistryPrivateEndpointConnection_STATUS() to populate field RegistryPrivateEndpointConnections")
			}
			registryPrivateEndpointConnectionList[registryPrivateEndpointConnectionIndex] = registryPrivateEndpointConnection
		}
		registry.RegistryPrivateEndpointConnections = registryPrivateEndpointConnectionList
	} else {
		registry.RegistryPrivateEndpointConnections = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		registry.Sku = &sku
	} else {
		registry.Sku = nil
	}

	// Tags
	registry.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (registry *Registry_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (registry *Registry_Spec) SetAzureName(azureName string) { registry.AzureName = azureName }

type RegistryTrackedResource_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DiscoveryUrl: Discovery URL for the Registry
	DiscoveryUrl *string `json:"discoveryUrl,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// IntellectualPropertyPublisher: IntellectualPropertyPublisher for the registry
	IntellectualPropertyPublisher *string `json:"intellectualPropertyPublisher,omitempty"`

	// Kind: Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// ManagedResourceGroup: ResourceId of the managed RG if the registry has system created resources
	ManagedResourceGroup *ArmResourceId_STATUS `json:"managedResourceGroup,omitempty"`

	// MlFlowRegistryUri: MLFlow Registry URI for the Registry
	MlFlowRegistryUri *string `json:"mlFlowRegistryUri,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// PublicNetworkAccess: Is the Registry accessible from the internet?
	// Possible values: "Enabled" or "Disabled"
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RegionDetails: Details of each region the registry is in
	RegionDetails []RegistryRegionArmDetails_STATUS `json:"regionDetails,omitempty"`

	// RegistryPrivateEndpointConnections: Private endpoint connections info used for pending connections in private link portal
	RegistryPrivateEndpointConnections []RegistryPrivateEndpointConnection_STATUS `json:"registryPrivateEndpointConnections,omitempty"`

	// Sku: Sku details required for ARM contract for Autoscaling.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &RegistryTrackedResource_STATUS{}

// ConvertStatusFrom populates our RegistryTrackedResource_STATUS from the provided source
func (resource *RegistryTrackedResource_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.RegistryTrackedResource_STATUS)
	if ok {
		// Populate our instance from source
		return resource.AssignProperties_From_RegistryTrackedResource_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.RegistryTrackedResource_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = resource.AssignProperties_From_RegistryTrackedResource_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our RegistryTrackedResource_STATUS
func (resource *RegistryTrackedResource_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.RegistryTrackedResource_STATUS)
	if ok {
		// Populate destination from our instance
		return resource.AssignProperties_To_RegistryTrackedResource_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.RegistryTrackedResource_STATUS{}
	err := resource.AssignProperties_To_RegistryTrackedResource_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &RegistryTrackedResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *RegistryTrackedResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryTrackedResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *RegistryTrackedResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryTrackedResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryTrackedResource_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "DiscoveryUrl":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiscoveryUrl != nil {
			discoveryUrl := *typedInput.Properties.DiscoveryUrl
			resource.DiscoveryUrl = &discoveryUrl
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		resource.Identity = &identity
	}

	// Set property "IntellectualPropertyPublisher":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntellectualPropertyPublisher != nil {
			intellectualPropertyPublisher := *typedInput.Properties.IntellectualPropertyPublisher
			resource.IntellectualPropertyPublisher = &intellectualPropertyPublisher
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		resource.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property "ManagedResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedResourceGroup != nil {
			var managedResourceGroup1 ArmResourceId_STATUS
			err := managedResourceGroup1.PopulateFromARM(owner, *typedInput.Properties.ManagedResourceGroup)
			if err != nil {
				return err
			}
			managedResourceGroup := managedResourceGroup1
			resource.ManagedResourceGroup = &managedResourceGroup
		}
	}

	// Set property "MlFlowRegistryUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MlFlowRegistryUri != nil {
			mlFlowRegistryUri := *typedInput.Properties.MlFlowRegistryUri
			resource.MlFlowRegistryUri = &mlFlowRegistryUri
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			resource.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RegionDetails":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RegionDetails {
			var item1 RegistryRegionArmDetails_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			resource.RegionDetails = append(resource.RegionDetails, item1)
		}
	}

	// Set property "RegistryPrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RegistryPrivateEndpointConnections {
			var item1 RegistryPrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			resource.RegistryPrivateEndpointConnections = append(resource.RegistryPrivateEndpointConnections, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		resource.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		resource.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		resource.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			resource.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryTrackedResource_STATUS populates our RegistryTrackedResource_STATUS from the provided source RegistryTrackedResource_STATUS
func (resource *RegistryTrackedResource_STATUS) AssignProperties_From_RegistryTrackedResource_STATUS(source *storage.RegistryTrackedResource_STATUS) error {

	// Conditions
	resource.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiscoveryUrl
	resource.DiscoveryUrl = genruntime.ClonePointerToString(source.DiscoveryUrl)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		resource.Identity = &identity
	} else {
		resource.Identity = nil
	}

	// IntellectualPropertyPublisher
	resource.IntellectualPropertyPublisher = genruntime.ClonePointerToString(source.IntellectualPropertyPublisher)

	// Kind
	resource.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedResourceGroup
	if source.ManagedResourceGroup != nil {
		var managedResourceGroup ArmResourceId_STATUS
		err := managedResourceGroup.AssignProperties_From_ArmResourceId_STATUS(source.ManagedResourceGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId_STATUS() to populate field ManagedResourceGroup")
		}
		resource.ManagedResourceGroup = &managedResourceGroup
	} else {
		resource.ManagedResourceGroup = nil
	}

	// MlFlowRegistryUri
	resource.MlFlowRegistryUri = genruntime.ClonePointerToString(source.MlFlowRegistryUri)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PublicNetworkAccess
	resource.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RegionDetails
	if source.RegionDetails != nil {
		regionDetailList := make([]RegistryRegionArmDetails_STATUS, len(source.RegionDetails))
		for regionDetailIndex, regionDetailItem := range source.RegionDetails {
			// Shadow the loop variable to avoid aliasing
			regionDetailItem := regionDetailItem
			var regionDetail RegistryRegionArmDetails_STATUS
			err := regionDetail.AssignProperties_From_RegistryRegionArmDetails_STATUS(&regionDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RegistryRegionArmDetails_STATUS() to populate field RegionDetails")
			}
			regionDetailList[regionDetailIndex] = regionDetail
		}
		resource.RegionDetails = regionDetailList
	} else {
		resource.RegionDetails = nil
	}

	// RegistryPrivateEndpointConnections
	if source.RegistryPrivateEndpointConnections != nil {
		registryPrivateEndpointConnectionList := make([]RegistryPrivateEndpointConnection_STATUS, len(source.RegistryPrivateEndpointConnections))
		for registryPrivateEndpointConnectionIndex, registryPrivateEndpointConnectionItem := range source.RegistryPrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			registryPrivateEndpointConnectionItem := registryPrivateEndpointConnectionItem
			var registryPrivateEndpointConnection RegistryPrivateEndpointConnection_STATUS
			err := registryPrivateEndpointConnection.AssignProperties_From_RegistryPrivateEndpointConnection_STATUS(&registryPrivateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RegistryPrivateEndpointConnection_STATUS() to populate field RegistryPrivateEndpointConnections")
			}
			registryPrivateEndpointConnectionList[registryPrivateEndpointConnectionIndex] = registryPrivateEndpointConnection
		}
		resource.RegistryPrivateEndpointConnections = registryPrivateEndpointConnectionList
	} else {
		resource.RegistryPrivateEndpointConnections = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		resource.SystemData = &systemDatum
	} else {
		resource.SystemData = nil
	}

	// Tags
	resource.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_RegistryTrackedResource_STATUS populates the provided destination RegistryTrackedResource_STATUS from our RegistryTrackedResource_STATUS
func (resource *RegistryTrackedResource_STATUS) AssignProperties_To_RegistryTrackedResource_STATUS(destination *storage.RegistryTrackedResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(resource.Conditions)

	// DiscoveryUrl
	destination.DiscoveryUrl = genruntime.ClonePointerToString(resource.DiscoveryUrl)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Identity
	if resource.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := resource.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IntellectualPropertyPublisher
	destination.IntellectualPropertyPublisher = genruntime.ClonePointerToString(resource.IntellectualPropertyPublisher)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(resource.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// ManagedResourceGroup
	if resource.ManagedResourceGroup != nil {
		var managedResourceGroup storage.ArmResourceId_STATUS
		err := resource.ManagedResourceGroup.AssignProperties_To_ArmResourceId_STATUS(&managedResourceGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId_STATUS() to populate field ManagedResourceGroup")
		}
		destination.ManagedResourceGroup = &managedResourceGroup
	} else {
		destination.ManagedResourceGroup = nil
	}

	// MlFlowRegistryUri
	destination.MlFlowRegistryUri = genruntime.ClonePointerToString(resource.MlFlowRegistryUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(resource.PublicNetworkAccess)

	// RegionDetails
	if resource.RegionDetails != nil {
		regionDetailList := make([]storage.RegistryRegionArmDetails_STATUS, len(resource.RegionDetails))
		for regionDetailIndex, regionDetailItem := range resource.RegionDetails {
			// Shadow the loop variable to avoid aliasing
			regionDetailItem := regionDetailItem
			var regionDetail storage.RegistryRegionArmDetails_STATUS
			err := regionDetailItem.AssignProperties_To_RegistryRegionArmDetails_STATUS(&regionDetail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RegistryRegionArmDetails_STATUS() to populate field RegionDetails")
			}
			regionDetailList[regionDetailIndex] = regionDetail
		}
		destination.RegionDetails = regionDetailList
	} else {
		destination.RegionDetails = nil
	}

	// RegistryPrivateEndpointConnections
	if resource.RegistryPrivateEndpointConnections != nil {
		registryPrivateEndpointConnectionList := make([]storage.RegistryPrivateEndpointConnection_STATUS, len(resource.RegistryPrivateEndpointConnections))
		for registryPrivateEndpointConnectionIndex, registryPrivateEndpointConnectionItem := range resource.RegistryPrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			registryPrivateEndpointConnectionItem := registryPrivateEndpointConnectionItem
			var registryPrivateEndpointConnection storage.RegistryPrivateEndpointConnection_STATUS
			err := registryPrivateEndpointConnectionItem.AssignProperties_To_RegistryPrivateEndpointConnection_STATUS(&registryPrivateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RegistryPrivateEndpointConnection_STATUS() to populate field RegistryPrivateEndpointConnections")
			}
			registryPrivateEndpointConnectionList[registryPrivateEndpointConnectionIndex] = registryPrivateEndpointConnection
		}
		destination.RegistryPrivateEndpointConnections = registryPrivateEndpointConnectionList
	} else {
		destination.RegistryPrivateEndpointConnections = nil
	}

	// Sku
	if resource.Sku != nil {
		var sku storage.Sku_STATUS
		err := resource.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if resource.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := resource.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(resource.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// ARM ResourceId of a resource
type ArmResourceId struct {
	// ResourceReference: Arm ResourceId is in the format
	// "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
	// or
	// "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ArmResourceId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resourceId *ArmResourceId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resourceId == nil {
		return nil, nil
	}
	result := &arm.ArmResourceId{}

	// Set property "ResourceId":
	if resourceId.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*resourceId.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ArmResourceId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ArmResourceId{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ArmResourceId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ArmResourceId)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ArmResourceId, got %T", armInput)
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_ArmResourceId populates our ArmResourceId from the provided source ArmResourceId
func (resourceId *ArmResourceId) AssignProperties_From_ArmResourceId(source *storage.ArmResourceId) error {

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		resourceId.ResourceReference = &resourceReference
	} else {
		resourceId.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ArmResourceId populates the provided destination ArmResourceId from our ArmResourceId
func (resourceId *ArmResourceId) AssignProperties_To_ArmResourceId(destination *storage.ArmResourceId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceReference
	if resourceId.ResourceReference != nil {
		resourceReference := resourceId.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ArmResourceId_STATUS populates our ArmResourceId from the provided source ArmResourceId_STATUS
func (resourceId *ArmResourceId) Initialize_From_ArmResourceId_STATUS(source *ArmResourceId_STATUS) error {

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		resourceId.ResourceReference = &resourceReference
	} else {
		resourceId.ResourceReference = nil
	}

	// No error
	return nil
}

// ARM ResourceId of a resource
type ArmResourceId_STATUS struct {
	// ResourceId: Arm ResourceId is in the format
	// "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
	// or
	// "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &ArmResourceId_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ArmResourceId_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ArmResourceId_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ArmResourceId_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ArmResourceId_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ArmResourceId_STATUS, got %T", armInput)
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId1 := *typedInput.ResourceId
		resourceId.ResourceId = &resourceId1
	}

	// No error
	return nil
}

// AssignProperties_From_ArmResourceId_STATUS populates our ArmResourceId_STATUS from the provided source ArmResourceId_STATUS
func (resourceId *ArmResourceId_STATUS) AssignProperties_From_ArmResourceId_STATUS(source *storage.ArmResourceId_STATUS) error {

	// ResourceId
	resourceId.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_ArmResourceId_STATUS populates the provided destination ArmResourceId_STATUS from our ArmResourceId_STATUS
func (resourceId *ArmResourceId_STATUS) AssignProperties_To_ArmResourceId_STATUS(destination *storage.ArmResourceId_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(resourceId.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// +kubebuilder:validation:Required
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType   `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentityType_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The service principal ID of the system assigned identity. This property will only be provided for a system
	// assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType_STATUS     `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type RegistryOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *RegistryOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_RegistryOperatorSpec populates our RegistryOperatorSpec from the provided source RegistryOperatorSpec
func (operator *RegistryOperatorSpec) AssignProperties_From_RegistryOperatorSpec(source *storage.RegistryOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap RegistryOperatorConfigMaps
		err := configMap.AssignProperties_From_RegistryOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RegistryOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryOperatorSpec populates the provided destination RegistryOperatorSpec from our RegistryOperatorSpec
func (operator *RegistryOperatorSpec) AssignProperties_To_RegistryOperatorSpec(destination *storage.RegistryOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.RegistryOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_RegistryOperatorConfigMaps(&configMap)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RegistryOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnection struct {
	// GroupIds: The group ids
	GroupIds []string `json:"groupIds,omitempty"`

	// Location: Same as workspace location.
	Location *string `json:"location,omitempty"`

	// PrivateEndpoint: The PE network resource that is linked to this PE connection.
	PrivateEndpoint *PrivateEndpointResource `json:"privateEndpoint,omitempty"`

	// ProvisioningState: One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Reference: This is the private endpoint connection name created on SRP
	// Full resource id:
	// /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// RegistryPrivateLinkServiceConnectionState: The connection state.
	RegistryPrivateLinkServiceConnectionState *RegistryPrivateLinkServiceConnectionState `json:"registryPrivateLinkServiceConnectionState,omitempty"`
}

var _ genruntime.ARMTransformer = &RegistryPrivateEndpointConnection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *RegistryPrivateEndpointConnection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.RegistryPrivateEndpointConnection{}

	// Set property "Id":
	if connection.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*connection.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Location":
	if connection.Location != nil {
		location := *connection.Location
		result.Location = &location
	}

	// Set property "Properties":
	if connection.GroupIds != nil ||
		connection.PrivateEndpoint != nil ||
		connection.ProvisioningState != nil ||
		connection.RegistryPrivateLinkServiceConnectionState != nil {
		result.Properties = &arm.RegistryPrivateEndpointConnectionProperties{}
	}
	for _, item := range connection.GroupIds {
		result.Properties.GroupIds = append(result.Properties.GroupIds, item)
	}
	if connection.PrivateEndpoint != nil {
		privateEndpoint_ARM, err := (*connection.PrivateEndpoint).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		privateEndpoint := *privateEndpoint_ARM.(*arm.PrivateEndpointResource)
		result.Properties.PrivateEndpoint = &privateEndpoint
	}
	if connection.ProvisioningState != nil {
		provisioningState := *connection.ProvisioningState
		result.Properties.ProvisioningState = &provisioningState
	}
	if connection.RegistryPrivateLinkServiceConnectionState != nil {
		registryPrivateLinkServiceConnectionState_ARM, err := (*connection.RegistryPrivateLinkServiceConnectionState).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registryPrivateLinkServiceConnectionState := *registryPrivateLinkServiceConnectionState_ARM.(*arm.RegistryPrivateLinkServiceConnectionState)
		result.Properties.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *RegistryPrivateEndpointConnection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryPrivateEndpointConnection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *RegistryPrivateEndpointConnection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryPrivateEndpointConnection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryPrivateEndpointConnection, got %T", armInput)
	}

	// Set property "GroupIds":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GroupIds {
			connection.GroupIds = append(connection.GroupIds, item)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "PrivateEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpoint != nil {
			var privateEndpoint1 PrivateEndpointResource
			err := privateEndpoint1.PopulateFromARM(owner, *typedInput.Properties.PrivateEndpoint)
			if err != nil {
				return err
			}
			privateEndpoint := privateEndpoint1
			connection.PrivateEndpoint = &privateEndpoint
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			connection.ProvisioningState = &provisioningState
		}
	}

	// no assignment for property "Reference"

	// Set property "RegistryPrivateLinkServiceConnectionState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RegistryPrivateLinkServiceConnectionState != nil {
			var registryPrivateLinkServiceConnectionState1 RegistryPrivateLinkServiceConnectionState
			err := registryPrivateLinkServiceConnectionState1.PopulateFromARM(owner, *typedInput.Properties.RegistryPrivateLinkServiceConnectionState)
			if err != nil {
				return err
			}
			registryPrivateLinkServiceConnectionState := registryPrivateLinkServiceConnectionState1
			connection.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
		}
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryPrivateEndpointConnection populates our RegistryPrivateEndpointConnection from the provided source RegistryPrivateEndpointConnection
func (connection *RegistryPrivateEndpointConnection) AssignProperties_From_RegistryPrivateEndpointConnection(source *storage.RegistryPrivateEndpointConnection) error {

	// GroupIds
	connection.GroupIds = genruntime.CloneSliceOfString(source.GroupIds)

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointResource
		err := privateEndpoint.AssignProperties_From_PrivateEndpointResource(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointResource() to populate field PrivateEndpoint")
		}
		connection.PrivateEndpoint = &privateEndpoint
	} else {
		connection.PrivateEndpoint = nil
	}

	// ProvisioningState
	connection.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		connection.Reference = &reference
	} else {
		connection.Reference = nil
	}

	// RegistryPrivateLinkServiceConnectionState
	if source.RegistryPrivateLinkServiceConnectionState != nil {
		var registryPrivateLinkServiceConnectionState RegistryPrivateLinkServiceConnectionState
		err := registryPrivateLinkServiceConnectionState.AssignProperties_From_RegistryPrivateLinkServiceConnectionState(source.RegistryPrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RegistryPrivateLinkServiceConnectionState() to populate field RegistryPrivateLinkServiceConnectionState")
		}
		connection.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
	} else {
		connection.RegistryPrivateLinkServiceConnectionState = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryPrivateEndpointConnection populates the provided destination RegistryPrivateEndpointConnection from our RegistryPrivateEndpointConnection
func (connection *RegistryPrivateEndpointConnection) AssignProperties_To_RegistryPrivateEndpointConnection(destination *storage.RegistryPrivateEndpointConnection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupIds
	destination.GroupIds = genruntime.CloneSliceOfString(connection.GroupIds)

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// PrivateEndpoint
	if connection.PrivateEndpoint != nil {
		var privateEndpoint storage.PrivateEndpointResource
		err := connection.PrivateEndpoint.AssignProperties_To_PrivateEndpointResource(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointResource() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(connection.ProvisioningState)

	// Reference
	if connection.Reference != nil {
		reference := connection.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RegistryPrivateLinkServiceConnectionState
	if connection.RegistryPrivateLinkServiceConnectionState != nil {
		var registryPrivateLinkServiceConnectionState storage.RegistryPrivateLinkServiceConnectionState
		err := connection.RegistryPrivateLinkServiceConnectionState.AssignProperties_To_RegistryPrivateLinkServiceConnectionState(&registryPrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RegistryPrivateLinkServiceConnectionState() to populate field RegistryPrivateLinkServiceConnectionState")
		}
		destination.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
	} else {
		destination.RegistryPrivateLinkServiceConnectionState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RegistryPrivateEndpointConnection_STATUS populates our RegistryPrivateEndpointConnection from the provided source RegistryPrivateEndpointConnection_STATUS
func (connection *RegistryPrivateEndpointConnection) Initialize_From_RegistryPrivateEndpointConnection_STATUS(source *RegistryPrivateEndpointConnection_STATUS) error {

	// GroupIds
	connection.GroupIds = genruntime.CloneSliceOfString(source.GroupIds)

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointResource
		err := privateEndpoint.Initialize_From_PrivateEndpointResource_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PrivateEndpointResource_STATUS() to populate field PrivateEndpoint")
		}
		connection.PrivateEndpoint = &privateEndpoint
	} else {
		connection.PrivateEndpoint = nil
	}

	// ProvisioningState
	connection.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		connection.Reference = &reference
	} else {
		connection.Reference = nil
	}

	// RegistryPrivateLinkServiceConnectionState
	if source.RegistryPrivateLinkServiceConnectionState != nil {
		var registryPrivateLinkServiceConnectionState RegistryPrivateLinkServiceConnectionState
		err := registryPrivateLinkServiceConnectionState.Initialize_From_RegistryPrivateLinkServiceConnectionState_STATUS(source.RegistryPrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RegistryPrivateLinkServiceConnectionState_STATUS() to populate field RegistryPrivateLinkServiceConnectionState")
		}
		connection.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
	} else {
		connection.RegistryPrivateLinkServiceConnectionState = nil
	}

	// No error
	return nil
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnection_STATUS struct {
	// GroupIds: The group ids
	GroupIds []string `json:"groupIds,omitempty"`

	// Id: This is the private endpoint connection name created on SRP
	// Full resource id:
	// /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
	Id *string `json:"id,omitempty"`

	// Location: Same as workspace location.
	Location *string `json:"location,omitempty"`

	// PrivateEndpoint: The PE network resource that is linked to this PE connection.
	PrivateEndpoint *PrivateEndpointResource_STATUS `json:"privateEndpoint,omitempty"`

	// ProvisioningState: One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// RegistryPrivateLinkServiceConnectionState: The connection state.
	RegistryPrivateLinkServiceConnectionState *RegistryPrivateLinkServiceConnectionState_STATUS `json:"registryPrivateLinkServiceConnectionState,omitempty"`
}

var _ genruntime.FromARMConverter = &RegistryPrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *RegistryPrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryPrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *RegistryPrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryPrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryPrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "GroupIds":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GroupIds {
			connection.GroupIds = append(connection.GroupIds, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		connection.Location = &location
	}

	// Set property "PrivateEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpoint != nil {
			var privateEndpoint1 PrivateEndpointResource_STATUS
			err := privateEndpoint1.PopulateFromARM(owner, *typedInput.Properties.PrivateEndpoint)
			if err != nil {
				return err
			}
			privateEndpoint := privateEndpoint1
			connection.PrivateEndpoint = &privateEndpoint
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			connection.ProvisioningState = &provisioningState
		}
	}

	// Set property "RegistryPrivateLinkServiceConnectionState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RegistryPrivateLinkServiceConnectionState != nil {
			var registryPrivateLinkServiceConnectionState1 RegistryPrivateLinkServiceConnectionState_STATUS
			err := registryPrivateLinkServiceConnectionState1.PopulateFromARM(owner, *typedInput.Properties.RegistryPrivateLinkServiceConnectionState)
			if err != nil {
				return err
			}
			registryPrivateLinkServiceConnectionState := registryPrivateLinkServiceConnectionState1
			connection.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
		}
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryPrivateEndpointConnection_STATUS populates our RegistryPrivateEndpointConnection_STATUS from the provided source RegistryPrivateEndpointConnection_STATUS
func (connection *RegistryPrivateEndpointConnection_STATUS) AssignProperties_From_RegistryPrivateEndpointConnection_STATUS(source *storage.RegistryPrivateEndpointConnection_STATUS) error {

	// GroupIds
	connection.GroupIds = genruntime.CloneSliceOfString(source.GroupIds)

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	connection.Location = genruntime.ClonePointerToString(source.Location)

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointResource_STATUS
		err := privateEndpoint.AssignProperties_From_PrivateEndpointResource_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointResource_STATUS() to populate field PrivateEndpoint")
		}
		connection.PrivateEndpoint = &privateEndpoint
	} else {
		connection.PrivateEndpoint = nil
	}

	// ProvisioningState
	connection.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RegistryPrivateLinkServiceConnectionState
	if source.RegistryPrivateLinkServiceConnectionState != nil {
		var registryPrivateLinkServiceConnectionState RegistryPrivateLinkServiceConnectionState_STATUS
		err := registryPrivateLinkServiceConnectionState.AssignProperties_From_RegistryPrivateLinkServiceConnectionState_STATUS(source.RegistryPrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RegistryPrivateLinkServiceConnectionState_STATUS() to populate field RegistryPrivateLinkServiceConnectionState")
		}
		connection.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
	} else {
		connection.RegistryPrivateLinkServiceConnectionState = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryPrivateEndpointConnection_STATUS populates the provided destination RegistryPrivateEndpointConnection_STATUS from our RegistryPrivateEndpointConnection_STATUS
func (connection *RegistryPrivateEndpointConnection_STATUS) AssignProperties_To_RegistryPrivateEndpointConnection_STATUS(destination *storage.RegistryPrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupIds
	destination.GroupIds = genruntime.CloneSliceOfString(connection.GroupIds)

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(connection.Location)

	// PrivateEndpoint
	if connection.PrivateEndpoint != nil {
		var privateEndpoint storage.PrivateEndpointResource_STATUS
		err := connection.PrivateEndpoint.AssignProperties_To_PrivateEndpointResource_STATUS(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointResource_STATUS() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(connection.ProvisioningState)

	// RegistryPrivateLinkServiceConnectionState
	if connection.RegistryPrivateLinkServiceConnectionState != nil {
		var registryPrivateLinkServiceConnectionState storage.RegistryPrivateLinkServiceConnectionState_STATUS
		err := connection.RegistryPrivateLinkServiceConnectionState.AssignProperties_To_RegistryPrivateLinkServiceConnectionState_STATUS(&registryPrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RegistryPrivateLinkServiceConnectionState_STATUS() to populate field RegistryPrivateLinkServiceConnectionState")
		}
		destination.RegistryPrivateLinkServiceConnectionState = &registryPrivateLinkServiceConnectionState
	} else {
		destination.RegistryPrivateLinkServiceConnectionState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for each region the registry is in
type RegistryRegionArmDetails struct {
	// AcrDetails: List of ACR accounts
	AcrDetails []AcrDetails `json:"acrDetails,omitempty"`

	// Location: The location where the registry exists
	Location *string `json:"location,omitempty"`

	// StorageAccountDetails: List of storage accounts
	StorageAccountDetails []StorageAccountDetails `json:"storageAccountDetails,omitempty"`
}

var _ genruntime.ARMTransformer = &RegistryRegionArmDetails{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (details *RegistryRegionArmDetails) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if details == nil {
		return nil, nil
	}
	result := &arm.RegistryRegionArmDetails{}

	// Set property "AcrDetails":
	for _, item := range details.AcrDetails {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AcrDetails = append(result.AcrDetails, *item_ARM.(*arm.AcrDetails))
	}

	// Set property "Location":
	if details.Location != nil {
		location := *details.Location
		result.Location = &location
	}

	// Set property "StorageAccountDetails":
	for _, item := range details.StorageAccountDetails {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageAccountDetails = append(result.StorageAccountDetails, *item_ARM.(*arm.StorageAccountDetails))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *RegistryRegionArmDetails) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryRegionArmDetails{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *RegistryRegionArmDetails) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryRegionArmDetails)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryRegionArmDetails, got %T", armInput)
	}

	// Set property "AcrDetails":
	for _, item := range typedInput.AcrDetails {
		var item1 AcrDetails
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		details.AcrDetails = append(details.AcrDetails, item1)
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		details.Location = &location
	}

	// Set property "StorageAccountDetails":
	for _, item := range typedInput.StorageAccountDetails {
		var item1 StorageAccountDetails
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		details.StorageAccountDetails = append(details.StorageAccountDetails, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryRegionArmDetails populates our RegistryRegionArmDetails from the provided source RegistryRegionArmDetails
func (details *RegistryRegionArmDetails) AssignProperties_From_RegistryRegionArmDetails(source *storage.RegistryRegionArmDetails) error {

	// AcrDetails
	if source.AcrDetails != nil {
		acrDetailList := make([]AcrDetails, len(source.AcrDetails))
		for acrDetailIndex, acrDetailItem := range source.AcrDetails {
			// Shadow the loop variable to avoid aliasing
			acrDetailItem := acrDetailItem
			var acrDetail AcrDetails
			err := acrDetail.AssignProperties_From_AcrDetails(&acrDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AcrDetails() to populate field AcrDetails")
			}
			acrDetailList[acrDetailIndex] = acrDetail
		}
		details.AcrDetails = acrDetailList
	} else {
		details.AcrDetails = nil
	}

	// Location
	details.Location = genruntime.ClonePointerToString(source.Location)

	// StorageAccountDetails
	if source.StorageAccountDetails != nil {
		storageAccountDetailList := make([]StorageAccountDetails, len(source.StorageAccountDetails))
		for storageAccountDetailIndex, storageAccountDetailItem := range source.StorageAccountDetails {
			// Shadow the loop variable to avoid aliasing
			storageAccountDetailItem := storageAccountDetailItem
			var storageAccountDetail StorageAccountDetails
			err := storageAccountDetail.AssignProperties_From_StorageAccountDetails(&storageAccountDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StorageAccountDetails() to populate field StorageAccountDetails")
			}
			storageAccountDetailList[storageAccountDetailIndex] = storageAccountDetail
		}
		details.StorageAccountDetails = storageAccountDetailList
	} else {
		details.StorageAccountDetails = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryRegionArmDetails populates the provided destination RegistryRegionArmDetails from our RegistryRegionArmDetails
func (details *RegistryRegionArmDetails) AssignProperties_To_RegistryRegionArmDetails(destination *storage.RegistryRegionArmDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrDetails
	if details.AcrDetails != nil {
		acrDetailList := make([]storage.AcrDetails, len(details.AcrDetails))
		for acrDetailIndex, acrDetailItem := range details.AcrDetails {
			// Shadow the loop variable to avoid aliasing
			acrDetailItem := acrDetailItem
			var acrDetail storage.AcrDetails
			err := acrDetailItem.AssignProperties_To_AcrDetails(&acrDetail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AcrDetails() to populate field AcrDetails")
			}
			acrDetailList[acrDetailIndex] = acrDetail
		}
		destination.AcrDetails = acrDetailList
	} else {
		destination.AcrDetails = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(details.Location)

	// StorageAccountDetails
	if details.StorageAccountDetails != nil {
		storageAccountDetailList := make([]storage.StorageAccountDetails, len(details.StorageAccountDetails))
		for storageAccountDetailIndex, storageAccountDetailItem := range details.StorageAccountDetails {
			// Shadow the loop variable to avoid aliasing
			storageAccountDetailItem := storageAccountDetailItem
			var storageAccountDetail storage.StorageAccountDetails
			err := storageAccountDetailItem.AssignProperties_To_StorageAccountDetails(&storageAccountDetail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StorageAccountDetails() to populate field StorageAccountDetails")
			}
			storageAccountDetailList[storageAccountDetailIndex] = storageAccountDetail
		}
		destination.StorageAccountDetails = storageAccountDetailList
	} else {
		destination.StorageAccountDetails = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RegistryRegionArmDetails_STATUS populates our RegistryRegionArmDetails from the provided source RegistryRegionArmDetails_STATUS
func (details *RegistryRegionArmDetails) Initialize_From_RegistryRegionArmDetails_STATUS(source *RegistryRegionArmDetails_STATUS) error {

	// AcrDetails
	if source.AcrDetails != nil {
		acrDetailList := make([]AcrDetails, len(source.AcrDetails))
		for acrDetailIndex, acrDetailItem := range source.AcrDetails {
			// Shadow the loop variable to avoid aliasing
			acrDetailItem := acrDetailItem
			var acrDetail AcrDetails
			err := acrDetail.Initialize_From_AcrDetails_STATUS(&acrDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_AcrDetails_STATUS() to populate field AcrDetails")
			}
			acrDetailList[acrDetailIndex] = acrDetail
		}
		details.AcrDetails = acrDetailList
	} else {
		details.AcrDetails = nil
	}

	// Location
	details.Location = genruntime.ClonePointerToString(source.Location)

	// StorageAccountDetails
	if source.StorageAccountDetails != nil {
		storageAccountDetailList := make([]StorageAccountDetails, len(source.StorageAccountDetails))
		for storageAccountDetailIndex, storageAccountDetailItem := range source.StorageAccountDetails {
			// Shadow the loop variable to avoid aliasing
			storageAccountDetailItem := storageAccountDetailItem
			var storageAccountDetail StorageAccountDetails
			err := storageAccountDetail.Initialize_From_StorageAccountDetails_STATUS(&storageAccountDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_StorageAccountDetails_STATUS() to populate field StorageAccountDetails")
			}
			storageAccountDetailList[storageAccountDetailIndex] = storageAccountDetail
		}
		details.StorageAccountDetails = storageAccountDetailList
	} else {
		details.StorageAccountDetails = nil
	}

	// No error
	return nil
}

// Details for each region the registry is in
type RegistryRegionArmDetails_STATUS struct {
	// AcrDetails: List of ACR accounts
	AcrDetails []AcrDetails_STATUS `json:"acrDetails,omitempty"`

	// Location: The location where the registry exists
	Location *string `json:"location,omitempty"`

	// StorageAccountDetails: List of storage accounts
	StorageAccountDetails []StorageAccountDetails_STATUS `json:"storageAccountDetails,omitempty"`
}

var _ genruntime.FromARMConverter = &RegistryRegionArmDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *RegistryRegionArmDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryRegionArmDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *RegistryRegionArmDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryRegionArmDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryRegionArmDetails_STATUS, got %T", armInput)
	}

	// Set property "AcrDetails":
	for _, item := range typedInput.AcrDetails {
		var item1 AcrDetails_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		details.AcrDetails = append(details.AcrDetails, item1)
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		details.Location = &location
	}

	// Set property "StorageAccountDetails":
	for _, item := range typedInput.StorageAccountDetails {
		var item1 StorageAccountDetails_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		details.StorageAccountDetails = append(details.StorageAccountDetails, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryRegionArmDetails_STATUS populates our RegistryRegionArmDetails_STATUS from the provided source RegistryRegionArmDetails_STATUS
func (details *RegistryRegionArmDetails_STATUS) AssignProperties_From_RegistryRegionArmDetails_STATUS(source *storage.RegistryRegionArmDetails_STATUS) error {

	// AcrDetails
	if source.AcrDetails != nil {
		acrDetailList := make([]AcrDetails_STATUS, len(source.AcrDetails))
		for acrDetailIndex, acrDetailItem := range source.AcrDetails {
			// Shadow the loop variable to avoid aliasing
			acrDetailItem := acrDetailItem
			var acrDetail AcrDetails_STATUS
			err := acrDetail.AssignProperties_From_AcrDetails_STATUS(&acrDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AcrDetails_STATUS() to populate field AcrDetails")
			}
			acrDetailList[acrDetailIndex] = acrDetail
		}
		details.AcrDetails = acrDetailList
	} else {
		details.AcrDetails = nil
	}

	// Location
	details.Location = genruntime.ClonePointerToString(source.Location)

	// StorageAccountDetails
	if source.StorageAccountDetails != nil {
		storageAccountDetailList := make([]StorageAccountDetails_STATUS, len(source.StorageAccountDetails))
		for storageAccountDetailIndex, storageAccountDetailItem := range source.StorageAccountDetails {
			// Shadow the loop variable to avoid aliasing
			storageAccountDetailItem := storageAccountDetailItem
			var storageAccountDetail StorageAccountDetails_STATUS
			err := storageAccountDetail.AssignProperties_From_StorageAccountDetails_STATUS(&storageAccountDetailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StorageAccountDetails_STATUS() to populate field StorageAccountDetails")
			}
			storageAccountDetailList[storageAccountDetailIndex] = storageAccountDetail
		}
		details.StorageAccountDetails = storageAccountDetailList
	} else {
		details.StorageAccountDetails = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryRegionArmDetails_STATUS populates the provided destination RegistryRegionArmDetails_STATUS from our RegistryRegionArmDetails_STATUS
func (details *RegistryRegionArmDetails_STATUS) AssignProperties_To_RegistryRegionArmDetails_STATUS(destination *storage.RegistryRegionArmDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrDetails
	if details.AcrDetails != nil {
		acrDetailList := make([]storage.AcrDetails_STATUS, len(details.AcrDetails))
		for acrDetailIndex, acrDetailItem := range details.AcrDetails {
			// Shadow the loop variable to avoid aliasing
			acrDetailItem := acrDetailItem
			var acrDetail storage.AcrDetails_STATUS
			err := acrDetailItem.AssignProperties_To_AcrDetails_STATUS(&acrDetail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AcrDetails_STATUS() to populate field AcrDetails")
			}
			acrDetailList[acrDetailIndex] = acrDetail
		}
		destination.AcrDetails = acrDetailList
	} else {
		destination.AcrDetails = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(details.Location)

	// StorageAccountDetails
	if details.StorageAccountDetails != nil {
		storageAccountDetailList := make([]storage.StorageAccountDetails_STATUS, len(details.StorageAccountDetails))
		for storageAccountDetailIndex, storageAccountDetailItem := range details.StorageAccountDetails {
			// Shadow the loop variable to avoid aliasing
			storageAccountDetailItem := storageAccountDetailItem
			var storageAccountDetail storage.StorageAccountDetails_STATUS
			err := storageAccountDetailItem.AssignProperties_To_StorageAccountDetails_STATUS(&storageAccountDetail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StorageAccountDetails_STATUS() to populate field StorageAccountDetails")
			}
			storageAccountDetailList[storageAccountDetailIndex] = storageAccountDetail
		}
		destination.StorageAccountDetails = storageAccountDetailList
	} else {
		destination.StorageAccountDetails = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource model definition representing SKU
type Sku struct {
	// Capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible
	// for the resource this may be omitted.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// Size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone
	// code.
	Size *string `json:"size,omitempty"`

	// Tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is
	// not  required on a PUT.
	Tier *SkuTier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Family":
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property "Size":
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property "Tier":
	if sku.Tier != nil {
		var temp string
		temp = string(*sku.Tier)
		tier := arm.SkuTier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := SkuTier(temp)
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, skuTier_Values)
		sku.Tier = &tierTemp
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), skuTier_Values)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// The resource model definition representing SKU
type Sku_STATUS struct {
	// Capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible
	// for the resource this may be omitted.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// Name: The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// Size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone
	// code.
	Size *string `json:"size,omitempty"`

	// Tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is
	// not  required on a PUT.
	Tier *SkuTier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := SkuTier_STATUS(temp)
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, skuTier_STATUS_Values)
		sku.Tier = &tierTemp
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of ACR account to be used for the Registry
type AcrDetails struct {
	// SystemCreatedAcrAccount: Details of system created ACR account to be used for the Registry
	SystemCreatedAcrAccount *SystemCreatedAcrAccount `json:"systemCreatedAcrAccount,omitempty"`

	// UserCreatedAcrAccount: Details of user created ACR account to be used for the Registry
	UserCreatedAcrAccount *UserCreatedAcrAccount `json:"userCreatedAcrAccount,omitempty"`
}

var _ genruntime.ARMTransformer = &AcrDetails{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (details *AcrDetails) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if details == nil {
		return nil, nil
	}
	result := &arm.AcrDetails{}

	// Set property "SystemCreatedAcrAccount":
	if details.SystemCreatedAcrAccount != nil {
		systemCreatedAcrAccount_ARM, err := (*details.SystemCreatedAcrAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemCreatedAcrAccount := *systemCreatedAcrAccount_ARM.(*arm.SystemCreatedAcrAccount)
		result.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	}

	// Set property "UserCreatedAcrAccount":
	if details.UserCreatedAcrAccount != nil {
		userCreatedAcrAccount_ARM, err := (*details.UserCreatedAcrAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		userCreatedAcrAccount := *userCreatedAcrAccount_ARM.(*arm.UserCreatedAcrAccount)
		result.UserCreatedAcrAccount = &userCreatedAcrAccount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *AcrDetails) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AcrDetails{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *AcrDetails) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AcrDetails)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AcrDetails, got %T", armInput)
	}

	// Set property "SystemCreatedAcrAccount":
	if typedInput.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount1 SystemCreatedAcrAccount
		err := systemCreatedAcrAccount1.PopulateFromARM(owner, *typedInput.SystemCreatedAcrAccount)
		if err != nil {
			return err
		}
		systemCreatedAcrAccount := systemCreatedAcrAccount1
		details.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	}

	// Set property "UserCreatedAcrAccount":
	if typedInput.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount1 UserCreatedAcrAccount
		err := userCreatedAcrAccount1.PopulateFromARM(owner, *typedInput.UserCreatedAcrAccount)
		if err != nil {
			return err
		}
		userCreatedAcrAccount := userCreatedAcrAccount1
		details.UserCreatedAcrAccount = &userCreatedAcrAccount
	}

	// No error
	return nil
}

// AssignProperties_From_AcrDetails populates our AcrDetails from the provided source AcrDetails
func (details *AcrDetails) AssignProperties_From_AcrDetails(source *storage.AcrDetails) error {

	// SystemCreatedAcrAccount
	if source.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount SystemCreatedAcrAccount
		err := systemCreatedAcrAccount.AssignProperties_From_SystemCreatedAcrAccount(source.SystemCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemCreatedAcrAccount() to populate field SystemCreatedAcrAccount")
		}
		details.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	} else {
		details.SystemCreatedAcrAccount = nil
	}

	// UserCreatedAcrAccount
	if source.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount UserCreatedAcrAccount
		err := userCreatedAcrAccount.AssignProperties_From_UserCreatedAcrAccount(source.UserCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserCreatedAcrAccount() to populate field UserCreatedAcrAccount")
		}
		details.UserCreatedAcrAccount = &userCreatedAcrAccount
	} else {
		details.UserCreatedAcrAccount = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AcrDetails populates the provided destination AcrDetails from our AcrDetails
func (details *AcrDetails) AssignProperties_To_AcrDetails(destination *storage.AcrDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SystemCreatedAcrAccount
	if details.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount storage.SystemCreatedAcrAccount
		err := details.SystemCreatedAcrAccount.AssignProperties_To_SystemCreatedAcrAccount(&systemCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemCreatedAcrAccount() to populate field SystemCreatedAcrAccount")
		}
		destination.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	} else {
		destination.SystemCreatedAcrAccount = nil
	}

	// UserCreatedAcrAccount
	if details.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount storage.UserCreatedAcrAccount
		err := details.UserCreatedAcrAccount.AssignProperties_To_UserCreatedAcrAccount(&userCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserCreatedAcrAccount() to populate field UserCreatedAcrAccount")
		}
		destination.UserCreatedAcrAccount = &userCreatedAcrAccount
	} else {
		destination.UserCreatedAcrAccount = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AcrDetails_STATUS populates our AcrDetails from the provided source AcrDetails_STATUS
func (details *AcrDetails) Initialize_From_AcrDetails_STATUS(source *AcrDetails_STATUS) error {

	// SystemCreatedAcrAccount
	if source.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount SystemCreatedAcrAccount
		err := systemCreatedAcrAccount.Initialize_From_SystemCreatedAcrAccount_STATUS(source.SystemCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SystemCreatedAcrAccount_STATUS() to populate field SystemCreatedAcrAccount")
		}
		details.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	} else {
		details.SystemCreatedAcrAccount = nil
	}

	// UserCreatedAcrAccount
	if source.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount UserCreatedAcrAccount
		err := userCreatedAcrAccount.Initialize_From_UserCreatedAcrAccount_STATUS(source.UserCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UserCreatedAcrAccount_STATUS() to populate field UserCreatedAcrAccount")
		}
		details.UserCreatedAcrAccount = &userCreatedAcrAccount
	} else {
		details.UserCreatedAcrAccount = nil
	}

	// No error
	return nil
}

// Details of ACR account to be used for the Registry
type AcrDetails_STATUS struct {
	// SystemCreatedAcrAccount: Details of system created ACR account to be used for the Registry
	SystemCreatedAcrAccount *SystemCreatedAcrAccount_STATUS `json:"systemCreatedAcrAccount,omitempty"`

	// UserCreatedAcrAccount: Details of user created ACR account to be used for the Registry
	UserCreatedAcrAccount *UserCreatedAcrAccount_STATUS `json:"userCreatedAcrAccount,omitempty"`
}

var _ genruntime.FromARMConverter = &AcrDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *AcrDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AcrDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *AcrDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AcrDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AcrDetails_STATUS, got %T", armInput)
	}

	// Set property "SystemCreatedAcrAccount":
	if typedInput.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount1 SystemCreatedAcrAccount_STATUS
		err := systemCreatedAcrAccount1.PopulateFromARM(owner, *typedInput.SystemCreatedAcrAccount)
		if err != nil {
			return err
		}
		systemCreatedAcrAccount := systemCreatedAcrAccount1
		details.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	}

	// Set property "UserCreatedAcrAccount":
	if typedInput.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount1 UserCreatedAcrAccount_STATUS
		err := userCreatedAcrAccount1.PopulateFromARM(owner, *typedInput.UserCreatedAcrAccount)
		if err != nil {
			return err
		}
		userCreatedAcrAccount := userCreatedAcrAccount1
		details.UserCreatedAcrAccount = &userCreatedAcrAccount
	}

	// No error
	return nil
}

// AssignProperties_From_AcrDetails_STATUS populates our AcrDetails_STATUS from the provided source AcrDetails_STATUS
func (details *AcrDetails_STATUS) AssignProperties_From_AcrDetails_STATUS(source *storage.AcrDetails_STATUS) error {

	// SystemCreatedAcrAccount
	if source.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount SystemCreatedAcrAccount_STATUS
		err := systemCreatedAcrAccount.AssignProperties_From_SystemCreatedAcrAccount_STATUS(source.SystemCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemCreatedAcrAccount_STATUS() to populate field SystemCreatedAcrAccount")
		}
		details.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	} else {
		details.SystemCreatedAcrAccount = nil
	}

	// UserCreatedAcrAccount
	if source.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount UserCreatedAcrAccount_STATUS
		err := userCreatedAcrAccount.AssignProperties_From_UserCreatedAcrAccount_STATUS(source.UserCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserCreatedAcrAccount_STATUS() to populate field UserCreatedAcrAccount")
		}
		details.UserCreatedAcrAccount = &userCreatedAcrAccount
	} else {
		details.UserCreatedAcrAccount = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AcrDetails_STATUS populates the provided destination AcrDetails_STATUS from our AcrDetails_STATUS
func (details *AcrDetails_STATUS) AssignProperties_To_AcrDetails_STATUS(destination *storage.AcrDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SystemCreatedAcrAccount
	if details.SystemCreatedAcrAccount != nil {
		var systemCreatedAcrAccount storage.SystemCreatedAcrAccount_STATUS
		err := details.SystemCreatedAcrAccount.AssignProperties_To_SystemCreatedAcrAccount_STATUS(&systemCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemCreatedAcrAccount_STATUS() to populate field SystemCreatedAcrAccount")
		}
		destination.SystemCreatedAcrAccount = &systemCreatedAcrAccount
	} else {
		destination.SystemCreatedAcrAccount = nil
	}

	// UserCreatedAcrAccount
	if details.UserCreatedAcrAccount != nil {
		var userCreatedAcrAccount storage.UserCreatedAcrAccount_STATUS
		err := details.UserCreatedAcrAccount.AssignProperties_To_UserCreatedAcrAccount_STATUS(&userCreatedAcrAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserCreatedAcrAccount_STATUS() to populate field UserCreatedAcrAccount")
		}
		destination.UserCreatedAcrAccount = &userCreatedAcrAccount
	} else {
		destination.UserCreatedAcrAccount = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned,UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                        ManagedServiceIdentityType_None,
	"systemassigned":              ManagedServiceIdentityType_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_UserAssigned,
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
type ManagedServiceIdentityType_STATUS string

const (
	ManagedServiceIdentityType_STATUS_None                       = ManagedServiceIdentityType_STATUS("None")
	ManagedServiceIdentityType_STATUS_SystemAssigned             = ManagedServiceIdentityType_STATUS("SystemAssigned")
	ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentityType_STATUS("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_STATUS_UserAssigned               = ManagedServiceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType_STATUS
var managedServiceIdentityType_STATUS_Values = map[string]ManagedServiceIdentityType_STATUS{
	"none":                        ManagedServiceIdentityType_STATUS_None,
	"systemassigned":              ManagedServiceIdentityType_STATUS_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_STATUS_UserAssigned,
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResource struct {
	// SubnetArmReference: The subnetId that the private endpoint is connected to.
	SubnetArmReference *genruntime.ResourceReference `armReference:"SubnetArmId" json:"subnetArmReference,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateEndpointResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *PrivateEndpointResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.PrivateEndpointResource{}

	// Set property "SubnetArmId":
	if resource.SubnetArmReference != nil {
		subnetArmReferenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.SubnetArmReference)
		if err != nil {
			return nil, err
		}
		subnetArmReference := subnetArmReferenceARMID
		result.SubnetArmId = &subnetArmReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateEndpointResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateEndpointResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.PrivateEndpointResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointResource, got %T", armInput)
	}

	// no assignment for property "SubnetArmReference"

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointResource populates our PrivateEndpointResource from the provided source PrivateEndpointResource
func (resource *PrivateEndpointResource) AssignProperties_From_PrivateEndpointResource(source *storage.PrivateEndpointResource) error {

	// SubnetArmReference
	if source.SubnetArmReference != nil {
		subnetArmReference := source.SubnetArmReference.Copy()
		resource.SubnetArmReference = &subnetArmReference
	} else {
		resource.SubnetArmReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointResource populates the provided destination PrivateEndpointResource from our PrivateEndpointResource
func (resource *PrivateEndpointResource) AssignProperties_To_PrivateEndpointResource(destination *storage.PrivateEndpointResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SubnetArmReference
	if resource.SubnetArmReference != nil {
		subnetArmReference := resource.SubnetArmReference.Copy()
		destination.SubnetArmReference = &subnetArmReference
	} else {
		destination.SubnetArmReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PrivateEndpointResource_STATUS populates our PrivateEndpointResource from the provided source PrivateEndpointResource_STATUS
func (resource *PrivateEndpointResource) Initialize_From_PrivateEndpointResource_STATUS(source *PrivateEndpointResource_STATUS) error {

	// SubnetArmReference
	if source.SubnetArmId != nil {
		subnetArmReference := genruntime.CreateResourceReferenceFromARMID(*source.SubnetArmId)
		resource.SubnetArmReference = &subnetArmReference
	} else {
		resource.SubnetArmReference = nil
	}

	// No error
	return nil
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResource_STATUS struct {
	// Id: The ARM identifier for Private Endpoint
	Id *string `json:"id,omitempty"`

	// SubnetArmId: The subnetId that the private endpoint is connected to.
	SubnetArmId *string `json:"subnetArmId,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateEndpointResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateEndpointResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointResource_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "SubnetArmId":
	if typedInput.SubnetArmId != nil {
		subnetArmId := *typedInput.SubnetArmId
		resource.SubnetArmId = &subnetArmId
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointResource_STATUS populates our PrivateEndpointResource_STATUS from the provided source PrivateEndpointResource_STATUS
func (resource *PrivateEndpointResource_STATUS) AssignProperties_From_PrivateEndpointResource_STATUS(source *storage.PrivateEndpointResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// SubnetArmId
	resource.SubnetArmId = genruntime.ClonePointerToString(source.SubnetArmId)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointResource_STATUS populates the provided destination PrivateEndpointResource_STATUS from our PrivateEndpointResource_STATUS
func (resource *PrivateEndpointResource_STATUS) AssignProperties_To_PrivateEndpointResource_STATUS(destination *storage.PrivateEndpointResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// SubnetArmId
	destination.SubnetArmId = genruntime.ClonePointerToString(resource.SubnetArmId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RegistryOperatorConfigMaps struct {
	// DiscoveryUrl: indicates where the DiscoveryUrl config map should be placed. If omitted, no config map will be created.
	DiscoveryUrl *genruntime.ConfigMapDestination `json:"discoveryUrl,omitempty"`

	// MlFlowRegistryUri: indicates where the MlFlowRegistryUri config map should be placed. If omitted, no config map will be
	// created.
	MlFlowRegistryUri *genruntime.ConfigMapDestination `json:"mlFlowRegistryUri,omitempty"`
}

// AssignProperties_From_RegistryOperatorConfigMaps populates our RegistryOperatorConfigMaps from the provided source RegistryOperatorConfigMaps
func (maps *RegistryOperatorConfigMaps) AssignProperties_From_RegistryOperatorConfigMaps(source *storage.RegistryOperatorConfigMaps) error {

	// DiscoveryUrl
	if source.DiscoveryUrl != nil {
		discoveryUrl := source.DiscoveryUrl.Copy()
		maps.DiscoveryUrl = &discoveryUrl
	} else {
		maps.DiscoveryUrl = nil
	}

	// MlFlowRegistryUri
	if source.MlFlowRegistryUri != nil {
		mlFlowRegistryUri := source.MlFlowRegistryUri.Copy()
		maps.MlFlowRegistryUri = &mlFlowRegistryUri
	} else {
		maps.MlFlowRegistryUri = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryOperatorConfigMaps populates the provided destination RegistryOperatorConfigMaps from our RegistryOperatorConfigMaps
func (maps *RegistryOperatorConfigMaps) AssignProperties_To_RegistryOperatorConfigMaps(destination *storage.RegistryOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiscoveryUrl
	if maps.DiscoveryUrl != nil {
		discoveryUrl := maps.DiscoveryUrl.Copy()
		destination.DiscoveryUrl = &discoveryUrl
	} else {
		destination.DiscoveryUrl = nil
	}

	// MlFlowRegistryUri
	if maps.MlFlowRegistryUri != nil {
		mlFlowRegistryUri := maps.MlFlowRegistryUri.Copy()
		destination.MlFlowRegistryUri = &mlFlowRegistryUri
	} else {
		destination.MlFlowRegistryUri = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The connection state.
type RegistryPrivateLinkServiceConnectionState struct {
	// ActionsRequired: Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description: User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `json:"description,omitempty"`

	// Status: Connection status of the service consumer with the service provider
	Status *EndpointServiceConnectionStatus `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &RegistryPrivateLinkServiceConnectionState{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (state *RegistryPrivateLinkServiceConnectionState) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if state == nil {
		return nil, nil
	}
	result := &arm.RegistryPrivateLinkServiceConnectionState{}

	// Set property "ActionsRequired":
	if state.ActionsRequired != nil {
		actionsRequired := *state.ActionsRequired
		result.ActionsRequired = &actionsRequired
	}

	// Set property "Description":
	if state.Description != nil {
		description := *state.Description
		result.Description = &description
	}

	// Set property "Status":
	if state.Status != nil {
		var temp string
		temp = string(*state.Status)
		status := arm.EndpointServiceConnectionStatus(temp)
		result.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *RegistryPrivateLinkServiceConnectionState) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryPrivateLinkServiceConnectionState{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *RegistryPrivateLinkServiceConnectionState) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryPrivateLinkServiceConnectionState)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryPrivateLinkServiceConnectionState, got %T", armInput)
	}

	// Set property "ActionsRequired":
	if typedInput.ActionsRequired != nil {
		actionsRequired := *typedInput.ActionsRequired
		state.ActionsRequired = &actionsRequired
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		state.Description = &description
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := EndpointServiceConnectionStatus(temp)
		state.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryPrivateLinkServiceConnectionState populates our RegistryPrivateLinkServiceConnectionState from the provided source RegistryPrivateLinkServiceConnectionState
func (state *RegistryPrivateLinkServiceConnectionState) AssignProperties_From_RegistryPrivateLinkServiceConnectionState(source *storage.RegistryPrivateLinkServiceConnectionState) error {

	// ActionsRequired
	state.ActionsRequired = genruntime.ClonePointerToString(source.ActionsRequired)

	// Description
	state.Description = genruntime.ClonePointerToString(source.Description)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, endpointServiceConnectionStatus_Values)
		state.Status = &statusTemp
	} else {
		state.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryPrivateLinkServiceConnectionState populates the provided destination RegistryPrivateLinkServiceConnectionState from our RegistryPrivateLinkServiceConnectionState
func (state *RegistryPrivateLinkServiceConnectionState) AssignProperties_To_RegistryPrivateLinkServiceConnectionState(destination *storage.RegistryPrivateLinkServiceConnectionState) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionsRequired
	destination.ActionsRequired = genruntime.ClonePointerToString(state.ActionsRequired)

	// Description
	destination.Description = genruntime.ClonePointerToString(state.Description)

	// Status
	if state.Status != nil {
		status := string(*state.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RegistryPrivateLinkServiceConnectionState_STATUS populates our RegistryPrivateLinkServiceConnectionState from the provided source RegistryPrivateLinkServiceConnectionState_STATUS
func (state *RegistryPrivateLinkServiceConnectionState) Initialize_From_RegistryPrivateLinkServiceConnectionState_STATUS(source *RegistryPrivateLinkServiceConnectionState_STATUS) error {

	// ActionsRequired
	state.ActionsRequired = genruntime.ClonePointerToString(source.ActionsRequired)

	// Description
	state.Description = genruntime.ClonePointerToString(source.Description)

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), endpointServiceConnectionStatus_Values)
		state.Status = &status
	} else {
		state.Status = nil
	}

	// No error
	return nil
}

// The connection state.
type RegistryPrivateLinkServiceConnectionState_STATUS struct {
	// ActionsRequired: Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description: User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `json:"description,omitempty"`

	// Status: Connection status of the service consumer with the service provider
	Status *EndpointServiceConnectionStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &RegistryPrivateLinkServiceConnectionState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *RegistryPrivateLinkServiceConnectionState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryPrivateLinkServiceConnectionState_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *RegistryPrivateLinkServiceConnectionState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryPrivateLinkServiceConnectionState_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryPrivateLinkServiceConnectionState_STATUS, got %T", armInput)
	}

	// Set property "ActionsRequired":
	if typedInput.ActionsRequired != nil {
		actionsRequired := *typedInput.ActionsRequired
		state.ActionsRequired = &actionsRequired
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		state.Description = &description
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := EndpointServiceConnectionStatus_STATUS(temp)
		state.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryPrivateLinkServiceConnectionState_STATUS populates our RegistryPrivateLinkServiceConnectionState_STATUS from the provided source RegistryPrivateLinkServiceConnectionState_STATUS
func (state *RegistryPrivateLinkServiceConnectionState_STATUS) AssignProperties_From_RegistryPrivateLinkServiceConnectionState_STATUS(source *storage.RegistryPrivateLinkServiceConnectionState_STATUS) error {

	// ActionsRequired
	state.ActionsRequired = genruntime.ClonePointerToString(source.ActionsRequired)

	// Description
	state.Description = genruntime.ClonePointerToString(source.Description)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, endpointServiceConnectionStatus_STATUS_Values)
		state.Status = &statusTemp
	} else {
		state.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryPrivateLinkServiceConnectionState_STATUS populates the provided destination RegistryPrivateLinkServiceConnectionState_STATUS from our RegistryPrivateLinkServiceConnectionState_STATUS
func (state *RegistryPrivateLinkServiceConnectionState_STATUS) AssignProperties_To_RegistryPrivateLinkServiceConnectionState_STATUS(destination *storage.RegistryPrivateLinkServiceConnectionState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionsRequired
	destination.ActionsRequired = genruntime.ClonePointerToString(state.ActionsRequired)

	// Description
	destination.Description = genruntime.ClonePointerToString(state.Description)

	// Status
	if state.Status != nil {
		status := string(*state.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not
// required on a PUT.
// +kubebuilder:validation:Enum={"Basic","Free","Premium","Standard"}
type SkuTier string

const (
	SkuTier_Basic    = SkuTier("Basic")
	SkuTier_Free     = SkuTier("Free")
	SkuTier_Premium  = SkuTier("Premium")
	SkuTier_Standard = SkuTier("Standard")
)

// Mapping from string to SkuTier
var skuTier_Values = map[string]SkuTier{
	"basic":    SkuTier_Basic,
	"free":     SkuTier_Free,
	"premium":  SkuTier_Premium,
	"standard": SkuTier_Standard,
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not
// required on a PUT.
type SkuTier_STATUS string

const (
	SkuTier_STATUS_Basic    = SkuTier_STATUS("Basic")
	SkuTier_STATUS_Free     = SkuTier_STATUS("Free")
	SkuTier_STATUS_Premium  = SkuTier_STATUS("Premium")
	SkuTier_STATUS_Standard = SkuTier_STATUS("Standard")
)

// Mapping from string to SkuTier_STATUS
var skuTier_STATUS_Values = map[string]SkuTier_STATUS{
	"basic":    SkuTier_STATUS_Basic,
	"free":     SkuTier_STATUS_Free,
	"premium":  SkuTier_STATUS_Premium,
	"standard": SkuTier_STATUS_Standard,
}

// Details of storage account to be used for the Registry
type StorageAccountDetails struct {
	// SystemCreatedStorageAccount: Details of system created storage account to be used for the registry
	SystemCreatedStorageAccount *SystemCreatedStorageAccount `json:"systemCreatedStorageAccount,omitempty"`

	// UserCreatedStorageAccount: Details of user created storage account to be used for the registry
	UserCreatedStorageAccount *UserCreatedStorageAccount `json:"userCreatedStorageAccount,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageAccountDetails{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (details *StorageAccountDetails) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if details == nil {
		return nil, nil
	}
	result := &arm.StorageAccountDetails{}

	// Set property "SystemCreatedStorageAccount":
	if details.SystemCreatedStorageAccount != nil {
		systemCreatedStorageAccount_ARM, err := (*details.SystemCreatedStorageAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemCreatedStorageAccount := *systemCreatedStorageAccount_ARM.(*arm.SystemCreatedStorageAccount)
		result.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	}

	// Set property "UserCreatedStorageAccount":
	if details.UserCreatedStorageAccount != nil {
		userCreatedStorageAccount_ARM, err := (*details.UserCreatedStorageAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		userCreatedStorageAccount := *userCreatedStorageAccount_ARM.(*arm.UserCreatedStorageAccount)
		result.UserCreatedStorageAccount = &userCreatedStorageAccount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *StorageAccountDetails) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageAccountDetails{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *StorageAccountDetails) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageAccountDetails)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageAccountDetails, got %T", armInput)
	}

	// Set property "SystemCreatedStorageAccount":
	if typedInput.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount1 SystemCreatedStorageAccount
		err := systemCreatedStorageAccount1.PopulateFromARM(owner, *typedInput.SystemCreatedStorageAccount)
		if err != nil {
			return err
		}
		systemCreatedStorageAccount := systemCreatedStorageAccount1
		details.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	}

	// Set property "UserCreatedStorageAccount":
	if typedInput.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount1 UserCreatedStorageAccount
		err := userCreatedStorageAccount1.PopulateFromARM(owner, *typedInput.UserCreatedStorageAccount)
		if err != nil {
			return err
		}
		userCreatedStorageAccount := userCreatedStorageAccount1
		details.UserCreatedStorageAccount = &userCreatedStorageAccount
	}

	// No error
	return nil
}

// AssignProperties_From_StorageAccountDetails populates our StorageAccountDetails from the provided source StorageAccountDetails
func (details *StorageAccountDetails) AssignProperties_From_StorageAccountDetails(source *storage.StorageAccountDetails) error {

	// SystemCreatedStorageAccount
	if source.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount SystemCreatedStorageAccount
		err := systemCreatedStorageAccount.AssignProperties_From_SystemCreatedStorageAccount(source.SystemCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemCreatedStorageAccount() to populate field SystemCreatedStorageAccount")
		}
		details.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	} else {
		details.SystemCreatedStorageAccount = nil
	}

	// UserCreatedStorageAccount
	if source.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount UserCreatedStorageAccount
		err := userCreatedStorageAccount.AssignProperties_From_UserCreatedStorageAccount(source.UserCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserCreatedStorageAccount() to populate field UserCreatedStorageAccount")
		}
		details.UserCreatedStorageAccount = &userCreatedStorageAccount
	} else {
		details.UserCreatedStorageAccount = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageAccountDetails populates the provided destination StorageAccountDetails from our StorageAccountDetails
func (details *StorageAccountDetails) AssignProperties_To_StorageAccountDetails(destination *storage.StorageAccountDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SystemCreatedStorageAccount
	if details.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount storage.SystemCreatedStorageAccount
		err := details.SystemCreatedStorageAccount.AssignProperties_To_SystemCreatedStorageAccount(&systemCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemCreatedStorageAccount() to populate field SystemCreatedStorageAccount")
		}
		destination.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	} else {
		destination.SystemCreatedStorageAccount = nil
	}

	// UserCreatedStorageAccount
	if details.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount storage.UserCreatedStorageAccount
		err := details.UserCreatedStorageAccount.AssignProperties_To_UserCreatedStorageAccount(&userCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserCreatedStorageAccount() to populate field UserCreatedStorageAccount")
		}
		destination.UserCreatedStorageAccount = &userCreatedStorageAccount
	} else {
		destination.UserCreatedStorageAccount = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageAccountDetails_STATUS populates our StorageAccountDetails from the provided source StorageAccountDetails_STATUS
func (details *StorageAccountDetails) Initialize_From_StorageAccountDetails_STATUS(source *StorageAccountDetails_STATUS) error {

	// SystemCreatedStorageAccount
	if source.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount SystemCreatedStorageAccount
		err := systemCreatedStorageAccount.Initialize_From_SystemCreatedStorageAccount_STATUS(source.SystemCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SystemCreatedStorageAccount_STATUS() to populate field SystemCreatedStorageAccount")
		}
		details.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	} else {
		details.SystemCreatedStorageAccount = nil
	}

	// UserCreatedStorageAccount
	if source.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount UserCreatedStorageAccount
		err := userCreatedStorageAccount.Initialize_From_UserCreatedStorageAccount_STATUS(source.UserCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UserCreatedStorageAccount_STATUS() to populate field UserCreatedStorageAccount")
		}
		details.UserCreatedStorageAccount = &userCreatedStorageAccount
	} else {
		details.UserCreatedStorageAccount = nil
	}

	// No error
	return nil
}

// Details of storage account to be used for the Registry
type StorageAccountDetails_STATUS struct {
	// SystemCreatedStorageAccount: Details of system created storage account to be used for the registry
	SystemCreatedStorageAccount *SystemCreatedStorageAccount_STATUS `json:"systemCreatedStorageAccount,omitempty"`

	// UserCreatedStorageAccount: Details of user created storage account to be used for the registry
	UserCreatedStorageAccount *UserCreatedStorageAccount_STATUS `json:"userCreatedStorageAccount,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageAccountDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *StorageAccountDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageAccountDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *StorageAccountDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageAccountDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageAccountDetails_STATUS, got %T", armInput)
	}

	// Set property "SystemCreatedStorageAccount":
	if typedInput.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount1 SystemCreatedStorageAccount_STATUS
		err := systemCreatedStorageAccount1.PopulateFromARM(owner, *typedInput.SystemCreatedStorageAccount)
		if err != nil {
			return err
		}
		systemCreatedStorageAccount := systemCreatedStorageAccount1
		details.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	}

	// Set property "UserCreatedStorageAccount":
	if typedInput.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount1 UserCreatedStorageAccount_STATUS
		err := userCreatedStorageAccount1.PopulateFromARM(owner, *typedInput.UserCreatedStorageAccount)
		if err != nil {
			return err
		}
		userCreatedStorageAccount := userCreatedStorageAccount1
		details.UserCreatedStorageAccount = &userCreatedStorageAccount
	}

	// No error
	return nil
}

// AssignProperties_From_StorageAccountDetails_STATUS populates our StorageAccountDetails_STATUS from the provided source StorageAccountDetails_STATUS
func (details *StorageAccountDetails_STATUS) AssignProperties_From_StorageAccountDetails_STATUS(source *storage.StorageAccountDetails_STATUS) error {

	// SystemCreatedStorageAccount
	if source.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount SystemCreatedStorageAccount_STATUS
		err := systemCreatedStorageAccount.AssignProperties_From_SystemCreatedStorageAccount_STATUS(source.SystemCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemCreatedStorageAccount_STATUS() to populate field SystemCreatedStorageAccount")
		}
		details.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	} else {
		details.SystemCreatedStorageAccount = nil
	}

	// UserCreatedStorageAccount
	if source.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount UserCreatedStorageAccount_STATUS
		err := userCreatedStorageAccount.AssignProperties_From_UserCreatedStorageAccount_STATUS(source.UserCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserCreatedStorageAccount_STATUS() to populate field UserCreatedStorageAccount")
		}
		details.UserCreatedStorageAccount = &userCreatedStorageAccount
	} else {
		details.UserCreatedStorageAccount = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageAccountDetails_STATUS populates the provided destination StorageAccountDetails_STATUS from our StorageAccountDetails_STATUS
func (details *StorageAccountDetails_STATUS) AssignProperties_To_StorageAccountDetails_STATUS(destination *storage.StorageAccountDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SystemCreatedStorageAccount
	if details.SystemCreatedStorageAccount != nil {
		var systemCreatedStorageAccount storage.SystemCreatedStorageAccount_STATUS
		err := details.SystemCreatedStorageAccount.AssignProperties_To_SystemCreatedStorageAccount_STATUS(&systemCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemCreatedStorageAccount_STATUS() to populate field SystemCreatedStorageAccount")
		}
		destination.SystemCreatedStorageAccount = &systemCreatedStorageAccount
	} else {
		destination.SystemCreatedStorageAccount = nil
	}

	// UserCreatedStorageAccount
	if details.UserCreatedStorageAccount != nil {
		var userCreatedStorageAccount storage.UserCreatedStorageAccount_STATUS
		err := details.UserCreatedStorageAccount.AssignProperties_To_UserCreatedStorageAccount_STATUS(&userCreatedStorageAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserCreatedStorageAccount_STATUS() to populate field UserCreatedStorageAccount")
		}
		destination.UserCreatedStorageAccount = &userCreatedStorageAccount
	} else {
		destination.UserCreatedStorageAccount = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal ID of the assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Connection status of the service consumer with the service provider
// +kubebuilder:validation:Enum={"Approved","Disconnected","Pending","Rejected"}
type EndpointServiceConnectionStatus string

const (
	EndpointServiceConnectionStatus_Approved     = EndpointServiceConnectionStatus("Approved")
	EndpointServiceConnectionStatus_Disconnected = EndpointServiceConnectionStatus("Disconnected")
	EndpointServiceConnectionStatus_Pending      = EndpointServiceConnectionStatus("Pending")
	EndpointServiceConnectionStatus_Rejected     = EndpointServiceConnectionStatus("Rejected")
)

// Mapping from string to EndpointServiceConnectionStatus
var endpointServiceConnectionStatus_Values = map[string]EndpointServiceConnectionStatus{
	"approved":     EndpointServiceConnectionStatus_Approved,
	"disconnected": EndpointServiceConnectionStatus_Disconnected,
	"pending":      EndpointServiceConnectionStatus_Pending,
	"rejected":     EndpointServiceConnectionStatus_Rejected,
}

// Connection status of the service consumer with the service provider
type EndpointServiceConnectionStatus_STATUS string

const (
	EndpointServiceConnectionStatus_STATUS_Approved     = EndpointServiceConnectionStatus_STATUS("Approved")
	EndpointServiceConnectionStatus_STATUS_Disconnected = EndpointServiceConnectionStatus_STATUS("Disconnected")
	EndpointServiceConnectionStatus_STATUS_Pending      = EndpointServiceConnectionStatus_STATUS("Pending")
	EndpointServiceConnectionStatus_STATUS_Rejected     = EndpointServiceConnectionStatus_STATUS("Rejected")
)

// Mapping from string to EndpointServiceConnectionStatus_STATUS
var endpointServiceConnectionStatus_STATUS_Values = map[string]EndpointServiceConnectionStatus_STATUS{
	"approved":     EndpointServiceConnectionStatus_STATUS_Approved,
	"disconnected": EndpointServiceConnectionStatus_STATUS_Disconnected,
	"pending":      EndpointServiceConnectionStatus_STATUS_Pending,
	"rejected":     EndpointServiceConnectionStatus_STATUS_Rejected,
}

type SystemCreatedAcrAccount struct {
	// AcrAccountName: Name of the ACR account
	AcrAccountName *string `json:"acrAccountName,omitempty"`

	// AcrAccountSku: SKU of the ACR account
	AcrAccountSku *string `json:"acrAccountSku,omitempty"`
}

var _ genruntime.ARMTransformer = &SystemCreatedAcrAccount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (account *SystemCreatedAcrAccount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if account == nil {
		return nil, nil
	}
	result := &arm.SystemCreatedAcrAccount{}

	// Set property "AcrAccountName":
	if account.AcrAccountName != nil {
		acrAccountName := *account.AcrAccountName
		result.AcrAccountName = &acrAccountName
	}

	// Set property "AcrAccountSku":
	if account.AcrAccountSku != nil {
		acrAccountSku := *account.AcrAccountSku
		result.AcrAccountSku = &acrAccountSku
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *SystemCreatedAcrAccount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemCreatedAcrAccount{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *SystemCreatedAcrAccount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemCreatedAcrAccount)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemCreatedAcrAccount, got %T", armInput)
	}

	// Set property "AcrAccountName":
	if typedInput.AcrAccountName != nil {
		acrAccountName := *typedInput.AcrAccountName
		account.AcrAccountName = &acrAccountName
	}

	// Set property "AcrAccountSku":
	if typedInput.AcrAccountSku != nil {
		acrAccountSku := *typedInput.AcrAccountSku
		account.AcrAccountSku = &acrAccountSku
	}

	// No error
	return nil
}

// AssignProperties_From_SystemCreatedAcrAccount populates our SystemCreatedAcrAccount from the provided source SystemCreatedAcrAccount
func (account *SystemCreatedAcrAccount) AssignProperties_From_SystemCreatedAcrAccount(source *storage.SystemCreatedAcrAccount) error {

	// AcrAccountName
	account.AcrAccountName = genruntime.ClonePointerToString(source.AcrAccountName)

	// AcrAccountSku
	account.AcrAccountSku = genruntime.ClonePointerToString(source.AcrAccountSku)

	// No error
	return nil
}

// AssignProperties_To_SystemCreatedAcrAccount populates the provided destination SystemCreatedAcrAccount from our SystemCreatedAcrAccount
func (account *SystemCreatedAcrAccount) AssignProperties_To_SystemCreatedAcrAccount(destination *storage.SystemCreatedAcrAccount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrAccountName
	destination.AcrAccountName = genruntime.ClonePointerToString(account.AcrAccountName)

	// AcrAccountSku
	destination.AcrAccountSku = genruntime.ClonePointerToString(account.AcrAccountSku)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SystemCreatedAcrAccount_STATUS populates our SystemCreatedAcrAccount from the provided source SystemCreatedAcrAccount_STATUS
func (account *SystemCreatedAcrAccount) Initialize_From_SystemCreatedAcrAccount_STATUS(source *SystemCreatedAcrAccount_STATUS) error {

	// AcrAccountName
	account.AcrAccountName = genruntime.ClonePointerToString(source.AcrAccountName)

	// AcrAccountSku
	account.AcrAccountSku = genruntime.ClonePointerToString(source.AcrAccountSku)

	// No error
	return nil
}

type SystemCreatedAcrAccount_STATUS struct {
	// AcrAccountName: Name of the ACR account
	AcrAccountName *string `json:"acrAccountName,omitempty"`

	// AcrAccountSku: SKU of the ACR account
	AcrAccountSku *string `json:"acrAccountSku,omitempty"`

	// ArmResourceId: This is populated once the ACR account is created.
	ArmResourceId *ArmResourceId_STATUS `json:"armResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemCreatedAcrAccount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *SystemCreatedAcrAccount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemCreatedAcrAccount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *SystemCreatedAcrAccount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemCreatedAcrAccount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemCreatedAcrAccount_STATUS, got %T", armInput)
	}

	// Set property "AcrAccountName":
	if typedInput.AcrAccountName != nil {
		acrAccountName := *typedInput.AcrAccountName
		account.AcrAccountName = &acrAccountName
	}

	// Set property "AcrAccountSku":
	if typedInput.AcrAccountSku != nil {
		acrAccountSku := *typedInput.AcrAccountSku
		account.AcrAccountSku = &acrAccountSku
	}

	// Set property "ArmResourceId":
	if typedInput.ArmResourceId != nil {
		var armResourceId1 ArmResourceId_STATUS
		err := armResourceId1.PopulateFromARM(owner, *typedInput.ArmResourceId)
		if err != nil {
			return err
		}
		armResourceId := armResourceId1
		account.ArmResourceId = &armResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_SystemCreatedAcrAccount_STATUS populates our SystemCreatedAcrAccount_STATUS from the provided source SystemCreatedAcrAccount_STATUS
func (account *SystemCreatedAcrAccount_STATUS) AssignProperties_From_SystemCreatedAcrAccount_STATUS(source *storage.SystemCreatedAcrAccount_STATUS) error {

	// AcrAccountName
	account.AcrAccountName = genruntime.ClonePointerToString(source.AcrAccountName)

	// AcrAccountSku
	account.AcrAccountSku = genruntime.ClonePointerToString(source.AcrAccountSku)

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId_STATUS
		err := armResourceId.AssignProperties_From_ArmResourceId_STATUS(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemCreatedAcrAccount_STATUS populates the provided destination SystemCreatedAcrAccount_STATUS from our SystemCreatedAcrAccount_STATUS
func (account *SystemCreatedAcrAccount_STATUS) AssignProperties_To_SystemCreatedAcrAccount_STATUS(destination *storage.SystemCreatedAcrAccount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrAccountName
	destination.AcrAccountName = genruntime.ClonePointerToString(account.AcrAccountName)

	// AcrAccountSku
	destination.AcrAccountSku = genruntime.ClonePointerToString(account.AcrAccountSku)

	// ArmResourceId
	if account.ArmResourceId != nil {
		var armResourceId storage.ArmResourceId_STATUS
		err := account.ArmResourceId.AssignProperties_To_ArmResourceId_STATUS(&armResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		destination.ArmResourceId = &armResourceId
	} else {
		destination.ArmResourceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemCreatedStorageAccount struct {
	// AllowBlobPublicAccess: Public blob access allowed
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// StorageAccountHnsEnabled: HNS enabled for storage account
	StorageAccountHnsEnabled *bool `json:"storageAccountHnsEnabled,omitempty"`

	// StorageAccountName: Name of the storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// StorageAccountType: Allowed values:
	// "Standard_LRS",
	// "Standard_GRS",
	// "Standard_RAGRS",
	// "Standard_ZRS",
	// "Standard_GZRS",
	// "Standard_RAGZRS",
	// "Premium_LRS",
	// "Premium_ZRS"
	StorageAccountType *string `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &SystemCreatedStorageAccount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (account *SystemCreatedStorageAccount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if account == nil {
		return nil, nil
	}
	result := &arm.SystemCreatedStorageAccount{}

	// Set property "AllowBlobPublicAccess":
	if account.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *account.AllowBlobPublicAccess
		result.AllowBlobPublicAccess = &allowBlobPublicAccess
	}

	// Set property "StorageAccountHnsEnabled":
	if account.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *account.StorageAccountHnsEnabled
		result.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	}

	// Set property "StorageAccountName":
	if account.StorageAccountName != nil {
		storageAccountName := *account.StorageAccountName
		result.StorageAccountName = &storageAccountName
	}

	// Set property "StorageAccountType":
	if account.StorageAccountType != nil {
		storageAccountType := *account.StorageAccountType
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *SystemCreatedStorageAccount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemCreatedStorageAccount{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *SystemCreatedStorageAccount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemCreatedStorageAccount)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemCreatedStorageAccount, got %T", armInput)
	}

	// Set property "AllowBlobPublicAccess":
	if typedInput.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *typedInput.AllowBlobPublicAccess
		account.AllowBlobPublicAccess = &allowBlobPublicAccess
	}

	// Set property "StorageAccountHnsEnabled":
	if typedInput.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *typedInput.StorageAccountHnsEnabled
		account.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	}

	// Set property "StorageAccountName":
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		account.StorageAccountName = &storageAccountName
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		account.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemCreatedStorageAccount populates our SystemCreatedStorageAccount from the provided source SystemCreatedStorageAccount
func (account *SystemCreatedStorageAccount) AssignProperties_From_SystemCreatedStorageAccount(source *storage.SystemCreatedStorageAccount) error {

	// AllowBlobPublicAccess
	if source.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *source.AllowBlobPublicAccess
		account.AllowBlobPublicAccess = &allowBlobPublicAccess
	} else {
		account.AllowBlobPublicAccess = nil
	}

	// StorageAccountHnsEnabled
	if source.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *source.StorageAccountHnsEnabled
		account.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	} else {
		account.StorageAccountHnsEnabled = nil
	}

	// StorageAccountName
	account.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// StorageAccountType
	account.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// No error
	return nil
}

// AssignProperties_To_SystemCreatedStorageAccount populates the provided destination SystemCreatedStorageAccount from our SystemCreatedStorageAccount
func (account *SystemCreatedStorageAccount) AssignProperties_To_SystemCreatedStorageAccount(destination *storage.SystemCreatedStorageAccount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowBlobPublicAccess
	if account.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *account.AllowBlobPublicAccess
		destination.AllowBlobPublicAccess = &allowBlobPublicAccess
	} else {
		destination.AllowBlobPublicAccess = nil
	}

	// StorageAccountHnsEnabled
	if account.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *account.StorageAccountHnsEnabled
		destination.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	} else {
		destination.StorageAccountHnsEnabled = nil
	}

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(account.StorageAccountName)

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(account.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SystemCreatedStorageAccount_STATUS populates our SystemCreatedStorageAccount from the provided source SystemCreatedStorageAccount_STATUS
func (account *SystemCreatedStorageAccount) Initialize_From_SystemCreatedStorageAccount_STATUS(source *SystemCreatedStorageAccount_STATUS) error {

	// AllowBlobPublicAccess
	if source.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *source.AllowBlobPublicAccess
		account.AllowBlobPublicAccess = &allowBlobPublicAccess
	} else {
		account.AllowBlobPublicAccess = nil
	}

	// StorageAccountHnsEnabled
	if source.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *source.StorageAccountHnsEnabled
		account.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	} else {
		account.StorageAccountHnsEnabled = nil
	}

	// StorageAccountName
	account.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// StorageAccountType
	account.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// No error
	return nil
}

type SystemCreatedStorageAccount_STATUS struct {
	// AllowBlobPublicAccess: Public blob access allowed
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// ArmResourceId: This is populated once the storage account is created.
	ArmResourceId *ArmResourceId_STATUS `json:"armResourceId,omitempty"`

	// StorageAccountHnsEnabled: HNS enabled for storage account
	StorageAccountHnsEnabled *bool `json:"storageAccountHnsEnabled,omitempty"`

	// StorageAccountName: Name of the storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// StorageAccountType: Allowed values:
	// "Standard_LRS",
	// "Standard_GRS",
	// "Standard_RAGRS",
	// "Standard_ZRS",
	// "Standard_GZRS",
	// "Standard_RAGZRS",
	// "Premium_LRS",
	// "Premium_ZRS"
	StorageAccountType *string `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemCreatedStorageAccount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *SystemCreatedStorageAccount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemCreatedStorageAccount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *SystemCreatedStorageAccount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemCreatedStorageAccount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemCreatedStorageAccount_STATUS, got %T", armInput)
	}

	// Set property "AllowBlobPublicAccess":
	if typedInput.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *typedInput.AllowBlobPublicAccess
		account.AllowBlobPublicAccess = &allowBlobPublicAccess
	}

	// Set property "ArmResourceId":
	if typedInput.ArmResourceId != nil {
		var armResourceId1 ArmResourceId_STATUS
		err := armResourceId1.PopulateFromARM(owner, *typedInput.ArmResourceId)
		if err != nil {
			return err
		}
		armResourceId := armResourceId1
		account.ArmResourceId = &armResourceId
	}

	// Set property "StorageAccountHnsEnabled":
	if typedInput.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *typedInput.StorageAccountHnsEnabled
		account.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	}

	// Set property "StorageAccountName":
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		account.StorageAccountName = &storageAccountName
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		account.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemCreatedStorageAccount_STATUS populates our SystemCreatedStorageAccount_STATUS from the provided source SystemCreatedStorageAccount_STATUS
func (account *SystemCreatedStorageAccount_STATUS) AssignProperties_From_SystemCreatedStorageAccount_STATUS(source *storage.SystemCreatedStorageAccount_STATUS) error {

	// AllowBlobPublicAccess
	if source.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *source.AllowBlobPublicAccess
		account.AllowBlobPublicAccess = &allowBlobPublicAccess
	} else {
		account.AllowBlobPublicAccess = nil
	}

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId_STATUS
		err := armResourceId.AssignProperties_From_ArmResourceId_STATUS(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// StorageAccountHnsEnabled
	if source.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *source.StorageAccountHnsEnabled
		account.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	} else {
		account.StorageAccountHnsEnabled = nil
	}

	// StorageAccountName
	account.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// StorageAccountType
	account.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// No error
	return nil
}

// AssignProperties_To_SystemCreatedStorageAccount_STATUS populates the provided destination SystemCreatedStorageAccount_STATUS from our SystemCreatedStorageAccount_STATUS
func (account *SystemCreatedStorageAccount_STATUS) AssignProperties_To_SystemCreatedStorageAccount_STATUS(destination *storage.SystemCreatedStorageAccount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowBlobPublicAccess
	if account.AllowBlobPublicAccess != nil {
		allowBlobPublicAccess := *account.AllowBlobPublicAccess
		destination.AllowBlobPublicAccess = &allowBlobPublicAccess
	} else {
		destination.AllowBlobPublicAccess = nil
	}

	// ArmResourceId
	if account.ArmResourceId != nil {
		var armResourceId storage.ArmResourceId_STATUS
		err := account.ArmResourceId.AssignProperties_To_ArmResourceId_STATUS(&armResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		destination.ArmResourceId = &armResourceId
	} else {
		destination.ArmResourceId = nil
	}

	// StorageAccountHnsEnabled
	if account.StorageAccountHnsEnabled != nil {
		storageAccountHnsEnabled := *account.StorageAccountHnsEnabled
		destination.StorageAccountHnsEnabled = &storageAccountHnsEnabled
	} else {
		destination.StorageAccountHnsEnabled = nil
	}

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(account.StorageAccountName)

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(account.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserCreatedAcrAccount struct {
	// ArmResourceId: ARM ResourceId of a resource
	ArmResourceId *ArmResourceId `json:"armResourceId,omitempty"`
}

var _ genruntime.ARMTransformer = &UserCreatedAcrAccount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (account *UserCreatedAcrAccount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if account == nil {
		return nil, nil
	}
	result := &arm.UserCreatedAcrAccount{}

	// Set property "ArmResourceId":
	if account.ArmResourceId != nil {
		armResourceId_ARM, err := (*account.ArmResourceId).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		armResourceId := *armResourceId_ARM.(*arm.ArmResourceId)
		result.ArmResourceId = &armResourceId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *UserCreatedAcrAccount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserCreatedAcrAccount{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *UserCreatedAcrAccount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserCreatedAcrAccount)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserCreatedAcrAccount, got %T", armInput)
	}

	// Set property "ArmResourceId":
	if typedInput.ArmResourceId != nil {
		var armResourceId1 ArmResourceId
		err := armResourceId1.PopulateFromARM(owner, *typedInput.ArmResourceId)
		if err != nil {
			return err
		}
		armResourceId := armResourceId1
		account.ArmResourceId = &armResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserCreatedAcrAccount populates our UserCreatedAcrAccount from the provided source UserCreatedAcrAccount
func (account *UserCreatedAcrAccount) AssignProperties_From_UserCreatedAcrAccount(source *storage.UserCreatedAcrAccount) error {

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId
		err := armResourceId.AssignProperties_From_ArmResourceId(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserCreatedAcrAccount populates the provided destination UserCreatedAcrAccount from our UserCreatedAcrAccount
func (account *UserCreatedAcrAccount) AssignProperties_To_UserCreatedAcrAccount(destination *storage.UserCreatedAcrAccount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArmResourceId
	if account.ArmResourceId != nil {
		var armResourceId storage.ArmResourceId
		err := account.ArmResourceId.AssignProperties_To_ArmResourceId(&armResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId() to populate field ArmResourceId")
		}
		destination.ArmResourceId = &armResourceId
	} else {
		destination.ArmResourceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UserCreatedAcrAccount_STATUS populates our UserCreatedAcrAccount from the provided source UserCreatedAcrAccount_STATUS
func (account *UserCreatedAcrAccount) Initialize_From_UserCreatedAcrAccount_STATUS(source *UserCreatedAcrAccount_STATUS) error {

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId
		err := armResourceId.Initialize_From_ArmResourceId_STATUS(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

type UserCreatedAcrAccount_STATUS struct {
	// ArmResourceId: ARM ResourceId of a resource
	ArmResourceId *ArmResourceId_STATUS `json:"armResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserCreatedAcrAccount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *UserCreatedAcrAccount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserCreatedAcrAccount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *UserCreatedAcrAccount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserCreatedAcrAccount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserCreatedAcrAccount_STATUS, got %T", armInput)
	}

	// Set property "ArmResourceId":
	if typedInput.ArmResourceId != nil {
		var armResourceId1 ArmResourceId_STATUS
		err := armResourceId1.PopulateFromARM(owner, *typedInput.ArmResourceId)
		if err != nil {
			return err
		}
		armResourceId := armResourceId1
		account.ArmResourceId = &armResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserCreatedAcrAccount_STATUS populates our UserCreatedAcrAccount_STATUS from the provided source UserCreatedAcrAccount_STATUS
func (account *UserCreatedAcrAccount_STATUS) AssignProperties_From_UserCreatedAcrAccount_STATUS(source *storage.UserCreatedAcrAccount_STATUS) error {

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId_STATUS
		err := armResourceId.AssignProperties_From_ArmResourceId_STATUS(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserCreatedAcrAccount_STATUS populates the provided destination UserCreatedAcrAccount_STATUS from our UserCreatedAcrAccount_STATUS
func (account *UserCreatedAcrAccount_STATUS) AssignProperties_To_UserCreatedAcrAccount_STATUS(destination *storage.UserCreatedAcrAccount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArmResourceId
	if account.ArmResourceId != nil {
		var armResourceId storage.ArmResourceId_STATUS
		err := account.ArmResourceId.AssignProperties_To_ArmResourceId_STATUS(&armResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		destination.ArmResourceId = &armResourceId
	} else {
		destination.ArmResourceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserCreatedStorageAccount struct {
	// ArmResourceId: ARM ResourceId of a resource
	ArmResourceId *ArmResourceId `json:"armResourceId,omitempty"`
}

var _ genruntime.ARMTransformer = &UserCreatedStorageAccount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (account *UserCreatedStorageAccount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if account == nil {
		return nil, nil
	}
	result := &arm.UserCreatedStorageAccount{}

	// Set property "ArmResourceId":
	if account.ArmResourceId != nil {
		armResourceId_ARM, err := (*account.ArmResourceId).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		armResourceId := *armResourceId_ARM.(*arm.ArmResourceId)
		result.ArmResourceId = &armResourceId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *UserCreatedStorageAccount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserCreatedStorageAccount{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *UserCreatedStorageAccount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserCreatedStorageAccount)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserCreatedStorageAccount, got %T", armInput)
	}

	// Set property "ArmResourceId":
	if typedInput.ArmResourceId != nil {
		var armResourceId1 ArmResourceId
		err := armResourceId1.PopulateFromARM(owner, *typedInput.ArmResourceId)
		if err != nil {
			return err
		}
		armResourceId := armResourceId1
		account.ArmResourceId = &armResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserCreatedStorageAccount populates our UserCreatedStorageAccount from the provided source UserCreatedStorageAccount
func (account *UserCreatedStorageAccount) AssignProperties_From_UserCreatedStorageAccount(source *storage.UserCreatedStorageAccount) error {

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId
		err := armResourceId.AssignProperties_From_ArmResourceId(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserCreatedStorageAccount populates the provided destination UserCreatedStorageAccount from our UserCreatedStorageAccount
func (account *UserCreatedStorageAccount) AssignProperties_To_UserCreatedStorageAccount(destination *storage.UserCreatedStorageAccount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArmResourceId
	if account.ArmResourceId != nil {
		var armResourceId storage.ArmResourceId
		err := account.ArmResourceId.AssignProperties_To_ArmResourceId(&armResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId() to populate field ArmResourceId")
		}
		destination.ArmResourceId = &armResourceId
	} else {
		destination.ArmResourceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UserCreatedStorageAccount_STATUS populates our UserCreatedStorageAccount from the provided source UserCreatedStorageAccount_STATUS
func (account *UserCreatedStorageAccount) Initialize_From_UserCreatedStorageAccount_STATUS(source *UserCreatedStorageAccount_STATUS) error {

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId
		err := armResourceId.Initialize_From_ArmResourceId_STATUS(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

type UserCreatedStorageAccount_STATUS struct {
	// ArmResourceId: ARM ResourceId of a resource
	ArmResourceId *ArmResourceId_STATUS `json:"armResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserCreatedStorageAccount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *UserCreatedStorageAccount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserCreatedStorageAccount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *UserCreatedStorageAccount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserCreatedStorageAccount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserCreatedStorageAccount_STATUS, got %T", armInput)
	}

	// Set property "ArmResourceId":
	if typedInput.ArmResourceId != nil {
		var armResourceId1 ArmResourceId_STATUS
		err := armResourceId1.PopulateFromARM(owner, *typedInput.ArmResourceId)
		if err != nil {
			return err
		}
		armResourceId := armResourceId1
		account.ArmResourceId = &armResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserCreatedStorageAccount_STATUS populates our UserCreatedStorageAccount_STATUS from the provided source UserCreatedStorageAccount_STATUS
func (account *UserCreatedStorageAccount_STATUS) AssignProperties_From_UserCreatedStorageAccount_STATUS(source *storage.UserCreatedStorageAccount_STATUS) error {

	// ArmResourceId
	if source.ArmResourceId != nil {
		var armResourceId ArmResourceId_STATUS
		err := armResourceId.AssignProperties_From_ArmResourceId_STATUS(source.ArmResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		account.ArmResourceId = &armResourceId
	} else {
		account.ArmResourceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserCreatedStorageAccount_STATUS populates the provided destination UserCreatedStorageAccount_STATUS from our UserCreatedStorageAccount_STATUS
func (account *UserCreatedStorageAccount_STATUS) AssignProperties_To_UserCreatedStorageAccount_STATUS(destination *storage.UserCreatedStorageAccount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArmResourceId
	if account.ArmResourceId != nil {
		var armResourceId storage.ArmResourceId_STATUS
		err := account.ArmResourceId.AssignProperties_To_ArmResourceId_STATUS(&armResourceId)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ArmResourceId_STATUS() to populate field ArmResourceId")
		}
		destination.ArmResourceId = &armResourceId
	} else {
		destination.ArmResourceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Registry{}, &RegistryList{})
}
