// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/AuthConfigs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}
type AuthConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AuthConfig_Spec   `json:"spec,omitempty"`
	Status            AuthConfig_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &AuthConfig{}

// GetConditions returns the conditions of the resource
func (config *AuthConfig) GetConditions() conditions.Conditions {
	return config.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (config *AuthConfig) SetConditions(conditions conditions.Conditions) {
	config.Status.Conditions = conditions
}

var _ conversion.Convertible = &AuthConfig{}

// ConvertFrom populates our AuthConfig from the provided hub AuthConfig
func (config *AuthConfig) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.AuthConfig)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/AuthConfig but received %T instead", hub)
	}

	return config.AssignProperties_From_AuthConfig(source)
}

// ConvertTo populates the provided hub AuthConfig from our AuthConfig
func (config *AuthConfig) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.AuthConfig)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/AuthConfig but received %T instead", hub)
	}

	return config.AssignProperties_To_AuthConfig(destination)
}

var _ configmaps.Exporter = &AuthConfig{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (config *AuthConfig) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if config.Spec.OperatorSpec == nil {
		return nil
	}
	return config.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &AuthConfig{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (config *AuthConfig) SecretDestinationExpressions() []*core.DestinationExpression {
	if config.Spec.OperatorSpec == nil {
		return nil
	}
	return config.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &AuthConfig{}

// InitializeSpec initializes the spec for this resource from the given status
func (config *AuthConfig) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*AuthConfig_STATUS); ok {
		return config.Spec.Initialize_From_AuthConfig_STATUS(s)
	}

	return fmt.Errorf("expected Status of type AuthConfig_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &AuthConfig{}

// AzureName returns the Azure name of the resource
func (config *AuthConfig) AzureName() string {
	return config.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (config AuthConfig) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (config *AuthConfig) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (config *AuthConfig) GetSpec() genruntime.ConvertibleSpec {
	return &config.Spec
}

// GetStatus returns the status of this resource
func (config *AuthConfig) GetStatus() genruntime.ConvertibleStatus {
	return &config.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (config *AuthConfig) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/containerApps/authConfigs"
func (config *AuthConfig) GetType() string {
	return "Microsoft.App/containerApps/authConfigs"
}

// NewEmptyStatus returns a new empty (blank) status
func (config *AuthConfig) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &AuthConfig_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (config *AuthConfig) Owner() *genruntime.ResourceReference {
	if config.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(config.Spec)
	return config.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (config *AuthConfig) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*AuthConfig_STATUS); ok {
		config.Status = *st
		return nil
	}

	// Convert status to required version
	var st AuthConfig_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	config.Status = st
	return nil
}

// AssignProperties_From_AuthConfig populates our AuthConfig from the provided source AuthConfig
func (config *AuthConfig) AssignProperties_From_AuthConfig(source *storage.AuthConfig) error {

	// ObjectMeta
	config.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec AuthConfig_Spec
	err := spec.AssignProperties_From_AuthConfig_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_AuthConfig_Spec() to populate field Spec")
	}
	config.Spec = spec

	// Status
	var status AuthConfig_STATUS
	err = status.AssignProperties_From_AuthConfig_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_AuthConfig_STATUS() to populate field Status")
	}
	config.Status = status

	// No error
	return nil
}

// AssignProperties_To_AuthConfig populates the provided destination AuthConfig from our AuthConfig
func (config *AuthConfig) AssignProperties_To_AuthConfig(destination *storage.AuthConfig) error {

	// ObjectMeta
	destination.ObjectMeta = *config.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.AuthConfig_Spec
	err := config.Spec.AssignProperties_To_AuthConfig_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_AuthConfig_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.AuthConfig_STATUS
	err = config.Status.AssignProperties_To_AuthConfig_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_AuthConfig_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (config *AuthConfig) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: config.Spec.OriginalVersion(),
		Kind:    "AuthConfig",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/AuthConfigs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}
type AuthConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AuthConfig `json:"items"`
}

// +kubebuilder:validation:Enum={"2024-03-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-03-01")

type AuthConfig_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// EncryptionSettings: The configuration settings of the secrets references of encryption key and signing key for
	// ContainerApp Service Authentication/Authorization.
	EncryptionSettings *EncryptionSettings `json:"encryptionSettings,omitempty"`

	// GlobalValidation: The configuration settings that determines the validation flow of users using  Service
	// Authentication/Authorization.
	GlobalValidation *GlobalValidation `json:"globalValidation,omitempty"`

	// HttpSettings: The configuration settings of the HTTP requests for authentication and authorization requests made against
	// ContainerApp Service Authentication/Authorization.
	HttpSettings *HttpSettings `json:"httpSettings,omitempty"`

	// IdentityProviders: The configuration settings of each of the identity providers used to configure ContainerApp Service
	// Authentication/Authorization.
	IdentityProviders *IdentityProviders `json:"identityProviders,omitempty"`

	// Login: The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
	Login *Login `json:"login,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *AuthConfigOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a app.azure.com/ContainerApp resource
	Owner *genruntime.KnownResourceReference `group:"app.azure.com" json:"owner,omitempty" kind:"ContainerApp"`

	// Platform: The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
	Platform *AuthPlatform `json:"platform,omitempty"`
}

var _ genruntime.ARMTransformer = &AuthConfig_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *AuthConfig_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.AuthConfig_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if config.EncryptionSettings != nil ||
		config.GlobalValidation != nil ||
		config.HttpSettings != nil ||
		config.IdentityProviders != nil ||
		config.Login != nil ||
		config.Platform != nil {
		result.Properties = &arm.ContainerApps_AuthConfig_Properties_Spec{}
	}
	if config.EncryptionSettings != nil {
		encryptionSettings_ARM, err := (*config.EncryptionSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionSettings := *encryptionSettings_ARM.(*arm.EncryptionSettings)
		result.Properties.EncryptionSettings = &encryptionSettings
	}
	if config.GlobalValidation != nil {
		globalValidation_ARM, err := (*config.GlobalValidation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		globalValidation := *globalValidation_ARM.(*arm.GlobalValidation)
		result.Properties.GlobalValidation = &globalValidation
	}
	if config.HttpSettings != nil {
		httpSettings_ARM, err := (*config.HttpSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpSettings := *httpSettings_ARM.(*arm.HttpSettings)
		result.Properties.HttpSettings = &httpSettings
	}
	if config.IdentityProviders != nil {
		identityProviders_ARM, err := (*config.IdentityProviders).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identityProviders := *identityProviders_ARM.(*arm.IdentityProviders)
		result.Properties.IdentityProviders = &identityProviders
	}
	if config.Login != nil {
		login_ARM, err := (*config.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.Login)
		result.Properties.Login = &login
	}
	if config.Platform != nil {
		platform_ARM, err := (*config.Platform).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		platform := *platform_ARM.(*arm.AuthPlatform)
		result.Properties.Platform = &platform
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *AuthConfig_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AuthConfig_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *AuthConfig_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AuthConfig_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AuthConfig_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	config.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "EncryptionSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionSettings != nil {
			var encryptionSettings1 EncryptionSettings
			err := encryptionSettings1.PopulateFromARM(owner, *typedInput.Properties.EncryptionSettings)
			if err != nil {
				return err
			}
			encryptionSettings := encryptionSettings1
			config.EncryptionSettings = &encryptionSettings
		}
	}

	// Set property "GlobalValidation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GlobalValidation != nil {
			var globalValidation1 GlobalValidation
			err := globalValidation1.PopulateFromARM(owner, *typedInput.Properties.GlobalValidation)
			if err != nil {
				return err
			}
			globalValidation := globalValidation1
			config.GlobalValidation = &globalValidation
		}
	}

	// Set property "HttpSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpSettings != nil {
			var httpSettings1 HttpSettings
			err := httpSettings1.PopulateFromARM(owner, *typedInput.Properties.HttpSettings)
			if err != nil {
				return err
			}
			httpSettings := httpSettings1
			config.HttpSettings = &httpSettings
		}
	}

	// Set property "IdentityProviders":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProviders != nil {
			var identityProviders1 IdentityProviders
			err := identityProviders1.PopulateFromARM(owner, *typedInput.Properties.IdentityProviders)
			if err != nil {
				return err
			}
			identityProviders := identityProviders1
			config.IdentityProviders = &identityProviders
		}
	}

	// Set property "Login":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Login != nil {
			var login1 Login
			err := login1.PopulateFromARM(owner, *typedInput.Properties.Login)
			if err != nil {
				return err
			}
			login := login1
			config.Login = &login
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	config.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Platform":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Platform != nil {
			var platform1 AuthPlatform
			err := platform1.PopulateFromARM(owner, *typedInput.Properties.Platform)
			if err != nil {
				return err
			}
			platform := platform1
			config.Platform = &platform
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &AuthConfig_Spec{}

// ConvertSpecFrom populates our AuthConfig_Spec from the provided source
func (config *AuthConfig_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.AuthConfig_Spec)
	if ok {
		// Populate our instance from source
		return config.AssignProperties_From_AuthConfig_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.AuthConfig_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = config.AssignProperties_From_AuthConfig_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our AuthConfig_Spec
func (config *AuthConfig_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.AuthConfig_Spec)
	if ok {
		// Populate destination from our instance
		return config.AssignProperties_To_AuthConfig_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AuthConfig_Spec{}
	err := config.AssignProperties_To_AuthConfig_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_AuthConfig_Spec populates our AuthConfig_Spec from the provided source AuthConfig_Spec
func (config *AuthConfig_Spec) AssignProperties_From_AuthConfig_Spec(source *storage.AuthConfig_Spec) error {

	// AzureName
	config.AzureName = source.AzureName

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting EncryptionSettings
		err := encryptionSetting.AssignProperties_From_EncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionSettings() to populate field EncryptionSettings")
		}
		config.EncryptionSettings = &encryptionSetting
	} else {
		config.EncryptionSettings = nil
	}

	// GlobalValidation
	if source.GlobalValidation != nil {
		var globalValidation GlobalValidation
		err := globalValidation.AssignProperties_From_GlobalValidation(source.GlobalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GlobalValidation() to populate field GlobalValidation")
		}
		config.GlobalValidation = &globalValidation
	} else {
		config.GlobalValidation = nil
	}

	// HttpSettings
	if source.HttpSettings != nil {
		var httpSetting HttpSettings
		err := httpSetting.AssignProperties_From_HttpSettings(source.HttpSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettings() to populate field HttpSettings")
		}
		config.HttpSettings = &httpSetting
	} else {
		config.HttpSettings = nil
	}

	// IdentityProviders
	if source.IdentityProviders != nil {
		var identityProvider IdentityProviders
		err := identityProvider.AssignProperties_From_IdentityProviders(source.IdentityProviders)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IdentityProviders() to populate field IdentityProviders")
		}
		config.IdentityProviders = &identityProvider
	} else {
		config.IdentityProviders = nil
	}

	// Login
	if source.Login != nil {
		var login Login
		err := login.AssignProperties_From_Login(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Login() to populate field Login")
		}
		config.Login = &login
	} else {
		config.Login = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec AuthConfigOperatorSpec
		err := operatorSpec.AssignProperties_From_AuthConfigOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AuthConfigOperatorSpec() to populate field OperatorSpec")
		}
		config.OperatorSpec = &operatorSpec
	} else {
		config.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		config.Owner = &owner
	} else {
		config.Owner = nil
	}

	// Platform
	if source.Platform != nil {
		var platform AuthPlatform
		err := platform.AssignProperties_From_AuthPlatform(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AuthPlatform() to populate field Platform")
		}
		config.Platform = &platform
	} else {
		config.Platform = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AuthConfig_Spec populates the provided destination AuthConfig_Spec from our AuthConfig_Spec
func (config *AuthConfig_Spec) AssignProperties_To_AuthConfig_Spec(destination *storage.AuthConfig_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = config.AzureName

	// EncryptionSettings
	if config.EncryptionSettings != nil {
		var encryptionSetting storage.EncryptionSettings
		err := config.EncryptionSettings.AssignProperties_To_EncryptionSettings(&encryptionSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// GlobalValidation
	if config.GlobalValidation != nil {
		var globalValidation storage.GlobalValidation
		err := config.GlobalValidation.AssignProperties_To_GlobalValidation(&globalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GlobalValidation() to populate field GlobalValidation")
		}
		destination.GlobalValidation = &globalValidation
	} else {
		destination.GlobalValidation = nil
	}

	// HttpSettings
	if config.HttpSettings != nil {
		var httpSetting storage.HttpSettings
		err := config.HttpSettings.AssignProperties_To_HttpSettings(&httpSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettings() to populate field HttpSettings")
		}
		destination.HttpSettings = &httpSetting
	} else {
		destination.HttpSettings = nil
	}

	// IdentityProviders
	if config.IdentityProviders != nil {
		var identityProvider storage.IdentityProviders
		err := config.IdentityProviders.AssignProperties_To_IdentityProviders(&identityProvider)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IdentityProviders() to populate field IdentityProviders")
		}
		destination.IdentityProviders = &identityProvider
	} else {
		destination.IdentityProviders = nil
	}

	// Login
	if config.Login != nil {
		var login storage.Login
		err := config.Login.AssignProperties_To_Login(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Login() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// OperatorSpec
	if config.OperatorSpec != nil {
		var operatorSpec storage.AuthConfigOperatorSpec
		err := config.OperatorSpec.AssignProperties_To_AuthConfigOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AuthConfigOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = config.OriginalVersion()

	// Owner
	if config.Owner != nil {
		owner := config.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Platform
	if config.Platform != nil {
		var platform storage.AuthPlatform
		err := config.Platform.AssignProperties_To_AuthPlatform(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AuthPlatform() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AuthConfig_STATUS populates our AuthConfig_Spec from the provided source AuthConfig_STATUS
func (config *AuthConfig_Spec) Initialize_From_AuthConfig_STATUS(source *AuthConfig_STATUS) error {

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting EncryptionSettings
		err := encryptionSetting.Initialize_From_EncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		config.EncryptionSettings = &encryptionSetting
	} else {
		config.EncryptionSettings = nil
	}

	// GlobalValidation
	if source.GlobalValidation != nil {
		var globalValidation GlobalValidation
		err := globalValidation.Initialize_From_GlobalValidation_STATUS(source.GlobalValidation)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_GlobalValidation_STATUS() to populate field GlobalValidation")
		}
		config.GlobalValidation = &globalValidation
	} else {
		config.GlobalValidation = nil
	}

	// HttpSettings
	if source.HttpSettings != nil {
		var httpSetting HttpSettings
		err := httpSetting.Initialize_From_HttpSettings_STATUS(source.HttpSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_HttpSettings_STATUS() to populate field HttpSettings")
		}
		config.HttpSettings = &httpSetting
	} else {
		config.HttpSettings = nil
	}

	// IdentityProviders
	if source.IdentityProviders != nil {
		var identityProvider IdentityProviders
		err := identityProvider.Initialize_From_IdentityProviders_STATUS(source.IdentityProviders)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_IdentityProviders_STATUS() to populate field IdentityProviders")
		}
		config.IdentityProviders = &identityProvider
	} else {
		config.IdentityProviders = nil
	}

	// Login
	if source.Login != nil {
		var login Login
		err := login.Initialize_From_Login_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Login_STATUS() to populate field Login")
		}
		config.Login = &login
	} else {
		config.Login = nil
	}

	// Platform
	if source.Platform != nil {
		var platform AuthPlatform
		err := platform.Initialize_From_AuthPlatform_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AuthPlatform_STATUS() to populate field Platform")
		}
		config.Platform = &platform
	} else {
		config.Platform = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (config *AuthConfig_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (config *AuthConfig_Spec) SetAzureName(azureName string) { config.AzureName = azureName }

type AuthConfig_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// EncryptionSettings: The configuration settings of the secrets references of encryption key and signing key for
	// ContainerApp Service Authentication/Authorization.
	EncryptionSettings *EncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`

	// GlobalValidation: The configuration settings that determines the validation flow of users using  Service
	// Authentication/Authorization.
	GlobalValidation *GlobalValidation_STATUS `json:"globalValidation,omitempty"`

	// HttpSettings: The configuration settings of the HTTP requests for authentication and authorization requests made against
	// ContainerApp Service Authentication/Authorization.
	HttpSettings *HttpSettings_STATUS `json:"httpSettings,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// IdentityProviders: The configuration settings of each of the identity providers used to configure ContainerApp Service
	// Authentication/Authorization.
	IdentityProviders *IdentityProviders_STATUS `json:"identityProviders,omitempty"`

	// Login: The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
	Login *Login_STATUS `json:"login,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Platform: The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
	Platform *AuthPlatform_STATUS `json:"platform,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &AuthConfig_STATUS{}

// ConvertStatusFrom populates our AuthConfig_STATUS from the provided source
func (config *AuthConfig_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.AuthConfig_STATUS)
	if ok {
		// Populate our instance from source
		return config.AssignProperties_From_AuthConfig_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.AuthConfig_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = config.AssignProperties_From_AuthConfig_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our AuthConfig_STATUS
func (config *AuthConfig_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.AuthConfig_STATUS)
	if ok {
		// Populate destination from our instance
		return config.AssignProperties_To_AuthConfig_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AuthConfig_STATUS{}
	err := config.AssignProperties_To_AuthConfig_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &AuthConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *AuthConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AuthConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *AuthConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AuthConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AuthConfig_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "EncryptionSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionSettings != nil {
			var encryptionSettings1 EncryptionSettings_STATUS
			err := encryptionSettings1.PopulateFromARM(owner, *typedInput.Properties.EncryptionSettings)
			if err != nil {
				return err
			}
			encryptionSettings := encryptionSettings1
			config.EncryptionSettings = &encryptionSettings
		}
	}

	// Set property "GlobalValidation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GlobalValidation != nil {
			var globalValidation1 GlobalValidation_STATUS
			err := globalValidation1.PopulateFromARM(owner, *typedInput.Properties.GlobalValidation)
			if err != nil {
				return err
			}
			globalValidation := globalValidation1
			config.GlobalValidation = &globalValidation
		}
	}

	// Set property "HttpSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpSettings != nil {
			var httpSettings1 HttpSettings_STATUS
			err := httpSettings1.PopulateFromARM(owner, *typedInput.Properties.HttpSettings)
			if err != nil {
				return err
			}
			httpSettings := httpSettings1
			config.HttpSettings = &httpSettings
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		config.Id = &id
	}

	// Set property "IdentityProviders":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProviders != nil {
			var identityProviders1 IdentityProviders_STATUS
			err := identityProviders1.PopulateFromARM(owner, *typedInput.Properties.IdentityProviders)
			if err != nil {
				return err
			}
			identityProviders := identityProviders1
			config.IdentityProviders = &identityProviders
		}
	}

	// Set property "Login":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Login != nil {
			var login1 Login_STATUS
			err := login1.PopulateFromARM(owner, *typedInput.Properties.Login)
			if err != nil {
				return err
			}
			login := login1
			config.Login = &login
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		config.Name = &name
	}

	// Set property "Platform":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Platform != nil {
			var platform1 AuthPlatform_STATUS
			err := platform1.PopulateFromARM(owner, *typedInput.Properties.Platform)
			if err != nil {
				return err
			}
			platform := platform1
			config.Platform = &platform
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		config.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		config.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AuthConfig_STATUS populates our AuthConfig_STATUS from the provided source AuthConfig_STATUS
func (config *AuthConfig_STATUS) AssignProperties_From_AuthConfig_STATUS(source *storage.AuthConfig_STATUS) error {

	// Conditions
	config.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting EncryptionSettings_STATUS
		err := encryptionSetting.AssignProperties_From_EncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		config.EncryptionSettings = &encryptionSetting
	} else {
		config.EncryptionSettings = nil
	}

	// GlobalValidation
	if source.GlobalValidation != nil {
		var globalValidation GlobalValidation_STATUS
		err := globalValidation.AssignProperties_From_GlobalValidation_STATUS(source.GlobalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GlobalValidation_STATUS() to populate field GlobalValidation")
		}
		config.GlobalValidation = &globalValidation
	} else {
		config.GlobalValidation = nil
	}

	// HttpSettings
	if source.HttpSettings != nil {
		var httpSetting HttpSettings_STATUS
		err := httpSetting.AssignProperties_From_HttpSettings_STATUS(source.HttpSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettings_STATUS() to populate field HttpSettings")
		}
		config.HttpSettings = &httpSetting
	} else {
		config.HttpSettings = nil
	}

	// Id
	config.Id = genruntime.ClonePointerToString(source.Id)

	// IdentityProviders
	if source.IdentityProviders != nil {
		var identityProvider IdentityProviders_STATUS
		err := identityProvider.AssignProperties_From_IdentityProviders_STATUS(source.IdentityProviders)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IdentityProviders_STATUS() to populate field IdentityProviders")
		}
		config.IdentityProviders = &identityProvider
	} else {
		config.IdentityProviders = nil
	}

	// Login
	if source.Login != nil {
		var login Login_STATUS
		err := login.AssignProperties_From_Login_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Login_STATUS() to populate field Login")
		}
		config.Login = &login
	} else {
		config.Login = nil
	}

	// Name
	config.Name = genruntime.ClonePointerToString(source.Name)

	// Platform
	if source.Platform != nil {
		var platform AuthPlatform_STATUS
		err := platform.AssignProperties_From_AuthPlatform_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AuthPlatform_STATUS() to populate field Platform")
		}
		config.Platform = &platform
	} else {
		config.Platform = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		config.SystemData = &systemDatum
	} else {
		config.SystemData = nil
	}

	// Type
	config.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_AuthConfig_STATUS populates the provided destination AuthConfig_STATUS from our AuthConfig_STATUS
func (config *AuthConfig_STATUS) AssignProperties_To_AuthConfig_STATUS(destination *storage.AuthConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(config.Conditions)

	// EncryptionSettings
	if config.EncryptionSettings != nil {
		var encryptionSetting storage.EncryptionSettings_STATUS
		err := config.EncryptionSettings.AssignProperties_To_EncryptionSettings_STATUS(&encryptionSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// GlobalValidation
	if config.GlobalValidation != nil {
		var globalValidation storage.GlobalValidation_STATUS
		err := config.GlobalValidation.AssignProperties_To_GlobalValidation_STATUS(&globalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GlobalValidation_STATUS() to populate field GlobalValidation")
		}
		destination.GlobalValidation = &globalValidation
	} else {
		destination.GlobalValidation = nil
	}

	// HttpSettings
	if config.HttpSettings != nil {
		var httpSetting storage.HttpSettings_STATUS
		err := config.HttpSettings.AssignProperties_To_HttpSettings_STATUS(&httpSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettings_STATUS() to populate field HttpSettings")
		}
		destination.HttpSettings = &httpSetting
	} else {
		destination.HttpSettings = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(config.Id)

	// IdentityProviders
	if config.IdentityProviders != nil {
		var identityProvider storage.IdentityProviders_STATUS
		err := config.IdentityProviders.AssignProperties_To_IdentityProviders_STATUS(&identityProvider)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IdentityProviders_STATUS() to populate field IdentityProviders")
		}
		destination.IdentityProviders = &identityProvider
	} else {
		destination.IdentityProviders = nil
	}

	// Login
	if config.Login != nil {
		var login storage.Login_STATUS
		err := config.Login.AssignProperties_To_Login_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Login_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(config.Name)

	// Platform
	if config.Platform != nil {
		var platform storage.AuthPlatform_STATUS
		err := config.Platform.AssignProperties_To_AuthPlatform_STATUS(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AuthPlatform_STATUS() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// SystemData
	if config.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := config.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(config.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type AuthConfigOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_AuthConfigOperatorSpec populates our AuthConfigOperatorSpec from the provided source AuthConfigOperatorSpec
func (operator *AuthConfigOperatorSpec) AssignProperties_From_AuthConfigOperatorSpec(source *storage.AuthConfigOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AuthConfigOperatorSpec populates the provided destination AuthConfigOperatorSpec from our AuthConfigOperatorSpec
func (operator *AuthConfigOperatorSpec) AssignProperties_To_AuthConfigOperatorSpec(destination *storage.AuthConfigOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
type AuthPlatform struct {
	// Enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise,
	// <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// RuntimeVersion: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
	// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &AuthPlatform{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (platform *AuthPlatform) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if platform == nil {
		return nil, nil
	}
	result := &arm.AuthPlatform{}

	// Set property "Enabled":
	if platform.Enabled != nil {
		enabled := *platform.Enabled
		result.Enabled = &enabled
	}

	// Set property "RuntimeVersion":
	if platform.RuntimeVersion != nil {
		runtimeVersion := *platform.RuntimeVersion
		result.RuntimeVersion = &runtimeVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (platform *AuthPlatform) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AuthPlatform{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (platform *AuthPlatform) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AuthPlatform)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AuthPlatform, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		platform.Enabled = &enabled
	}

	// Set property "RuntimeVersion":
	if typedInput.RuntimeVersion != nil {
		runtimeVersion := *typedInput.RuntimeVersion
		platform.RuntimeVersion = &runtimeVersion
	}

	// No error
	return nil
}

// AssignProperties_From_AuthPlatform populates our AuthPlatform from the provided source AuthPlatform
func (platform *AuthPlatform) AssignProperties_From_AuthPlatform(source *storage.AuthPlatform) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		platform.Enabled = &enabled
	} else {
		platform.Enabled = nil
	}

	// RuntimeVersion
	platform.RuntimeVersion = genruntime.ClonePointerToString(source.RuntimeVersion)

	// No error
	return nil
}

// AssignProperties_To_AuthPlatform populates the provided destination AuthPlatform from our AuthPlatform
func (platform *AuthPlatform) AssignProperties_To_AuthPlatform(destination *storage.AuthPlatform) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if platform.Enabled != nil {
		enabled := *platform.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RuntimeVersion
	destination.RuntimeVersion = genruntime.ClonePointerToString(platform.RuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AuthPlatform_STATUS populates our AuthPlatform from the provided source AuthPlatform_STATUS
func (platform *AuthPlatform) Initialize_From_AuthPlatform_STATUS(source *AuthPlatform_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		platform.Enabled = &enabled
	} else {
		platform.Enabled = nil
	}

	// RuntimeVersion
	platform.RuntimeVersion = genruntime.ClonePointerToString(source.RuntimeVersion)

	// No error
	return nil
}

// The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
type AuthPlatform_STATUS struct {
	// Enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise,
	// <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// RuntimeVersion: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
	// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
	RuntimeVersion *string `json:"runtimeVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &AuthPlatform_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (platform *AuthPlatform_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AuthPlatform_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (platform *AuthPlatform_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AuthPlatform_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AuthPlatform_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		platform.Enabled = &enabled
	}

	// Set property "RuntimeVersion":
	if typedInput.RuntimeVersion != nil {
		runtimeVersion := *typedInput.RuntimeVersion
		platform.RuntimeVersion = &runtimeVersion
	}

	// No error
	return nil
}

// AssignProperties_From_AuthPlatform_STATUS populates our AuthPlatform_STATUS from the provided source AuthPlatform_STATUS
func (platform *AuthPlatform_STATUS) AssignProperties_From_AuthPlatform_STATUS(source *storage.AuthPlatform_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		platform.Enabled = &enabled
	} else {
		platform.Enabled = nil
	}

	// RuntimeVersion
	platform.RuntimeVersion = genruntime.ClonePointerToString(source.RuntimeVersion)

	// No error
	return nil
}

// AssignProperties_To_AuthPlatform_STATUS populates the provided destination AuthPlatform_STATUS from our AuthPlatform_STATUS
func (platform *AuthPlatform_STATUS) AssignProperties_To_AuthPlatform_STATUS(destination *storage.AuthPlatform_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if platform.Enabled != nil {
		enabled := *platform.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RuntimeVersion
	destination.RuntimeVersion = genruntime.ClonePointerToString(platform.RuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service
// Authentication/Authorization.
type EncryptionSettings struct {
	// ContainerAppAuthEncryptionSecretName: The secret name which is referenced for EncryptionKey.
	ContainerAppAuthEncryptionSecretName *string `json:"containerAppAuthEncryptionSecretName,omitempty"`

	// ContainerAppAuthSigningSecretName: The secret name which is referenced for SigningKey.
	ContainerAppAuthSigningSecretName *string `json:"containerAppAuthSigningSecretName,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *EncryptionSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.EncryptionSettings{}

	// Set property "ContainerAppAuthEncryptionSecretName":
	if settings.ContainerAppAuthEncryptionSecretName != nil {
		containerAppAuthEncryptionSecretName := *settings.ContainerAppAuthEncryptionSecretName
		result.ContainerAppAuthEncryptionSecretName = &containerAppAuthEncryptionSecretName
	}

	// Set property "ContainerAppAuthSigningSecretName":
	if settings.ContainerAppAuthSigningSecretName != nil {
		containerAppAuthSigningSecretName := *settings.ContainerAppAuthSigningSecretName
		result.ContainerAppAuthSigningSecretName = &containerAppAuthSigningSecretName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *EncryptionSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *EncryptionSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionSettings, got %T", armInput)
	}

	// Set property "ContainerAppAuthEncryptionSecretName":
	if typedInput.ContainerAppAuthEncryptionSecretName != nil {
		containerAppAuthEncryptionSecretName := *typedInput.ContainerAppAuthEncryptionSecretName
		settings.ContainerAppAuthEncryptionSecretName = &containerAppAuthEncryptionSecretName
	}

	// Set property "ContainerAppAuthSigningSecretName":
	if typedInput.ContainerAppAuthSigningSecretName != nil {
		containerAppAuthSigningSecretName := *typedInput.ContainerAppAuthSigningSecretName
		settings.ContainerAppAuthSigningSecretName = &containerAppAuthSigningSecretName
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionSettings populates our EncryptionSettings from the provided source EncryptionSettings
func (settings *EncryptionSettings) AssignProperties_From_EncryptionSettings(source *storage.EncryptionSettings) error {

	// ContainerAppAuthEncryptionSecretName
	settings.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	settings.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthSigningSecretName)

	// No error
	return nil
}

// AssignProperties_To_EncryptionSettings populates the provided destination EncryptionSettings from our EncryptionSettings
func (settings *EncryptionSettings) AssignProperties_To_EncryptionSettings(destination *storage.EncryptionSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainerAppAuthEncryptionSecretName
	destination.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	destination.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthSigningSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionSettings_STATUS populates our EncryptionSettings from the provided source EncryptionSettings_STATUS
func (settings *EncryptionSettings) Initialize_From_EncryptionSettings_STATUS(source *EncryptionSettings_STATUS) error {

	// ContainerAppAuthEncryptionSecretName
	settings.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	settings.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthSigningSecretName)

	// No error
	return nil
}

// The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service
// Authentication/Authorization.
type EncryptionSettings_STATUS struct {
	// ContainerAppAuthEncryptionSecretName: The secret name which is referenced for EncryptionKey.
	ContainerAppAuthEncryptionSecretName *string `json:"containerAppAuthEncryptionSecretName,omitempty"`

	// ContainerAppAuthSigningSecretName: The secret name which is referenced for SigningKey.
	ContainerAppAuthSigningSecretName *string `json:"containerAppAuthSigningSecretName,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *EncryptionSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *EncryptionSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionSettings_STATUS, got %T", armInput)
	}

	// Set property "ContainerAppAuthEncryptionSecretName":
	if typedInput.ContainerAppAuthEncryptionSecretName != nil {
		containerAppAuthEncryptionSecretName := *typedInput.ContainerAppAuthEncryptionSecretName
		settings.ContainerAppAuthEncryptionSecretName = &containerAppAuthEncryptionSecretName
	}

	// Set property "ContainerAppAuthSigningSecretName":
	if typedInput.ContainerAppAuthSigningSecretName != nil {
		containerAppAuthSigningSecretName := *typedInput.ContainerAppAuthSigningSecretName
		settings.ContainerAppAuthSigningSecretName = &containerAppAuthSigningSecretName
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionSettings_STATUS populates our EncryptionSettings_STATUS from the provided source EncryptionSettings_STATUS
func (settings *EncryptionSettings_STATUS) AssignProperties_From_EncryptionSettings_STATUS(source *storage.EncryptionSettings_STATUS) error {

	// ContainerAppAuthEncryptionSecretName
	settings.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	settings.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthSigningSecretName)

	// No error
	return nil
}

// AssignProperties_To_EncryptionSettings_STATUS populates the provided destination EncryptionSettings_STATUS from our EncryptionSettings_STATUS
func (settings *EncryptionSettings_STATUS) AssignProperties_To_EncryptionSettings_STATUS(destination *storage.EncryptionSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainerAppAuthEncryptionSecretName
	destination.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	destination.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthSigningSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings that determines the validation flow of users using ContainerApp Service
// Authentication/Authorization.
type GlobalValidation struct {
	// ExcludedPaths: The paths for which unauthenticated flow would not be redirected to the login page.
	ExcludedPaths []string `json:"excludedPaths,omitempty"`

	// RedirectToProvider: The default authentication provider to use when multiple providers are configured.
	// This setting is only needed if multiple providers are configured and the unauthenticated client
	// action is set to "RedirectToLoginPage".
	RedirectToProvider *string `json:"redirectToProvider,omitempty"`

	// UnauthenticatedClientAction: The action to take when an unauthenticated client attempts to access the app.
	UnauthenticatedClientAction *GlobalValidation_UnauthenticatedClientAction `json:"unauthenticatedClientAction,omitempty"`
}

var _ genruntime.ARMTransformer = &GlobalValidation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (validation *GlobalValidation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if validation == nil {
		return nil, nil
	}
	result := &arm.GlobalValidation{}

	// Set property "ExcludedPaths":
	for _, item := range validation.ExcludedPaths {
		result.ExcludedPaths = append(result.ExcludedPaths, item)
	}

	// Set property "RedirectToProvider":
	if validation.RedirectToProvider != nil {
		redirectToProvider := *validation.RedirectToProvider
		result.RedirectToProvider = &redirectToProvider
	}

	// Set property "UnauthenticatedClientAction":
	if validation.UnauthenticatedClientAction != nil {
		var temp string
		temp = string(*validation.UnauthenticatedClientAction)
		unauthenticatedClientAction := arm.GlobalValidation_UnauthenticatedClientAction(temp)
		result.UnauthenticatedClientAction = &unauthenticatedClientAction
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (validation *GlobalValidation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GlobalValidation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (validation *GlobalValidation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GlobalValidation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GlobalValidation, got %T", armInput)
	}

	// Set property "ExcludedPaths":
	for _, item := range typedInput.ExcludedPaths {
		validation.ExcludedPaths = append(validation.ExcludedPaths, item)
	}

	// Set property "RedirectToProvider":
	if typedInput.RedirectToProvider != nil {
		redirectToProvider := *typedInput.RedirectToProvider
		validation.RedirectToProvider = &redirectToProvider
	}

	// Set property "UnauthenticatedClientAction":
	if typedInput.UnauthenticatedClientAction != nil {
		var temp string
		temp = string(*typedInput.UnauthenticatedClientAction)
		unauthenticatedClientAction := GlobalValidation_UnauthenticatedClientAction(temp)
		validation.UnauthenticatedClientAction = &unauthenticatedClientAction
	}

	// No error
	return nil
}

// AssignProperties_From_GlobalValidation populates our GlobalValidation from the provided source GlobalValidation
func (validation *GlobalValidation) AssignProperties_From_GlobalValidation(source *storage.GlobalValidation) error {

	// ExcludedPaths
	validation.ExcludedPaths = genruntime.CloneSliceOfString(source.ExcludedPaths)

	// RedirectToProvider
	validation.RedirectToProvider = genruntime.ClonePointerToString(source.RedirectToProvider)

	// UnauthenticatedClientAction
	if source.UnauthenticatedClientAction != nil {
		unauthenticatedClientAction := *source.UnauthenticatedClientAction
		unauthenticatedClientActionTemp := genruntime.ToEnum(unauthenticatedClientAction, globalValidation_UnauthenticatedClientAction_Values)
		validation.UnauthenticatedClientAction = &unauthenticatedClientActionTemp
	} else {
		validation.UnauthenticatedClientAction = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GlobalValidation populates the provided destination GlobalValidation from our GlobalValidation
func (validation *GlobalValidation) AssignProperties_To_GlobalValidation(destination *storage.GlobalValidation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExcludedPaths
	destination.ExcludedPaths = genruntime.CloneSliceOfString(validation.ExcludedPaths)

	// RedirectToProvider
	destination.RedirectToProvider = genruntime.ClonePointerToString(validation.RedirectToProvider)

	// UnauthenticatedClientAction
	if validation.UnauthenticatedClientAction != nil {
		unauthenticatedClientAction := string(*validation.UnauthenticatedClientAction)
		destination.UnauthenticatedClientAction = &unauthenticatedClientAction
	} else {
		destination.UnauthenticatedClientAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GlobalValidation_STATUS populates our GlobalValidation from the provided source GlobalValidation_STATUS
func (validation *GlobalValidation) Initialize_From_GlobalValidation_STATUS(source *GlobalValidation_STATUS) error {

	// ExcludedPaths
	validation.ExcludedPaths = genruntime.CloneSliceOfString(source.ExcludedPaths)

	// RedirectToProvider
	validation.RedirectToProvider = genruntime.ClonePointerToString(source.RedirectToProvider)

	// UnauthenticatedClientAction
	if source.UnauthenticatedClientAction != nil {
		unauthenticatedClientAction := genruntime.ToEnum(string(*source.UnauthenticatedClientAction), globalValidation_UnauthenticatedClientAction_Values)
		validation.UnauthenticatedClientAction = &unauthenticatedClientAction
	} else {
		validation.UnauthenticatedClientAction = nil
	}

	// No error
	return nil
}

// The configuration settings that determines the validation flow of users using ContainerApp Service
// Authentication/Authorization.
type GlobalValidation_STATUS struct {
	// ExcludedPaths: The paths for which unauthenticated flow would not be redirected to the login page.
	ExcludedPaths []string `json:"excludedPaths,omitempty"`

	// RedirectToProvider: The default authentication provider to use when multiple providers are configured.
	// This setting is only needed if multiple providers are configured and the unauthenticated client
	// action is set to "RedirectToLoginPage".
	RedirectToProvider *string `json:"redirectToProvider,omitempty"`

	// UnauthenticatedClientAction: The action to take when an unauthenticated client attempts to access the app.
	UnauthenticatedClientAction *GlobalValidation_UnauthenticatedClientAction_STATUS `json:"unauthenticatedClientAction,omitempty"`
}

var _ genruntime.FromARMConverter = &GlobalValidation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (validation *GlobalValidation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GlobalValidation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (validation *GlobalValidation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GlobalValidation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GlobalValidation_STATUS, got %T", armInput)
	}

	// Set property "ExcludedPaths":
	for _, item := range typedInput.ExcludedPaths {
		validation.ExcludedPaths = append(validation.ExcludedPaths, item)
	}

	// Set property "RedirectToProvider":
	if typedInput.RedirectToProvider != nil {
		redirectToProvider := *typedInput.RedirectToProvider
		validation.RedirectToProvider = &redirectToProvider
	}

	// Set property "UnauthenticatedClientAction":
	if typedInput.UnauthenticatedClientAction != nil {
		var temp string
		temp = string(*typedInput.UnauthenticatedClientAction)
		unauthenticatedClientAction := GlobalValidation_UnauthenticatedClientAction_STATUS(temp)
		validation.UnauthenticatedClientAction = &unauthenticatedClientAction
	}

	// No error
	return nil
}

// AssignProperties_From_GlobalValidation_STATUS populates our GlobalValidation_STATUS from the provided source GlobalValidation_STATUS
func (validation *GlobalValidation_STATUS) AssignProperties_From_GlobalValidation_STATUS(source *storage.GlobalValidation_STATUS) error {

	// ExcludedPaths
	validation.ExcludedPaths = genruntime.CloneSliceOfString(source.ExcludedPaths)

	// RedirectToProvider
	validation.RedirectToProvider = genruntime.ClonePointerToString(source.RedirectToProvider)

	// UnauthenticatedClientAction
	if source.UnauthenticatedClientAction != nil {
		unauthenticatedClientAction := *source.UnauthenticatedClientAction
		unauthenticatedClientActionTemp := genruntime.ToEnum(unauthenticatedClientAction, globalValidation_UnauthenticatedClientAction_STATUS_Values)
		validation.UnauthenticatedClientAction = &unauthenticatedClientActionTemp
	} else {
		validation.UnauthenticatedClientAction = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GlobalValidation_STATUS populates the provided destination GlobalValidation_STATUS from our GlobalValidation_STATUS
func (validation *GlobalValidation_STATUS) AssignProperties_To_GlobalValidation_STATUS(destination *storage.GlobalValidation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExcludedPaths
	destination.ExcludedPaths = genruntime.CloneSliceOfString(validation.ExcludedPaths)

	// RedirectToProvider
	destination.RedirectToProvider = genruntime.ClonePointerToString(validation.RedirectToProvider)

	// UnauthenticatedClientAction
	if validation.UnauthenticatedClientAction != nil {
		unauthenticatedClientAction := string(*validation.UnauthenticatedClientAction)
		destination.UnauthenticatedClientAction = &unauthenticatedClientAction
	} else {
		destination.UnauthenticatedClientAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp
// Service Authentication/Authorization.
type HttpSettings struct {
	// ForwardProxy: The configuration settings of a forward proxy used to make the requests.
	ForwardProxy *ForwardProxy `json:"forwardProxy,omitempty"`

	// RequireHttps: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are
	// permissible; otherwise, <code>true</code>.
	RequireHttps *bool `json:"requireHttps,omitempty"`

	// Routes: The configuration settings of the paths HTTP requests.
	Routes *HttpSettingsRoutes `json:"routes,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *HttpSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.HttpSettings{}

	// Set property "ForwardProxy":
	if settings.ForwardProxy != nil {
		forwardProxy_ARM, err := (*settings.ForwardProxy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		forwardProxy := *forwardProxy_ARM.(*arm.ForwardProxy)
		result.ForwardProxy = &forwardProxy
	}

	// Set property "RequireHttps":
	if settings.RequireHttps != nil {
		requireHttps := *settings.RequireHttps
		result.RequireHttps = &requireHttps
	}

	// Set property "Routes":
	if settings.Routes != nil {
		routes_ARM, err := (*settings.Routes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routes := *routes_ARM.(*arm.HttpSettingsRoutes)
		result.Routes = &routes
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *HttpSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *HttpSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpSettings, got %T", armInput)
	}

	// Set property "ForwardProxy":
	if typedInput.ForwardProxy != nil {
		var forwardProxy1 ForwardProxy
		err := forwardProxy1.PopulateFromARM(owner, *typedInput.ForwardProxy)
		if err != nil {
			return err
		}
		forwardProxy := forwardProxy1
		settings.ForwardProxy = &forwardProxy
	}

	// Set property "RequireHttps":
	if typedInput.RequireHttps != nil {
		requireHttps := *typedInput.RequireHttps
		settings.RequireHttps = &requireHttps
	}

	// Set property "Routes":
	if typedInput.Routes != nil {
		var routes1 HttpSettingsRoutes
		err := routes1.PopulateFromARM(owner, *typedInput.Routes)
		if err != nil {
			return err
		}
		routes := routes1
		settings.Routes = &routes
	}

	// No error
	return nil
}

// AssignProperties_From_HttpSettings populates our HttpSettings from the provided source HttpSettings
func (settings *HttpSettings) AssignProperties_From_HttpSettings(source *storage.HttpSettings) error {

	// ForwardProxy
	if source.ForwardProxy != nil {
		var forwardProxy ForwardProxy
		err := forwardProxy.AssignProperties_From_ForwardProxy(source.ForwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ForwardProxy() to populate field ForwardProxy")
		}
		settings.ForwardProxy = &forwardProxy
	} else {
		settings.ForwardProxy = nil
	}

	// RequireHttps
	if source.RequireHttps != nil {
		requireHttpsHTTPS := *source.RequireHttps
		settings.RequireHttps = &requireHttpsHTTPS
	} else {
		settings.RequireHttps = nil
	}

	// Routes
	if source.Routes != nil {
		var route HttpSettingsRoutes
		err := route.AssignProperties_From_HttpSettingsRoutes(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettingsRoutes() to populate field Routes")
		}
		settings.Routes = &route
	} else {
		settings.Routes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpSettings populates the provided destination HttpSettings from our HttpSettings
func (settings *HttpSettings) AssignProperties_To_HttpSettings(destination *storage.HttpSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForwardProxy
	if settings.ForwardProxy != nil {
		var forwardProxy storage.ForwardProxy
		err := settings.ForwardProxy.AssignProperties_To_ForwardProxy(&forwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ForwardProxy() to populate field ForwardProxy")
		}
		destination.ForwardProxy = &forwardProxy
	} else {
		destination.ForwardProxy = nil
	}

	// RequireHttps
	if settings.RequireHttps != nil {
		requireHttpsHTTPS := *settings.RequireHttps
		destination.RequireHttps = &requireHttpsHTTPS
	} else {
		destination.RequireHttps = nil
	}

	// Routes
	if settings.Routes != nil {
		var route storage.HttpSettingsRoutes
		err := settings.Routes.AssignProperties_To_HttpSettingsRoutes(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettingsRoutes() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpSettings_STATUS populates our HttpSettings from the provided source HttpSettings_STATUS
func (settings *HttpSettings) Initialize_From_HttpSettings_STATUS(source *HttpSettings_STATUS) error {

	// ForwardProxy
	if source.ForwardProxy != nil {
		var forwardProxy ForwardProxy
		err := forwardProxy.Initialize_From_ForwardProxy_STATUS(source.ForwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ForwardProxy_STATUS() to populate field ForwardProxy")
		}
		settings.ForwardProxy = &forwardProxy
	} else {
		settings.ForwardProxy = nil
	}

	// RequireHttps
	if source.RequireHttps != nil {
		requireHttpsHTTPS := *source.RequireHttps
		settings.RequireHttps = &requireHttpsHTTPS
	} else {
		settings.RequireHttps = nil
	}

	// Routes
	if source.Routes != nil {
		var route HttpSettingsRoutes
		err := route.Initialize_From_HttpSettingsRoutes_STATUS(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_HttpSettingsRoutes_STATUS() to populate field Routes")
		}
		settings.Routes = &route
	} else {
		settings.Routes = nil
	}

	// No error
	return nil
}

// The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp
// Service Authentication/Authorization.
type HttpSettings_STATUS struct {
	// ForwardProxy: The configuration settings of a forward proxy used to make the requests.
	ForwardProxy *ForwardProxy_STATUS `json:"forwardProxy,omitempty"`

	// RequireHttps: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are
	// permissible; otherwise, <code>true</code>.
	RequireHttps *bool `json:"requireHttps,omitempty"`

	// Routes: The configuration settings of the paths HTTP requests.
	Routes *HttpSettingsRoutes_STATUS `json:"routes,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *HttpSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *HttpSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpSettings_STATUS, got %T", armInput)
	}

	// Set property "ForwardProxy":
	if typedInput.ForwardProxy != nil {
		var forwardProxy1 ForwardProxy_STATUS
		err := forwardProxy1.PopulateFromARM(owner, *typedInput.ForwardProxy)
		if err != nil {
			return err
		}
		forwardProxy := forwardProxy1
		settings.ForwardProxy = &forwardProxy
	}

	// Set property "RequireHttps":
	if typedInput.RequireHttps != nil {
		requireHttps := *typedInput.RequireHttps
		settings.RequireHttps = &requireHttps
	}

	// Set property "Routes":
	if typedInput.Routes != nil {
		var routes1 HttpSettingsRoutes_STATUS
		err := routes1.PopulateFromARM(owner, *typedInput.Routes)
		if err != nil {
			return err
		}
		routes := routes1
		settings.Routes = &routes
	}

	// No error
	return nil
}

// AssignProperties_From_HttpSettings_STATUS populates our HttpSettings_STATUS from the provided source HttpSettings_STATUS
func (settings *HttpSettings_STATUS) AssignProperties_From_HttpSettings_STATUS(source *storage.HttpSettings_STATUS) error {

	// ForwardProxy
	if source.ForwardProxy != nil {
		var forwardProxy ForwardProxy_STATUS
		err := forwardProxy.AssignProperties_From_ForwardProxy_STATUS(source.ForwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ForwardProxy_STATUS() to populate field ForwardProxy")
		}
		settings.ForwardProxy = &forwardProxy
	} else {
		settings.ForwardProxy = nil
	}

	// RequireHttps
	if source.RequireHttps != nil {
		requireHttpsHTTPS := *source.RequireHttps
		settings.RequireHttps = &requireHttpsHTTPS
	} else {
		settings.RequireHttps = nil
	}

	// Routes
	if source.Routes != nil {
		var route HttpSettingsRoutes_STATUS
		err := route.AssignProperties_From_HttpSettingsRoutes_STATUS(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettingsRoutes_STATUS() to populate field Routes")
		}
		settings.Routes = &route
	} else {
		settings.Routes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpSettings_STATUS populates the provided destination HttpSettings_STATUS from our HttpSettings_STATUS
func (settings *HttpSettings_STATUS) AssignProperties_To_HttpSettings_STATUS(destination *storage.HttpSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForwardProxy
	if settings.ForwardProxy != nil {
		var forwardProxy storage.ForwardProxy_STATUS
		err := settings.ForwardProxy.AssignProperties_To_ForwardProxy_STATUS(&forwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ForwardProxy_STATUS() to populate field ForwardProxy")
		}
		destination.ForwardProxy = &forwardProxy
	} else {
		destination.ForwardProxy = nil
	}

	// RequireHttps
	if settings.RequireHttps != nil {
		requireHttpsHTTPS := *settings.RequireHttps
		destination.RequireHttps = &requireHttpsHTTPS
	} else {
		destination.RequireHttps = nil
	}

	// Routes
	if settings.Routes != nil {
		var route storage.HttpSettingsRoutes_STATUS
		err := settings.Routes.AssignProperties_To_HttpSettingsRoutes_STATUS(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettingsRoutes_STATUS() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of each of the identity providers used to configure ContainerApp Service
// Authentication/Authorization.
type IdentityProviders struct {
	// Apple: The configuration settings of the Apple provider.
	Apple *Apple `json:"apple,omitempty"`

	// AzureActiveDirectory: The configuration settings of the Azure Active directory provider.
	AzureActiveDirectory *AzureActiveDirectory `json:"azureActiveDirectory,omitempty"`

	// AzureStaticWebApps: The configuration settings of the Azure Static Web Apps provider.
	AzureStaticWebApps *AzureStaticWebApps `json:"azureStaticWebApps,omitempty"`

	// CustomOpenIdConnectProviders: The map of the name of the alias of each custom Open ID Connect provider to the
	// configuration settings of the custom Open ID Connect provider.
	CustomOpenIdConnectProviders map[string]CustomOpenIdConnectProvider `json:"customOpenIdConnectProviders,omitempty"`

	// Facebook: The configuration settings of the Facebook provider.
	Facebook *Facebook `json:"facebook,omitempty"`

	// GitHub: The configuration settings of the GitHub provider.
	GitHub *GitHub `json:"gitHub,omitempty"`

	// Google: The configuration settings of the Google provider.
	Google *Google `json:"google,omitempty"`

	// Twitter: The configuration settings of the Twitter provider.
	Twitter *Twitter `json:"twitter,omitempty"`
}

var _ genruntime.ARMTransformer = &IdentityProviders{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (providers *IdentityProviders) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if providers == nil {
		return nil, nil
	}
	result := &arm.IdentityProviders{}

	// Set property "Apple":
	if providers.Apple != nil {
		apple_ARM, err := (*providers.Apple).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apple := *apple_ARM.(*arm.Apple)
		result.Apple = &apple
	}

	// Set property "AzureActiveDirectory":
	if providers.AzureActiveDirectory != nil {
		azureActiveDirectory_ARM, err := (*providers.AzureActiveDirectory).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureActiveDirectory := *azureActiveDirectory_ARM.(*arm.AzureActiveDirectory)
		result.AzureActiveDirectory = &azureActiveDirectory
	}

	// Set property "AzureStaticWebApps":
	if providers.AzureStaticWebApps != nil {
		azureStaticWebApps_ARM, err := (*providers.AzureStaticWebApps).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureStaticWebApps := *azureStaticWebApps_ARM.(*arm.AzureStaticWebApps)
		result.AzureStaticWebApps = &azureStaticWebApps
	}

	// Set property "CustomOpenIdConnectProviders":
	if providers.CustomOpenIdConnectProviders != nil {
		result.CustomOpenIdConnectProviders = make(map[string]arm.CustomOpenIdConnectProvider, len(providers.CustomOpenIdConnectProviders))
		for key, value := range providers.CustomOpenIdConnectProviders {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.CustomOpenIdConnectProviders[key] = *value_ARM.(*arm.CustomOpenIdConnectProvider)
		}
	}

	// Set property "Facebook":
	if providers.Facebook != nil {
		facebook_ARM, err := (*providers.Facebook).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		facebook := *facebook_ARM.(*arm.Facebook)
		result.Facebook = &facebook
	}

	// Set property "GitHub":
	if providers.GitHub != nil {
		gitHub_ARM, err := (*providers.GitHub).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gitHub := *gitHub_ARM.(*arm.GitHub)
		result.GitHub = &gitHub
	}

	// Set property "Google":
	if providers.Google != nil {
		google_ARM, err := (*providers.Google).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		google := *google_ARM.(*arm.Google)
		result.Google = &google
	}

	// Set property "Twitter":
	if providers.Twitter != nil {
		twitter_ARM, err := (*providers.Twitter).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		twitter := *twitter_ARM.(*arm.Twitter)
		result.Twitter = &twitter
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (providers *IdentityProviders) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IdentityProviders{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (providers *IdentityProviders) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IdentityProviders)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IdentityProviders, got %T", armInput)
	}

	// Set property "Apple":
	if typedInput.Apple != nil {
		var apple1 Apple
		err := apple1.PopulateFromARM(owner, *typedInput.Apple)
		if err != nil {
			return err
		}
		apple := apple1
		providers.Apple = &apple
	}

	// Set property "AzureActiveDirectory":
	if typedInput.AzureActiveDirectory != nil {
		var azureActiveDirectory1 AzureActiveDirectory
		err := azureActiveDirectory1.PopulateFromARM(owner, *typedInput.AzureActiveDirectory)
		if err != nil {
			return err
		}
		azureActiveDirectory := azureActiveDirectory1
		providers.AzureActiveDirectory = &azureActiveDirectory
	}

	// Set property "AzureStaticWebApps":
	if typedInput.AzureStaticWebApps != nil {
		var azureStaticWebApps1 AzureStaticWebApps
		err := azureStaticWebApps1.PopulateFromARM(owner, *typedInput.AzureStaticWebApps)
		if err != nil {
			return err
		}
		azureStaticWebApps := azureStaticWebApps1
		providers.AzureStaticWebApps = &azureStaticWebApps
	}

	// Set property "CustomOpenIdConnectProviders":
	if typedInput.CustomOpenIdConnectProviders != nil {
		providers.CustomOpenIdConnectProviders = make(map[string]CustomOpenIdConnectProvider, len(typedInput.CustomOpenIdConnectProviders))
		for key, value := range typedInput.CustomOpenIdConnectProviders {
			var value1 CustomOpenIdConnectProvider
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			providers.CustomOpenIdConnectProviders[key] = value1
		}
	}

	// Set property "Facebook":
	if typedInput.Facebook != nil {
		var facebook1 Facebook
		err := facebook1.PopulateFromARM(owner, *typedInput.Facebook)
		if err != nil {
			return err
		}
		facebook := facebook1
		providers.Facebook = &facebook
	}

	// Set property "GitHub":
	if typedInput.GitHub != nil {
		var gitHub1 GitHub
		err := gitHub1.PopulateFromARM(owner, *typedInput.GitHub)
		if err != nil {
			return err
		}
		gitHub := gitHub1
		providers.GitHub = &gitHub
	}

	// Set property "Google":
	if typedInput.Google != nil {
		var google1 Google
		err := google1.PopulateFromARM(owner, *typedInput.Google)
		if err != nil {
			return err
		}
		google := google1
		providers.Google = &google
	}

	// Set property "Twitter":
	if typedInput.Twitter != nil {
		var twitter1 Twitter
		err := twitter1.PopulateFromARM(owner, *typedInput.Twitter)
		if err != nil {
			return err
		}
		twitter := twitter1
		providers.Twitter = &twitter
	}

	// No error
	return nil
}

// AssignProperties_From_IdentityProviders populates our IdentityProviders from the provided source IdentityProviders
func (providers *IdentityProviders) AssignProperties_From_IdentityProviders(source *storage.IdentityProviders) error {

	// Apple
	if source.Apple != nil {
		var apple Apple
		err := apple.AssignProperties_From_Apple(source.Apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Apple() to populate field Apple")
		}
		providers.Apple = &apple
	} else {
		providers.Apple = nil
	}

	// AzureActiveDirectory
	if source.AzureActiveDirectory != nil {
		var azureActiveDirectory AzureActiveDirectory
		err := azureActiveDirectory.AssignProperties_From_AzureActiveDirectory(source.AzureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectory() to populate field AzureActiveDirectory")
		}
		providers.AzureActiveDirectory = &azureActiveDirectory
	} else {
		providers.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if source.AzureStaticWebApps != nil {
		var azureStaticWebApp AzureStaticWebApps
		err := azureStaticWebApp.AssignProperties_From_AzureStaticWebApps(source.AzureStaticWebApps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebApps() to populate field AzureStaticWebApps")
		}
		providers.AzureStaticWebApps = &azureStaticWebApp
	} else {
		providers.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if source.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]CustomOpenIdConnectProvider, len(source.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range source.CustomOpenIdConnectProviders {
			// Shadow the loop variable to avoid aliasing
			customOpenIdConnectProviderValue := customOpenIdConnectProviderValue
			var customOpenIdConnectProvider CustomOpenIdConnectProvider
			err := customOpenIdConnectProvider.AssignProperties_From_CustomOpenIdConnectProvider(&customOpenIdConnectProviderValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomOpenIdConnectProvider() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		providers.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		providers.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if source.Facebook != nil {
		var facebook Facebook
		err := facebook.AssignProperties_From_Facebook(source.Facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Facebook() to populate field Facebook")
		}
		providers.Facebook = &facebook
	} else {
		providers.Facebook = nil
	}

	// GitHub
	if source.GitHub != nil {
		var gitHub GitHub
		err := gitHub.AssignProperties_From_GitHub(source.GitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GitHub() to populate field GitHub")
		}
		providers.GitHub = &gitHub
	} else {
		providers.GitHub = nil
	}

	// Google
	if source.Google != nil {
		var google Google
		err := google.AssignProperties_From_Google(source.Google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Google() to populate field Google")
		}
		providers.Google = &google
	} else {
		providers.Google = nil
	}

	// Twitter
	if source.Twitter != nil {
		var twitter Twitter
		err := twitter.AssignProperties_From_Twitter(source.Twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Twitter() to populate field Twitter")
		}
		providers.Twitter = &twitter
	} else {
		providers.Twitter = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IdentityProviders populates the provided destination IdentityProviders from our IdentityProviders
func (providers *IdentityProviders) AssignProperties_To_IdentityProviders(destination *storage.IdentityProviders) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Apple
	if providers.Apple != nil {
		var apple storage.Apple
		err := providers.Apple.AssignProperties_To_Apple(&apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Apple() to populate field Apple")
		}
		destination.Apple = &apple
	} else {
		destination.Apple = nil
	}

	// AzureActiveDirectory
	if providers.AzureActiveDirectory != nil {
		var azureActiveDirectory storage.AzureActiveDirectory
		err := providers.AzureActiveDirectory.AssignProperties_To_AzureActiveDirectory(&azureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectory() to populate field AzureActiveDirectory")
		}
		destination.AzureActiveDirectory = &azureActiveDirectory
	} else {
		destination.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if providers.AzureStaticWebApps != nil {
		var azureStaticWebApp storage.AzureStaticWebApps
		err := providers.AzureStaticWebApps.AssignProperties_To_AzureStaticWebApps(&azureStaticWebApp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebApps() to populate field AzureStaticWebApps")
		}
		destination.AzureStaticWebApps = &azureStaticWebApp
	} else {
		destination.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if providers.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]storage.CustomOpenIdConnectProvider, len(providers.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range providers.CustomOpenIdConnectProviders {
			// Shadow the loop variable to avoid aliasing
			customOpenIdConnectProviderValue := customOpenIdConnectProviderValue
			var customOpenIdConnectProvider storage.CustomOpenIdConnectProvider
			err := customOpenIdConnectProviderValue.AssignProperties_To_CustomOpenIdConnectProvider(&customOpenIdConnectProvider)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomOpenIdConnectProvider() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		destination.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		destination.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if providers.Facebook != nil {
		var facebook storage.Facebook
		err := providers.Facebook.AssignProperties_To_Facebook(&facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Facebook() to populate field Facebook")
		}
		destination.Facebook = &facebook
	} else {
		destination.Facebook = nil
	}

	// GitHub
	if providers.GitHub != nil {
		var gitHub storage.GitHub
		err := providers.GitHub.AssignProperties_To_GitHub(&gitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GitHub() to populate field GitHub")
		}
		destination.GitHub = &gitHub
	} else {
		destination.GitHub = nil
	}

	// Google
	if providers.Google != nil {
		var google storage.Google
		err := providers.Google.AssignProperties_To_Google(&google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Google() to populate field Google")
		}
		destination.Google = &google
	} else {
		destination.Google = nil
	}

	// Twitter
	if providers.Twitter != nil {
		var twitter storage.Twitter
		err := providers.Twitter.AssignProperties_To_Twitter(&twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Twitter() to populate field Twitter")
		}
		destination.Twitter = &twitter
	} else {
		destination.Twitter = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IdentityProviders_STATUS populates our IdentityProviders from the provided source IdentityProviders_STATUS
func (providers *IdentityProviders) Initialize_From_IdentityProviders_STATUS(source *IdentityProviders_STATUS) error {

	// Apple
	if source.Apple != nil {
		var apple Apple
		err := apple.Initialize_From_Apple_STATUS(source.Apple)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Apple_STATUS() to populate field Apple")
		}
		providers.Apple = &apple
	} else {
		providers.Apple = nil
	}

	// AzureActiveDirectory
	if source.AzureActiveDirectory != nil {
		var azureActiveDirectory AzureActiveDirectory
		err := azureActiveDirectory.Initialize_From_AzureActiveDirectory_STATUS(source.AzureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureActiveDirectory_STATUS() to populate field AzureActiveDirectory")
		}
		providers.AzureActiveDirectory = &azureActiveDirectory
	} else {
		providers.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if source.AzureStaticWebApps != nil {
		var azureStaticWebApp AzureStaticWebApps
		err := azureStaticWebApp.Initialize_From_AzureStaticWebApps_STATUS(source.AzureStaticWebApps)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureStaticWebApps_STATUS() to populate field AzureStaticWebApps")
		}
		providers.AzureStaticWebApps = &azureStaticWebApp
	} else {
		providers.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if source.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]CustomOpenIdConnectProvider, len(source.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range source.CustomOpenIdConnectProviders {
			// Shadow the loop variable to avoid aliasing
			customOpenIdConnectProviderValue := customOpenIdConnectProviderValue
			var customOpenIdConnectProvider CustomOpenIdConnectProvider
			err := customOpenIdConnectProvider.Initialize_From_CustomOpenIdConnectProvider_STATUS(&customOpenIdConnectProviderValue)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_CustomOpenIdConnectProvider_STATUS() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		providers.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		providers.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if source.Facebook != nil {
		var facebook Facebook
		err := facebook.Initialize_From_Facebook_STATUS(source.Facebook)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Facebook_STATUS() to populate field Facebook")
		}
		providers.Facebook = &facebook
	} else {
		providers.Facebook = nil
	}

	// GitHub
	if source.GitHub != nil {
		var gitHub GitHub
		err := gitHub.Initialize_From_GitHub_STATUS(source.GitHub)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_GitHub_STATUS() to populate field GitHub")
		}
		providers.GitHub = &gitHub
	} else {
		providers.GitHub = nil
	}

	// Google
	if source.Google != nil {
		var google Google
		err := google.Initialize_From_Google_STATUS(source.Google)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Google_STATUS() to populate field Google")
		}
		providers.Google = &google
	} else {
		providers.Google = nil
	}

	// Twitter
	if source.Twitter != nil {
		var twitter Twitter
		err := twitter.Initialize_From_Twitter_STATUS(source.Twitter)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Twitter_STATUS() to populate field Twitter")
		}
		providers.Twitter = &twitter
	} else {
		providers.Twitter = nil
	}

	// No error
	return nil
}

// The configuration settings of each of the identity providers used to configure ContainerApp Service
// Authentication/Authorization.
type IdentityProviders_STATUS struct {
	// Apple: The configuration settings of the Apple provider.
	Apple *Apple_STATUS `json:"apple,omitempty"`

	// AzureActiveDirectory: The configuration settings of the Azure Active directory provider.
	AzureActiveDirectory *AzureActiveDirectory_STATUS `json:"azureActiveDirectory,omitempty"`

	// AzureStaticWebApps: The configuration settings of the Azure Static Web Apps provider.
	AzureStaticWebApps *AzureStaticWebApps_STATUS `json:"azureStaticWebApps,omitempty"`

	// CustomOpenIdConnectProviders: The map of the name of the alias of each custom Open ID Connect provider to the
	// configuration settings of the custom Open ID Connect provider.
	CustomOpenIdConnectProviders map[string]CustomOpenIdConnectProvider_STATUS `json:"customOpenIdConnectProviders,omitempty"`

	// Facebook: The configuration settings of the Facebook provider.
	Facebook *Facebook_STATUS `json:"facebook,omitempty"`

	// GitHub: The configuration settings of the GitHub provider.
	GitHub *GitHub_STATUS `json:"gitHub,omitempty"`

	// Google: The configuration settings of the Google provider.
	Google *Google_STATUS `json:"google,omitempty"`

	// Twitter: The configuration settings of the Twitter provider.
	Twitter *Twitter_STATUS `json:"twitter,omitempty"`
}

var _ genruntime.FromARMConverter = &IdentityProviders_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (providers *IdentityProviders_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IdentityProviders_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (providers *IdentityProviders_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IdentityProviders_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IdentityProviders_STATUS, got %T", armInput)
	}

	// Set property "Apple":
	if typedInput.Apple != nil {
		var apple1 Apple_STATUS
		err := apple1.PopulateFromARM(owner, *typedInput.Apple)
		if err != nil {
			return err
		}
		apple := apple1
		providers.Apple = &apple
	}

	// Set property "AzureActiveDirectory":
	if typedInput.AzureActiveDirectory != nil {
		var azureActiveDirectory1 AzureActiveDirectory_STATUS
		err := azureActiveDirectory1.PopulateFromARM(owner, *typedInput.AzureActiveDirectory)
		if err != nil {
			return err
		}
		azureActiveDirectory := azureActiveDirectory1
		providers.AzureActiveDirectory = &azureActiveDirectory
	}

	// Set property "AzureStaticWebApps":
	if typedInput.AzureStaticWebApps != nil {
		var azureStaticWebApps1 AzureStaticWebApps_STATUS
		err := azureStaticWebApps1.PopulateFromARM(owner, *typedInput.AzureStaticWebApps)
		if err != nil {
			return err
		}
		azureStaticWebApps := azureStaticWebApps1
		providers.AzureStaticWebApps = &azureStaticWebApps
	}

	// Set property "CustomOpenIdConnectProviders":
	if typedInput.CustomOpenIdConnectProviders != nil {
		providers.CustomOpenIdConnectProviders = make(map[string]CustomOpenIdConnectProvider_STATUS, len(typedInput.CustomOpenIdConnectProviders))
		for key, value := range typedInput.CustomOpenIdConnectProviders {
			var value1 CustomOpenIdConnectProvider_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			providers.CustomOpenIdConnectProviders[key] = value1
		}
	}

	// Set property "Facebook":
	if typedInput.Facebook != nil {
		var facebook1 Facebook_STATUS
		err := facebook1.PopulateFromARM(owner, *typedInput.Facebook)
		if err != nil {
			return err
		}
		facebook := facebook1
		providers.Facebook = &facebook
	}

	// Set property "GitHub":
	if typedInput.GitHub != nil {
		var gitHub1 GitHub_STATUS
		err := gitHub1.PopulateFromARM(owner, *typedInput.GitHub)
		if err != nil {
			return err
		}
		gitHub := gitHub1
		providers.GitHub = &gitHub
	}

	// Set property "Google":
	if typedInput.Google != nil {
		var google1 Google_STATUS
		err := google1.PopulateFromARM(owner, *typedInput.Google)
		if err != nil {
			return err
		}
		google := google1
		providers.Google = &google
	}

	// Set property "Twitter":
	if typedInput.Twitter != nil {
		var twitter1 Twitter_STATUS
		err := twitter1.PopulateFromARM(owner, *typedInput.Twitter)
		if err != nil {
			return err
		}
		twitter := twitter1
		providers.Twitter = &twitter
	}

	// No error
	return nil
}

// AssignProperties_From_IdentityProviders_STATUS populates our IdentityProviders_STATUS from the provided source IdentityProviders_STATUS
func (providers *IdentityProviders_STATUS) AssignProperties_From_IdentityProviders_STATUS(source *storage.IdentityProviders_STATUS) error {

	// Apple
	if source.Apple != nil {
		var apple Apple_STATUS
		err := apple.AssignProperties_From_Apple_STATUS(source.Apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Apple_STATUS() to populate field Apple")
		}
		providers.Apple = &apple
	} else {
		providers.Apple = nil
	}

	// AzureActiveDirectory
	if source.AzureActiveDirectory != nil {
		var azureActiveDirectory AzureActiveDirectory_STATUS
		err := azureActiveDirectory.AssignProperties_From_AzureActiveDirectory_STATUS(source.AzureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectory_STATUS() to populate field AzureActiveDirectory")
		}
		providers.AzureActiveDirectory = &azureActiveDirectory
	} else {
		providers.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if source.AzureStaticWebApps != nil {
		var azureStaticWebApp AzureStaticWebApps_STATUS
		err := azureStaticWebApp.AssignProperties_From_AzureStaticWebApps_STATUS(source.AzureStaticWebApps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebApps_STATUS() to populate field AzureStaticWebApps")
		}
		providers.AzureStaticWebApps = &azureStaticWebApp
	} else {
		providers.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if source.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]CustomOpenIdConnectProvider_STATUS, len(source.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range source.CustomOpenIdConnectProviders {
			// Shadow the loop variable to avoid aliasing
			customOpenIdConnectProviderValue := customOpenIdConnectProviderValue
			var customOpenIdConnectProvider CustomOpenIdConnectProvider_STATUS
			err := customOpenIdConnectProvider.AssignProperties_From_CustomOpenIdConnectProvider_STATUS(&customOpenIdConnectProviderValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomOpenIdConnectProvider_STATUS() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		providers.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		providers.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if source.Facebook != nil {
		var facebook Facebook_STATUS
		err := facebook.AssignProperties_From_Facebook_STATUS(source.Facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Facebook_STATUS() to populate field Facebook")
		}
		providers.Facebook = &facebook
	} else {
		providers.Facebook = nil
	}

	// GitHub
	if source.GitHub != nil {
		var gitHub GitHub_STATUS
		err := gitHub.AssignProperties_From_GitHub_STATUS(source.GitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GitHub_STATUS() to populate field GitHub")
		}
		providers.GitHub = &gitHub
	} else {
		providers.GitHub = nil
	}

	// Google
	if source.Google != nil {
		var google Google_STATUS
		err := google.AssignProperties_From_Google_STATUS(source.Google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Google_STATUS() to populate field Google")
		}
		providers.Google = &google
	} else {
		providers.Google = nil
	}

	// Twitter
	if source.Twitter != nil {
		var twitter Twitter_STATUS
		err := twitter.AssignProperties_From_Twitter_STATUS(source.Twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Twitter_STATUS() to populate field Twitter")
		}
		providers.Twitter = &twitter
	} else {
		providers.Twitter = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IdentityProviders_STATUS populates the provided destination IdentityProviders_STATUS from our IdentityProviders_STATUS
func (providers *IdentityProviders_STATUS) AssignProperties_To_IdentityProviders_STATUS(destination *storage.IdentityProviders_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Apple
	if providers.Apple != nil {
		var apple storage.Apple_STATUS
		err := providers.Apple.AssignProperties_To_Apple_STATUS(&apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Apple_STATUS() to populate field Apple")
		}
		destination.Apple = &apple
	} else {
		destination.Apple = nil
	}

	// AzureActiveDirectory
	if providers.AzureActiveDirectory != nil {
		var azureActiveDirectory storage.AzureActiveDirectory_STATUS
		err := providers.AzureActiveDirectory.AssignProperties_To_AzureActiveDirectory_STATUS(&azureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectory_STATUS() to populate field AzureActiveDirectory")
		}
		destination.AzureActiveDirectory = &azureActiveDirectory
	} else {
		destination.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if providers.AzureStaticWebApps != nil {
		var azureStaticWebApp storage.AzureStaticWebApps_STATUS
		err := providers.AzureStaticWebApps.AssignProperties_To_AzureStaticWebApps_STATUS(&azureStaticWebApp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebApps_STATUS() to populate field AzureStaticWebApps")
		}
		destination.AzureStaticWebApps = &azureStaticWebApp
	} else {
		destination.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if providers.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]storage.CustomOpenIdConnectProvider_STATUS, len(providers.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range providers.CustomOpenIdConnectProviders {
			// Shadow the loop variable to avoid aliasing
			customOpenIdConnectProviderValue := customOpenIdConnectProviderValue
			var customOpenIdConnectProvider storage.CustomOpenIdConnectProvider_STATUS
			err := customOpenIdConnectProviderValue.AssignProperties_To_CustomOpenIdConnectProvider_STATUS(&customOpenIdConnectProvider)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomOpenIdConnectProvider_STATUS() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		destination.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		destination.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if providers.Facebook != nil {
		var facebook storage.Facebook_STATUS
		err := providers.Facebook.AssignProperties_To_Facebook_STATUS(&facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Facebook_STATUS() to populate field Facebook")
		}
		destination.Facebook = &facebook
	} else {
		destination.Facebook = nil
	}

	// GitHub
	if providers.GitHub != nil {
		var gitHub storage.GitHub_STATUS
		err := providers.GitHub.AssignProperties_To_GitHub_STATUS(&gitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GitHub_STATUS() to populate field GitHub")
		}
		destination.GitHub = &gitHub
	} else {
		destination.GitHub = nil
	}

	// Google
	if providers.Google != nil {
		var google storage.Google_STATUS
		err := providers.Google.AssignProperties_To_Google_STATUS(&google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Google_STATUS() to populate field Google")
		}
		destination.Google = &google
	} else {
		destination.Google = nil
	}

	// Twitter
	if providers.Twitter != nil {
		var twitter storage.Twitter_STATUS
		err := providers.Twitter.AssignProperties_To_Twitter_STATUS(&twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Twitter_STATUS() to populate field Twitter")
		}
		destination.Twitter = &twitter
	} else {
		destination.Twitter = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
type Login struct {
	// AllowedExternalRedirectUrls: External URLs that can be redirected to as part of logging in or logging out of the app.
	// Note that the query string part of the URL is ignored.
	// This is an advanced setting typically only needed by Windows Store application backends.
	// Note that URLs within the current domain are always implicitly allowed.
	AllowedExternalRedirectUrls []string `json:"allowedExternalRedirectUrls,omitempty"`

	// CookieExpiration: The configuration settings of the session cookie's expiration.
	CookieExpiration *CookieExpiration `json:"cookieExpiration,omitempty"`

	// Nonce: The configuration settings of the nonce used in the login flow.
	Nonce *Nonce `json:"nonce,omitempty"`

	// PreserveUrlFragmentsForLogins: <code>true</code> if the fragments from the request are preserved after the login request
	// is made; otherwise, <code>false</code>.
	PreserveUrlFragmentsForLogins *bool `json:"preserveUrlFragmentsForLogins,omitempty"`

	// Routes: The routes that specify the endpoints used for login and logout requests.
	Routes *LoginRoutes `json:"routes,omitempty"`

	// TokenStore: The configuration settings of the token store.
	TokenStore *TokenStore `json:"tokenStore,omitempty"`
}

var _ genruntime.ARMTransformer = &Login{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (login *Login) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if login == nil {
		return nil, nil
	}
	result := &arm.Login{}

	// Set property "AllowedExternalRedirectUrls":
	for _, item := range login.AllowedExternalRedirectUrls {
		result.AllowedExternalRedirectUrls = append(result.AllowedExternalRedirectUrls, item)
	}

	// Set property "CookieExpiration":
	if login.CookieExpiration != nil {
		cookieExpiration_ARM, err := (*login.CookieExpiration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cookieExpiration := *cookieExpiration_ARM.(*arm.CookieExpiration)
		result.CookieExpiration = &cookieExpiration
	}

	// Set property "Nonce":
	if login.Nonce != nil {
		nonce_ARM, err := (*login.Nonce).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nonce := *nonce_ARM.(*arm.Nonce)
		result.Nonce = &nonce
	}

	// Set property "PreserveUrlFragmentsForLogins":
	if login.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogins := *login.PreserveUrlFragmentsForLogins
		result.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogins
	}

	// Set property "Routes":
	if login.Routes != nil {
		routes_ARM, err := (*login.Routes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routes := *routes_ARM.(*arm.LoginRoutes)
		result.Routes = &routes
	}

	// Set property "TokenStore":
	if login.TokenStore != nil {
		tokenStore_ARM, err := (*login.TokenStore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tokenStore := *tokenStore_ARM.(*arm.TokenStore)
		result.TokenStore = &tokenStore
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (login *Login) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Login{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (login *Login) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Login)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Login, got %T", armInput)
	}

	// Set property "AllowedExternalRedirectUrls":
	for _, item := range typedInput.AllowedExternalRedirectUrls {
		login.AllowedExternalRedirectUrls = append(login.AllowedExternalRedirectUrls, item)
	}

	// Set property "CookieExpiration":
	if typedInput.CookieExpiration != nil {
		var cookieExpiration1 CookieExpiration
		err := cookieExpiration1.PopulateFromARM(owner, *typedInput.CookieExpiration)
		if err != nil {
			return err
		}
		cookieExpiration := cookieExpiration1
		login.CookieExpiration = &cookieExpiration
	}

	// Set property "Nonce":
	if typedInput.Nonce != nil {
		var nonce1 Nonce
		err := nonce1.PopulateFromARM(owner, *typedInput.Nonce)
		if err != nil {
			return err
		}
		nonce := nonce1
		login.Nonce = &nonce
	}

	// Set property "PreserveUrlFragmentsForLogins":
	if typedInput.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogins := *typedInput.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogins
	}

	// Set property "Routes":
	if typedInput.Routes != nil {
		var routes1 LoginRoutes
		err := routes1.PopulateFromARM(owner, *typedInput.Routes)
		if err != nil {
			return err
		}
		routes := routes1
		login.Routes = &routes
	}

	// Set property "TokenStore":
	if typedInput.TokenStore != nil {
		var tokenStore1 TokenStore
		err := tokenStore1.PopulateFromARM(owner, *typedInput.TokenStore)
		if err != nil {
			return err
		}
		tokenStore := tokenStore1
		login.TokenStore = &tokenStore
	}

	// No error
	return nil
}

// AssignProperties_From_Login populates our Login from the provided source Login
func (login *Login) AssignProperties_From_Login(source *storage.Login) error {

	// AllowedExternalRedirectUrls
	login.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(source.AllowedExternalRedirectUrls)

	// CookieExpiration
	if source.CookieExpiration != nil {
		var cookieExpiration CookieExpiration
		err := cookieExpiration.AssignProperties_From_CookieExpiration(source.CookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CookieExpiration() to populate field CookieExpiration")
		}
		login.CookieExpiration = &cookieExpiration
	} else {
		login.CookieExpiration = nil
	}

	// Nonce
	if source.Nonce != nil {
		var nonce Nonce
		err := nonce.AssignProperties_From_Nonce(source.Nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Nonce() to populate field Nonce")
		}
		login.Nonce = &nonce
	} else {
		login.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if source.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *source.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		login.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if source.Routes != nil {
		var route LoginRoutes
		err := route.AssignProperties_From_LoginRoutes(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginRoutes() to populate field Routes")
		}
		login.Routes = &route
	} else {
		login.Routes = nil
	}

	// TokenStore
	if source.TokenStore != nil {
		var tokenStore TokenStore
		err := tokenStore.AssignProperties_From_TokenStore(source.TokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenStore() to populate field TokenStore")
		}
		login.TokenStore = &tokenStore
	} else {
		login.TokenStore = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Login populates the provided destination Login from our Login
func (login *Login) AssignProperties_To_Login(destination *storage.Login) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedExternalRedirectUrls
	destination.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(login.AllowedExternalRedirectUrls)

	// CookieExpiration
	if login.CookieExpiration != nil {
		var cookieExpiration storage.CookieExpiration
		err := login.CookieExpiration.AssignProperties_To_CookieExpiration(&cookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CookieExpiration() to populate field CookieExpiration")
		}
		destination.CookieExpiration = &cookieExpiration
	} else {
		destination.CookieExpiration = nil
	}

	// Nonce
	if login.Nonce != nil {
		var nonce storage.Nonce
		err := login.Nonce.AssignProperties_To_Nonce(&nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Nonce() to populate field Nonce")
		}
		destination.Nonce = &nonce
	} else {
		destination.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if login.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *login.PreserveUrlFragmentsForLogins
		destination.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		destination.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if login.Routes != nil {
		var route storage.LoginRoutes
		err := login.Routes.AssignProperties_To_LoginRoutes(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginRoutes() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// TokenStore
	if login.TokenStore != nil {
		var tokenStore storage.TokenStore
		err := login.TokenStore.AssignProperties_To_TokenStore(&tokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenStore() to populate field TokenStore")
		}
		destination.TokenStore = &tokenStore
	} else {
		destination.TokenStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Login_STATUS populates our Login from the provided source Login_STATUS
func (login *Login) Initialize_From_Login_STATUS(source *Login_STATUS) error {

	// AllowedExternalRedirectUrls
	login.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(source.AllowedExternalRedirectUrls)

	// CookieExpiration
	if source.CookieExpiration != nil {
		var cookieExpiration CookieExpiration
		err := cookieExpiration.Initialize_From_CookieExpiration_STATUS(source.CookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CookieExpiration_STATUS() to populate field CookieExpiration")
		}
		login.CookieExpiration = &cookieExpiration
	} else {
		login.CookieExpiration = nil
	}

	// Nonce
	if source.Nonce != nil {
		var nonce Nonce
		err := nonce.Initialize_From_Nonce_STATUS(source.Nonce)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Nonce_STATUS() to populate field Nonce")
		}
		login.Nonce = &nonce
	} else {
		login.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if source.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *source.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		login.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if source.Routes != nil {
		var route LoginRoutes
		err := route.Initialize_From_LoginRoutes_STATUS(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LoginRoutes_STATUS() to populate field Routes")
		}
		login.Routes = &route
	} else {
		login.Routes = nil
	}

	// TokenStore
	if source.TokenStore != nil {
		var tokenStore TokenStore
		err := tokenStore.Initialize_From_TokenStore_STATUS(source.TokenStore)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TokenStore_STATUS() to populate field TokenStore")
		}
		login.TokenStore = &tokenStore
	} else {
		login.TokenStore = nil
	}

	// No error
	return nil
}

// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
type Login_STATUS struct {
	// AllowedExternalRedirectUrls: External URLs that can be redirected to as part of logging in or logging out of the app.
	// Note that the query string part of the URL is ignored.
	// This is an advanced setting typically only needed by Windows Store application backends.
	// Note that URLs within the current domain are always implicitly allowed.
	AllowedExternalRedirectUrls []string `json:"allowedExternalRedirectUrls,omitempty"`

	// CookieExpiration: The configuration settings of the session cookie's expiration.
	CookieExpiration *CookieExpiration_STATUS `json:"cookieExpiration,omitempty"`

	// Nonce: The configuration settings of the nonce used in the login flow.
	Nonce *Nonce_STATUS `json:"nonce,omitempty"`

	// PreserveUrlFragmentsForLogins: <code>true</code> if the fragments from the request are preserved after the login request
	// is made; otherwise, <code>false</code>.
	PreserveUrlFragmentsForLogins *bool `json:"preserveUrlFragmentsForLogins,omitempty"`

	// Routes: The routes that specify the endpoints used for login and logout requests.
	Routes *LoginRoutes_STATUS `json:"routes,omitempty"`

	// TokenStore: The configuration settings of the token store.
	TokenStore *TokenStore_STATUS `json:"tokenStore,omitempty"`
}

var _ genruntime.FromARMConverter = &Login_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (login *Login_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Login_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (login *Login_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Login_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Login_STATUS, got %T", armInput)
	}

	// Set property "AllowedExternalRedirectUrls":
	for _, item := range typedInput.AllowedExternalRedirectUrls {
		login.AllowedExternalRedirectUrls = append(login.AllowedExternalRedirectUrls, item)
	}

	// Set property "CookieExpiration":
	if typedInput.CookieExpiration != nil {
		var cookieExpiration1 CookieExpiration_STATUS
		err := cookieExpiration1.PopulateFromARM(owner, *typedInput.CookieExpiration)
		if err != nil {
			return err
		}
		cookieExpiration := cookieExpiration1
		login.CookieExpiration = &cookieExpiration
	}

	// Set property "Nonce":
	if typedInput.Nonce != nil {
		var nonce1 Nonce_STATUS
		err := nonce1.PopulateFromARM(owner, *typedInput.Nonce)
		if err != nil {
			return err
		}
		nonce := nonce1
		login.Nonce = &nonce
	}

	// Set property "PreserveUrlFragmentsForLogins":
	if typedInput.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogins := *typedInput.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogins
	}

	// Set property "Routes":
	if typedInput.Routes != nil {
		var routes1 LoginRoutes_STATUS
		err := routes1.PopulateFromARM(owner, *typedInput.Routes)
		if err != nil {
			return err
		}
		routes := routes1
		login.Routes = &routes
	}

	// Set property "TokenStore":
	if typedInput.TokenStore != nil {
		var tokenStore1 TokenStore_STATUS
		err := tokenStore1.PopulateFromARM(owner, *typedInput.TokenStore)
		if err != nil {
			return err
		}
		tokenStore := tokenStore1
		login.TokenStore = &tokenStore
	}

	// No error
	return nil
}

// AssignProperties_From_Login_STATUS populates our Login_STATUS from the provided source Login_STATUS
func (login *Login_STATUS) AssignProperties_From_Login_STATUS(source *storage.Login_STATUS) error {

	// AllowedExternalRedirectUrls
	login.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(source.AllowedExternalRedirectUrls)

	// CookieExpiration
	if source.CookieExpiration != nil {
		var cookieExpiration CookieExpiration_STATUS
		err := cookieExpiration.AssignProperties_From_CookieExpiration_STATUS(source.CookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CookieExpiration_STATUS() to populate field CookieExpiration")
		}
		login.CookieExpiration = &cookieExpiration
	} else {
		login.CookieExpiration = nil
	}

	// Nonce
	if source.Nonce != nil {
		var nonce Nonce_STATUS
		err := nonce.AssignProperties_From_Nonce_STATUS(source.Nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Nonce_STATUS() to populate field Nonce")
		}
		login.Nonce = &nonce
	} else {
		login.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if source.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *source.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		login.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if source.Routes != nil {
		var route LoginRoutes_STATUS
		err := route.AssignProperties_From_LoginRoutes_STATUS(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginRoutes_STATUS() to populate field Routes")
		}
		login.Routes = &route
	} else {
		login.Routes = nil
	}

	// TokenStore
	if source.TokenStore != nil {
		var tokenStore TokenStore_STATUS
		err := tokenStore.AssignProperties_From_TokenStore_STATUS(source.TokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenStore_STATUS() to populate field TokenStore")
		}
		login.TokenStore = &tokenStore
	} else {
		login.TokenStore = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Login_STATUS populates the provided destination Login_STATUS from our Login_STATUS
func (login *Login_STATUS) AssignProperties_To_Login_STATUS(destination *storage.Login_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedExternalRedirectUrls
	destination.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(login.AllowedExternalRedirectUrls)

	// CookieExpiration
	if login.CookieExpiration != nil {
		var cookieExpiration storage.CookieExpiration_STATUS
		err := login.CookieExpiration.AssignProperties_To_CookieExpiration_STATUS(&cookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CookieExpiration_STATUS() to populate field CookieExpiration")
		}
		destination.CookieExpiration = &cookieExpiration
	} else {
		destination.CookieExpiration = nil
	}

	// Nonce
	if login.Nonce != nil {
		var nonce storage.Nonce_STATUS
		err := login.Nonce.AssignProperties_To_Nonce_STATUS(&nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Nonce_STATUS() to populate field Nonce")
		}
		destination.Nonce = &nonce
	} else {
		destination.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if login.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *login.PreserveUrlFragmentsForLogins
		destination.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		destination.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if login.Routes != nil {
		var route storage.LoginRoutes_STATUS
		err := login.Routes.AssignProperties_To_LoginRoutes_STATUS(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginRoutes_STATUS() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// TokenStore
	if login.TokenStore != nil {
		var tokenStore storage.TokenStore_STATUS
		err := login.TokenStore.AssignProperties_To_TokenStore_STATUS(&tokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenStore_STATUS() to populate field TokenStore")
		}
		destination.TokenStore = &tokenStore
	} else {
		destination.TokenStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Apple provider.
type Apple struct {
	// Enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`

	// Registration: The configuration settings of the Apple registration.
	Registration *AppleRegistration `json:"registration,omitempty"`
}

var _ genruntime.ARMTransformer = &Apple{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (apple *Apple) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if apple == nil {
		return nil, nil
	}
	result := &arm.Apple{}

	// Set property "Enabled":
	if apple.Enabled != nil {
		enabled := *apple.Enabled
		result.Enabled = &enabled
	}

	// Set property "Login":
	if apple.Login != nil {
		login_ARM, err := (*apple.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.LoginScopes)
		result.Login = &login
	}

	// Set property "Registration":
	if apple.Registration != nil {
		registration_ARM, err := (*apple.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.AppleRegistration)
		result.Registration = &registration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apple *Apple) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Apple{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apple *Apple) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Apple)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Apple, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		apple.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		apple.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AppleRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		apple.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_Apple populates our Apple from the provided source Apple
func (apple *Apple) AssignProperties_From_Apple(source *storage.Apple) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apple.Enabled = &enabled
	} else {
		apple.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		apple.Login = &login
	} else {
		apple.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppleRegistration
		err := registration.AssignProperties_From_AppleRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppleRegistration() to populate field Registration")
		}
		apple.Registration = &registration
	} else {
		apple.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Apple populates the provided destination Apple from our Apple
func (apple *Apple) AssignProperties_To_Apple(destination *storage.Apple) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if apple.Enabled != nil {
		enabled := *apple.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if apple.Login != nil {
		var login storage.LoginScopes
		err := apple.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if apple.Registration != nil {
		var registration storage.AppleRegistration
		err := apple.Registration.AssignProperties_To_AppleRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppleRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Apple_STATUS populates our Apple from the provided source Apple_STATUS
func (apple *Apple) Initialize_From_Apple_STATUS(source *Apple_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apple.Enabled = &enabled
	} else {
		apple.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.Initialize_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LoginScopes_STATUS() to populate field Login")
		}
		apple.Login = &login
	} else {
		apple.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppleRegistration
		err := registration.Initialize_From_AppleRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AppleRegistration_STATUS() to populate field Registration")
		}
		apple.Registration = &registration
	} else {
		apple.Registration = nil
	}

	// No error
	return nil
}

// The configuration settings of the Apple provider.
type Apple_STATUS struct {
	// Enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes_STATUS `json:"login,omitempty"`

	// Registration: The configuration settings of the Apple registration.
	Registration *AppleRegistration_STATUS `json:"registration,omitempty"`
}

var _ genruntime.FromARMConverter = &Apple_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apple *Apple_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Apple_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apple *Apple_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Apple_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Apple_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		apple.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes_STATUS
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		apple.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AppleRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		apple.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_Apple_STATUS populates our Apple_STATUS from the provided source Apple_STATUS
func (apple *Apple_STATUS) AssignProperties_From_Apple_STATUS(source *storage.Apple_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apple.Enabled = &enabled
	} else {
		apple.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		apple.Login = &login
	} else {
		apple.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppleRegistration_STATUS
		err := registration.AssignProperties_From_AppleRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppleRegistration_STATUS() to populate field Registration")
		}
		apple.Registration = &registration
	} else {
		apple.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Apple_STATUS populates the provided destination Apple_STATUS from our Apple_STATUS
func (apple *Apple_STATUS) AssignProperties_To_Apple_STATUS(destination *storage.Apple_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if apple.Enabled != nil {
		enabled := *apple.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if apple.Login != nil {
		var login storage.LoginScopes_STATUS
		err := apple.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if apple.Registration != nil {
		var registration storage.AppleRegistration_STATUS
		err := apple.Registration.AssignProperties_To_AppleRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppleRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active directory provider.
type AzureActiveDirectory struct {
	// Enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration;
	// otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// IsAutoProvisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party
	// tooling.
	// This is an internal flag primarily intended to support the Azure Management Portal. Users should not
	// read or write to this property.
	IsAutoProvisioned *bool `json:"isAutoProvisioned,omitempty"`

	// Login: The configuration settings of the Azure Active Directory login flow.
	Login *AzureActiveDirectoryLogin `json:"login,omitempty"`

	// Registration: The configuration settings of the Azure Active Directory app registration.
	Registration *AzureActiveDirectoryRegistration `json:"registration,omitempty"`

	// Validation: The configuration settings of the Azure Active Directory token validation flow.
	Validation *AzureActiveDirectoryValidation `json:"validation,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureActiveDirectory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (directory *AzureActiveDirectory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if directory == nil {
		return nil, nil
	}
	result := &arm.AzureActiveDirectory{}

	// Set property "Enabled":
	if directory.Enabled != nil {
		enabled := *directory.Enabled
		result.Enabled = &enabled
	}

	// Set property "IsAutoProvisioned":
	if directory.IsAutoProvisioned != nil {
		isAutoProvisioned := *directory.IsAutoProvisioned
		result.IsAutoProvisioned = &isAutoProvisioned
	}

	// Set property "Login":
	if directory.Login != nil {
		login_ARM, err := (*directory.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.AzureActiveDirectoryLogin)
		result.Login = &login
	}

	// Set property "Registration":
	if directory.Registration != nil {
		registration_ARM, err := (*directory.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.AzureActiveDirectoryRegistration)
		result.Registration = &registration
	}

	// Set property "Validation":
	if directory.Validation != nil {
		validation_ARM, err := (*directory.Validation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		validation := *validation_ARM.(*arm.AzureActiveDirectoryValidation)
		result.Validation = &validation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *AzureActiveDirectory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectory{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *AzureActiveDirectory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectory)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectory, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		directory.Enabled = &enabled
	}

	// Set property "IsAutoProvisioned":
	if typedInput.IsAutoProvisioned != nil {
		isAutoProvisioned := *typedInput.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 AzureActiveDirectoryLogin
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		directory.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AzureActiveDirectoryRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		directory.Registration = &registration
	}

	// Set property "Validation":
	if typedInput.Validation != nil {
		var validation1 AzureActiveDirectoryValidation
		err := validation1.PopulateFromARM(owner, *typedInput.Validation)
		if err != nil {
			return err
		}
		validation := validation1
		directory.Validation = &validation
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectory populates our AzureActiveDirectory from the provided source AzureActiveDirectory
func (directory *AzureActiveDirectory) AssignProperties_From_AzureActiveDirectory(source *storage.AzureActiveDirectory) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		directory.Enabled = &enabled
	} else {
		directory.Enabled = nil
	}

	// IsAutoProvisioned
	if source.IsAutoProvisioned != nil {
		isAutoProvisioned := *source.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	} else {
		directory.IsAutoProvisioned = nil
	}

	// Login
	if source.Login != nil {
		var login AzureActiveDirectoryLogin
		err := login.AssignProperties_From_AzureActiveDirectoryLogin(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryLogin() to populate field Login")
		}
		directory.Login = &login
	} else {
		directory.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureActiveDirectoryRegistration
		err := registration.AssignProperties_From_AzureActiveDirectoryRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryRegistration() to populate field Registration")
		}
		directory.Registration = &registration
	} else {
		directory.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AzureActiveDirectoryValidation
		err := validation.AssignProperties_From_AzureActiveDirectoryValidation(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryValidation() to populate field Validation")
		}
		directory.Validation = &validation
	} else {
		directory.Validation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectory populates the provided destination AzureActiveDirectory from our AzureActiveDirectory
func (directory *AzureActiveDirectory) AssignProperties_To_AzureActiveDirectory(destination *storage.AzureActiveDirectory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if directory.Enabled != nil {
		enabled := *directory.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IsAutoProvisioned
	if directory.IsAutoProvisioned != nil {
		isAutoProvisioned := *directory.IsAutoProvisioned
		destination.IsAutoProvisioned = &isAutoProvisioned
	} else {
		destination.IsAutoProvisioned = nil
	}

	// Login
	if directory.Login != nil {
		var login storage.AzureActiveDirectoryLogin
		err := directory.Login.AssignProperties_To_AzureActiveDirectoryLogin(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryLogin() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if directory.Registration != nil {
		var registration storage.AzureActiveDirectoryRegistration
		err := directory.Registration.AssignProperties_To_AzureActiveDirectoryRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if directory.Validation != nil {
		var validation storage.AzureActiveDirectoryValidation
		err := directory.Validation.AssignProperties_To_AzureActiveDirectoryValidation(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryValidation() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureActiveDirectory_STATUS populates our AzureActiveDirectory from the provided source AzureActiveDirectory_STATUS
func (directory *AzureActiveDirectory) Initialize_From_AzureActiveDirectory_STATUS(source *AzureActiveDirectory_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		directory.Enabled = &enabled
	} else {
		directory.Enabled = nil
	}

	// IsAutoProvisioned
	if source.IsAutoProvisioned != nil {
		isAutoProvisioned := *source.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	} else {
		directory.IsAutoProvisioned = nil
	}

	// Login
	if source.Login != nil {
		var login AzureActiveDirectoryLogin
		err := login.Initialize_From_AzureActiveDirectoryLogin_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureActiveDirectoryLogin_STATUS() to populate field Login")
		}
		directory.Login = &login
	} else {
		directory.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureActiveDirectoryRegistration
		err := registration.Initialize_From_AzureActiveDirectoryRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureActiveDirectoryRegistration_STATUS() to populate field Registration")
		}
		directory.Registration = &registration
	} else {
		directory.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AzureActiveDirectoryValidation
		err := validation.Initialize_From_AzureActiveDirectoryValidation_STATUS(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureActiveDirectoryValidation_STATUS() to populate field Validation")
		}
		directory.Validation = &validation
	} else {
		directory.Validation = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active directory provider.
type AzureActiveDirectory_STATUS struct {
	// Enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration;
	// otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// IsAutoProvisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party
	// tooling.
	// This is an internal flag primarily intended to support the Azure Management Portal. Users should not
	// read or write to this property.
	IsAutoProvisioned *bool `json:"isAutoProvisioned,omitempty"`

	// Login: The configuration settings of the Azure Active Directory login flow.
	Login *AzureActiveDirectoryLogin_STATUS `json:"login,omitempty"`

	// Registration: The configuration settings of the Azure Active Directory app registration.
	Registration *AzureActiveDirectoryRegistration_STATUS `json:"registration,omitempty"`

	// Validation: The configuration settings of the Azure Active Directory token validation flow.
	Validation *AzureActiveDirectoryValidation_STATUS `json:"validation,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureActiveDirectory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *AzureActiveDirectory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectory_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *AzureActiveDirectory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectory_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectory_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		directory.Enabled = &enabled
	}

	// Set property "IsAutoProvisioned":
	if typedInput.IsAutoProvisioned != nil {
		isAutoProvisioned := *typedInput.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 AzureActiveDirectoryLogin_STATUS
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		directory.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AzureActiveDirectoryRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		directory.Registration = &registration
	}

	// Set property "Validation":
	if typedInput.Validation != nil {
		var validation1 AzureActiveDirectoryValidation_STATUS
		err := validation1.PopulateFromARM(owner, *typedInput.Validation)
		if err != nil {
			return err
		}
		validation := validation1
		directory.Validation = &validation
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectory_STATUS populates our AzureActiveDirectory_STATUS from the provided source AzureActiveDirectory_STATUS
func (directory *AzureActiveDirectory_STATUS) AssignProperties_From_AzureActiveDirectory_STATUS(source *storage.AzureActiveDirectory_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		directory.Enabled = &enabled
	} else {
		directory.Enabled = nil
	}

	// IsAutoProvisioned
	if source.IsAutoProvisioned != nil {
		isAutoProvisioned := *source.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	} else {
		directory.IsAutoProvisioned = nil
	}

	// Login
	if source.Login != nil {
		var login AzureActiveDirectoryLogin_STATUS
		err := login.AssignProperties_From_AzureActiveDirectoryLogin_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryLogin_STATUS() to populate field Login")
		}
		directory.Login = &login
	} else {
		directory.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureActiveDirectoryRegistration_STATUS
		err := registration.AssignProperties_From_AzureActiveDirectoryRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryRegistration_STATUS() to populate field Registration")
		}
		directory.Registration = &registration
	} else {
		directory.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AzureActiveDirectoryValidation_STATUS
		err := validation.AssignProperties_From_AzureActiveDirectoryValidation_STATUS(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryValidation_STATUS() to populate field Validation")
		}
		directory.Validation = &validation
	} else {
		directory.Validation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectory_STATUS populates the provided destination AzureActiveDirectory_STATUS from our AzureActiveDirectory_STATUS
func (directory *AzureActiveDirectory_STATUS) AssignProperties_To_AzureActiveDirectory_STATUS(destination *storage.AzureActiveDirectory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if directory.Enabled != nil {
		enabled := *directory.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IsAutoProvisioned
	if directory.IsAutoProvisioned != nil {
		isAutoProvisioned := *directory.IsAutoProvisioned
		destination.IsAutoProvisioned = &isAutoProvisioned
	} else {
		destination.IsAutoProvisioned = nil
	}

	// Login
	if directory.Login != nil {
		var login storage.AzureActiveDirectoryLogin_STATUS
		err := directory.Login.AssignProperties_To_AzureActiveDirectoryLogin_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryLogin_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if directory.Registration != nil {
		var registration storage.AzureActiveDirectoryRegistration_STATUS
		err := directory.Registration.AssignProperties_To_AzureActiveDirectoryRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if directory.Validation != nil {
		var validation storage.AzureActiveDirectoryValidation_STATUS
		err := directory.Validation.AssignProperties_To_AzureActiveDirectoryValidation_STATUS(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryValidation_STATUS() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Static Web Apps provider.
type AzureStaticWebApps struct {
	// Enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration;
	// otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Registration: The configuration settings of the Azure Static Web Apps registration.
	Registration *AzureStaticWebAppsRegistration `json:"registration,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureStaticWebApps{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (apps *AzureStaticWebApps) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if apps == nil {
		return nil, nil
	}
	result := &arm.AzureStaticWebApps{}

	// Set property "Enabled":
	if apps.Enabled != nil {
		enabled := *apps.Enabled
		result.Enabled = &enabled
	}

	// Set property "Registration":
	if apps.Registration != nil {
		registration_ARM, err := (*apps.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.AzureStaticWebAppsRegistration)
		result.Registration = &registration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apps *AzureStaticWebApps) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureStaticWebApps{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apps *AzureStaticWebApps) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureStaticWebApps)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureStaticWebApps, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		apps.Enabled = &enabled
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AzureStaticWebAppsRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		apps.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStaticWebApps populates our AzureStaticWebApps from the provided source AzureStaticWebApps
func (apps *AzureStaticWebApps) AssignProperties_From_AzureStaticWebApps(source *storage.AzureStaticWebApps) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apps.Enabled = &enabled
	} else {
		apps.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureStaticWebAppsRegistration
		err := registration.AssignProperties_From_AzureStaticWebAppsRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebAppsRegistration() to populate field Registration")
		}
		apps.Registration = &registration
	} else {
		apps.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebApps populates the provided destination AzureStaticWebApps from our AzureStaticWebApps
func (apps *AzureStaticWebApps) AssignProperties_To_AzureStaticWebApps(destination *storage.AzureStaticWebApps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if apps.Enabled != nil {
		enabled := *apps.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if apps.Registration != nil {
		var registration storage.AzureStaticWebAppsRegistration
		err := apps.Registration.AssignProperties_To_AzureStaticWebAppsRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebAppsRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureStaticWebApps_STATUS populates our AzureStaticWebApps from the provided source AzureStaticWebApps_STATUS
func (apps *AzureStaticWebApps) Initialize_From_AzureStaticWebApps_STATUS(source *AzureStaticWebApps_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apps.Enabled = &enabled
	} else {
		apps.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureStaticWebAppsRegistration
		err := registration.Initialize_From_AzureStaticWebAppsRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureStaticWebAppsRegistration_STATUS() to populate field Registration")
		}
		apps.Registration = &registration
	} else {
		apps.Registration = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Static Web Apps provider.
type AzureStaticWebApps_STATUS struct {
	// Enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration;
	// otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Registration: The configuration settings of the Azure Static Web Apps registration.
	Registration *AzureStaticWebAppsRegistration_STATUS `json:"registration,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureStaticWebApps_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apps *AzureStaticWebApps_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureStaticWebApps_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apps *AzureStaticWebApps_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureStaticWebApps_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureStaticWebApps_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		apps.Enabled = &enabled
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AzureStaticWebAppsRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		apps.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStaticWebApps_STATUS populates our AzureStaticWebApps_STATUS from the provided source AzureStaticWebApps_STATUS
func (apps *AzureStaticWebApps_STATUS) AssignProperties_From_AzureStaticWebApps_STATUS(source *storage.AzureStaticWebApps_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apps.Enabled = &enabled
	} else {
		apps.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureStaticWebAppsRegistration_STATUS
		err := registration.AssignProperties_From_AzureStaticWebAppsRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebAppsRegistration_STATUS() to populate field Registration")
		}
		apps.Registration = &registration
	} else {
		apps.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebApps_STATUS populates the provided destination AzureStaticWebApps_STATUS from our AzureStaticWebApps_STATUS
func (apps *AzureStaticWebApps_STATUS) AssignProperties_To_AzureStaticWebApps_STATUS(destination *storage.AzureStaticWebApps_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if apps.Enabled != nil {
		enabled := *apps.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if apps.Registration != nil {
		var registration storage.AzureStaticWebAppsRegistration_STATUS
		err := apps.Registration.AssignProperties_To_AzureStaticWebAppsRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebAppsRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the session cookie's expiration.
type CookieExpiration struct {
	// Convention: The convention used when determining the session cookie's expiration.
	Convention *CookieExpiration_Convention `json:"convention,omitempty"`

	// TimeToExpiration: The time after the request is made when the session cookie should expire.
	TimeToExpiration *string `json:"timeToExpiration,omitempty"`
}

var _ genruntime.ARMTransformer = &CookieExpiration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (expiration *CookieExpiration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if expiration == nil {
		return nil, nil
	}
	result := &arm.CookieExpiration{}

	// Set property "Convention":
	if expiration.Convention != nil {
		var temp string
		temp = string(*expiration.Convention)
		convention := arm.CookieExpiration_Convention(temp)
		result.Convention = &convention
	}

	// Set property "TimeToExpiration":
	if expiration.TimeToExpiration != nil {
		timeToExpiration := *expiration.TimeToExpiration
		result.TimeToExpiration = &timeToExpiration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (expiration *CookieExpiration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CookieExpiration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (expiration *CookieExpiration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CookieExpiration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CookieExpiration, got %T", armInput)
	}

	// Set property "Convention":
	if typedInput.Convention != nil {
		var temp string
		temp = string(*typedInput.Convention)
		convention := CookieExpiration_Convention(temp)
		expiration.Convention = &convention
	}

	// Set property "TimeToExpiration":
	if typedInput.TimeToExpiration != nil {
		timeToExpiration := *typedInput.TimeToExpiration
		expiration.TimeToExpiration = &timeToExpiration
	}

	// No error
	return nil
}

// AssignProperties_From_CookieExpiration populates our CookieExpiration from the provided source CookieExpiration
func (expiration *CookieExpiration) AssignProperties_From_CookieExpiration(source *storage.CookieExpiration) error {

	// Convention
	if source.Convention != nil {
		convention := *source.Convention
		conventionTemp := genruntime.ToEnum(convention, cookieExpiration_Convention_Values)
		expiration.Convention = &conventionTemp
	} else {
		expiration.Convention = nil
	}

	// TimeToExpiration
	expiration.TimeToExpiration = genruntime.ClonePointerToString(source.TimeToExpiration)

	// No error
	return nil
}

// AssignProperties_To_CookieExpiration populates the provided destination CookieExpiration from our CookieExpiration
func (expiration *CookieExpiration) AssignProperties_To_CookieExpiration(destination *storage.CookieExpiration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Convention
	if expiration.Convention != nil {
		convention := string(*expiration.Convention)
		destination.Convention = &convention
	} else {
		destination.Convention = nil
	}

	// TimeToExpiration
	destination.TimeToExpiration = genruntime.ClonePointerToString(expiration.TimeToExpiration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CookieExpiration_STATUS populates our CookieExpiration from the provided source CookieExpiration_STATUS
func (expiration *CookieExpiration) Initialize_From_CookieExpiration_STATUS(source *CookieExpiration_STATUS) error {

	// Convention
	if source.Convention != nil {
		convention := genruntime.ToEnum(string(*source.Convention), cookieExpiration_Convention_Values)
		expiration.Convention = &convention
	} else {
		expiration.Convention = nil
	}

	// TimeToExpiration
	expiration.TimeToExpiration = genruntime.ClonePointerToString(source.TimeToExpiration)

	// No error
	return nil
}

// The configuration settings of the session cookie's expiration.
type CookieExpiration_STATUS struct {
	// Convention: The convention used when determining the session cookie's expiration.
	Convention *CookieExpiration_Convention_STATUS `json:"convention,omitempty"`

	// TimeToExpiration: The time after the request is made when the session cookie should expire.
	TimeToExpiration *string `json:"timeToExpiration,omitempty"`
}

var _ genruntime.FromARMConverter = &CookieExpiration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (expiration *CookieExpiration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CookieExpiration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (expiration *CookieExpiration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CookieExpiration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CookieExpiration_STATUS, got %T", armInput)
	}

	// Set property "Convention":
	if typedInput.Convention != nil {
		var temp string
		temp = string(*typedInput.Convention)
		convention := CookieExpiration_Convention_STATUS(temp)
		expiration.Convention = &convention
	}

	// Set property "TimeToExpiration":
	if typedInput.TimeToExpiration != nil {
		timeToExpiration := *typedInput.TimeToExpiration
		expiration.TimeToExpiration = &timeToExpiration
	}

	// No error
	return nil
}

// AssignProperties_From_CookieExpiration_STATUS populates our CookieExpiration_STATUS from the provided source CookieExpiration_STATUS
func (expiration *CookieExpiration_STATUS) AssignProperties_From_CookieExpiration_STATUS(source *storage.CookieExpiration_STATUS) error {

	// Convention
	if source.Convention != nil {
		convention := *source.Convention
		conventionTemp := genruntime.ToEnum(convention, cookieExpiration_Convention_STATUS_Values)
		expiration.Convention = &conventionTemp
	} else {
		expiration.Convention = nil
	}

	// TimeToExpiration
	expiration.TimeToExpiration = genruntime.ClonePointerToString(source.TimeToExpiration)

	// No error
	return nil
}

// AssignProperties_To_CookieExpiration_STATUS populates the provided destination CookieExpiration_STATUS from our CookieExpiration_STATUS
func (expiration *CookieExpiration_STATUS) AssignProperties_To_CookieExpiration_STATUS(destination *storage.CookieExpiration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Convention
	if expiration.Convention != nil {
		convention := string(*expiration.Convention)
		destination.Convention = &convention
	} else {
		destination.Convention = nil
	}

	// TimeToExpiration
	destination.TimeToExpiration = genruntime.ClonePointerToString(expiration.TimeToExpiration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the custom Open ID Connect provider.
type CustomOpenIdConnectProvider struct {
	// Enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow of the custom Open ID Connect provider.
	Login *OpenIdConnectLogin `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the custom Open ID Connect provider.
	Registration *OpenIdConnectRegistration `json:"registration,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomOpenIdConnectProvider{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (provider *CustomOpenIdConnectProvider) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if provider == nil {
		return nil, nil
	}
	result := &arm.CustomOpenIdConnectProvider{}

	// Set property "Enabled":
	if provider.Enabled != nil {
		enabled := *provider.Enabled
		result.Enabled = &enabled
	}

	// Set property "Login":
	if provider.Login != nil {
		login_ARM, err := (*provider.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.OpenIdConnectLogin)
		result.Login = &login
	}

	// Set property "Registration":
	if provider.Registration != nil {
		registration_ARM, err := (*provider.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.OpenIdConnectRegistration)
		result.Registration = &registration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (provider *CustomOpenIdConnectProvider) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomOpenIdConnectProvider{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (provider *CustomOpenIdConnectProvider) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomOpenIdConnectProvider)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomOpenIdConnectProvider, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		provider.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 OpenIdConnectLogin
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		provider.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 OpenIdConnectRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		provider.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_CustomOpenIdConnectProvider populates our CustomOpenIdConnectProvider from the provided source CustomOpenIdConnectProvider
func (provider *CustomOpenIdConnectProvider) AssignProperties_From_CustomOpenIdConnectProvider(source *storage.CustomOpenIdConnectProvider) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		provider.Enabled = &enabled
	} else {
		provider.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login OpenIdConnectLogin
		err := login.AssignProperties_From_OpenIdConnectLogin(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectLogin() to populate field Login")
		}
		provider.Login = &login
	} else {
		provider.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration OpenIdConnectRegistration
		err := registration.AssignProperties_From_OpenIdConnectRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectRegistration() to populate field Registration")
		}
		provider.Registration = &registration
	} else {
		provider.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomOpenIdConnectProvider populates the provided destination CustomOpenIdConnectProvider from our CustomOpenIdConnectProvider
func (provider *CustomOpenIdConnectProvider) AssignProperties_To_CustomOpenIdConnectProvider(destination *storage.CustomOpenIdConnectProvider) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if provider.Enabled != nil {
		enabled := *provider.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if provider.Login != nil {
		var login storage.OpenIdConnectLogin
		err := provider.Login.AssignProperties_To_OpenIdConnectLogin(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectLogin() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if provider.Registration != nil {
		var registration storage.OpenIdConnectRegistration
		err := provider.Registration.AssignProperties_To_OpenIdConnectRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomOpenIdConnectProvider_STATUS populates our CustomOpenIdConnectProvider from the provided source CustomOpenIdConnectProvider_STATUS
func (provider *CustomOpenIdConnectProvider) Initialize_From_CustomOpenIdConnectProvider_STATUS(source *CustomOpenIdConnectProvider_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		provider.Enabled = &enabled
	} else {
		provider.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login OpenIdConnectLogin
		err := login.Initialize_From_OpenIdConnectLogin_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OpenIdConnectLogin_STATUS() to populate field Login")
		}
		provider.Login = &login
	} else {
		provider.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration OpenIdConnectRegistration
		err := registration.Initialize_From_OpenIdConnectRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OpenIdConnectRegistration_STATUS() to populate field Registration")
		}
		provider.Registration = &registration
	} else {
		provider.Registration = nil
	}

	// No error
	return nil
}

// The configuration settings of the custom Open ID Connect provider.
type CustomOpenIdConnectProvider_STATUS struct {
	// Enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow of the custom Open ID Connect provider.
	Login *OpenIdConnectLogin_STATUS `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the custom Open ID Connect provider.
	Registration *OpenIdConnectRegistration_STATUS `json:"registration,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomOpenIdConnectProvider_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (provider *CustomOpenIdConnectProvider_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomOpenIdConnectProvider_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (provider *CustomOpenIdConnectProvider_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomOpenIdConnectProvider_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomOpenIdConnectProvider_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		provider.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 OpenIdConnectLogin_STATUS
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		provider.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 OpenIdConnectRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		provider.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_CustomOpenIdConnectProvider_STATUS populates our CustomOpenIdConnectProvider_STATUS from the provided source CustomOpenIdConnectProvider_STATUS
func (provider *CustomOpenIdConnectProvider_STATUS) AssignProperties_From_CustomOpenIdConnectProvider_STATUS(source *storage.CustomOpenIdConnectProvider_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		provider.Enabled = &enabled
	} else {
		provider.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login OpenIdConnectLogin_STATUS
		err := login.AssignProperties_From_OpenIdConnectLogin_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectLogin_STATUS() to populate field Login")
		}
		provider.Login = &login
	} else {
		provider.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration OpenIdConnectRegistration_STATUS
		err := registration.AssignProperties_From_OpenIdConnectRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectRegistration_STATUS() to populate field Registration")
		}
		provider.Registration = &registration
	} else {
		provider.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomOpenIdConnectProvider_STATUS populates the provided destination CustomOpenIdConnectProvider_STATUS from our CustomOpenIdConnectProvider_STATUS
func (provider *CustomOpenIdConnectProvider_STATUS) AssignProperties_To_CustomOpenIdConnectProvider_STATUS(destination *storage.CustomOpenIdConnectProvider_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if provider.Enabled != nil {
		enabled := *provider.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if provider.Login != nil {
		var login storage.OpenIdConnectLogin_STATUS
		err := provider.Login.AssignProperties_To_OpenIdConnectLogin_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectLogin_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if provider.Registration != nil {
		var registration storage.OpenIdConnectRegistration_STATUS
		err := provider.Registration.AssignProperties_To_OpenIdConnectRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Facebook provider.
type Facebook struct {
	// Enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// GraphApiVersion: The version of the Facebook api to be used while logging in.
	GraphApiVersion *string `json:"graphApiVersion,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the Facebook provider.
	Registration *AppRegistration `json:"registration,omitempty"`
}

var _ genruntime.ARMTransformer = &Facebook{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (facebook *Facebook) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if facebook == nil {
		return nil, nil
	}
	result := &arm.Facebook{}

	// Set property "Enabled":
	if facebook.Enabled != nil {
		enabled := *facebook.Enabled
		result.Enabled = &enabled
	}

	// Set property "GraphApiVersion":
	if facebook.GraphApiVersion != nil {
		graphApiVersion := *facebook.GraphApiVersion
		result.GraphApiVersion = &graphApiVersion
	}

	// Set property "Login":
	if facebook.Login != nil {
		login_ARM, err := (*facebook.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.LoginScopes)
		result.Login = &login
	}

	// Set property "Registration":
	if facebook.Registration != nil {
		registration_ARM, err := (*facebook.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.AppRegistration)
		result.Registration = &registration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (facebook *Facebook) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Facebook{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (facebook *Facebook) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Facebook)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Facebook, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		facebook.Enabled = &enabled
	}

	// Set property "GraphApiVersion":
	if typedInput.GraphApiVersion != nil {
		graphApiVersion := *typedInput.GraphApiVersion
		facebook.GraphApiVersion = &graphApiVersion
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		facebook.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AppRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		facebook.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_Facebook populates our Facebook from the provided source Facebook
func (facebook *Facebook) AssignProperties_From_Facebook(source *storage.Facebook) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		facebook.Enabled = &enabled
	} else {
		facebook.Enabled = nil
	}

	// GraphApiVersion
	facebook.GraphApiVersion = genruntime.ClonePointerToString(source.GraphApiVersion)

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		facebook.Login = &login
	} else {
		facebook.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppRegistration
		err := registration.AssignProperties_From_AppRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppRegistration() to populate field Registration")
		}
		facebook.Registration = &registration
	} else {
		facebook.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Facebook populates the provided destination Facebook from our Facebook
func (facebook *Facebook) AssignProperties_To_Facebook(destination *storage.Facebook) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if facebook.Enabled != nil {
		enabled := *facebook.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GraphApiVersion
	destination.GraphApiVersion = genruntime.ClonePointerToString(facebook.GraphApiVersion)

	// Login
	if facebook.Login != nil {
		var login storage.LoginScopes
		err := facebook.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if facebook.Registration != nil {
		var registration storage.AppRegistration
		err := facebook.Registration.AssignProperties_To_AppRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Facebook_STATUS populates our Facebook from the provided source Facebook_STATUS
func (facebook *Facebook) Initialize_From_Facebook_STATUS(source *Facebook_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		facebook.Enabled = &enabled
	} else {
		facebook.Enabled = nil
	}

	// GraphApiVersion
	facebook.GraphApiVersion = genruntime.ClonePointerToString(source.GraphApiVersion)

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.Initialize_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LoginScopes_STATUS() to populate field Login")
		}
		facebook.Login = &login
	} else {
		facebook.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppRegistration
		err := registration.Initialize_From_AppRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AppRegistration_STATUS() to populate field Registration")
		}
		facebook.Registration = &registration
	} else {
		facebook.Registration = nil
	}

	// No error
	return nil
}

// The configuration settings of the Facebook provider.
type Facebook_STATUS struct {
	// Enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// GraphApiVersion: The version of the Facebook api to be used while logging in.
	GraphApiVersion *string `json:"graphApiVersion,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes_STATUS `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the Facebook provider.
	Registration *AppRegistration_STATUS `json:"registration,omitempty"`
}

var _ genruntime.FromARMConverter = &Facebook_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (facebook *Facebook_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Facebook_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (facebook *Facebook_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Facebook_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Facebook_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		facebook.Enabled = &enabled
	}

	// Set property "GraphApiVersion":
	if typedInput.GraphApiVersion != nil {
		graphApiVersion := *typedInput.GraphApiVersion
		facebook.GraphApiVersion = &graphApiVersion
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes_STATUS
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		facebook.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 AppRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		facebook.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_Facebook_STATUS populates our Facebook_STATUS from the provided source Facebook_STATUS
func (facebook *Facebook_STATUS) AssignProperties_From_Facebook_STATUS(source *storage.Facebook_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		facebook.Enabled = &enabled
	} else {
		facebook.Enabled = nil
	}

	// GraphApiVersion
	facebook.GraphApiVersion = genruntime.ClonePointerToString(source.GraphApiVersion)

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		facebook.Login = &login
	} else {
		facebook.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppRegistration_STATUS
		err := registration.AssignProperties_From_AppRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppRegistration_STATUS() to populate field Registration")
		}
		facebook.Registration = &registration
	} else {
		facebook.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Facebook_STATUS populates the provided destination Facebook_STATUS from our Facebook_STATUS
func (facebook *Facebook_STATUS) AssignProperties_To_Facebook_STATUS(destination *storage.Facebook_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if facebook.Enabled != nil {
		enabled := *facebook.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GraphApiVersion
	destination.GraphApiVersion = genruntime.ClonePointerToString(facebook.GraphApiVersion)

	// Login
	if facebook.Login != nil {
		var login storage.LoginScopes_STATUS
		err := facebook.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if facebook.Registration != nil {
		var registration storage.AppRegistration_STATUS
		err := facebook.Registration.AssignProperties_To_AppRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of a forward proxy used to make the requests.
type ForwardProxy struct {
	// Convention: The convention used to determine the url of the request made.
	Convention *ForwardProxy_Convention `json:"convention,omitempty"`

	// CustomHostHeaderName: The name of the header containing the host of the request.
	CustomHostHeaderName *string `json:"customHostHeaderName,omitempty"`

	// CustomProtoHeaderName: The name of the header containing the scheme of the request.
	CustomProtoHeaderName *string `json:"customProtoHeaderName,omitempty"`
}

var _ genruntime.ARMTransformer = &ForwardProxy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (proxy *ForwardProxy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if proxy == nil {
		return nil, nil
	}
	result := &arm.ForwardProxy{}

	// Set property "Convention":
	if proxy.Convention != nil {
		var temp string
		temp = string(*proxy.Convention)
		convention := arm.ForwardProxy_Convention(temp)
		result.Convention = &convention
	}

	// Set property "CustomHostHeaderName":
	if proxy.CustomHostHeaderName != nil {
		customHostHeaderName := *proxy.CustomHostHeaderName
		result.CustomHostHeaderName = &customHostHeaderName
	}

	// Set property "CustomProtoHeaderName":
	if proxy.CustomProtoHeaderName != nil {
		customProtoHeaderName := *proxy.CustomProtoHeaderName
		result.CustomProtoHeaderName = &customProtoHeaderName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (proxy *ForwardProxy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ForwardProxy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (proxy *ForwardProxy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ForwardProxy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ForwardProxy, got %T", armInput)
	}

	// Set property "Convention":
	if typedInput.Convention != nil {
		var temp string
		temp = string(*typedInput.Convention)
		convention := ForwardProxy_Convention(temp)
		proxy.Convention = &convention
	}

	// Set property "CustomHostHeaderName":
	if typedInput.CustomHostHeaderName != nil {
		customHostHeaderName := *typedInput.CustomHostHeaderName
		proxy.CustomHostHeaderName = &customHostHeaderName
	}

	// Set property "CustomProtoHeaderName":
	if typedInput.CustomProtoHeaderName != nil {
		customProtoHeaderName := *typedInput.CustomProtoHeaderName
		proxy.CustomProtoHeaderName = &customProtoHeaderName
	}

	// No error
	return nil
}

// AssignProperties_From_ForwardProxy populates our ForwardProxy from the provided source ForwardProxy
func (proxy *ForwardProxy) AssignProperties_From_ForwardProxy(source *storage.ForwardProxy) error {

	// Convention
	if source.Convention != nil {
		convention := *source.Convention
		conventionTemp := genruntime.ToEnum(convention, forwardProxy_Convention_Values)
		proxy.Convention = &conventionTemp
	} else {
		proxy.Convention = nil
	}

	// CustomHostHeaderName
	proxy.CustomHostHeaderName = genruntime.ClonePointerToString(source.CustomHostHeaderName)

	// CustomProtoHeaderName
	proxy.CustomProtoHeaderName = genruntime.ClonePointerToString(source.CustomProtoHeaderName)

	// No error
	return nil
}

// AssignProperties_To_ForwardProxy populates the provided destination ForwardProxy from our ForwardProxy
func (proxy *ForwardProxy) AssignProperties_To_ForwardProxy(destination *storage.ForwardProxy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Convention
	if proxy.Convention != nil {
		convention := string(*proxy.Convention)
		destination.Convention = &convention
	} else {
		destination.Convention = nil
	}

	// CustomHostHeaderName
	destination.CustomHostHeaderName = genruntime.ClonePointerToString(proxy.CustomHostHeaderName)

	// CustomProtoHeaderName
	destination.CustomProtoHeaderName = genruntime.ClonePointerToString(proxy.CustomProtoHeaderName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ForwardProxy_STATUS populates our ForwardProxy from the provided source ForwardProxy_STATUS
func (proxy *ForwardProxy) Initialize_From_ForwardProxy_STATUS(source *ForwardProxy_STATUS) error {

	// Convention
	if source.Convention != nil {
		convention := genruntime.ToEnum(string(*source.Convention), forwardProxy_Convention_Values)
		proxy.Convention = &convention
	} else {
		proxy.Convention = nil
	}

	// CustomHostHeaderName
	proxy.CustomHostHeaderName = genruntime.ClonePointerToString(source.CustomHostHeaderName)

	// CustomProtoHeaderName
	proxy.CustomProtoHeaderName = genruntime.ClonePointerToString(source.CustomProtoHeaderName)

	// No error
	return nil
}

// The configuration settings of a forward proxy used to make the requests.
type ForwardProxy_STATUS struct {
	// Convention: The convention used to determine the url of the request made.
	Convention *ForwardProxy_Convention_STATUS `json:"convention,omitempty"`

	// CustomHostHeaderName: The name of the header containing the host of the request.
	CustomHostHeaderName *string `json:"customHostHeaderName,omitempty"`

	// CustomProtoHeaderName: The name of the header containing the scheme of the request.
	CustomProtoHeaderName *string `json:"customProtoHeaderName,omitempty"`
}

var _ genruntime.FromARMConverter = &ForwardProxy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (proxy *ForwardProxy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ForwardProxy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (proxy *ForwardProxy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ForwardProxy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ForwardProxy_STATUS, got %T", armInput)
	}

	// Set property "Convention":
	if typedInput.Convention != nil {
		var temp string
		temp = string(*typedInput.Convention)
		convention := ForwardProxy_Convention_STATUS(temp)
		proxy.Convention = &convention
	}

	// Set property "CustomHostHeaderName":
	if typedInput.CustomHostHeaderName != nil {
		customHostHeaderName := *typedInput.CustomHostHeaderName
		proxy.CustomHostHeaderName = &customHostHeaderName
	}

	// Set property "CustomProtoHeaderName":
	if typedInput.CustomProtoHeaderName != nil {
		customProtoHeaderName := *typedInput.CustomProtoHeaderName
		proxy.CustomProtoHeaderName = &customProtoHeaderName
	}

	// No error
	return nil
}

// AssignProperties_From_ForwardProxy_STATUS populates our ForwardProxy_STATUS from the provided source ForwardProxy_STATUS
func (proxy *ForwardProxy_STATUS) AssignProperties_From_ForwardProxy_STATUS(source *storage.ForwardProxy_STATUS) error {

	// Convention
	if source.Convention != nil {
		convention := *source.Convention
		conventionTemp := genruntime.ToEnum(convention, forwardProxy_Convention_STATUS_Values)
		proxy.Convention = &conventionTemp
	} else {
		proxy.Convention = nil
	}

	// CustomHostHeaderName
	proxy.CustomHostHeaderName = genruntime.ClonePointerToString(source.CustomHostHeaderName)

	// CustomProtoHeaderName
	proxy.CustomProtoHeaderName = genruntime.ClonePointerToString(source.CustomProtoHeaderName)

	// No error
	return nil
}

// AssignProperties_To_ForwardProxy_STATUS populates the provided destination ForwardProxy_STATUS from our ForwardProxy_STATUS
func (proxy *ForwardProxy_STATUS) AssignProperties_To_ForwardProxy_STATUS(destination *storage.ForwardProxy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Convention
	if proxy.Convention != nil {
		convention := string(*proxy.Convention)
		destination.Convention = &convention
	} else {
		destination.Convention = nil
	}

	// CustomHostHeaderName
	destination.CustomHostHeaderName = genruntime.ClonePointerToString(proxy.CustomHostHeaderName)

	// CustomProtoHeaderName
	destination.CustomProtoHeaderName = genruntime.ClonePointerToString(proxy.CustomProtoHeaderName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the GitHub provider.
type GitHub struct {
	// Enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the GitHub provider.
	Registration *ClientRegistration `json:"registration,omitempty"`
}

var _ genruntime.ARMTransformer = &GitHub{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (gitHub *GitHub) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if gitHub == nil {
		return nil, nil
	}
	result := &arm.GitHub{}

	// Set property "Enabled":
	if gitHub.Enabled != nil {
		enabled := *gitHub.Enabled
		result.Enabled = &enabled
	}

	// Set property "Login":
	if gitHub.Login != nil {
		login_ARM, err := (*gitHub.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.LoginScopes)
		result.Login = &login
	}

	// Set property "Registration":
	if gitHub.Registration != nil {
		registration_ARM, err := (*gitHub.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.ClientRegistration)
		result.Registration = &registration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gitHub *GitHub) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GitHub{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gitHub *GitHub) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GitHub)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GitHub, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gitHub.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		gitHub.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 ClientRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		gitHub.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_GitHub populates our GitHub from the provided source GitHub
func (gitHub *GitHub) AssignProperties_From_GitHub(source *storage.GitHub) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gitHub.Enabled = &enabled
	} else {
		gitHub.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		gitHub.Login = &login
	} else {
		gitHub.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration
		err := registration.AssignProperties_From_ClientRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration() to populate field Registration")
		}
		gitHub.Registration = &registration
	} else {
		gitHub.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GitHub populates the provided destination GitHub from our GitHub
func (gitHub *GitHub) AssignProperties_To_GitHub(destination *storage.GitHub) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if gitHub.Enabled != nil {
		enabled := *gitHub.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if gitHub.Login != nil {
		var login storage.LoginScopes
		err := gitHub.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if gitHub.Registration != nil {
		var registration storage.ClientRegistration
		err := gitHub.Registration.AssignProperties_To_ClientRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GitHub_STATUS populates our GitHub from the provided source GitHub_STATUS
func (gitHub *GitHub) Initialize_From_GitHub_STATUS(source *GitHub_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gitHub.Enabled = &enabled
	} else {
		gitHub.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.Initialize_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LoginScopes_STATUS() to populate field Login")
		}
		gitHub.Login = &login
	} else {
		gitHub.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration
		err := registration.Initialize_From_ClientRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClientRegistration_STATUS() to populate field Registration")
		}
		gitHub.Registration = &registration
	} else {
		gitHub.Registration = nil
	}

	// No error
	return nil
}

// The configuration settings of the GitHub provider.
type GitHub_STATUS struct {
	// Enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes_STATUS `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the GitHub provider.
	Registration *ClientRegistration_STATUS `json:"registration,omitempty"`
}

var _ genruntime.FromARMConverter = &GitHub_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gitHub *GitHub_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GitHub_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gitHub *GitHub_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GitHub_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GitHub_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gitHub.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes_STATUS
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		gitHub.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 ClientRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		gitHub.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_GitHub_STATUS populates our GitHub_STATUS from the provided source GitHub_STATUS
func (gitHub *GitHub_STATUS) AssignProperties_From_GitHub_STATUS(source *storage.GitHub_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gitHub.Enabled = &enabled
	} else {
		gitHub.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		gitHub.Login = &login
	} else {
		gitHub.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration_STATUS
		err := registration.AssignProperties_From_ClientRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration_STATUS() to populate field Registration")
		}
		gitHub.Registration = &registration
	} else {
		gitHub.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GitHub_STATUS populates the provided destination GitHub_STATUS from our GitHub_STATUS
func (gitHub *GitHub_STATUS) AssignProperties_To_GitHub_STATUS(destination *storage.GitHub_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if gitHub.Enabled != nil {
		enabled := *gitHub.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if gitHub.Login != nil {
		var login storage.LoginScopes_STATUS
		err := gitHub.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if gitHub.Registration != nil {
		var registration storage.ClientRegistration_STATUS
		err := gitHub.Registration.AssignProperties_To_ClientRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AllowAnonymous","RedirectToLoginPage","Return401","Return403"}
type GlobalValidation_UnauthenticatedClientAction string

const (
	GlobalValidation_UnauthenticatedClientAction_AllowAnonymous      = GlobalValidation_UnauthenticatedClientAction("AllowAnonymous")
	GlobalValidation_UnauthenticatedClientAction_RedirectToLoginPage = GlobalValidation_UnauthenticatedClientAction("RedirectToLoginPage")
	GlobalValidation_UnauthenticatedClientAction_Return401           = GlobalValidation_UnauthenticatedClientAction("Return401")
	GlobalValidation_UnauthenticatedClientAction_Return403           = GlobalValidation_UnauthenticatedClientAction("Return403")
)

// Mapping from string to GlobalValidation_UnauthenticatedClientAction
var globalValidation_UnauthenticatedClientAction_Values = map[string]GlobalValidation_UnauthenticatedClientAction{
	"allowanonymous":      GlobalValidation_UnauthenticatedClientAction_AllowAnonymous,
	"redirecttologinpage": GlobalValidation_UnauthenticatedClientAction_RedirectToLoginPage,
	"return401":           GlobalValidation_UnauthenticatedClientAction_Return401,
	"return403":           GlobalValidation_UnauthenticatedClientAction_Return403,
}

type GlobalValidation_UnauthenticatedClientAction_STATUS string

const (
	GlobalValidation_UnauthenticatedClientAction_STATUS_AllowAnonymous      = GlobalValidation_UnauthenticatedClientAction_STATUS("AllowAnonymous")
	GlobalValidation_UnauthenticatedClientAction_STATUS_RedirectToLoginPage = GlobalValidation_UnauthenticatedClientAction_STATUS("RedirectToLoginPage")
	GlobalValidation_UnauthenticatedClientAction_STATUS_Return401           = GlobalValidation_UnauthenticatedClientAction_STATUS("Return401")
	GlobalValidation_UnauthenticatedClientAction_STATUS_Return403           = GlobalValidation_UnauthenticatedClientAction_STATUS("Return403")
)

// Mapping from string to GlobalValidation_UnauthenticatedClientAction_STATUS
var globalValidation_UnauthenticatedClientAction_STATUS_Values = map[string]GlobalValidation_UnauthenticatedClientAction_STATUS{
	"allowanonymous":      GlobalValidation_UnauthenticatedClientAction_STATUS_AllowAnonymous,
	"redirecttologinpage": GlobalValidation_UnauthenticatedClientAction_STATUS_RedirectToLoginPage,
	"return401":           GlobalValidation_UnauthenticatedClientAction_STATUS_Return401,
	"return403":           GlobalValidation_UnauthenticatedClientAction_STATUS_Return403,
}

// The configuration settings of the Google provider.
type Google struct {
	// Enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the Google provider.
	Registration *ClientRegistration `json:"registration,omitempty"`

	// Validation: The configuration settings of the Azure Active Directory token validation flow.
	Validation *AllowedAudiencesValidation `json:"validation,omitempty"`
}

var _ genruntime.ARMTransformer = &Google{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (google *Google) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if google == nil {
		return nil, nil
	}
	result := &arm.Google{}

	// Set property "Enabled":
	if google.Enabled != nil {
		enabled := *google.Enabled
		result.Enabled = &enabled
	}

	// Set property "Login":
	if google.Login != nil {
		login_ARM, err := (*google.Login).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		login := *login_ARM.(*arm.LoginScopes)
		result.Login = &login
	}

	// Set property "Registration":
	if google.Registration != nil {
		registration_ARM, err := (*google.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.ClientRegistration)
		result.Registration = &registration
	}

	// Set property "Validation":
	if google.Validation != nil {
		validation_ARM, err := (*google.Validation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		validation := *validation_ARM.(*arm.AllowedAudiencesValidation)
		result.Validation = &validation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (google *Google) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Google{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (google *Google) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Google)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Google, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		google.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		google.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 ClientRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		google.Registration = &registration
	}

	// Set property "Validation":
	if typedInput.Validation != nil {
		var validation1 AllowedAudiencesValidation
		err := validation1.PopulateFromARM(owner, *typedInput.Validation)
		if err != nil {
			return err
		}
		validation := validation1
		google.Validation = &validation
	}

	// No error
	return nil
}

// AssignProperties_From_Google populates our Google from the provided source Google
func (google *Google) AssignProperties_From_Google(source *storage.Google) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		google.Enabled = &enabled
	} else {
		google.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		google.Login = &login
	} else {
		google.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration
		err := registration.AssignProperties_From_ClientRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration() to populate field Registration")
		}
		google.Registration = &registration
	} else {
		google.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AllowedAudiencesValidation
		err := validation.AssignProperties_From_AllowedAudiencesValidation(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedAudiencesValidation() to populate field Validation")
		}
		google.Validation = &validation
	} else {
		google.Validation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Google populates the provided destination Google from our Google
func (google *Google) AssignProperties_To_Google(destination *storage.Google) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if google.Enabled != nil {
		enabled := *google.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if google.Login != nil {
		var login storage.LoginScopes
		err := google.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if google.Registration != nil {
		var registration storage.ClientRegistration
		err := google.Registration.AssignProperties_To_ClientRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if google.Validation != nil {
		var validation storage.AllowedAudiencesValidation
		err := google.Validation.AssignProperties_To_AllowedAudiencesValidation(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedAudiencesValidation() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Google_STATUS populates our Google from the provided source Google_STATUS
func (google *Google) Initialize_From_Google_STATUS(source *Google_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		google.Enabled = &enabled
	} else {
		google.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.Initialize_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LoginScopes_STATUS() to populate field Login")
		}
		google.Login = &login
	} else {
		google.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration
		err := registration.Initialize_From_ClientRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClientRegistration_STATUS() to populate field Registration")
		}
		google.Registration = &registration
	} else {
		google.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AllowedAudiencesValidation
		err := validation.Initialize_From_AllowedAudiencesValidation_STATUS(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AllowedAudiencesValidation_STATUS() to populate field Validation")
		}
		google.Validation = &validation
	} else {
		google.Validation = nil
	}

	// No error
	return nil
}

// The configuration settings of the Google provider.
type Google_STATUS struct {
	// Enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Login: The configuration settings of the login flow.
	Login *LoginScopes_STATUS `json:"login,omitempty"`

	// Registration: The configuration settings of the app registration for the Google provider.
	Registration *ClientRegistration_STATUS `json:"registration,omitempty"`

	// Validation: The configuration settings of the Azure Active Directory token validation flow.
	Validation *AllowedAudiencesValidation_STATUS `json:"validation,omitempty"`
}

var _ genruntime.FromARMConverter = &Google_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (google *Google_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Google_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (google *Google_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Google_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Google_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		google.Enabled = &enabled
	}

	// Set property "Login":
	if typedInput.Login != nil {
		var login1 LoginScopes_STATUS
		err := login1.PopulateFromARM(owner, *typedInput.Login)
		if err != nil {
			return err
		}
		login := login1
		google.Login = &login
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 ClientRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		google.Registration = &registration
	}

	// Set property "Validation":
	if typedInput.Validation != nil {
		var validation1 AllowedAudiencesValidation_STATUS
		err := validation1.PopulateFromARM(owner, *typedInput.Validation)
		if err != nil {
			return err
		}
		validation := validation1
		google.Validation = &validation
	}

	// No error
	return nil
}

// AssignProperties_From_Google_STATUS populates our Google_STATUS from the provided source Google_STATUS
func (google *Google_STATUS) AssignProperties_From_Google_STATUS(source *storage.Google_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		google.Enabled = &enabled
	} else {
		google.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		google.Login = &login
	} else {
		google.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration_STATUS
		err := registration.AssignProperties_From_ClientRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration_STATUS() to populate field Registration")
		}
		google.Registration = &registration
	} else {
		google.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AllowedAudiencesValidation_STATUS
		err := validation.AssignProperties_From_AllowedAudiencesValidation_STATUS(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedAudiencesValidation_STATUS() to populate field Validation")
		}
		google.Validation = &validation
	} else {
		google.Validation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Google_STATUS populates the provided destination Google_STATUS from our Google_STATUS
func (google *Google_STATUS) AssignProperties_To_Google_STATUS(destination *storage.Google_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if google.Enabled != nil {
		enabled := *google.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if google.Login != nil {
		var login storage.LoginScopes_STATUS
		err := google.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if google.Registration != nil {
		var registration storage.ClientRegistration_STATUS
		err := google.Registration.AssignProperties_To_ClientRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if google.Validation != nil {
		var validation storage.AllowedAudiencesValidation_STATUS
		err := google.Validation.AssignProperties_To_AllowedAudiencesValidation_STATUS(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedAudiencesValidation_STATUS() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the paths HTTP requests.
type HttpSettingsRoutes struct {
	// ApiPrefix: The prefix that should precede all the authentication/authorization paths.
	ApiPrefix *string `json:"apiPrefix,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpSettingsRoutes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (routes *HttpSettingsRoutes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if routes == nil {
		return nil, nil
	}
	result := &arm.HttpSettingsRoutes{}

	// Set property "ApiPrefix":
	if routes.ApiPrefix != nil {
		apiPrefix := *routes.ApiPrefix
		result.ApiPrefix = &apiPrefix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routes *HttpSettingsRoutes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpSettingsRoutes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routes *HttpSettingsRoutes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpSettingsRoutes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpSettingsRoutes, got %T", armInput)
	}

	// Set property "ApiPrefix":
	if typedInput.ApiPrefix != nil {
		apiPrefix := *typedInput.ApiPrefix
		routes.ApiPrefix = &apiPrefix
	}

	// No error
	return nil
}

// AssignProperties_From_HttpSettingsRoutes populates our HttpSettingsRoutes from the provided source HttpSettingsRoutes
func (routes *HttpSettingsRoutes) AssignProperties_From_HttpSettingsRoutes(source *storage.HttpSettingsRoutes) error {

	// ApiPrefix
	routes.ApiPrefix = genruntime.ClonePointerToString(source.ApiPrefix)

	// No error
	return nil
}

// AssignProperties_To_HttpSettingsRoutes populates the provided destination HttpSettingsRoutes from our HttpSettingsRoutes
func (routes *HttpSettingsRoutes) AssignProperties_To_HttpSettingsRoutes(destination *storage.HttpSettingsRoutes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApiPrefix
	destination.ApiPrefix = genruntime.ClonePointerToString(routes.ApiPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpSettingsRoutes_STATUS populates our HttpSettingsRoutes from the provided source HttpSettingsRoutes_STATUS
func (routes *HttpSettingsRoutes) Initialize_From_HttpSettingsRoutes_STATUS(source *HttpSettingsRoutes_STATUS) error {

	// ApiPrefix
	routes.ApiPrefix = genruntime.ClonePointerToString(source.ApiPrefix)

	// No error
	return nil
}

// The configuration settings of the paths HTTP requests.
type HttpSettingsRoutes_STATUS struct {
	// ApiPrefix: The prefix that should precede all the authentication/authorization paths.
	ApiPrefix *string `json:"apiPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpSettingsRoutes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routes *HttpSettingsRoutes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpSettingsRoutes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routes *HttpSettingsRoutes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpSettingsRoutes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpSettingsRoutes_STATUS, got %T", armInput)
	}

	// Set property "ApiPrefix":
	if typedInput.ApiPrefix != nil {
		apiPrefix := *typedInput.ApiPrefix
		routes.ApiPrefix = &apiPrefix
	}

	// No error
	return nil
}

// AssignProperties_From_HttpSettingsRoutes_STATUS populates our HttpSettingsRoutes_STATUS from the provided source HttpSettingsRoutes_STATUS
func (routes *HttpSettingsRoutes_STATUS) AssignProperties_From_HttpSettingsRoutes_STATUS(source *storage.HttpSettingsRoutes_STATUS) error {

	// ApiPrefix
	routes.ApiPrefix = genruntime.ClonePointerToString(source.ApiPrefix)

	// No error
	return nil
}

// AssignProperties_To_HttpSettingsRoutes_STATUS populates the provided destination HttpSettingsRoutes_STATUS from our HttpSettingsRoutes_STATUS
func (routes *HttpSettingsRoutes_STATUS) AssignProperties_To_HttpSettingsRoutes_STATUS(destination *storage.HttpSettingsRoutes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApiPrefix
	destination.ApiPrefix = genruntime.ClonePointerToString(routes.ApiPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The routes that specify the endpoints used for login and logout requests.
type LoginRoutes struct {
	// LogoutEndpoint: The endpoint at which a logout request should be made.
	LogoutEndpoint *string `json:"logoutEndpoint,omitempty"`
}

var _ genruntime.ARMTransformer = &LoginRoutes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (routes *LoginRoutes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if routes == nil {
		return nil, nil
	}
	result := &arm.LoginRoutes{}

	// Set property "LogoutEndpoint":
	if routes.LogoutEndpoint != nil {
		logoutEndpoint := *routes.LogoutEndpoint
		result.LogoutEndpoint = &logoutEndpoint
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routes *LoginRoutes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LoginRoutes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routes *LoginRoutes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LoginRoutes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LoginRoutes, got %T", armInput)
	}

	// Set property "LogoutEndpoint":
	if typedInput.LogoutEndpoint != nil {
		logoutEndpoint := *typedInput.LogoutEndpoint
		routes.LogoutEndpoint = &logoutEndpoint
	}

	// No error
	return nil
}

// AssignProperties_From_LoginRoutes populates our LoginRoutes from the provided source LoginRoutes
func (routes *LoginRoutes) AssignProperties_From_LoginRoutes(source *storage.LoginRoutes) error {

	// LogoutEndpoint
	routes.LogoutEndpoint = genruntime.ClonePointerToString(source.LogoutEndpoint)

	// No error
	return nil
}

// AssignProperties_To_LoginRoutes populates the provided destination LoginRoutes from our LoginRoutes
func (routes *LoginRoutes) AssignProperties_To_LoginRoutes(destination *storage.LoginRoutes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogoutEndpoint
	destination.LogoutEndpoint = genruntime.ClonePointerToString(routes.LogoutEndpoint)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LoginRoutes_STATUS populates our LoginRoutes from the provided source LoginRoutes_STATUS
func (routes *LoginRoutes) Initialize_From_LoginRoutes_STATUS(source *LoginRoutes_STATUS) error {

	// LogoutEndpoint
	routes.LogoutEndpoint = genruntime.ClonePointerToString(source.LogoutEndpoint)

	// No error
	return nil
}

// The routes that specify the endpoints used for login and logout requests.
type LoginRoutes_STATUS struct {
	// LogoutEndpoint: The endpoint at which a logout request should be made.
	LogoutEndpoint *string `json:"logoutEndpoint,omitempty"`
}

var _ genruntime.FromARMConverter = &LoginRoutes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routes *LoginRoutes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LoginRoutes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routes *LoginRoutes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LoginRoutes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LoginRoutes_STATUS, got %T", armInput)
	}

	// Set property "LogoutEndpoint":
	if typedInput.LogoutEndpoint != nil {
		logoutEndpoint := *typedInput.LogoutEndpoint
		routes.LogoutEndpoint = &logoutEndpoint
	}

	// No error
	return nil
}

// AssignProperties_From_LoginRoutes_STATUS populates our LoginRoutes_STATUS from the provided source LoginRoutes_STATUS
func (routes *LoginRoutes_STATUS) AssignProperties_From_LoginRoutes_STATUS(source *storage.LoginRoutes_STATUS) error {

	// LogoutEndpoint
	routes.LogoutEndpoint = genruntime.ClonePointerToString(source.LogoutEndpoint)

	// No error
	return nil
}

// AssignProperties_To_LoginRoutes_STATUS populates the provided destination LoginRoutes_STATUS from our LoginRoutes_STATUS
func (routes *LoginRoutes_STATUS) AssignProperties_To_LoginRoutes_STATUS(destination *storage.LoginRoutes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogoutEndpoint
	destination.LogoutEndpoint = genruntime.ClonePointerToString(routes.LogoutEndpoint)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the nonce used in the login flow.
type Nonce struct {
	// NonceExpirationInterval: The time after the request is made when the nonce should expire.
	NonceExpirationInterval *string `json:"nonceExpirationInterval,omitempty"`

	// ValidateNonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise,
	// <code>true</code>.
	ValidateNonce *bool `json:"validateNonce,omitempty"`
}

var _ genruntime.ARMTransformer = &Nonce{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (nonce *Nonce) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if nonce == nil {
		return nil, nil
	}
	result := &arm.Nonce{}

	// Set property "NonceExpirationInterval":
	if nonce.NonceExpirationInterval != nil {
		nonceExpirationInterval := *nonce.NonceExpirationInterval
		result.NonceExpirationInterval = &nonceExpirationInterval
	}

	// Set property "ValidateNonce":
	if nonce.ValidateNonce != nil {
		validateNonce := *nonce.ValidateNonce
		result.ValidateNonce = &validateNonce
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (nonce *Nonce) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Nonce{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (nonce *Nonce) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Nonce)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Nonce, got %T", armInput)
	}

	// Set property "NonceExpirationInterval":
	if typedInput.NonceExpirationInterval != nil {
		nonceExpirationInterval := *typedInput.NonceExpirationInterval
		nonce.NonceExpirationInterval = &nonceExpirationInterval
	}

	// Set property "ValidateNonce":
	if typedInput.ValidateNonce != nil {
		validateNonce := *typedInput.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	}

	// No error
	return nil
}

// AssignProperties_From_Nonce populates our Nonce from the provided source Nonce
func (nonce *Nonce) AssignProperties_From_Nonce(source *storage.Nonce) error {

	// NonceExpirationInterval
	nonce.NonceExpirationInterval = genruntime.ClonePointerToString(source.NonceExpirationInterval)

	// ValidateNonce
	if source.ValidateNonce != nil {
		validateNonce := *source.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	} else {
		nonce.ValidateNonce = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Nonce populates the provided destination Nonce from our Nonce
func (nonce *Nonce) AssignProperties_To_Nonce(destination *storage.Nonce) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NonceExpirationInterval
	destination.NonceExpirationInterval = genruntime.ClonePointerToString(nonce.NonceExpirationInterval)

	// ValidateNonce
	if nonce.ValidateNonce != nil {
		validateNonce := *nonce.ValidateNonce
		destination.ValidateNonce = &validateNonce
	} else {
		destination.ValidateNonce = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Nonce_STATUS populates our Nonce from the provided source Nonce_STATUS
func (nonce *Nonce) Initialize_From_Nonce_STATUS(source *Nonce_STATUS) error {

	// NonceExpirationInterval
	nonce.NonceExpirationInterval = genruntime.ClonePointerToString(source.NonceExpirationInterval)

	// ValidateNonce
	if source.ValidateNonce != nil {
		validateNonce := *source.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	} else {
		nonce.ValidateNonce = nil
	}

	// No error
	return nil
}

// The configuration settings of the nonce used in the login flow.
type Nonce_STATUS struct {
	// NonceExpirationInterval: The time after the request is made when the nonce should expire.
	NonceExpirationInterval *string `json:"nonceExpirationInterval,omitempty"`

	// ValidateNonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise,
	// <code>true</code>.
	ValidateNonce *bool `json:"validateNonce,omitempty"`
}

var _ genruntime.FromARMConverter = &Nonce_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (nonce *Nonce_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Nonce_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (nonce *Nonce_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Nonce_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Nonce_STATUS, got %T", armInput)
	}

	// Set property "NonceExpirationInterval":
	if typedInput.NonceExpirationInterval != nil {
		nonceExpirationInterval := *typedInput.NonceExpirationInterval
		nonce.NonceExpirationInterval = &nonceExpirationInterval
	}

	// Set property "ValidateNonce":
	if typedInput.ValidateNonce != nil {
		validateNonce := *typedInput.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	}

	// No error
	return nil
}

// AssignProperties_From_Nonce_STATUS populates our Nonce_STATUS from the provided source Nonce_STATUS
func (nonce *Nonce_STATUS) AssignProperties_From_Nonce_STATUS(source *storage.Nonce_STATUS) error {

	// NonceExpirationInterval
	nonce.NonceExpirationInterval = genruntime.ClonePointerToString(source.NonceExpirationInterval)

	// ValidateNonce
	if source.ValidateNonce != nil {
		validateNonce := *source.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	} else {
		nonce.ValidateNonce = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Nonce_STATUS populates the provided destination Nonce_STATUS from our Nonce_STATUS
func (nonce *Nonce_STATUS) AssignProperties_To_Nonce_STATUS(destination *storage.Nonce_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NonceExpirationInterval
	destination.NonceExpirationInterval = genruntime.ClonePointerToString(nonce.NonceExpirationInterval)

	// ValidateNonce
	if nonce.ValidateNonce != nil {
		validateNonce := *nonce.ValidateNonce
		destination.ValidateNonce = &validateNonce
	} else {
		destination.ValidateNonce = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// The configuration settings of the token store.
type TokenStore struct {
	// AzureBlobStorage: The configuration settings of the storage of the tokens if blob storage is used.
	AzureBlobStorage *BlobStorageTokenStore `json:"azureBlobStorage,omitempty"`

	// Enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows;
	// otherwise, <code>false</code>.
	// The default is <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// TokenRefreshExtensionHours: The number of hours after session token expiration that a session token can be used to
	// call the token refresh API. The default is 72 hours.
	TokenRefreshExtensionHours *float64 `json:"tokenRefreshExtensionHours,omitempty"`
}

var _ genruntime.ARMTransformer = &TokenStore{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (store *TokenStore) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if store == nil {
		return nil, nil
	}
	result := &arm.TokenStore{}

	// Set property "AzureBlobStorage":
	if store.AzureBlobStorage != nil {
		azureBlobStorage_ARM, err := (*store.AzureBlobStorage).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureBlobStorage := *azureBlobStorage_ARM.(*arm.BlobStorageTokenStore)
		result.AzureBlobStorage = &azureBlobStorage
	}

	// Set property "Enabled":
	if store.Enabled != nil {
		enabled := *store.Enabled
		result.Enabled = &enabled
	}

	// Set property "TokenRefreshExtensionHours":
	if store.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHours := *store.TokenRefreshExtensionHours
		result.TokenRefreshExtensionHours = &tokenRefreshExtensionHours
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (store *TokenStore) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenStore{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (store *TokenStore) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenStore)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenStore, got %T", armInput)
	}

	// Set property "AzureBlobStorage":
	if typedInput.AzureBlobStorage != nil {
		var azureBlobStorage1 BlobStorageTokenStore
		err := azureBlobStorage1.PopulateFromARM(owner, *typedInput.AzureBlobStorage)
		if err != nil {
			return err
		}
		azureBlobStorage := azureBlobStorage1
		store.AzureBlobStorage = &azureBlobStorage
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		store.Enabled = &enabled
	}

	// Set property "TokenRefreshExtensionHours":
	if typedInput.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHours := *typedInput.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHours
	}

	// No error
	return nil
}

// AssignProperties_From_TokenStore populates our TokenStore from the provided source TokenStore
func (store *TokenStore) AssignProperties_From_TokenStore(source *storage.TokenStore) error {

	// AzureBlobStorage
	if source.AzureBlobStorage != nil {
		var azureBlobStorage BlobStorageTokenStore
		err := azureBlobStorage.AssignProperties_From_BlobStorageTokenStore(source.AzureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BlobStorageTokenStore() to populate field AzureBlobStorage")
		}
		store.AzureBlobStorage = &azureBlobStorage
	} else {
		store.AzureBlobStorage = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		store.Enabled = &enabled
	} else {
		store.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if source.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *source.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		store.TokenRefreshExtensionHours = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TokenStore populates the provided destination TokenStore from our TokenStore
func (store *TokenStore) AssignProperties_To_TokenStore(destination *storage.TokenStore) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBlobStorage
	if store.AzureBlobStorage != nil {
		var azureBlobStorage storage.BlobStorageTokenStore
		err := store.AzureBlobStorage.AssignProperties_To_BlobStorageTokenStore(&azureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BlobStorageTokenStore() to populate field AzureBlobStorage")
		}
		destination.AzureBlobStorage = &azureBlobStorage
	} else {
		destination.AzureBlobStorage = nil
	}

	// Enabled
	if store.Enabled != nil {
		enabled := *store.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if store.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *store.TokenRefreshExtensionHours
		destination.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		destination.TokenRefreshExtensionHours = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TokenStore_STATUS populates our TokenStore from the provided source TokenStore_STATUS
func (store *TokenStore) Initialize_From_TokenStore_STATUS(source *TokenStore_STATUS) error {

	// AzureBlobStorage
	if source.AzureBlobStorage != nil {
		var azureBlobStorage BlobStorageTokenStore
		err := azureBlobStorage.Initialize_From_BlobStorageTokenStore_STATUS(source.AzureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_BlobStorageTokenStore_STATUS() to populate field AzureBlobStorage")
		}
		store.AzureBlobStorage = &azureBlobStorage
	} else {
		store.AzureBlobStorage = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		store.Enabled = &enabled
	} else {
		store.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if source.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *source.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		store.TokenRefreshExtensionHours = nil
	}

	// No error
	return nil
}

// The configuration settings of the token store.
type TokenStore_STATUS struct {
	// AzureBlobStorage: The configuration settings of the storage of the tokens if blob storage is used.
	AzureBlobStorage *BlobStorageTokenStore_STATUS `json:"azureBlobStorage,omitempty"`

	// Enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows;
	// otherwise, <code>false</code>.
	// The default is <code>false</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// TokenRefreshExtensionHours: The number of hours after session token expiration that a session token can be used to
	// call the token refresh API. The default is 72 hours.
	TokenRefreshExtensionHours *float64 `json:"tokenRefreshExtensionHours,omitempty"`
}

var _ genruntime.FromARMConverter = &TokenStore_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (store *TokenStore_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenStore_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (store *TokenStore_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenStore_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenStore_STATUS, got %T", armInput)
	}

	// Set property "AzureBlobStorage":
	if typedInput.AzureBlobStorage != nil {
		var azureBlobStorage1 BlobStorageTokenStore_STATUS
		err := azureBlobStorage1.PopulateFromARM(owner, *typedInput.AzureBlobStorage)
		if err != nil {
			return err
		}
		azureBlobStorage := azureBlobStorage1
		store.AzureBlobStorage = &azureBlobStorage
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		store.Enabled = &enabled
	}

	// Set property "TokenRefreshExtensionHours":
	if typedInput.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHours := *typedInput.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHours
	}

	// No error
	return nil
}

// AssignProperties_From_TokenStore_STATUS populates our TokenStore_STATUS from the provided source TokenStore_STATUS
func (store *TokenStore_STATUS) AssignProperties_From_TokenStore_STATUS(source *storage.TokenStore_STATUS) error {

	// AzureBlobStorage
	if source.AzureBlobStorage != nil {
		var azureBlobStorage BlobStorageTokenStore_STATUS
		err := azureBlobStorage.AssignProperties_From_BlobStorageTokenStore_STATUS(source.AzureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BlobStorageTokenStore_STATUS() to populate field AzureBlobStorage")
		}
		store.AzureBlobStorage = &azureBlobStorage
	} else {
		store.AzureBlobStorage = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		store.Enabled = &enabled
	} else {
		store.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if source.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *source.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		store.TokenRefreshExtensionHours = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TokenStore_STATUS populates the provided destination TokenStore_STATUS from our TokenStore_STATUS
func (store *TokenStore_STATUS) AssignProperties_To_TokenStore_STATUS(destination *storage.TokenStore_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureBlobStorage
	if store.AzureBlobStorage != nil {
		var azureBlobStorage storage.BlobStorageTokenStore_STATUS
		err := store.AzureBlobStorage.AssignProperties_To_BlobStorageTokenStore_STATUS(&azureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BlobStorageTokenStore_STATUS() to populate field AzureBlobStorage")
		}
		destination.AzureBlobStorage = &azureBlobStorage
	} else {
		destination.AzureBlobStorage = nil
	}

	// Enabled
	if store.Enabled != nil {
		enabled := *store.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if store.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *store.TokenRefreshExtensionHours
		destination.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		destination.TokenRefreshExtensionHours = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Twitter provider.
type Twitter struct {
	// Enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Registration: The configuration settings of the app registration for the Twitter provider.
	Registration *TwitterRegistration `json:"registration,omitempty"`
}

var _ genruntime.ARMTransformer = &Twitter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (twitter *Twitter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if twitter == nil {
		return nil, nil
	}
	result := &arm.Twitter{}

	// Set property "Enabled":
	if twitter.Enabled != nil {
		enabled := *twitter.Enabled
		result.Enabled = &enabled
	}

	// Set property "Registration":
	if twitter.Registration != nil {
		registration_ARM, err := (*twitter.Registration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		registration := *registration_ARM.(*arm.TwitterRegistration)
		result.Registration = &registration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (twitter *Twitter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Twitter{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (twitter *Twitter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Twitter)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Twitter, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		twitter.Enabled = &enabled
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 TwitterRegistration
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		twitter.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_Twitter populates our Twitter from the provided source Twitter
func (twitter *Twitter) AssignProperties_From_Twitter(source *storage.Twitter) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		twitter.Enabled = &enabled
	} else {
		twitter.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration TwitterRegistration
		err := registration.AssignProperties_From_TwitterRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TwitterRegistration() to populate field Registration")
		}
		twitter.Registration = &registration
	} else {
		twitter.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Twitter populates the provided destination Twitter from our Twitter
func (twitter *Twitter) AssignProperties_To_Twitter(destination *storage.Twitter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if twitter.Enabled != nil {
		enabled := *twitter.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if twitter.Registration != nil {
		var registration storage.TwitterRegistration
		err := twitter.Registration.AssignProperties_To_TwitterRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TwitterRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Twitter_STATUS populates our Twitter from the provided source Twitter_STATUS
func (twitter *Twitter) Initialize_From_Twitter_STATUS(source *Twitter_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		twitter.Enabled = &enabled
	} else {
		twitter.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration TwitterRegistration
		err := registration.Initialize_From_TwitterRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TwitterRegistration_STATUS() to populate field Registration")
		}
		twitter.Registration = &registration
	} else {
		twitter.Registration = nil
	}

	// No error
	return nil
}

// The configuration settings of the Twitter provider.
type Twitter_STATUS struct {
	// Enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise,
	// <code>true</code>.
	Enabled *bool `json:"enabled,omitempty"`

	// Registration: The configuration settings of the app registration for the Twitter provider.
	Registration *TwitterRegistration_STATUS `json:"registration,omitempty"`
}

var _ genruntime.FromARMConverter = &Twitter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (twitter *Twitter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Twitter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (twitter *Twitter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Twitter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Twitter_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		twitter.Enabled = &enabled
	}

	// Set property "Registration":
	if typedInput.Registration != nil {
		var registration1 TwitterRegistration_STATUS
		err := registration1.PopulateFromARM(owner, *typedInput.Registration)
		if err != nil {
			return err
		}
		registration := registration1
		twitter.Registration = &registration
	}

	// No error
	return nil
}

// AssignProperties_From_Twitter_STATUS populates our Twitter_STATUS from the provided source Twitter_STATUS
func (twitter *Twitter_STATUS) AssignProperties_From_Twitter_STATUS(source *storage.Twitter_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		twitter.Enabled = &enabled
	} else {
		twitter.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration TwitterRegistration_STATUS
		err := registration.AssignProperties_From_TwitterRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TwitterRegistration_STATUS() to populate field Registration")
		}
		twitter.Registration = &registration
	} else {
		twitter.Registration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Twitter_STATUS populates the provided destination Twitter_STATUS from our Twitter_STATUS
func (twitter *Twitter_STATUS) AssignProperties_To_Twitter_STATUS(destination *storage.Twitter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if twitter.Enabled != nil {
		enabled := *twitter.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if twitter.Registration != nil {
		var registration storage.TwitterRegistration_STATUS
		err := twitter.Registration.AssignProperties_To_TwitterRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TwitterRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Allowed Audiences validation flow.
type AllowedAudiencesValidation struct {
	// AllowedAudiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
	AllowedAudiences []string `json:"allowedAudiences,omitempty"`
}

var _ genruntime.ARMTransformer = &AllowedAudiencesValidation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (validation *AllowedAudiencesValidation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if validation == nil {
		return nil, nil
	}
	result := &arm.AllowedAudiencesValidation{}

	// Set property "AllowedAudiences":
	for _, item := range validation.AllowedAudiences {
		result.AllowedAudiences = append(result.AllowedAudiences, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (validation *AllowedAudiencesValidation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AllowedAudiencesValidation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (validation *AllowedAudiencesValidation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AllowedAudiencesValidation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AllowedAudiencesValidation, got %T", armInput)
	}

	// Set property "AllowedAudiences":
	for _, item := range typedInput.AllowedAudiences {
		validation.AllowedAudiences = append(validation.AllowedAudiences, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AllowedAudiencesValidation populates our AllowedAudiencesValidation from the provided source AllowedAudiencesValidation
func (validation *AllowedAudiencesValidation) AssignProperties_From_AllowedAudiencesValidation(source *storage.AllowedAudiencesValidation) error {

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// No error
	return nil
}

// AssignProperties_To_AllowedAudiencesValidation populates the provided destination AllowedAudiencesValidation from our AllowedAudiencesValidation
func (validation *AllowedAudiencesValidation) AssignProperties_To_AllowedAudiencesValidation(destination *storage.AllowedAudiencesValidation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AllowedAudiencesValidation_STATUS populates our AllowedAudiencesValidation from the provided source AllowedAudiencesValidation_STATUS
func (validation *AllowedAudiencesValidation) Initialize_From_AllowedAudiencesValidation_STATUS(source *AllowedAudiencesValidation_STATUS) error {

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// No error
	return nil
}

// The configuration settings of the Allowed Audiences validation flow.
type AllowedAudiencesValidation_STATUS struct {
	// AllowedAudiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
	AllowedAudiences []string `json:"allowedAudiences,omitempty"`
}

var _ genruntime.FromARMConverter = &AllowedAudiencesValidation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (validation *AllowedAudiencesValidation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AllowedAudiencesValidation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (validation *AllowedAudiencesValidation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AllowedAudiencesValidation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AllowedAudiencesValidation_STATUS, got %T", armInput)
	}

	// Set property "AllowedAudiences":
	for _, item := range typedInput.AllowedAudiences {
		validation.AllowedAudiences = append(validation.AllowedAudiences, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AllowedAudiencesValidation_STATUS populates our AllowedAudiencesValidation_STATUS from the provided source AllowedAudiencesValidation_STATUS
func (validation *AllowedAudiencesValidation_STATUS) AssignProperties_From_AllowedAudiencesValidation_STATUS(source *storage.AllowedAudiencesValidation_STATUS) error {

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// No error
	return nil
}

// AssignProperties_To_AllowedAudiencesValidation_STATUS populates the provided destination AllowedAudiencesValidation_STATUS from our AllowedAudiencesValidation_STATUS
func (validation *AllowedAudiencesValidation_STATUS) AssignProperties_To_AllowedAudiencesValidation_STATUS(destination *storage.AllowedAudiencesValidation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the registration for the Apple provider
type AppleRegistration struct {
	// ClientId: The Client ID of the app used for login.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecretSettingName: The app setting name that contains the client secret.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

var _ genruntime.ARMTransformer = &AppleRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *AppleRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.AppleRegistration{}

	// Set property "ClientId":
	if registration.ClientId != nil {
		clientId := *registration.ClientId
		result.ClientId = &clientId
	}

	// Set property "ClientSecretSettingName":
	if registration.ClientSecretSettingName != nil {
		clientSecretSettingName := *registration.ClientSecretSettingName
		result.ClientSecretSettingName = &clientSecretSettingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AppleRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AppleRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AppleRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AppleRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AppleRegistration, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		registration.ClientSecretSettingName = &clientSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_AppleRegistration populates our AppleRegistration from the provided source AppleRegistration
func (registration *AppleRegistration) AssignProperties_From_AppleRegistration(source *storage.AppleRegistration) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_AppleRegistration populates the provided destination AppleRegistration from our AppleRegistration
func (registration *AppleRegistration) AssignProperties_To_AppleRegistration(destination *storage.AppleRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AppleRegistration_STATUS populates our AppleRegistration from the provided source AppleRegistration_STATUS
func (registration *AppleRegistration) Initialize_From_AppleRegistration_STATUS(source *AppleRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// No error
	return nil
}

// The configuration settings of the registration for the Apple provider
type AppleRegistration_STATUS struct {
	// ClientId: The Client ID of the app used for login.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecretSettingName: The app setting name that contains the client secret.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

var _ genruntime.FromARMConverter = &AppleRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AppleRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AppleRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AppleRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AppleRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AppleRegistration_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		registration.ClientSecretSettingName = &clientSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_AppleRegistration_STATUS populates our AppleRegistration_STATUS from the provided source AppleRegistration_STATUS
func (registration *AppleRegistration_STATUS) AssignProperties_From_AppleRegistration_STATUS(source *storage.AppleRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_AppleRegistration_STATUS populates the provided destination AppleRegistration_STATUS from our AppleRegistration_STATUS
func (registration *AppleRegistration_STATUS) AssignProperties_To_AppleRegistration_STATUS(destination *storage.AppleRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the app registration for providers that have app ids and app secrets
type AppRegistration struct {
	// AppId: The App ID of the app used for login.
	AppId *string `json:"appId,omitempty"`

	// AppSecretSettingName: The app setting name that contains the app secret.
	AppSecretSettingName *string `json:"appSecretSettingName,omitempty"`
}

var _ genruntime.ARMTransformer = &AppRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *AppRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.AppRegistration{}

	// Set property "AppId":
	if registration.AppId != nil {
		appId := *registration.AppId
		result.AppId = &appId
	}

	// Set property "AppSecretSettingName":
	if registration.AppSecretSettingName != nil {
		appSecretSettingName := *registration.AppSecretSettingName
		result.AppSecretSettingName = &appSecretSettingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AppRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AppRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AppRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AppRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AppRegistration, got %T", armInput)
	}

	// Set property "AppId":
	if typedInput.AppId != nil {
		appId := *typedInput.AppId
		registration.AppId = &appId
	}

	// Set property "AppSecretSettingName":
	if typedInput.AppSecretSettingName != nil {
		appSecretSettingName := *typedInput.AppSecretSettingName
		registration.AppSecretSettingName = &appSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_AppRegistration populates our AppRegistration from the provided source AppRegistration
func (registration *AppRegistration) AssignProperties_From_AppRegistration(source *storage.AppRegistration) error {

	// AppId
	registration.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppSecretSettingName
	registration.AppSecretSettingName = genruntime.ClonePointerToString(source.AppSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_AppRegistration populates the provided destination AppRegistration from our AppRegistration
func (registration *AppRegistration) AssignProperties_To_AppRegistration(destination *storage.AppRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppId
	destination.AppId = genruntime.ClonePointerToString(registration.AppId)

	// AppSecretSettingName
	destination.AppSecretSettingName = genruntime.ClonePointerToString(registration.AppSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AppRegistration_STATUS populates our AppRegistration from the provided source AppRegistration_STATUS
func (registration *AppRegistration) Initialize_From_AppRegistration_STATUS(source *AppRegistration_STATUS) error {

	// AppId
	registration.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppSecretSettingName
	registration.AppSecretSettingName = genruntime.ClonePointerToString(source.AppSecretSettingName)

	// No error
	return nil
}

// The configuration settings of the app registration for providers that have app ids and app secrets
type AppRegistration_STATUS struct {
	// AppId: The App ID of the app used for login.
	AppId *string `json:"appId,omitempty"`

	// AppSecretSettingName: The app setting name that contains the app secret.
	AppSecretSettingName *string `json:"appSecretSettingName,omitempty"`
}

var _ genruntime.FromARMConverter = &AppRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AppRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AppRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AppRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AppRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AppRegistration_STATUS, got %T", armInput)
	}

	// Set property "AppId":
	if typedInput.AppId != nil {
		appId := *typedInput.AppId
		registration.AppId = &appId
	}

	// Set property "AppSecretSettingName":
	if typedInput.AppSecretSettingName != nil {
		appSecretSettingName := *typedInput.AppSecretSettingName
		registration.AppSecretSettingName = &appSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_AppRegistration_STATUS populates our AppRegistration_STATUS from the provided source AppRegistration_STATUS
func (registration *AppRegistration_STATUS) AssignProperties_From_AppRegistration_STATUS(source *storage.AppRegistration_STATUS) error {

	// AppId
	registration.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppSecretSettingName
	registration.AppSecretSettingName = genruntime.ClonePointerToString(source.AppSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_AppRegistration_STATUS populates the provided destination AppRegistration_STATUS from our AppRegistration_STATUS
func (registration *AppRegistration_STATUS) AssignProperties_To_AppRegistration_STATUS(destination *storage.AppRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppId
	destination.AppId = genruntime.ClonePointerToString(registration.AppId)

	// AppSecretSettingName
	destination.AppSecretSettingName = genruntime.ClonePointerToString(registration.AppSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory login flow.
type AzureActiveDirectoryLogin struct {
	// DisableWWWAuthenticate: <code>true</code> if the www-authenticate provider should be omitted from the request;
	// otherwise, <code>false</code>.
	DisableWWWAuthenticate *bool `json:"disableWWWAuthenticate,omitempty"`

	// LoginParameters: Login parameters to send to the OpenID Connect authorization endpoint when
	// a user logs in. Each parameter must be in the form "key=value".
	LoginParameters []string `json:"loginParameters,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureActiveDirectoryLogin{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (login *AzureActiveDirectoryLogin) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if login == nil {
		return nil, nil
	}
	result := &arm.AzureActiveDirectoryLogin{}

	// Set property "DisableWWWAuthenticate":
	if login.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *login.DisableWWWAuthenticate
		result.DisableWWWAuthenticate = &disableWWWAuthenticate
	}

	// Set property "LoginParameters":
	for _, item := range login.LoginParameters {
		result.LoginParameters = append(result.LoginParameters, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (login *AzureActiveDirectoryLogin) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectoryLogin{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (login *AzureActiveDirectoryLogin) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectoryLogin)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectoryLogin, got %T", armInput)
	}

	// Set property "DisableWWWAuthenticate":
	if typedInput.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *typedInput.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	}

	// Set property "LoginParameters":
	for _, item := range typedInput.LoginParameters {
		login.LoginParameters = append(login.LoginParameters, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectoryLogin populates our AzureActiveDirectoryLogin from the provided source AzureActiveDirectoryLogin
func (login *AzureActiveDirectoryLogin) AssignProperties_From_AzureActiveDirectoryLogin(source *storage.AzureActiveDirectoryLogin) error {

	// DisableWWWAuthenticate
	if source.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *source.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		login.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	login.LoginParameters = genruntime.CloneSliceOfString(source.LoginParameters)

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryLogin populates the provided destination AzureActiveDirectoryLogin from our AzureActiveDirectoryLogin
func (login *AzureActiveDirectoryLogin) AssignProperties_To_AzureActiveDirectoryLogin(destination *storage.AzureActiveDirectoryLogin) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableWWWAuthenticate
	if login.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *login.DisableWWWAuthenticate
		destination.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		destination.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	destination.LoginParameters = genruntime.CloneSliceOfString(login.LoginParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureActiveDirectoryLogin_STATUS populates our AzureActiveDirectoryLogin from the provided source AzureActiveDirectoryLogin_STATUS
func (login *AzureActiveDirectoryLogin) Initialize_From_AzureActiveDirectoryLogin_STATUS(source *AzureActiveDirectoryLogin_STATUS) error {

	// DisableWWWAuthenticate
	if source.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *source.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		login.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	login.LoginParameters = genruntime.CloneSliceOfString(source.LoginParameters)

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory login flow.
type AzureActiveDirectoryLogin_STATUS struct {
	// DisableWWWAuthenticate: <code>true</code> if the www-authenticate provider should be omitted from the request;
	// otherwise, <code>false</code>.
	DisableWWWAuthenticate *bool `json:"disableWWWAuthenticate,omitempty"`

	// LoginParameters: Login parameters to send to the OpenID Connect authorization endpoint when
	// a user logs in. Each parameter must be in the form "key=value".
	LoginParameters []string `json:"loginParameters,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureActiveDirectoryLogin_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (login *AzureActiveDirectoryLogin_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectoryLogin_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (login *AzureActiveDirectoryLogin_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectoryLogin_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectoryLogin_STATUS, got %T", armInput)
	}

	// Set property "DisableWWWAuthenticate":
	if typedInput.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *typedInput.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	}

	// Set property "LoginParameters":
	for _, item := range typedInput.LoginParameters {
		login.LoginParameters = append(login.LoginParameters, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectoryLogin_STATUS populates our AzureActiveDirectoryLogin_STATUS from the provided source AzureActiveDirectoryLogin_STATUS
func (login *AzureActiveDirectoryLogin_STATUS) AssignProperties_From_AzureActiveDirectoryLogin_STATUS(source *storage.AzureActiveDirectoryLogin_STATUS) error {

	// DisableWWWAuthenticate
	if source.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *source.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		login.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	login.LoginParameters = genruntime.CloneSliceOfString(source.LoginParameters)

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryLogin_STATUS populates the provided destination AzureActiveDirectoryLogin_STATUS from our AzureActiveDirectoryLogin_STATUS
func (login *AzureActiveDirectoryLogin_STATUS) AssignProperties_To_AzureActiveDirectoryLogin_STATUS(destination *storage.AzureActiveDirectoryLogin_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableWWWAuthenticate
	if login.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *login.DisableWWWAuthenticate
		destination.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		destination.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	destination.LoginParameters = genruntime.CloneSliceOfString(login.LoginParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory app registration.
type AzureActiveDirectoryRegistration struct {
	// ClientId: The Client ID of this relying party application, known as the client_id.
	// This setting is required for enabling OpenID Connection authentication with Azure Active Directory or
	// other 3rd party OpenID Connect providers.
	// More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecretCertificateIssuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used
	// for signing purposes. This property acts as
	// a replacement for the Client Secret Certificate Thumbprint. It is also optional.
	ClientSecretCertificateIssuer *string `json:"clientSecretCertificateIssuer,omitempty"`

	// ClientSecretCertificateSubjectAlternativeName: An alternative to the client secret thumbprint, that is the subject
	// alternative name of a certificate used for signing purposes. This property acts as
	// a replacement for the Client Secret Certificate Thumbprint. It is also optional.
	ClientSecretCertificateSubjectAlternativeName *string `json:"clientSecretCertificateSubjectAlternativeName,omitempty"`

	// ClientSecretCertificateThumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for
	// signing purposes. This property acts as
	// a replacement for the Client Secret. It is also optional.
	ClientSecretCertificateThumbprint *string `json:"clientSecretCertificateThumbprint,omitempty"`

	// ClientSecretSettingName: The app setting name that contains the client secret of the relying party application.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`

	// OpenIdIssuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
	// When using Azure Active Directory, this value is the URI of the directory tenant, e.g.
	// `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
	// This URI is a case-sensitive identifier for the token issuer.
	// More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
	OpenIdIssuer *string `json:"openIdIssuer,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureActiveDirectoryRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *AzureActiveDirectoryRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.AzureActiveDirectoryRegistration{}

	// Set property "ClientId":
	if registration.ClientId != nil {
		clientId := *registration.ClientId
		result.ClientId = &clientId
	}

	// Set property "ClientSecretCertificateIssuer":
	if registration.ClientSecretCertificateIssuer != nil {
		clientSecretCertificateIssuer := *registration.ClientSecretCertificateIssuer
		result.ClientSecretCertificateIssuer = &clientSecretCertificateIssuer
	}

	// Set property "ClientSecretCertificateSubjectAlternativeName":
	if registration.ClientSecretCertificateSubjectAlternativeName != nil {
		clientSecretCertificateSubjectAlternativeName := *registration.ClientSecretCertificateSubjectAlternativeName
		result.ClientSecretCertificateSubjectAlternativeName = &clientSecretCertificateSubjectAlternativeName
	}

	// Set property "ClientSecretCertificateThumbprint":
	if registration.ClientSecretCertificateThumbprint != nil {
		clientSecretCertificateThumbprint := *registration.ClientSecretCertificateThumbprint
		result.ClientSecretCertificateThumbprint = &clientSecretCertificateThumbprint
	}

	// Set property "ClientSecretSettingName":
	if registration.ClientSecretSettingName != nil {
		clientSecretSettingName := *registration.ClientSecretSettingName
		result.ClientSecretSettingName = &clientSecretSettingName
	}

	// Set property "OpenIdIssuer":
	if registration.OpenIdIssuer != nil {
		openIdIssuer := *registration.OpenIdIssuer
		result.OpenIdIssuer = &openIdIssuer
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AzureActiveDirectoryRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectoryRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AzureActiveDirectoryRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectoryRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectoryRegistration, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "ClientSecretCertificateIssuer":
	if typedInput.ClientSecretCertificateIssuer != nil {
		clientSecretCertificateIssuer := *typedInput.ClientSecretCertificateIssuer
		registration.ClientSecretCertificateIssuer = &clientSecretCertificateIssuer
	}

	// Set property "ClientSecretCertificateSubjectAlternativeName":
	if typedInput.ClientSecretCertificateSubjectAlternativeName != nil {
		clientSecretCertificateSubjectAlternativeName := *typedInput.ClientSecretCertificateSubjectAlternativeName
		registration.ClientSecretCertificateSubjectAlternativeName = &clientSecretCertificateSubjectAlternativeName
	}

	// Set property "ClientSecretCertificateThumbprint":
	if typedInput.ClientSecretCertificateThumbprint != nil {
		clientSecretCertificateThumbprint := *typedInput.ClientSecretCertificateThumbprint
		registration.ClientSecretCertificateThumbprint = &clientSecretCertificateThumbprint
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		registration.ClientSecretSettingName = &clientSecretSettingName
	}

	// Set property "OpenIdIssuer":
	if typedInput.OpenIdIssuer != nil {
		openIdIssuer := *typedInput.OpenIdIssuer
		registration.OpenIdIssuer = &openIdIssuer
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectoryRegistration populates our AzureActiveDirectoryRegistration from the provided source AzureActiveDirectoryRegistration
func (registration *AzureActiveDirectoryRegistration) AssignProperties_From_AzureActiveDirectoryRegistration(source *storage.AzureActiveDirectoryRegistration) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretCertificateIssuer
	registration.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(source.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	registration.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(source.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	registration.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(source.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// OpenIdIssuer
	registration.OpenIdIssuer = genruntime.ClonePointerToString(source.OpenIdIssuer)

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryRegistration populates the provided destination AzureActiveDirectoryRegistration from our AzureActiveDirectoryRegistration
func (registration *AzureActiveDirectoryRegistration) AssignProperties_To_AzureActiveDirectoryRegistration(destination *storage.AzureActiveDirectoryRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretCertificateIssuer
	destination.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(registration.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	destination.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(registration.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	destination.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(registration.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// OpenIdIssuer
	destination.OpenIdIssuer = genruntime.ClonePointerToString(registration.OpenIdIssuer)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureActiveDirectoryRegistration_STATUS populates our AzureActiveDirectoryRegistration from the provided source AzureActiveDirectoryRegistration_STATUS
func (registration *AzureActiveDirectoryRegistration) Initialize_From_AzureActiveDirectoryRegistration_STATUS(source *AzureActiveDirectoryRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretCertificateIssuer
	registration.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(source.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	registration.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(source.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	registration.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(source.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// OpenIdIssuer
	registration.OpenIdIssuer = genruntime.ClonePointerToString(source.OpenIdIssuer)

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory app registration.
type AzureActiveDirectoryRegistration_STATUS struct {
	// ClientId: The Client ID of this relying party application, known as the client_id.
	// This setting is required for enabling OpenID Connection authentication with Azure Active Directory or
	// other 3rd party OpenID Connect providers.
	// More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecretCertificateIssuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used
	// for signing purposes. This property acts as
	// a replacement for the Client Secret Certificate Thumbprint. It is also optional.
	ClientSecretCertificateIssuer *string `json:"clientSecretCertificateIssuer,omitempty"`

	// ClientSecretCertificateSubjectAlternativeName: An alternative to the client secret thumbprint, that is the subject
	// alternative name of a certificate used for signing purposes. This property acts as
	// a replacement for the Client Secret Certificate Thumbprint. It is also optional.
	ClientSecretCertificateSubjectAlternativeName *string `json:"clientSecretCertificateSubjectAlternativeName,omitempty"`

	// ClientSecretCertificateThumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for
	// signing purposes. This property acts as
	// a replacement for the Client Secret. It is also optional.
	ClientSecretCertificateThumbprint *string `json:"clientSecretCertificateThumbprint,omitempty"`

	// ClientSecretSettingName: The app setting name that contains the client secret of the relying party application.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`

	// OpenIdIssuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
	// When using Azure Active Directory, this value is the URI of the directory tenant, e.g.
	// `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
	// This URI is a case-sensitive identifier for the token issuer.
	// More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
	OpenIdIssuer *string `json:"openIdIssuer,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureActiveDirectoryRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AzureActiveDirectoryRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectoryRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AzureActiveDirectoryRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectoryRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectoryRegistration_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "ClientSecretCertificateIssuer":
	if typedInput.ClientSecretCertificateIssuer != nil {
		clientSecretCertificateIssuer := *typedInput.ClientSecretCertificateIssuer
		registration.ClientSecretCertificateIssuer = &clientSecretCertificateIssuer
	}

	// Set property "ClientSecretCertificateSubjectAlternativeName":
	if typedInput.ClientSecretCertificateSubjectAlternativeName != nil {
		clientSecretCertificateSubjectAlternativeName := *typedInput.ClientSecretCertificateSubjectAlternativeName
		registration.ClientSecretCertificateSubjectAlternativeName = &clientSecretCertificateSubjectAlternativeName
	}

	// Set property "ClientSecretCertificateThumbprint":
	if typedInput.ClientSecretCertificateThumbprint != nil {
		clientSecretCertificateThumbprint := *typedInput.ClientSecretCertificateThumbprint
		registration.ClientSecretCertificateThumbprint = &clientSecretCertificateThumbprint
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		registration.ClientSecretSettingName = &clientSecretSettingName
	}

	// Set property "OpenIdIssuer":
	if typedInput.OpenIdIssuer != nil {
		openIdIssuer := *typedInput.OpenIdIssuer
		registration.OpenIdIssuer = &openIdIssuer
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectoryRegistration_STATUS populates our AzureActiveDirectoryRegistration_STATUS from the provided source AzureActiveDirectoryRegistration_STATUS
func (registration *AzureActiveDirectoryRegistration_STATUS) AssignProperties_From_AzureActiveDirectoryRegistration_STATUS(source *storage.AzureActiveDirectoryRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretCertificateIssuer
	registration.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(source.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	registration.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(source.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	registration.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(source.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// OpenIdIssuer
	registration.OpenIdIssuer = genruntime.ClonePointerToString(source.OpenIdIssuer)

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryRegistration_STATUS populates the provided destination AzureActiveDirectoryRegistration_STATUS from our AzureActiveDirectoryRegistration_STATUS
func (registration *AzureActiveDirectoryRegistration_STATUS) AssignProperties_To_AzureActiveDirectoryRegistration_STATUS(destination *storage.AzureActiveDirectoryRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretCertificateIssuer
	destination.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(registration.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	destination.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(registration.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	destination.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(registration.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// OpenIdIssuer
	destination.OpenIdIssuer = genruntime.ClonePointerToString(registration.OpenIdIssuer)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory token validation flow.
type AzureActiveDirectoryValidation struct {
	// AllowedAudiences: The list of audiences that can make successful authentication/authorization requests.
	AllowedAudiences []string `json:"allowedAudiences,omitempty"`

	// DefaultAuthorizationPolicy: The configuration settings of the default authorization policy.
	DefaultAuthorizationPolicy *DefaultAuthorizationPolicy `json:"defaultAuthorizationPolicy,omitempty"`

	// JwtClaimChecks: The configuration settings of the checks that should be made while validating the JWT Claims.
	JwtClaimChecks *JwtClaimChecks `json:"jwtClaimChecks,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureActiveDirectoryValidation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (validation *AzureActiveDirectoryValidation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if validation == nil {
		return nil, nil
	}
	result := &arm.AzureActiveDirectoryValidation{}

	// Set property "AllowedAudiences":
	for _, item := range validation.AllowedAudiences {
		result.AllowedAudiences = append(result.AllowedAudiences, item)
	}

	// Set property "DefaultAuthorizationPolicy":
	if validation.DefaultAuthorizationPolicy != nil {
		defaultAuthorizationPolicy_ARM, err := (*validation.DefaultAuthorizationPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultAuthorizationPolicy := *defaultAuthorizationPolicy_ARM.(*arm.DefaultAuthorizationPolicy)
		result.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	}

	// Set property "JwtClaimChecks":
	if validation.JwtClaimChecks != nil {
		jwtClaimChecks_ARM, err := (*validation.JwtClaimChecks).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		jwtClaimChecks := *jwtClaimChecks_ARM.(*arm.JwtClaimChecks)
		result.JwtClaimChecks = &jwtClaimChecks
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (validation *AzureActiveDirectoryValidation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectoryValidation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (validation *AzureActiveDirectoryValidation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectoryValidation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectoryValidation, got %T", armInput)
	}

	// Set property "AllowedAudiences":
	for _, item := range typedInput.AllowedAudiences {
		validation.AllowedAudiences = append(validation.AllowedAudiences, item)
	}

	// Set property "DefaultAuthorizationPolicy":
	if typedInput.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy1 DefaultAuthorizationPolicy
		err := defaultAuthorizationPolicy1.PopulateFromARM(owner, *typedInput.DefaultAuthorizationPolicy)
		if err != nil {
			return err
		}
		defaultAuthorizationPolicy := defaultAuthorizationPolicy1
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	}

	// Set property "JwtClaimChecks":
	if typedInput.JwtClaimChecks != nil {
		var jwtClaimChecks1 JwtClaimChecks
		err := jwtClaimChecks1.PopulateFromARM(owner, *typedInput.JwtClaimChecks)
		if err != nil {
			return err
		}
		jwtClaimChecks := jwtClaimChecks1
		validation.JwtClaimChecks = &jwtClaimChecks
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectoryValidation populates our AzureActiveDirectoryValidation from the provided source AzureActiveDirectoryValidation
func (validation *AzureActiveDirectoryValidation) AssignProperties_From_AzureActiveDirectoryValidation(source *storage.AzureActiveDirectoryValidation) error {

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if source.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy DefaultAuthorizationPolicy
		err := defaultAuthorizationPolicy.AssignProperties_From_DefaultAuthorizationPolicy(source.DefaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DefaultAuthorizationPolicy() to populate field DefaultAuthorizationPolicy")
		}
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		validation.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if source.JwtClaimChecks != nil {
		var jwtClaimCheck JwtClaimChecks
		err := jwtClaimCheck.AssignProperties_From_JwtClaimChecks(source.JwtClaimChecks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JwtClaimChecks() to populate field JwtClaimChecks")
		}
		validation.JwtClaimChecks = &jwtClaimCheck
	} else {
		validation.JwtClaimChecks = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryValidation populates the provided destination AzureActiveDirectoryValidation from our AzureActiveDirectoryValidation
func (validation *AzureActiveDirectoryValidation) AssignProperties_To_AzureActiveDirectoryValidation(destination *storage.AzureActiveDirectoryValidation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if validation.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy storage.DefaultAuthorizationPolicy
		err := validation.DefaultAuthorizationPolicy.AssignProperties_To_DefaultAuthorizationPolicy(&defaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DefaultAuthorizationPolicy() to populate field DefaultAuthorizationPolicy")
		}
		destination.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		destination.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if validation.JwtClaimChecks != nil {
		var jwtClaimCheck storage.JwtClaimChecks
		err := validation.JwtClaimChecks.AssignProperties_To_JwtClaimChecks(&jwtClaimCheck)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JwtClaimChecks() to populate field JwtClaimChecks")
		}
		destination.JwtClaimChecks = &jwtClaimCheck
	} else {
		destination.JwtClaimChecks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureActiveDirectoryValidation_STATUS populates our AzureActiveDirectoryValidation from the provided source AzureActiveDirectoryValidation_STATUS
func (validation *AzureActiveDirectoryValidation) Initialize_From_AzureActiveDirectoryValidation_STATUS(source *AzureActiveDirectoryValidation_STATUS) error {

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if source.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy DefaultAuthorizationPolicy
		err := defaultAuthorizationPolicy.Initialize_From_DefaultAuthorizationPolicy_STATUS(source.DefaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DefaultAuthorizationPolicy_STATUS() to populate field DefaultAuthorizationPolicy")
		}
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		validation.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if source.JwtClaimChecks != nil {
		var jwtClaimCheck JwtClaimChecks
		err := jwtClaimCheck.Initialize_From_JwtClaimChecks_STATUS(source.JwtClaimChecks)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JwtClaimChecks_STATUS() to populate field JwtClaimChecks")
		}
		validation.JwtClaimChecks = &jwtClaimCheck
	} else {
		validation.JwtClaimChecks = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory token validation flow.
type AzureActiveDirectoryValidation_STATUS struct {
	// AllowedAudiences: The list of audiences that can make successful authentication/authorization requests.
	AllowedAudiences []string `json:"allowedAudiences,omitempty"`

	// DefaultAuthorizationPolicy: The configuration settings of the default authorization policy.
	DefaultAuthorizationPolicy *DefaultAuthorizationPolicy_STATUS `json:"defaultAuthorizationPolicy,omitempty"`

	// JwtClaimChecks: The configuration settings of the checks that should be made while validating the JWT Claims.
	JwtClaimChecks *JwtClaimChecks_STATUS `json:"jwtClaimChecks,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureActiveDirectoryValidation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (validation *AzureActiveDirectoryValidation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureActiveDirectoryValidation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (validation *AzureActiveDirectoryValidation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureActiveDirectoryValidation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureActiveDirectoryValidation_STATUS, got %T", armInput)
	}

	// Set property "AllowedAudiences":
	for _, item := range typedInput.AllowedAudiences {
		validation.AllowedAudiences = append(validation.AllowedAudiences, item)
	}

	// Set property "DefaultAuthorizationPolicy":
	if typedInput.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy1 DefaultAuthorizationPolicy_STATUS
		err := defaultAuthorizationPolicy1.PopulateFromARM(owner, *typedInput.DefaultAuthorizationPolicy)
		if err != nil {
			return err
		}
		defaultAuthorizationPolicy := defaultAuthorizationPolicy1
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	}

	// Set property "JwtClaimChecks":
	if typedInput.JwtClaimChecks != nil {
		var jwtClaimChecks1 JwtClaimChecks_STATUS
		err := jwtClaimChecks1.PopulateFromARM(owner, *typedInput.JwtClaimChecks)
		if err != nil {
			return err
		}
		jwtClaimChecks := jwtClaimChecks1
		validation.JwtClaimChecks = &jwtClaimChecks
	}

	// No error
	return nil
}

// AssignProperties_From_AzureActiveDirectoryValidation_STATUS populates our AzureActiveDirectoryValidation_STATUS from the provided source AzureActiveDirectoryValidation_STATUS
func (validation *AzureActiveDirectoryValidation_STATUS) AssignProperties_From_AzureActiveDirectoryValidation_STATUS(source *storage.AzureActiveDirectoryValidation_STATUS) error {

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if source.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy DefaultAuthorizationPolicy_STATUS
		err := defaultAuthorizationPolicy.AssignProperties_From_DefaultAuthorizationPolicy_STATUS(source.DefaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DefaultAuthorizationPolicy_STATUS() to populate field DefaultAuthorizationPolicy")
		}
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		validation.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if source.JwtClaimChecks != nil {
		var jwtClaimCheck JwtClaimChecks_STATUS
		err := jwtClaimCheck.AssignProperties_From_JwtClaimChecks_STATUS(source.JwtClaimChecks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JwtClaimChecks_STATUS() to populate field JwtClaimChecks")
		}
		validation.JwtClaimChecks = &jwtClaimCheck
	} else {
		validation.JwtClaimChecks = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryValidation_STATUS populates the provided destination AzureActiveDirectoryValidation_STATUS from our AzureActiveDirectoryValidation_STATUS
func (validation *AzureActiveDirectoryValidation_STATUS) AssignProperties_To_AzureActiveDirectoryValidation_STATUS(destination *storage.AzureActiveDirectoryValidation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if validation.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy storage.DefaultAuthorizationPolicy_STATUS
		err := validation.DefaultAuthorizationPolicy.AssignProperties_To_DefaultAuthorizationPolicy_STATUS(&defaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DefaultAuthorizationPolicy_STATUS() to populate field DefaultAuthorizationPolicy")
		}
		destination.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		destination.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if validation.JwtClaimChecks != nil {
		var jwtClaimCheck storage.JwtClaimChecks_STATUS
		err := validation.JwtClaimChecks.AssignProperties_To_JwtClaimChecks_STATUS(&jwtClaimCheck)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JwtClaimChecks_STATUS() to populate field JwtClaimChecks")
		}
		destination.JwtClaimChecks = &jwtClaimCheck
	} else {
		destination.JwtClaimChecks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the registration for the Azure Static Web Apps provider
type AzureStaticWebAppsRegistration struct {
	// ClientId: The Client ID of the app used for login.
	ClientId *string `json:"clientId,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureStaticWebAppsRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *AzureStaticWebAppsRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.AzureStaticWebAppsRegistration{}

	// Set property "ClientId":
	if registration.ClientId != nil {
		clientId := *registration.ClientId
		result.ClientId = &clientId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AzureStaticWebAppsRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureStaticWebAppsRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AzureStaticWebAppsRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureStaticWebAppsRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureStaticWebAppsRegistration, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStaticWebAppsRegistration populates our AzureStaticWebAppsRegistration from the provided source AzureStaticWebAppsRegistration
func (registration *AzureStaticWebAppsRegistration) AssignProperties_From_AzureStaticWebAppsRegistration(source *storage.AzureStaticWebAppsRegistration) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebAppsRegistration populates the provided destination AzureStaticWebAppsRegistration from our AzureStaticWebAppsRegistration
func (registration *AzureStaticWebAppsRegistration) AssignProperties_To_AzureStaticWebAppsRegistration(destination *storage.AzureStaticWebAppsRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureStaticWebAppsRegistration_STATUS populates our AzureStaticWebAppsRegistration from the provided source AzureStaticWebAppsRegistration_STATUS
func (registration *AzureStaticWebAppsRegistration) Initialize_From_AzureStaticWebAppsRegistration_STATUS(source *AzureStaticWebAppsRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// The configuration settings of the registration for the Azure Static Web Apps provider
type AzureStaticWebAppsRegistration_STATUS struct {
	// ClientId: The Client ID of the app used for login.
	ClientId *string `json:"clientId,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureStaticWebAppsRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *AzureStaticWebAppsRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureStaticWebAppsRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *AzureStaticWebAppsRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureStaticWebAppsRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureStaticWebAppsRegistration_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStaticWebAppsRegistration_STATUS populates our AzureStaticWebAppsRegistration_STATUS from the provided source AzureStaticWebAppsRegistration_STATUS
func (registration *AzureStaticWebAppsRegistration_STATUS) AssignProperties_From_AzureStaticWebAppsRegistration_STATUS(source *storage.AzureStaticWebAppsRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebAppsRegistration_STATUS populates the provided destination AzureStaticWebAppsRegistration_STATUS from our AzureStaticWebAppsRegistration_STATUS
func (registration *AzureStaticWebAppsRegistration_STATUS) AssignProperties_To_AzureStaticWebAppsRegistration_STATUS(destination *storage.AzureStaticWebAppsRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the storage of the tokens if blob storage is used.
type BlobStorageTokenStore struct {
	// +kubebuilder:validation:Required
	// SasUrlSettingName: The name of the app secrets containing the SAS URL of the blob storage containing the tokens.
	SasUrlSettingName *string `json:"sasUrlSettingName,omitempty"`
}

var _ genruntime.ARMTransformer = &BlobStorageTokenStore{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (store *BlobStorageTokenStore) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if store == nil {
		return nil, nil
	}
	result := &arm.BlobStorageTokenStore{}

	// Set property "SasUrlSettingName":
	if store.SasUrlSettingName != nil {
		sasUrlSettingName := *store.SasUrlSettingName
		result.SasUrlSettingName = &sasUrlSettingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (store *BlobStorageTokenStore) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BlobStorageTokenStore{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (store *BlobStorageTokenStore) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BlobStorageTokenStore)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BlobStorageTokenStore, got %T", armInput)
	}

	// Set property "SasUrlSettingName":
	if typedInput.SasUrlSettingName != nil {
		sasUrlSettingName := *typedInput.SasUrlSettingName
		store.SasUrlSettingName = &sasUrlSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_BlobStorageTokenStore populates our BlobStorageTokenStore from the provided source BlobStorageTokenStore
func (store *BlobStorageTokenStore) AssignProperties_From_BlobStorageTokenStore(source *storage.BlobStorageTokenStore) error {

	// SasUrlSettingName
	store.SasUrlSettingName = genruntime.ClonePointerToString(source.SasUrlSettingName)

	// No error
	return nil
}

// AssignProperties_To_BlobStorageTokenStore populates the provided destination BlobStorageTokenStore from our BlobStorageTokenStore
func (store *BlobStorageTokenStore) AssignProperties_To_BlobStorageTokenStore(destination *storage.BlobStorageTokenStore) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SasUrlSettingName
	destination.SasUrlSettingName = genruntime.ClonePointerToString(store.SasUrlSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BlobStorageTokenStore_STATUS populates our BlobStorageTokenStore from the provided source BlobStorageTokenStore_STATUS
func (store *BlobStorageTokenStore) Initialize_From_BlobStorageTokenStore_STATUS(source *BlobStorageTokenStore_STATUS) error {

	// SasUrlSettingName
	store.SasUrlSettingName = genruntime.ClonePointerToString(source.SasUrlSettingName)

	// No error
	return nil
}

// The configuration settings of the storage of the tokens if blob storage is used.
type BlobStorageTokenStore_STATUS struct {
	// SasUrlSettingName: The name of the app secrets containing the SAS URL of the blob storage containing the tokens.
	SasUrlSettingName *string `json:"sasUrlSettingName,omitempty"`
}

var _ genruntime.FromARMConverter = &BlobStorageTokenStore_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (store *BlobStorageTokenStore_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BlobStorageTokenStore_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (store *BlobStorageTokenStore_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BlobStorageTokenStore_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BlobStorageTokenStore_STATUS, got %T", armInput)
	}

	// Set property "SasUrlSettingName":
	if typedInput.SasUrlSettingName != nil {
		sasUrlSettingName := *typedInput.SasUrlSettingName
		store.SasUrlSettingName = &sasUrlSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_BlobStorageTokenStore_STATUS populates our BlobStorageTokenStore_STATUS from the provided source BlobStorageTokenStore_STATUS
func (store *BlobStorageTokenStore_STATUS) AssignProperties_From_BlobStorageTokenStore_STATUS(source *storage.BlobStorageTokenStore_STATUS) error {

	// SasUrlSettingName
	store.SasUrlSettingName = genruntime.ClonePointerToString(source.SasUrlSettingName)

	// No error
	return nil
}

// AssignProperties_To_BlobStorageTokenStore_STATUS populates the provided destination BlobStorageTokenStore_STATUS from our BlobStorageTokenStore_STATUS
func (store *BlobStorageTokenStore_STATUS) AssignProperties_To_BlobStorageTokenStore_STATUS(destination *storage.BlobStorageTokenStore_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SasUrlSettingName
	destination.SasUrlSettingName = genruntime.ClonePointerToString(store.SasUrlSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the app registration for providers that have client ids and client secrets
type ClientRegistration struct {
	// ClientId: The Client ID of the app used for login.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecretSettingName: The app setting name that contains the client secret.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

var _ genruntime.ARMTransformer = &ClientRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *ClientRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.ClientRegistration{}

	// Set property "ClientId":
	if registration.ClientId != nil {
		clientId := *registration.ClientId
		result.ClientId = &clientId
	}

	// Set property "ClientSecretSettingName":
	if registration.ClientSecretSettingName != nil {
		clientSecretSettingName := *registration.ClientSecretSettingName
		result.ClientSecretSettingName = &clientSecretSettingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *ClientRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClientRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *ClientRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClientRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClientRegistration, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		registration.ClientSecretSettingName = &clientSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_ClientRegistration populates our ClientRegistration from the provided source ClientRegistration
func (registration *ClientRegistration) AssignProperties_From_ClientRegistration(source *storage.ClientRegistration) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_ClientRegistration populates the provided destination ClientRegistration from our ClientRegistration
func (registration *ClientRegistration) AssignProperties_To_ClientRegistration(destination *storage.ClientRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClientRegistration_STATUS populates our ClientRegistration from the provided source ClientRegistration_STATUS
func (registration *ClientRegistration) Initialize_From_ClientRegistration_STATUS(source *ClientRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// No error
	return nil
}

// The configuration settings of the app registration for providers that have client ids and client secrets
type ClientRegistration_STATUS struct {
	// ClientId: The Client ID of the app used for login.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecretSettingName: The app setting name that contains the client secret.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`
}

var _ genruntime.FromARMConverter = &ClientRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *ClientRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClientRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *ClientRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClientRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClientRegistration_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		registration.ClientSecretSettingName = &clientSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_ClientRegistration_STATUS populates our ClientRegistration_STATUS from the provided source ClientRegistration_STATUS
func (registration *ClientRegistration_STATUS) AssignProperties_From_ClientRegistration_STATUS(source *storage.ClientRegistration_STATUS) error {

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_ClientRegistration_STATUS populates the provided destination ClientRegistration_STATUS from our ClientRegistration_STATUS
func (registration *ClientRegistration_STATUS) AssignProperties_To_ClientRegistration_STATUS(destination *storage.ClientRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"FixedTime","IdentityProviderDerived"}
type CookieExpiration_Convention string

const (
	CookieExpiration_Convention_FixedTime               = CookieExpiration_Convention("FixedTime")
	CookieExpiration_Convention_IdentityProviderDerived = CookieExpiration_Convention("IdentityProviderDerived")
)

// Mapping from string to CookieExpiration_Convention
var cookieExpiration_Convention_Values = map[string]CookieExpiration_Convention{
	"fixedtime":               CookieExpiration_Convention_FixedTime,
	"identityproviderderived": CookieExpiration_Convention_IdentityProviderDerived,
}

type CookieExpiration_Convention_STATUS string

const (
	CookieExpiration_Convention_STATUS_FixedTime               = CookieExpiration_Convention_STATUS("FixedTime")
	CookieExpiration_Convention_STATUS_IdentityProviderDerived = CookieExpiration_Convention_STATUS("IdentityProviderDerived")
)

// Mapping from string to CookieExpiration_Convention_STATUS
var cookieExpiration_Convention_STATUS_Values = map[string]CookieExpiration_Convention_STATUS{
	"fixedtime":               CookieExpiration_Convention_STATUS_FixedTime,
	"identityproviderderived": CookieExpiration_Convention_STATUS_IdentityProviderDerived,
}

// +kubebuilder:validation:Enum={"Custom","NoProxy","Standard"}
type ForwardProxy_Convention string

const (
	ForwardProxy_Convention_Custom   = ForwardProxy_Convention("Custom")
	ForwardProxy_Convention_NoProxy  = ForwardProxy_Convention("NoProxy")
	ForwardProxy_Convention_Standard = ForwardProxy_Convention("Standard")
)

// Mapping from string to ForwardProxy_Convention
var forwardProxy_Convention_Values = map[string]ForwardProxy_Convention{
	"custom":   ForwardProxy_Convention_Custom,
	"noproxy":  ForwardProxy_Convention_NoProxy,
	"standard": ForwardProxy_Convention_Standard,
}

type ForwardProxy_Convention_STATUS string

const (
	ForwardProxy_Convention_STATUS_Custom   = ForwardProxy_Convention_STATUS("Custom")
	ForwardProxy_Convention_STATUS_NoProxy  = ForwardProxy_Convention_STATUS("NoProxy")
	ForwardProxy_Convention_STATUS_Standard = ForwardProxy_Convention_STATUS("Standard")
)

// Mapping from string to ForwardProxy_Convention_STATUS
var forwardProxy_Convention_STATUS_Values = map[string]ForwardProxy_Convention_STATUS{
	"custom":   ForwardProxy_Convention_STATUS_Custom,
	"noproxy":  ForwardProxy_Convention_STATUS_NoProxy,
	"standard": ForwardProxy_Convention_STATUS_Standard,
}

// The configuration settings of the login flow, including the scopes that should be requested.
type LoginScopes struct {
	// Scopes: A list of the scopes that should be requested while authenticating.
	Scopes []string `json:"scopes,omitempty"`
}

var _ genruntime.ARMTransformer = &LoginScopes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scopes *LoginScopes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scopes == nil {
		return nil, nil
	}
	result := &arm.LoginScopes{}

	// Set property "Scopes":
	for _, item := range scopes.Scopes {
		result.Scopes = append(result.Scopes, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scopes *LoginScopes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LoginScopes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scopes *LoginScopes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LoginScopes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LoginScopes, got %T", armInput)
	}

	// Set property "Scopes":
	for _, item := range typedInput.Scopes {
		scopes.Scopes = append(scopes.Scopes, item)
	}

	// No error
	return nil
}

// AssignProperties_From_LoginScopes populates our LoginScopes from the provided source LoginScopes
func (scopes *LoginScopes) AssignProperties_From_LoginScopes(source *storage.LoginScopes) error {

	// Scopes
	scopes.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// No error
	return nil
}

// AssignProperties_To_LoginScopes populates the provided destination LoginScopes from our LoginScopes
func (scopes *LoginScopes) AssignProperties_To_LoginScopes(destination *storage.LoginScopes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(scopes.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LoginScopes_STATUS populates our LoginScopes from the provided source LoginScopes_STATUS
func (scopes *LoginScopes) Initialize_From_LoginScopes_STATUS(source *LoginScopes_STATUS) error {

	// Scopes
	scopes.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// No error
	return nil
}

// The configuration settings of the login flow, including the scopes that should be requested.
type LoginScopes_STATUS struct {
	// Scopes: A list of the scopes that should be requested while authenticating.
	Scopes []string `json:"scopes,omitempty"`
}

var _ genruntime.FromARMConverter = &LoginScopes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scopes *LoginScopes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LoginScopes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scopes *LoginScopes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LoginScopes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LoginScopes_STATUS, got %T", armInput)
	}

	// Set property "Scopes":
	for _, item := range typedInput.Scopes {
		scopes.Scopes = append(scopes.Scopes, item)
	}

	// No error
	return nil
}

// AssignProperties_From_LoginScopes_STATUS populates our LoginScopes_STATUS from the provided source LoginScopes_STATUS
func (scopes *LoginScopes_STATUS) AssignProperties_From_LoginScopes_STATUS(source *storage.LoginScopes_STATUS) error {

	// Scopes
	scopes.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// No error
	return nil
}

// AssignProperties_To_LoginScopes_STATUS populates the provided destination LoginScopes_STATUS from our LoginScopes_STATUS
func (scopes *LoginScopes_STATUS) AssignProperties_To_LoginScopes_STATUS(destination *storage.LoginScopes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(scopes.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the login flow of the custom Open ID Connect provider.
type OpenIdConnectLogin struct {
	// NameClaimType: The name of the claim that contains the users name.
	NameClaimType *string `json:"nameClaimType,omitempty"`

	// Scopes: A list of the scopes that should be requested while authenticating.
	Scopes []string `json:"scopes,omitempty"`
}

var _ genruntime.ARMTransformer = &OpenIdConnectLogin{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (login *OpenIdConnectLogin) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if login == nil {
		return nil, nil
	}
	result := &arm.OpenIdConnectLogin{}

	// Set property "NameClaimType":
	if login.NameClaimType != nil {
		nameClaimType := *login.NameClaimType
		result.NameClaimType = &nameClaimType
	}

	// Set property "Scopes":
	for _, item := range login.Scopes {
		result.Scopes = append(result.Scopes, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (login *OpenIdConnectLogin) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectLogin{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (login *OpenIdConnectLogin) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectLogin)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectLogin, got %T", armInput)
	}

	// Set property "NameClaimType":
	if typedInput.NameClaimType != nil {
		nameClaimType := *typedInput.NameClaimType
		login.NameClaimType = &nameClaimType
	}

	// Set property "Scopes":
	for _, item := range typedInput.Scopes {
		login.Scopes = append(login.Scopes, item)
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectLogin populates our OpenIdConnectLogin from the provided source OpenIdConnectLogin
func (login *OpenIdConnectLogin) AssignProperties_From_OpenIdConnectLogin(source *storage.OpenIdConnectLogin) error {

	// NameClaimType
	login.NameClaimType = genruntime.ClonePointerToString(source.NameClaimType)

	// Scopes
	login.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectLogin populates the provided destination OpenIdConnectLogin from our OpenIdConnectLogin
func (login *OpenIdConnectLogin) AssignProperties_To_OpenIdConnectLogin(destination *storage.OpenIdConnectLogin) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameClaimType
	destination.NameClaimType = genruntime.ClonePointerToString(login.NameClaimType)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(login.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OpenIdConnectLogin_STATUS populates our OpenIdConnectLogin from the provided source OpenIdConnectLogin_STATUS
func (login *OpenIdConnectLogin) Initialize_From_OpenIdConnectLogin_STATUS(source *OpenIdConnectLogin_STATUS) error {

	// NameClaimType
	login.NameClaimType = genruntime.ClonePointerToString(source.NameClaimType)

	// Scopes
	login.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// No error
	return nil
}

// The configuration settings of the login flow of the custom Open ID Connect provider.
type OpenIdConnectLogin_STATUS struct {
	// NameClaimType: The name of the claim that contains the users name.
	NameClaimType *string `json:"nameClaimType,omitempty"`

	// Scopes: A list of the scopes that should be requested while authenticating.
	Scopes []string `json:"scopes,omitempty"`
}

var _ genruntime.FromARMConverter = &OpenIdConnectLogin_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (login *OpenIdConnectLogin_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectLogin_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (login *OpenIdConnectLogin_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectLogin_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectLogin_STATUS, got %T", armInput)
	}

	// Set property "NameClaimType":
	if typedInput.NameClaimType != nil {
		nameClaimType := *typedInput.NameClaimType
		login.NameClaimType = &nameClaimType
	}

	// Set property "Scopes":
	for _, item := range typedInput.Scopes {
		login.Scopes = append(login.Scopes, item)
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectLogin_STATUS populates our OpenIdConnectLogin_STATUS from the provided source OpenIdConnectLogin_STATUS
func (login *OpenIdConnectLogin_STATUS) AssignProperties_From_OpenIdConnectLogin_STATUS(source *storage.OpenIdConnectLogin_STATUS) error {

	// NameClaimType
	login.NameClaimType = genruntime.ClonePointerToString(source.NameClaimType)

	// Scopes
	login.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectLogin_STATUS populates the provided destination OpenIdConnectLogin_STATUS from our OpenIdConnectLogin_STATUS
func (login *OpenIdConnectLogin_STATUS) AssignProperties_To_OpenIdConnectLogin_STATUS(destination *storage.OpenIdConnectLogin_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameClaimType
	destination.NameClaimType = genruntime.ClonePointerToString(login.NameClaimType)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(login.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the app registration for the custom Open ID Connect provider.
type OpenIdConnectRegistration struct {
	// ClientCredential: The authentication credentials of the custom Open ID Connect provider.
	ClientCredential *OpenIdConnectClientCredential `json:"clientCredential,omitempty"`

	// ClientId: The client id of the custom Open ID Connect provider.
	ClientId *string `json:"clientId,omitempty"`

	// OpenIdConnectConfiguration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
	OpenIdConnectConfiguration *OpenIdConnectConfig `json:"openIdConnectConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &OpenIdConnectRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *OpenIdConnectRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.OpenIdConnectRegistration{}

	// Set property "ClientCredential":
	if registration.ClientCredential != nil {
		clientCredential_ARM, err := (*registration.ClientCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		clientCredential := *clientCredential_ARM.(*arm.OpenIdConnectClientCredential)
		result.ClientCredential = &clientCredential
	}

	// Set property "ClientId":
	if registration.ClientId != nil {
		clientId := *registration.ClientId
		result.ClientId = &clientId
	}

	// Set property "OpenIdConnectConfiguration":
	if registration.OpenIdConnectConfiguration != nil {
		openIdConnectConfiguration_ARM, err := (*registration.OpenIdConnectConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		openIdConnectConfiguration := *openIdConnectConfiguration_ARM.(*arm.OpenIdConnectConfig)
		result.OpenIdConnectConfiguration = &openIdConnectConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *OpenIdConnectRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *OpenIdConnectRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectRegistration, got %T", armInput)
	}

	// Set property "ClientCredential":
	if typedInput.ClientCredential != nil {
		var clientCredential1 OpenIdConnectClientCredential
		err := clientCredential1.PopulateFromARM(owner, *typedInput.ClientCredential)
		if err != nil {
			return err
		}
		clientCredential := clientCredential1
		registration.ClientCredential = &clientCredential
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "OpenIdConnectConfiguration":
	if typedInput.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration1 OpenIdConnectConfig
		err := openIdConnectConfiguration1.PopulateFromARM(owner, *typedInput.OpenIdConnectConfiguration)
		if err != nil {
			return err
		}
		openIdConnectConfiguration := openIdConnectConfiguration1
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectRegistration populates our OpenIdConnectRegistration from the provided source OpenIdConnectRegistration
func (registration *OpenIdConnectRegistration) AssignProperties_From_OpenIdConnectRegistration(source *storage.OpenIdConnectRegistration) error {

	// ClientCredential
	if source.ClientCredential != nil {
		var clientCredential OpenIdConnectClientCredential
		err := clientCredential.AssignProperties_From_OpenIdConnectClientCredential(source.ClientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectClientCredential() to populate field ClientCredential")
		}
		registration.ClientCredential = &clientCredential
	} else {
		registration.ClientCredential = nil
	}

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// OpenIdConnectConfiguration
	if source.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration OpenIdConnectConfig
		err := openIdConnectConfiguration.AssignProperties_From_OpenIdConnectConfig(source.OpenIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectConfig() to populate field OpenIdConnectConfiguration")
		}
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		registration.OpenIdConnectConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectRegistration populates the provided destination OpenIdConnectRegistration from our OpenIdConnectRegistration
func (registration *OpenIdConnectRegistration) AssignProperties_To_OpenIdConnectRegistration(destination *storage.OpenIdConnectRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCredential
	if registration.ClientCredential != nil {
		var clientCredential storage.OpenIdConnectClientCredential
		err := registration.ClientCredential.AssignProperties_To_OpenIdConnectClientCredential(&clientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectClientCredential() to populate field ClientCredential")
		}
		destination.ClientCredential = &clientCredential
	} else {
		destination.ClientCredential = nil
	}

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// OpenIdConnectConfiguration
	if registration.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration storage.OpenIdConnectConfig
		err := registration.OpenIdConnectConfiguration.AssignProperties_To_OpenIdConnectConfig(&openIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectConfig() to populate field OpenIdConnectConfiguration")
		}
		destination.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		destination.OpenIdConnectConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OpenIdConnectRegistration_STATUS populates our OpenIdConnectRegistration from the provided source OpenIdConnectRegistration_STATUS
func (registration *OpenIdConnectRegistration) Initialize_From_OpenIdConnectRegistration_STATUS(source *OpenIdConnectRegistration_STATUS) error {

	// ClientCredential
	if source.ClientCredential != nil {
		var clientCredential OpenIdConnectClientCredential
		err := clientCredential.Initialize_From_OpenIdConnectClientCredential_STATUS(source.ClientCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OpenIdConnectClientCredential_STATUS() to populate field ClientCredential")
		}
		registration.ClientCredential = &clientCredential
	} else {
		registration.ClientCredential = nil
	}

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// OpenIdConnectConfiguration
	if source.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration OpenIdConnectConfig
		err := openIdConnectConfiguration.Initialize_From_OpenIdConnectConfig_STATUS(source.OpenIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OpenIdConnectConfig_STATUS() to populate field OpenIdConnectConfiguration")
		}
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		registration.OpenIdConnectConfiguration = nil
	}

	// No error
	return nil
}

// The configuration settings of the app registration for the custom Open ID Connect provider.
type OpenIdConnectRegistration_STATUS struct {
	// ClientCredential: The authentication credentials of the custom Open ID Connect provider.
	ClientCredential *OpenIdConnectClientCredential_STATUS `json:"clientCredential,omitempty"`

	// ClientId: The client id of the custom Open ID Connect provider.
	ClientId *string `json:"clientId,omitempty"`

	// OpenIdConnectConfiguration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
	OpenIdConnectConfiguration *OpenIdConnectConfig_STATUS `json:"openIdConnectConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &OpenIdConnectRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *OpenIdConnectRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *OpenIdConnectRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectRegistration_STATUS, got %T", armInput)
	}

	// Set property "ClientCredential":
	if typedInput.ClientCredential != nil {
		var clientCredential1 OpenIdConnectClientCredential_STATUS
		err := clientCredential1.PopulateFromARM(owner, *typedInput.ClientCredential)
		if err != nil {
			return err
		}
		clientCredential := clientCredential1
		registration.ClientCredential = &clientCredential
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		registration.ClientId = &clientId
	}

	// Set property "OpenIdConnectConfiguration":
	if typedInput.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration1 OpenIdConnectConfig_STATUS
		err := openIdConnectConfiguration1.PopulateFromARM(owner, *typedInput.OpenIdConnectConfiguration)
		if err != nil {
			return err
		}
		openIdConnectConfiguration := openIdConnectConfiguration1
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectRegistration_STATUS populates our OpenIdConnectRegistration_STATUS from the provided source OpenIdConnectRegistration_STATUS
func (registration *OpenIdConnectRegistration_STATUS) AssignProperties_From_OpenIdConnectRegistration_STATUS(source *storage.OpenIdConnectRegistration_STATUS) error {

	// ClientCredential
	if source.ClientCredential != nil {
		var clientCredential OpenIdConnectClientCredential_STATUS
		err := clientCredential.AssignProperties_From_OpenIdConnectClientCredential_STATUS(source.ClientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectClientCredential_STATUS() to populate field ClientCredential")
		}
		registration.ClientCredential = &clientCredential
	} else {
		registration.ClientCredential = nil
	}

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// OpenIdConnectConfiguration
	if source.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration OpenIdConnectConfig_STATUS
		err := openIdConnectConfiguration.AssignProperties_From_OpenIdConnectConfig_STATUS(source.OpenIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectConfig_STATUS() to populate field OpenIdConnectConfiguration")
		}
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		registration.OpenIdConnectConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectRegistration_STATUS populates the provided destination OpenIdConnectRegistration_STATUS from our OpenIdConnectRegistration_STATUS
func (registration *OpenIdConnectRegistration_STATUS) AssignProperties_To_OpenIdConnectRegistration_STATUS(destination *storage.OpenIdConnectRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCredential
	if registration.ClientCredential != nil {
		var clientCredential storage.OpenIdConnectClientCredential_STATUS
		err := registration.ClientCredential.AssignProperties_To_OpenIdConnectClientCredential_STATUS(&clientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectClientCredential_STATUS() to populate field ClientCredential")
		}
		destination.ClientCredential = &clientCredential
	} else {
		destination.ClientCredential = nil
	}

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// OpenIdConnectConfiguration
	if registration.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration storage.OpenIdConnectConfig_STATUS
		err := registration.OpenIdConnectConfiguration.AssignProperties_To_OpenIdConnectConfig_STATUS(&openIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectConfig_STATUS() to populate field OpenIdConnectConfiguration")
		}
		destination.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		destination.OpenIdConnectConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the app registration for the Twitter provider.
type TwitterRegistration struct {
	// ConsumerKey: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
	// This setting is required for enabling Twitter Sign-In.
	// Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
	ConsumerKey *string `json:"consumerKey,omitempty"`

	// ConsumerSecretSettingName: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
	// application used for sign-in.
	ConsumerSecretSettingName *string `json:"consumerSecretSettingName,omitempty"`
}

var _ genruntime.ARMTransformer = &TwitterRegistration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (registration *TwitterRegistration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if registration == nil {
		return nil, nil
	}
	result := &arm.TwitterRegistration{}

	// Set property "ConsumerKey":
	if registration.ConsumerKey != nil {
		consumerKey := *registration.ConsumerKey
		result.ConsumerKey = &consumerKey
	}

	// Set property "ConsumerSecretSettingName":
	if registration.ConsumerSecretSettingName != nil {
		consumerSecretSettingName := *registration.ConsumerSecretSettingName
		result.ConsumerSecretSettingName = &consumerSecretSettingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *TwitterRegistration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TwitterRegistration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *TwitterRegistration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TwitterRegistration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TwitterRegistration, got %T", armInput)
	}

	// Set property "ConsumerKey":
	if typedInput.ConsumerKey != nil {
		consumerKey := *typedInput.ConsumerKey
		registration.ConsumerKey = &consumerKey
	}

	// Set property "ConsumerSecretSettingName":
	if typedInput.ConsumerSecretSettingName != nil {
		consumerSecretSettingName := *typedInput.ConsumerSecretSettingName
		registration.ConsumerSecretSettingName = &consumerSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_TwitterRegistration populates our TwitterRegistration from the provided source TwitterRegistration
func (registration *TwitterRegistration) AssignProperties_From_TwitterRegistration(source *storage.TwitterRegistration) error {

	// ConsumerKey
	registration.ConsumerKey = genruntime.ClonePointerToString(source.ConsumerKey)

	// ConsumerSecretSettingName
	registration.ConsumerSecretSettingName = genruntime.ClonePointerToString(source.ConsumerSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_TwitterRegistration populates the provided destination TwitterRegistration from our TwitterRegistration
func (registration *TwitterRegistration) AssignProperties_To_TwitterRegistration(destination *storage.TwitterRegistration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsumerKey
	destination.ConsumerKey = genruntime.ClonePointerToString(registration.ConsumerKey)

	// ConsumerSecretSettingName
	destination.ConsumerSecretSettingName = genruntime.ClonePointerToString(registration.ConsumerSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TwitterRegistration_STATUS populates our TwitterRegistration from the provided source TwitterRegistration_STATUS
func (registration *TwitterRegistration) Initialize_From_TwitterRegistration_STATUS(source *TwitterRegistration_STATUS) error {

	// ConsumerKey
	registration.ConsumerKey = genruntime.ClonePointerToString(source.ConsumerKey)

	// ConsumerSecretSettingName
	registration.ConsumerSecretSettingName = genruntime.ClonePointerToString(source.ConsumerSecretSettingName)

	// No error
	return nil
}

// The configuration settings of the app registration for the Twitter provider.
type TwitterRegistration_STATUS struct {
	// ConsumerKey: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
	// This setting is required for enabling Twitter Sign-In.
	// Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
	ConsumerKey *string `json:"consumerKey,omitempty"`

	// ConsumerSecretSettingName: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
	// application used for sign-in.
	ConsumerSecretSettingName *string `json:"consumerSecretSettingName,omitempty"`
}

var _ genruntime.FromARMConverter = &TwitterRegistration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (registration *TwitterRegistration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TwitterRegistration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (registration *TwitterRegistration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TwitterRegistration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TwitterRegistration_STATUS, got %T", armInput)
	}

	// Set property "ConsumerKey":
	if typedInput.ConsumerKey != nil {
		consumerKey := *typedInput.ConsumerKey
		registration.ConsumerKey = &consumerKey
	}

	// Set property "ConsumerSecretSettingName":
	if typedInput.ConsumerSecretSettingName != nil {
		consumerSecretSettingName := *typedInput.ConsumerSecretSettingName
		registration.ConsumerSecretSettingName = &consumerSecretSettingName
	}

	// No error
	return nil
}

// AssignProperties_From_TwitterRegistration_STATUS populates our TwitterRegistration_STATUS from the provided source TwitterRegistration_STATUS
func (registration *TwitterRegistration_STATUS) AssignProperties_From_TwitterRegistration_STATUS(source *storage.TwitterRegistration_STATUS) error {

	// ConsumerKey
	registration.ConsumerKey = genruntime.ClonePointerToString(source.ConsumerKey)

	// ConsumerSecretSettingName
	registration.ConsumerSecretSettingName = genruntime.ClonePointerToString(source.ConsumerSecretSettingName)

	// No error
	return nil
}

// AssignProperties_To_TwitterRegistration_STATUS populates the provided destination TwitterRegistration_STATUS from our TwitterRegistration_STATUS
func (registration *TwitterRegistration_STATUS) AssignProperties_To_TwitterRegistration_STATUS(destination *storage.TwitterRegistration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsumerKey
	destination.ConsumerKey = genruntime.ClonePointerToString(registration.ConsumerKey)

	// ConsumerSecretSettingName
	destination.ConsumerSecretSettingName = genruntime.ClonePointerToString(registration.ConsumerSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory default authorization policy.
type DefaultAuthorizationPolicy struct {
	// AllowedApplications: The configuration settings of the Azure Active Directory allowed applications.
	AllowedApplications []string `json:"allowedApplications,omitempty"`

	// AllowedPrincipals: The configuration settings of the Azure Active Directory allowed principals.
	AllowedPrincipals *AllowedPrincipals `json:"allowedPrincipals,omitempty"`
}

var _ genruntime.ARMTransformer = &DefaultAuthorizationPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *DefaultAuthorizationPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.DefaultAuthorizationPolicy{}

	// Set property "AllowedApplications":
	for _, item := range policy.AllowedApplications {
		result.AllowedApplications = append(result.AllowedApplications, item)
	}

	// Set property "AllowedPrincipals":
	if policy.AllowedPrincipals != nil {
		allowedPrincipals_ARM, err := (*policy.AllowedPrincipals).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		allowedPrincipals := *allowedPrincipals_ARM.(*arm.AllowedPrincipals)
		result.AllowedPrincipals = &allowedPrincipals
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *DefaultAuthorizationPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DefaultAuthorizationPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *DefaultAuthorizationPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DefaultAuthorizationPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DefaultAuthorizationPolicy, got %T", armInput)
	}

	// Set property "AllowedApplications":
	for _, item := range typedInput.AllowedApplications {
		policy.AllowedApplications = append(policy.AllowedApplications, item)
	}

	// Set property "AllowedPrincipals":
	if typedInput.AllowedPrincipals != nil {
		var allowedPrincipals1 AllowedPrincipals
		err := allowedPrincipals1.PopulateFromARM(owner, *typedInput.AllowedPrincipals)
		if err != nil {
			return err
		}
		allowedPrincipals := allowedPrincipals1
		policy.AllowedPrincipals = &allowedPrincipals
	}

	// No error
	return nil
}

// AssignProperties_From_DefaultAuthorizationPolicy populates our DefaultAuthorizationPolicy from the provided source DefaultAuthorizationPolicy
func (policy *DefaultAuthorizationPolicy) AssignProperties_From_DefaultAuthorizationPolicy(source *storage.DefaultAuthorizationPolicy) error {

	// AllowedApplications
	policy.AllowedApplications = genruntime.CloneSliceOfString(source.AllowedApplications)

	// AllowedPrincipals
	if source.AllowedPrincipals != nil {
		var allowedPrincipal AllowedPrincipals
		err := allowedPrincipal.AssignProperties_From_AllowedPrincipals(source.AllowedPrincipals)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedPrincipals() to populate field AllowedPrincipals")
		}
		policy.AllowedPrincipals = &allowedPrincipal
	} else {
		policy.AllowedPrincipals = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultAuthorizationPolicy populates the provided destination DefaultAuthorizationPolicy from our DefaultAuthorizationPolicy
func (policy *DefaultAuthorizationPolicy) AssignProperties_To_DefaultAuthorizationPolicy(destination *storage.DefaultAuthorizationPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedApplications
	destination.AllowedApplications = genruntime.CloneSliceOfString(policy.AllowedApplications)

	// AllowedPrincipals
	if policy.AllowedPrincipals != nil {
		var allowedPrincipal storage.AllowedPrincipals
		err := policy.AllowedPrincipals.AssignProperties_To_AllowedPrincipals(&allowedPrincipal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedPrincipals() to populate field AllowedPrincipals")
		}
		destination.AllowedPrincipals = &allowedPrincipal
	} else {
		destination.AllowedPrincipals = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DefaultAuthorizationPolicy_STATUS populates our DefaultAuthorizationPolicy from the provided source DefaultAuthorizationPolicy_STATUS
func (policy *DefaultAuthorizationPolicy) Initialize_From_DefaultAuthorizationPolicy_STATUS(source *DefaultAuthorizationPolicy_STATUS) error {

	// AllowedApplications
	policy.AllowedApplications = genruntime.CloneSliceOfString(source.AllowedApplications)

	// AllowedPrincipals
	if source.AllowedPrincipals != nil {
		var allowedPrincipal AllowedPrincipals
		err := allowedPrincipal.Initialize_From_AllowedPrincipals_STATUS(source.AllowedPrincipals)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AllowedPrincipals_STATUS() to populate field AllowedPrincipals")
		}
		policy.AllowedPrincipals = &allowedPrincipal
	} else {
		policy.AllowedPrincipals = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory default authorization policy.
type DefaultAuthorizationPolicy_STATUS struct {
	// AllowedApplications: The configuration settings of the Azure Active Directory allowed applications.
	AllowedApplications []string `json:"allowedApplications,omitempty"`

	// AllowedPrincipals: The configuration settings of the Azure Active Directory allowed principals.
	AllowedPrincipals *AllowedPrincipals_STATUS `json:"allowedPrincipals,omitempty"`
}

var _ genruntime.FromARMConverter = &DefaultAuthorizationPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *DefaultAuthorizationPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DefaultAuthorizationPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *DefaultAuthorizationPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DefaultAuthorizationPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DefaultAuthorizationPolicy_STATUS, got %T", armInput)
	}

	// Set property "AllowedApplications":
	for _, item := range typedInput.AllowedApplications {
		policy.AllowedApplications = append(policy.AllowedApplications, item)
	}

	// Set property "AllowedPrincipals":
	if typedInput.AllowedPrincipals != nil {
		var allowedPrincipals1 AllowedPrincipals_STATUS
		err := allowedPrincipals1.PopulateFromARM(owner, *typedInput.AllowedPrincipals)
		if err != nil {
			return err
		}
		allowedPrincipals := allowedPrincipals1
		policy.AllowedPrincipals = &allowedPrincipals
	}

	// No error
	return nil
}

// AssignProperties_From_DefaultAuthorizationPolicy_STATUS populates our DefaultAuthorizationPolicy_STATUS from the provided source DefaultAuthorizationPolicy_STATUS
func (policy *DefaultAuthorizationPolicy_STATUS) AssignProperties_From_DefaultAuthorizationPolicy_STATUS(source *storage.DefaultAuthorizationPolicy_STATUS) error {

	// AllowedApplications
	policy.AllowedApplications = genruntime.CloneSliceOfString(source.AllowedApplications)

	// AllowedPrincipals
	if source.AllowedPrincipals != nil {
		var allowedPrincipal AllowedPrincipals_STATUS
		err := allowedPrincipal.AssignProperties_From_AllowedPrincipals_STATUS(source.AllowedPrincipals)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedPrincipals_STATUS() to populate field AllowedPrincipals")
		}
		policy.AllowedPrincipals = &allowedPrincipal
	} else {
		policy.AllowedPrincipals = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultAuthorizationPolicy_STATUS populates the provided destination DefaultAuthorizationPolicy_STATUS from our DefaultAuthorizationPolicy_STATUS
func (policy *DefaultAuthorizationPolicy_STATUS) AssignProperties_To_DefaultAuthorizationPolicy_STATUS(destination *storage.DefaultAuthorizationPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedApplications
	destination.AllowedApplications = genruntime.CloneSliceOfString(policy.AllowedApplications)

	// AllowedPrincipals
	if policy.AllowedPrincipals != nil {
		var allowedPrincipal storage.AllowedPrincipals_STATUS
		err := policy.AllowedPrincipals.AssignProperties_To_AllowedPrincipals_STATUS(&allowedPrincipal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedPrincipals_STATUS() to populate field AllowedPrincipals")
		}
		destination.AllowedPrincipals = &allowedPrincipal
	} else {
		destination.AllowedPrincipals = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the checks that should be made while validating the JWT Claims.
type JwtClaimChecks struct {
	// AllowedClientApplications: The list of the allowed client applications.
	AllowedClientApplications []string `json:"allowedClientApplications,omitempty"`

	// AllowedGroups: The list of the allowed groups.
	AllowedGroups []string `json:"allowedGroups,omitempty"`
}

var _ genruntime.ARMTransformer = &JwtClaimChecks{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (checks *JwtClaimChecks) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if checks == nil {
		return nil, nil
	}
	result := &arm.JwtClaimChecks{}

	// Set property "AllowedClientApplications":
	for _, item := range checks.AllowedClientApplications {
		result.AllowedClientApplications = append(result.AllowedClientApplications, item)
	}

	// Set property "AllowedGroups":
	for _, item := range checks.AllowedGroups {
		result.AllowedGroups = append(result.AllowedGroups, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (checks *JwtClaimChecks) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JwtClaimChecks{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (checks *JwtClaimChecks) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JwtClaimChecks)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JwtClaimChecks, got %T", armInput)
	}

	// Set property "AllowedClientApplications":
	for _, item := range typedInput.AllowedClientApplications {
		checks.AllowedClientApplications = append(checks.AllowedClientApplications, item)
	}

	// Set property "AllowedGroups":
	for _, item := range typedInput.AllowedGroups {
		checks.AllowedGroups = append(checks.AllowedGroups, item)
	}

	// No error
	return nil
}

// AssignProperties_From_JwtClaimChecks populates our JwtClaimChecks from the provided source JwtClaimChecks
func (checks *JwtClaimChecks) AssignProperties_From_JwtClaimChecks(source *storage.JwtClaimChecks) error {

	// AllowedClientApplications
	checks.AllowedClientApplications = genruntime.CloneSliceOfString(source.AllowedClientApplications)

	// AllowedGroups
	checks.AllowedGroups = genruntime.CloneSliceOfString(source.AllowedGroups)

	// No error
	return nil
}

// AssignProperties_To_JwtClaimChecks populates the provided destination JwtClaimChecks from our JwtClaimChecks
func (checks *JwtClaimChecks) AssignProperties_To_JwtClaimChecks(destination *storage.JwtClaimChecks) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedClientApplications
	destination.AllowedClientApplications = genruntime.CloneSliceOfString(checks.AllowedClientApplications)

	// AllowedGroups
	destination.AllowedGroups = genruntime.CloneSliceOfString(checks.AllowedGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JwtClaimChecks_STATUS populates our JwtClaimChecks from the provided source JwtClaimChecks_STATUS
func (checks *JwtClaimChecks) Initialize_From_JwtClaimChecks_STATUS(source *JwtClaimChecks_STATUS) error {

	// AllowedClientApplications
	checks.AllowedClientApplications = genruntime.CloneSliceOfString(source.AllowedClientApplications)

	// AllowedGroups
	checks.AllowedGroups = genruntime.CloneSliceOfString(source.AllowedGroups)

	// No error
	return nil
}

// The configuration settings of the checks that should be made while validating the JWT Claims.
type JwtClaimChecks_STATUS struct {
	// AllowedClientApplications: The list of the allowed client applications.
	AllowedClientApplications []string `json:"allowedClientApplications,omitempty"`

	// AllowedGroups: The list of the allowed groups.
	AllowedGroups []string `json:"allowedGroups,omitempty"`
}

var _ genruntime.FromARMConverter = &JwtClaimChecks_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (checks *JwtClaimChecks_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JwtClaimChecks_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (checks *JwtClaimChecks_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JwtClaimChecks_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JwtClaimChecks_STATUS, got %T", armInput)
	}

	// Set property "AllowedClientApplications":
	for _, item := range typedInput.AllowedClientApplications {
		checks.AllowedClientApplications = append(checks.AllowedClientApplications, item)
	}

	// Set property "AllowedGroups":
	for _, item := range typedInput.AllowedGroups {
		checks.AllowedGroups = append(checks.AllowedGroups, item)
	}

	// No error
	return nil
}

// AssignProperties_From_JwtClaimChecks_STATUS populates our JwtClaimChecks_STATUS from the provided source JwtClaimChecks_STATUS
func (checks *JwtClaimChecks_STATUS) AssignProperties_From_JwtClaimChecks_STATUS(source *storage.JwtClaimChecks_STATUS) error {

	// AllowedClientApplications
	checks.AllowedClientApplications = genruntime.CloneSliceOfString(source.AllowedClientApplications)

	// AllowedGroups
	checks.AllowedGroups = genruntime.CloneSliceOfString(source.AllowedGroups)

	// No error
	return nil
}

// AssignProperties_To_JwtClaimChecks_STATUS populates the provided destination JwtClaimChecks_STATUS from our JwtClaimChecks_STATUS
func (checks *JwtClaimChecks_STATUS) AssignProperties_To_JwtClaimChecks_STATUS(destination *storage.JwtClaimChecks_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedClientApplications
	destination.AllowedClientApplications = genruntime.CloneSliceOfString(checks.AllowedClientApplications)

	// AllowedGroups
	destination.AllowedGroups = genruntime.CloneSliceOfString(checks.AllowedGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The authentication client credentials of the custom Open ID Connect provider.
type OpenIdConnectClientCredential struct {
	// ClientSecretSettingName: The app setting that contains the client secret for the custom Open ID Connect provider.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`

	// Method: The method that should be used to authenticate the user.
	Method *OpenIdConnectClientCredential_Method `json:"method,omitempty"`
}

var _ genruntime.ARMTransformer = &OpenIdConnectClientCredential{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credential *OpenIdConnectClientCredential) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credential == nil {
		return nil, nil
	}
	result := &arm.OpenIdConnectClientCredential{}

	// Set property "ClientSecretSettingName":
	if credential.ClientSecretSettingName != nil {
		clientSecretSettingName := *credential.ClientSecretSettingName
		result.ClientSecretSettingName = &clientSecretSettingName
	}

	// Set property "Method":
	if credential.Method != nil {
		var temp string
		temp = string(*credential.Method)
		method := arm.OpenIdConnectClientCredential_Method(temp)
		result.Method = &method
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credential *OpenIdConnectClientCredential) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectClientCredential{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credential *OpenIdConnectClientCredential) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectClientCredential)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectClientCredential, got %T", armInput)
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		credential.ClientSecretSettingName = &clientSecretSettingName
	}

	// Set property "Method":
	if typedInput.Method != nil {
		var temp string
		temp = string(*typedInput.Method)
		method := OpenIdConnectClientCredential_Method(temp)
		credential.Method = &method
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectClientCredential populates our OpenIdConnectClientCredential from the provided source OpenIdConnectClientCredential
func (credential *OpenIdConnectClientCredential) AssignProperties_From_OpenIdConnectClientCredential(source *storage.OpenIdConnectClientCredential) error {

	// ClientSecretSettingName
	credential.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Method
	if source.Method != nil {
		method := *source.Method
		methodTemp := genruntime.ToEnum(method, openIdConnectClientCredential_Method_Values)
		credential.Method = &methodTemp
	} else {
		credential.Method = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectClientCredential populates the provided destination OpenIdConnectClientCredential from our OpenIdConnectClientCredential
func (credential *OpenIdConnectClientCredential) AssignProperties_To_OpenIdConnectClientCredential(destination *storage.OpenIdConnectClientCredential) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(credential.ClientSecretSettingName)

	// Method
	if credential.Method != nil {
		method := string(*credential.Method)
		destination.Method = &method
	} else {
		destination.Method = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OpenIdConnectClientCredential_STATUS populates our OpenIdConnectClientCredential from the provided source OpenIdConnectClientCredential_STATUS
func (credential *OpenIdConnectClientCredential) Initialize_From_OpenIdConnectClientCredential_STATUS(source *OpenIdConnectClientCredential_STATUS) error {

	// ClientSecretSettingName
	credential.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Method
	if source.Method != nil {
		method := genruntime.ToEnum(string(*source.Method), openIdConnectClientCredential_Method_Values)
		credential.Method = &method
	} else {
		credential.Method = nil
	}

	// No error
	return nil
}

// The authentication client credentials of the custom Open ID Connect provider.
type OpenIdConnectClientCredential_STATUS struct {
	// ClientSecretSettingName: The app setting that contains the client secret for the custom Open ID Connect provider.
	ClientSecretSettingName *string `json:"clientSecretSettingName,omitempty"`

	// Method: The method that should be used to authenticate the user.
	Method *OpenIdConnectClientCredential_Method_STATUS `json:"method,omitempty"`
}

var _ genruntime.FromARMConverter = &OpenIdConnectClientCredential_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credential *OpenIdConnectClientCredential_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectClientCredential_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credential *OpenIdConnectClientCredential_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectClientCredential_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectClientCredential_STATUS, got %T", armInput)
	}

	// Set property "ClientSecretSettingName":
	if typedInput.ClientSecretSettingName != nil {
		clientSecretSettingName := *typedInput.ClientSecretSettingName
		credential.ClientSecretSettingName = &clientSecretSettingName
	}

	// Set property "Method":
	if typedInput.Method != nil {
		var temp string
		temp = string(*typedInput.Method)
		method := OpenIdConnectClientCredential_Method_STATUS(temp)
		credential.Method = &method
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectClientCredential_STATUS populates our OpenIdConnectClientCredential_STATUS from the provided source OpenIdConnectClientCredential_STATUS
func (credential *OpenIdConnectClientCredential_STATUS) AssignProperties_From_OpenIdConnectClientCredential_STATUS(source *storage.OpenIdConnectClientCredential_STATUS) error {

	// ClientSecretSettingName
	credential.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Method
	if source.Method != nil {
		method := *source.Method
		methodTemp := genruntime.ToEnum(method, openIdConnectClientCredential_Method_STATUS_Values)
		credential.Method = &methodTemp
	} else {
		credential.Method = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectClientCredential_STATUS populates the provided destination OpenIdConnectClientCredential_STATUS from our OpenIdConnectClientCredential_STATUS
func (credential *OpenIdConnectClientCredential_STATUS) AssignProperties_To_OpenIdConnectClientCredential_STATUS(destination *storage.OpenIdConnectClientCredential_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(credential.ClientSecretSettingName)

	// Method
	if credential.Method != nil {
		method := string(*credential.Method)
		destination.Method = &method
	} else {
		destination.Method = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the endpoints used for the custom Open ID Connect provider.
type OpenIdConnectConfig struct {
	// AuthorizationEndpoint: The endpoint to be used to make an authorization request.
	AuthorizationEndpoint *string `json:"authorizationEndpoint,omitempty"`

	// CertificationUri: The endpoint that provides the keys necessary to validate the token.
	CertificationUri *string `json:"certificationUri,omitempty"`

	// Issuer: The endpoint that issues the token.
	Issuer *string `json:"issuer,omitempty"`

	// TokenEndpoint: The endpoint to be used to request a token.
	TokenEndpoint *string `json:"tokenEndpoint,omitempty"`

	// WellKnownOpenIdConfiguration: The endpoint that contains all the configuration endpoints for the provider.
	WellKnownOpenIdConfiguration *string `json:"wellKnownOpenIdConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &OpenIdConnectConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *OpenIdConnectConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.OpenIdConnectConfig{}

	// Set property "AuthorizationEndpoint":
	if config.AuthorizationEndpoint != nil {
		authorizationEndpoint := *config.AuthorizationEndpoint
		result.AuthorizationEndpoint = &authorizationEndpoint
	}

	// Set property "CertificationUri":
	if config.CertificationUri != nil {
		certificationUri := *config.CertificationUri
		result.CertificationUri = &certificationUri
	}

	// Set property "Issuer":
	if config.Issuer != nil {
		issuer := *config.Issuer
		result.Issuer = &issuer
	}

	// Set property "TokenEndpoint":
	if config.TokenEndpoint != nil {
		tokenEndpoint := *config.TokenEndpoint
		result.TokenEndpoint = &tokenEndpoint
	}

	// Set property "WellKnownOpenIdConfiguration":
	if config.WellKnownOpenIdConfiguration != nil {
		wellKnownOpenIdConfiguration := *config.WellKnownOpenIdConfiguration
		result.WellKnownOpenIdConfiguration = &wellKnownOpenIdConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *OpenIdConnectConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *OpenIdConnectConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectConfig, got %T", armInput)
	}

	// Set property "AuthorizationEndpoint":
	if typedInput.AuthorizationEndpoint != nil {
		authorizationEndpoint := *typedInput.AuthorizationEndpoint
		config.AuthorizationEndpoint = &authorizationEndpoint
	}

	// Set property "CertificationUri":
	if typedInput.CertificationUri != nil {
		certificationUri := *typedInput.CertificationUri
		config.CertificationUri = &certificationUri
	}

	// Set property "Issuer":
	if typedInput.Issuer != nil {
		issuer := *typedInput.Issuer
		config.Issuer = &issuer
	}

	// Set property "TokenEndpoint":
	if typedInput.TokenEndpoint != nil {
		tokenEndpoint := *typedInput.TokenEndpoint
		config.TokenEndpoint = &tokenEndpoint
	}

	// Set property "WellKnownOpenIdConfiguration":
	if typedInput.WellKnownOpenIdConfiguration != nil {
		wellKnownOpenIdConfiguration := *typedInput.WellKnownOpenIdConfiguration
		config.WellKnownOpenIdConfiguration = &wellKnownOpenIdConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectConfig populates our OpenIdConnectConfig from the provided source OpenIdConnectConfig
func (config *OpenIdConnectConfig) AssignProperties_From_OpenIdConnectConfig(source *storage.OpenIdConnectConfig) error {

	// AuthorizationEndpoint
	config.AuthorizationEndpoint = genruntime.ClonePointerToString(source.AuthorizationEndpoint)

	// CertificationUri
	config.CertificationUri = genruntime.ClonePointerToString(source.CertificationUri)

	// Issuer
	config.Issuer = genruntime.ClonePointerToString(source.Issuer)

	// TokenEndpoint
	config.TokenEndpoint = genruntime.ClonePointerToString(source.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	config.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(source.WellKnownOpenIdConfiguration)

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectConfig populates the provided destination OpenIdConnectConfig from our OpenIdConnectConfig
func (config *OpenIdConnectConfig) AssignProperties_To_OpenIdConnectConfig(destination *storage.OpenIdConnectConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizationEndpoint
	destination.AuthorizationEndpoint = genruntime.ClonePointerToString(config.AuthorizationEndpoint)

	// CertificationUri
	destination.CertificationUri = genruntime.ClonePointerToString(config.CertificationUri)

	// Issuer
	destination.Issuer = genruntime.ClonePointerToString(config.Issuer)

	// TokenEndpoint
	destination.TokenEndpoint = genruntime.ClonePointerToString(config.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	destination.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(config.WellKnownOpenIdConfiguration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OpenIdConnectConfig_STATUS populates our OpenIdConnectConfig from the provided source OpenIdConnectConfig_STATUS
func (config *OpenIdConnectConfig) Initialize_From_OpenIdConnectConfig_STATUS(source *OpenIdConnectConfig_STATUS) error {

	// AuthorizationEndpoint
	config.AuthorizationEndpoint = genruntime.ClonePointerToString(source.AuthorizationEndpoint)

	// CertificationUri
	config.CertificationUri = genruntime.ClonePointerToString(source.CertificationUri)

	// Issuer
	config.Issuer = genruntime.ClonePointerToString(source.Issuer)

	// TokenEndpoint
	config.TokenEndpoint = genruntime.ClonePointerToString(source.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	config.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(source.WellKnownOpenIdConfiguration)

	// No error
	return nil
}

// The configuration settings of the endpoints used for the custom Open ID Connect provider.
type OpenIdConnectConfig_STATUS struct {
	// AuthorizationEndpoint: The endpoint to be used to make an authorization request.
	AuthorizationEndpoint *string `json:"authorizationEndpoint,omitempty"`

	// CertificationUri: The endpoint that provides the keys necessary to validate the token.
	CertificationUri *string `json:"certificationUri,omitempty"`

	// Issuer: The endpoint that issues the token.
	Issuer *string `json:"issuer,omitempty"`

	// TokenEndpoint: The endpoint to be used to request a token.
	TokenEndpoint *string `json:"tokenEndpoint,omitempty"`

	// WellKnownOpenIdConfiguration: The endpoint that contains all the configuration endpoints for the provider.
	WellKnownOpenIdConfiguration *string `json:"wellKnownOpenIdConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &OpenIdConnectConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *OpenIdConnectConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OpenIdConnectConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *OpenIdConnectConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OpenIdConnectConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OpenIdConnectConfig_STATUS, got %T", armInput)
	}

	// Set property "AuthorizationEndpoint":
	if typedInput.AuthorizationEndpoint != nil {
		authorizationEndpoint := *typedInput.AuthorizationEndpoint
		config.AuthorizationEndpoint = &authorizationEndpoint
	}

	// Set property "CertificationUri":
	if typedInput.CertificationUri != nil {
		certificationUri := *typedInput.CertificationUri
		config.CertificationUri = &certificationUri
	}

	// Set property "Issuer":
	if typedInput.Issuer != nil {
		issuer := *typedInput.Issuer
		config.Issuer = &issuer
	}

	// Set property "TokenEndpoint":
	if typedInput.TokenEndpoint != nil {
		tokenEndpoint := *typedInput.TokenEndpoint
		config.TokenEndpoint = &tokenEndpoint
	}

	// Set property "WellKnownOpenIdConfiguration":
	if typedInput.WellKnownOpenIdConfiguration != nil {
		wellKnownOpenIdConfiguration := *typedInput.WellKnownOpenIdConfiguration
		config.WellKnownOpenIdConfiguration = &wellKnownOpenIdConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_OpenIdConnectConfig_STATUS populates our OpenIdConnectConfig_STATUS from the provided source OpenIdConnectConfig_STATUS
func (config *OpenIdConnectConfig_STATUS) AssignProperties_From_OpenIdConnectConfig_STATUS(source *storage.OpenIdConnectConfig_STATUS) error {

	// AuthorizationEndpoint
	config.AuthorizationEndpoint = genruntime.ClonePointerToString(source.AuthorizationEndpoint)

	// CertificationUri
	config.CertificationUri = genruntime.ClonePointerToString(source.CertificationUri)

	// Issuer
	config.Issuer = genruntime.ClonePointerToString(source.Issuer)

	// TokenEndpoint
	config.TokenEndpoint = genruntime.ClonePointerToString(source.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	config.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(source.WellKnownOpenIdConfiguration)

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectConfig_STATUS populates the provided destination OpenIdConnectConfig_STATUS from our OpenIdConnectConfig_STATUS
func (config *OpenIdConnectConfig_STATUS) AssignProperties_To_OpenIdConnectConfig_STATUS(destination *storage.OpenIdConnectConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizationEndpoint
	destination.AuthorizationEndpoint = genruntime.ClonePointerToString(config.AuthorizationEndpoint)

	// CertificationUri
	destination.CertificationUri = genruntime.ClonePointerToString(config.CertificationUri)

	// Issuer
	destination.Issuer = genruntime.ClonePointerToString(config.Issuer)

	// TokenEndpoint
	destination.TokenEndpoint = genruntime.ClonePointerToString(config.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	destination.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(config.WellKnownOpenIdConfiguration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory allowed principals.
type AllowedPrincipals struct {
	// Groups: The list of the allowed groups.
	Groups []string `json:"groups,omitempty"`

	// Identities: The list of the allowed identities.
	Identities []string `json:"identities,omitempty"`
}

var _ genruntime.ARMTransformer = &AllowedPrincipals{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (principals *AllowedPrincipals) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if principals == nil {
		return nil, nil
	}
	result := &arm.AllowedPrincipals{}

	// Set property "Groups":
	for _, item := range principals.Groups {
		result.Groups = append(result.Groups, item)
	}

	// Set property "Identities":
	for _, item := range principals.Identities {
		result.Identities = append(result.Identities, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (principals *AllowedPrincipals) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AllowedPrincipals{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (principals *AllowedPrincipals) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AllowedPrincipals)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AllowedPrincipals, got %T", armInput)
	}

	// Set property "Groups":
	for _, item := range typedInput.Groups {
		principals.Groups = append(principals.Groups, item)
	}

	// Set property "Identities":
	for _, item := range typedInput.Identities {
		principals.Identities = append(principals.Identities, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AllowedPrincipals populates our AllowedPrincipals from the provided source AllowedPrincipals
func (principals *AllowedPrincipals) AssignProperties_From_AllowedPrincipals(source *storage.AllowedPrincipals) error {

	// Groups
	principals.Groups = genruntime.CloneSliceOfString(source.Groups)

	// Identities
	principals.Identities = genruntime.CloneSliceOfString(source.Identities)

	// No error
	return nil
}

// AssignProperties_To_AllowedPrincipals populates the provided destination AllowedPrincipals from our AllowedPrincipals
func (principals *AllowedPrincipals) AssignProperties_To_AllowedPrincipals(destination *storage.AllowedPrincipals) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Groups
	destination.Groups = genruntime.CloneSliceOfString(principals.Groups)

	// Identities
	destination.Identities = genruntime.CloneSliceOfString(principals.Identities)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AllowedPrincipals_STATUS populates our AllowedPrincipals from the provided source AllowedPrincipals_STATUS
func (principals *AllowedPrincipals) Initialize_From_AllowedPrincipals_STATUS(source *AllowedPrincipals_STATUS) error {

	// Groups
	principals.Groups = genruntime.CloneSliceOfString(source.Groups)

	// Identities
	principals.Identities = genruntime.CloneSliceOfString(source.Identities)

	// No error
	return nil
}

// The configuration settings of the Azure Active Directory allowed principals.
type AllowedPrincipals_STATUS struct {
	// Groups: The list of the allowed groups.
	Groups []string `json:"groups,omitempty"`

	// Identities: The list of the allowed identities.
	Identities []string `json:"identities,omitempty"`
}

var _ genruntime.FromARMConverter = &AllowedPrincipals_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (principals *AllowedPrincipals_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AllowedPrincipals_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (principals *AllowedPrincipals_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AllowedPrincipals_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AllowedPrincipals_STATUS, got %T", armInput)
	}

	// Set property "Groups":
	for _, item := range typedInput.Groups {
		principals.Groups = append(principals.Groups, item)
	}

	// Set property "Identities":
	for _, item := range typedInput.Identities {
		principals.Identities = append(principals.Identities, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AllowedPrincipals_STATUS populates our AllowedPrincipals_STATUS from the provided source AllowedPrincipals_STATUS
func (principals *AllowedPrincipals_STATUS) AssignProperties_From_AllowedPrincipals_STATUS(source *storage.AllowedPrincipals_STATUS) error {

	// Groups
	principals.Groups = genruntime.CloneSliceOfString(source.Groups)

	// Identities
	principals.Identities = genruntime.CloneSliceOfString(source.Identities)

	// No error
	return nil
}

// AssignProperties_To_AllowedPrincipals_STATUS populates the provided destination AllowedPrincipals_STATUS from our AllowedPrincipals_STATUS
func (principals *AllowedPrincipals_STATUS) AssignProperties_To_AllowedPrincipals_STATUS(destination *storage.AllowedPrincipals_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Groups
	destination.Groups = genruntime.CloneSliceOfString(principals.Groups)

	// Identities
	destination.Identities = genruntime.CloneSliceOfString(principals.Identities)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ClientSecretPost"}
type OpenIdConnectClientCredential_Method string

const OpenIdConnectClientCredential_Method_ClientSecretPost = OpenIdConnectClientCredential_Method("ClientSecretPost")

// Mapping from string to OpenIdConnectClientCredential_Method
var openIdConnectClientCredential_Method_Values = map[string]OpenIdConnectClientCredential_Method{
	"clientsecretpost": OpenIdConnectClientCredential_Method_ClientSecretPost,
}

type OpenIdConnectClientCredential_Method_STATUS string

const OpenIdConnectClientCredential_Method_STATUS_ClientSecretPost = OpenIdConnectClientCredential_Method_STATUS("ClientSecretPost")

// Mapping from string to OpenIdConnectClientCredential_Method_STATUS
var openIdConnectClientCredential_Method_STATUS_Values = map[string]OpenIdConnectClientCredential_Method_STATUS{
	"clientsecretpost": OpenIdConnectClientCredential_Method_STATUS_ClientSecretPost,
}

func init() {
	SchemeBuilder.Register(&AuthConfig{}, &AuthConfigList{})
}
