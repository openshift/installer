// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20180301

import (
	"fmt"
	v20180301s "github.com/Azure/azure-service-operator/v2/api/insights/v1api20180301/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2018-03-01/metricAlert_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/metricAlerts/{ruleName}
type MetricAlert struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MetricAlert_Spec   `json:"spec,omitempty"`
	Status            MetricAlert_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &MetricAlert{}

// GetConditions returns the conditions of the resource
func (alert *MetricAlert) GetConditions() conditions.Conditions {
	return alert.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (alert *MetricAlert) SetConditions(conditions conditions.Conditions) {
	alert.Status.Conditions = conditions
}

var _ conversion.Convertible = &MetricAlert{}

// ConvertFrom populates our MetricAlert from the provided hub MetricAlert
func (alert *MetricAlert) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20180301s.MetricAlert)
	if !ok {
		return fmt.Errorf("expected insights/v1api20180301/storage/MetricAlert but received %T instead", hub)
	}

	return alert.AssignProperties_From_MetricAlert(source)
}

// ConvertTo populates the provided hub MetricAlert from our MetricAlert
func (alert *MetricAlert) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20180301s.MetricAlert)
	if !ok {
		return fmt.Errorf("expected insights/v1api20180301/storage/MetricAlert but received %T instead", hub)
	}

	return alert.AssignProperties_To_MetricAlert(destination)
}

// +kubebuilder:webhook:path=/mutate-insights-azure-com-v1api20180301-metricalert,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=insights.azure.com,resources=metricalerts,verbs=create;update,versions=v1api20180301,name=default.v1api20180301.metricalerts.insights.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &MetricAlert{}

// Default applies defaults to the MetricAlert resource
func (alert *MetricAlert) Default() {
	alert.defaultImpl()
	var temp any = alert
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (alert *MetricAlert) defaultAzureName() {
	if alert.Spec.AzureName == "" {
		alert.Spec.AzureName = alert.Name
	}
}

// defaultImpl applies the code generated defaults to the MetricAlert resource
func (alert *MetricAlert) defaultImpl() { alert.defaultAzureName() }

var _ genruntime.ImportableResource = &MetricAlert{}

// InitializeSpec initializes the spec for this resource from the given status
func (alert *MetricAlert) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*MetricAlert_STATUS); ok {
		return alert.Spec.Initialize_From_MetricAlert_STATUS(s)
	}

	return fmt.Errorf("expected Status of type MetricAlert_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &MetricAlert{}

// AzureName returns the Azure name of the resource
func (alert *MetricAlert) AzureName() string {
	return alert.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2018-03-01"
func (alert MetricAlert) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (alert *MetricAlert) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (alert *MetricAlert) GetSpec() genruntime.ConvertibleSpec {
	return &alert.Spec
}

// GetStatus returns the status of this resource
func (alert *MetricAlert) GetStatus() genruntime.ConvertibleStatus {
	return &alert.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (alert *MetricAlert) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Insights/metricAlerts"
func (alert *MetricAlert) GetType() string {
	return "Microsoft.Insights/metricAlerts"
}

// NewEmptyStatus returns a new empty (blank) status
func (alert *MetricAlert) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &MetricAlert_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (alert *MetricAlert) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(alert.Spec)
	return alert.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (alert *MetricAlert) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*MetricAlert_STATUS); ok {
		alert.Status = *st
		return nil
	}

	// Convert status to required version
	var st MetricAlert_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	alert.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-insights-azure-com-v1api20180301-metricalert,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=insights.azure.com,resources=metricalerts,verbs=create;update,versions=v1api20180301,name=validate.v1api20180301.metricalerts.insights.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &MetricAlert{}

// ValidateCreate validates the creation of the resource
func (alert *MetricAlert) ValidateCreate() (admission.Warnings, error) {
	validations := alert.createValidations()
	var temp any = alert
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (alert *MetricAlert) ValidateDelete() (admission.Warnings, error) {
	validations := alert.deleteValidations()
	var temp any = alert
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (alert *MetricAlert) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := alert.updateValidations()
	var temp any = alert
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (alert *MetricAlert) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){alert.validateResourceReferences, alert.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (alert *MetricAlert) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (alert *MetricAlert) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return alert.validateResourceReferences()
		},
		alert.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return alert.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (alert *MetricAlert) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(alert)
}

// validateResourceReferences validates all resource references
func (alert *MetricAlert) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&alert.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (alert *MetricAlert) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*MetricAlert)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, alert)
}

// AssignProperties_From_MetricAlert populates our MetricAlert from the provided source MetricAlert
func (alert *MetricAlert) AssignProperties_From_MetricAlert(source *v20180301s.MetricAlert) error {

	// ObjectMeta
	alert.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec MetricAlert_Spec
	err := spec.AssignProperties_From_MetricAlert_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_MetricAlert_Spec() to populate field Spec")
	}
	alert.Spec = spec

	// Status
	var status MetricAlert_STATUS
	err = status.AssignProperties_From_MetricAlert_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_MetricAlert_STATUS() to populate field Status")
	}
	alert.Status = status

	// No error
	return nil
}

// AssignProperties_To_MetricAlert populates the provided destination MetricAlert from our MetricAlert
func (alert *MetricAlert) AssignProperties_To_MetricAlert(destination *v20180301s.MetricAlert) error {

	// ObjectMeta
	destination.ObjectMeta = *alert.ObjectMeta.DeepCopy()

	// Spec
	var spec v20180301s.MetricAlert_Spec
	err := alert.Spec.AssignProperties_To_MetricAlert_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_MetricAlert_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20180301s.MetricAlert_STATUS
	err = alert.Status.AssignProperties_To_MetricAlert_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_MetricAlert_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (alert *MetricAlert) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: alert.Spec.OriginalVersion(),
		Kind:    "MetricAlert",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2018-03-01/metricAlert_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/metricAlerts/{ruleName}
type MetricAlertList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MetricAlert `json:"items"`
}

// +kubebuilder:validation:Enum={"2018-03-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2018-03-01")

type MetricAlert_Spec struct {
	// Actions: the array of actions that are performed when the alert rule becomes active, and when an alert condition is
	// resolved.
	Actions []MetricAlertAction `json:"actions,omitempty"`

	// AutoMitigate: the flag that indicates whether the alert should be auto resolved or not. The default is true.
	AutoMitigate *bool `json:"autoMitigate,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Criteria: defines the specific alert criteria information.
	Criteria *MetricAlertCriteria `json:"criteria,omitempty"`

	// Description: the description of the metric alert that will be included in the alert email.
	Description *string `json:"description,omitempty"`

	// +kubebuilder:validation:Required
	// Enabled: the flag that indicates whether the metric alert is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	// EvaluationFrequency: how often the metric alert is evaluated represented in ISO 8601 duration format.
	EvaluationFrequency *string `json:"evaluationFrequency,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// ScopesReferences: the list of resource id's that this metric alert is scoped to.
	ScopesReferences []genruntime.ResourceReference `armReference:"Scopes" json:"scopesReferences,omitempty"`

	// +kubebuilder:validation:Required
	// Severity: Alert severity {0, 1, 2, 3, 4}
	Severity *int `json:"severity,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// TargetResourceRegion: the region of the target resource(s) on which the alert is created/updated. Mandatory if the scope
	// contains a subscription, resource group, or more than one resource.
	TargetResourceRegion *string `json:"targetResourceRegion,omitempty"`

	// TargetResourceType: the resource type of the target resource(s) on which the alert is created/updated. Mandatory if the
	// scope contains a subscription, resource group, or more than one resource.
	TargetResourceType *string `json:"targetResourceType,omitempty"`

	// +kubebuilder:validation:Required
	// WindowSize: the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the
	// threshold.
	WindowSize *string `json:"windowSize,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricAlert_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (alert *MetricAlert_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if alert == nil {
		return nil, nil
	}
	result := &MetricAlert_Spec_ARM{}

	// Set property "Location":
	if alert.Location != nil {
		location := *alert.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if alert.Actions != nil ||
		alert.AutoMitigate != nil ||
		alert.Criteria != nil ||
		alert.Description != nil ||
		alert.Enabled != nil ||
		alert.EvaluationFrequency != nil ||
		alert.ScopesReferences != nil ||
		alert.Severity != nil ||
		alert.TargetResourceRegion != nil ||
		alert.TargetResourceType != nil ||
		alert.WindowSize != nil {
		result.Properties = &MetricAlertProperties_ARM{}
	}
	for _, item := range alert.Actions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Actions = append(result.Properties.Actions, *item_ARM.(*MetricAlertAction_ARM))
	}
	if alert.AutoMitigate != nil {
		autoMitigate := *alert.AutoMitigate
		result.Properties.AutoMitigate = &autoMitigate
	}
	if alert.Criteria != nil {
		criteria_ARM, err := (*alert.Criteria).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		criteria := *criteria_ARM.(*MetricAlertCriteria_ARM)
		result.Properties.Criteria = &criteria
	}
	if alert.Description != nil {
		description := *alert.Description
		result.Properties.Description = &description
	}
	if alert.Enabled != nil {
		enabled := *alert.Enabled
		result.Properties.Enabled = &enabled
	}
	if alert.EvaluationFrequency != nil {
		evaluationFrequency := *alert.EvaluationFrequency
		result.Properties.EvaluationFrequency = &evaluationFrequency
	}
	for _, item := range alert.ScopesReferences {
		itemARMID, err := resolved.ResolvedReferences.Lookup(item)
		if err != nil {
			return nil, err
		}
		result.Properties.Scopes = append(result.Properties.Scopes, itemARMID)
	}
	if alert.Severity != nil {
		severity := *alert.Severity
		result.Properties.Severity = &severity
	}
	if alert.TargetResourceRegion != nil {
		targetResourceRegion := *alert.TargetResourceRegion
		result.Properties.TargetResourceRegion = &targetResourceRegion
	}
	if alert.TargetResourceType != nil {
		targetResourceType := *alert.TargetResourceType
		result.Properties.TargetResourceType = &targetResourceType
	}
	if alert.WindowSize != nil {
		windowSize := *alert.WindowSize
		result.Properties.WindowSize = &windowSize
	}

	// Set property "Tags":
	if alert.Tags != nil {
		result.Tags = make(map[string]string, len(alert.Tags))
		for key, value := range alert.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (alert *MetricAlert_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlert_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (alert *MetricAlert_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlert_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlert_Spec_ARM, got %T", armInput)
	}

	// Set property "Actions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Actions {
			var item1 MetricAlertAction
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			alert.Actions = append(alert.Actions, item1)
		}
	}

	// Set property "AutoMitigate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoMitigate != nil {
			autoMitigate := *typedInput.Properties.AutoMitigate
			alert.AutoMitigate = &autoMitigate
		}
	}

	// Set property "AzureName":
	alert.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Criteria":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Criteria != nil {
			var criteria1 MetricAlertCriteria
			err := criteria1.PopulateFromARM(owner, *typedInput.Properties.Criteria)
			if err != nil {
				return err
			}
			criteria := criteria1
			alert.Criteria = &criteria
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			alert.Description = &description
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			alert.Enabled = &enabled
		}
	}

	// Set property "EvaluationFrequency":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvaluationFrequency != nil {
			evaluationFrequency := *typedInput.Properties.EvaluationFrequency
			alert.EvaluationFrequency = &evaluationFrequency
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		alert.Location = &location
	}

	// Set property "Owner":
	alert.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// no assignment for property "ScopesReferences"

	// Set property "Severity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Severity != nil {
			severity := *typedInput.Properties.Severity
			alert.Severity = &severity
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		alert.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			alert.Tags[key] = value
		}
	}

	// Set property "TargetResourceRegion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceRegion != nil {
			targetResourceRegion := *typedInput.Properties.TargetResourceRegion
			alert.TargetResourceRegion = &targetResourceRegion
		}
	}

	// Set property "TargetResourceType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceType != nil {
			targetResourceType := *typedInput.Properties.TargetResourceType
			alert.TargetResourceType = &targetResourceType
		}
	}

	// Set property "WindowSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowSize != nil {
			windowSize := *typedInput.Properties.WindowSize
			alert.WindowSize = &windowSize
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &MetricAlert_Spec{}

// ConvertSpecFrom populates our MetricAlert_Spec from the provided source
func (alert *MetricAlert_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20180301s.MetricAlert_Spec)
	if ok {
		// Populate our instance from source
		return alert.AssignProperties_From_MetricAlert_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20180301s.MetricAlert_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = alert.AssignProperties_From_MetricAlert_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our MetricAlert_Spec
func (alert *MetricAlert_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20180301s.MetricAlert_Spec)
	if ok {
		// Populate destination from our instance
		return alert.AssignProperties_To_MetricAlert_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20180301s.MetricAlert_Spec{}
	err := alert.AssignProperties_To_MetricAlert_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_MetricAlert_Spec populates our MetricAlert_Spec from the provided source MetricAlert_Spec
func (alert *MetricAlert_Spec) AssignProperties_From_MetricAlert_Spec(source *v20180301s.MetricAlert_Spec) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]MetricAlertAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action MetricAlertAction
			err := action.AssignProperties_From_MetricAlertAction(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricAlertAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		alert.Actions = actionList
	} else {
		alert.Actions = nil
	}

	// AutoMitigate
	if source.AutoMitigate != nil {
		autoMitigate := *source.AutoMitigate
		alert.AutoMitigate = &autoMitigate
	} else {
		alert.AutoMitigate = nil
	}

	// AzureName
	alert.AzureName = source.AzureName

	// Criteria
	if source.Criteria != nil {
		var criterion MetricAlertCriteria
		err := criterion.AssignProperties_From_MetricAlertCriteria(source.Criteria)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricAlertCriteria() to populate field Criteria")
		}
		alert.Criteria = &criterion
	} else {
		alert.Criteria = nil
	}

	// Description
	alert.Description = genruntime.ClonePointerToString(source.Description)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		alert.Enabled = &enabled
	} else {
		alert.Enabled = nil
	}

	// EvaluationFrequency
	alert.EvaluationFrequency = genruntime.ClonePointerToString(source.EvaluationFrequency)

	// Location
	alert.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		alert.Owner = &owner
	} else {
		alert.Owner = nil
	}

	// ScopesReferences
	if source.ScopesReferences != nil {
		scopesReferenceList := make([]genruntime.ResourceReference, len(source.ScopesReferences))
		for scopesReferenceIndex, scopesReferenceItem := range source.ScopesReferences {
			// Shadow the loop variable to avoid aliasing
			scopesReferenceItem := scopesReferenceItem
			scopesReferenceList[scopesReferenceIndex] = scopesReferenceItem.Copy()
		}
		alert.ScopesReferences = scopesReferenceList
	} else {
		alert.ScopesReferences = nil
	}

	// Severity
	alert.Severity = genruntime.ClonePointerToInt(source.Severity)

	// Tags
	alert.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceRegion
	alert.TargetResourceRegion = genruntime.ClonePointerToString(source.TargetResourceRegion)

	// TargetResourceType
	alert.TargetResourceType = genruntime.ClonePointerToString(source.TargetResourceType)

	// WindowSize
	alert.WindowSize = genruntime.ClonePointerToString(source.WindowSize)

	// No error
	return nil
}

// AssignProperties_To_MetricAlert_Spec populates the provided destination MetricAlert_Spec from our MetricAlert_Spec
func (alert *MetricAlert_Spec) AssignProperties_To_MetricAlert_Spec(destination *v20180301s.MetricAlert_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if alert.Actions != nil {
		actionList := make([]v20180301s.MetricAlertAction, len(alert.Actions))
		for actionIndex, actionItem := range alert.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20180301s.MetricAlertAction
			err := actionItem.AssignProperties_To_MetricAlertAction(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricAlertAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// AutoMitigate
	if alert.AutoMitigate != nil {
		autoMitigate := *alert.AutoMitigate
		destination.AutoMitigate = &autoMitigate
	} else {
		destination.AutoMitigate = nil
	}

	// AzureName
	destination.AzureName = alert.AzureName

	// Criteria
	if alert.Criteria != nil {
		var criterion v20180301s.MetricAlertCriteria
		err := alert.Criteria.AssignProperties_To_MetricAlertCriteria(&criterion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricAlertCriteria() to populate field Criteria")
		}
		destination.Criteria = &criterion
	} else {
		destination.Criteria = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(alert.Description)

	// Enabled
	if alert.Enabled != nil {
		enabled := *alert.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EvaluationFrequency
	destination.EvaluationFrequency = genruntime.ClonePointerToString(alert.EvaluationFrequency)

	// Location
	destination.Location = genruntime.ClonePointerToString(alert.Location)

	// OriginalVersion
	destination.OriginalVersion = alert.OriginalVersion()

	// Owner
	if alert.Owner != nil {
		owner := alert.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ScopesReferences
	if alert.ScopesReferences != nil {
		scopesReferenceList := make([]genruntime.ResourceReference, len(alert.ScopesReferences))
		for scopesReferenceIndex, scopesReferenceItem := range alert.ScopesReferences {
			// Shadow the loop variable to avoid aliasing
			scopesReferenceItem := scopesReferenceItem
			scopesReferenceList[scopesReferenceIndex] = scopesReferenceItem.Copy()
		}
		destination.ScopesReferences = scopesReferenceList
	} else {
		destination.ScopesReferences = nil
	}

	// Severity
	destination.Severity = genruntime.ClonePointerToInt(alert.Severity)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(alert.Tags)

	// TargetResourceRegion
	destination.TargetResourceRegion = genruntime.ClonePointerToString(alert.TargetResourceRegion)

	// TargetResourceType
	destination.TargetResourceType = genruntime.ClonePointerToString(alert.TargetResourceType)

	// WindowSize
	destination.WindowSize = genruntime.ClonePointerToString(alert.WindowSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricAlert_STATUS populates our MetricAlert_Spec from the provided source MetricAlert_STATUS
func (alert *MetricAlert_Spec) Initialize_From_MetricAlert_STATUS(source *MetricAlert_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]MetricAlertAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action MetricAlertAction
			err := action.Initialize_From_MetricAlertAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MetricAlertAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		alert.Actions = actionList
	} else {
		alert.Actions = nil
	}

	// AutoMitigate
	if source.AutoMitigate != nil {
		autoMitigate := *source.AutoMitigate
		alert.AutoMitigate = &autoMitigate
	} else {
		alert.AutoMitigate = nil
	}

	// Criteria
	if source.Criteria != nil {
		var criterion MetricAlertCriteria
		err := criterion.Initialize_From_MetricAlertCriteria_STATUS(source.Criteria)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MetricAlertCriteria_STATUS() to populate field Criteria")
		}
		alert.Criteria = &criterion
	} else {
		alert.Criteria = nil
	}

	// Description
	alert.Description = genruntime.ClonePointerToString(source.Description)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		alert.Enabled = &enabled
	} else {
		alert.Enabled = nil
	}

	// EvaluationFrequency
	alert.EvaluationFrequency = genruntime.ClonePointerToString(source.EvaluationFrequency)

	// Location
	alert.Location = genruntime.ClonePointerToString(source.Location)

	// Severity
	alert.Severity = genruntime.ClonePointerToInt(source.Severity)

	// Tags
	alert.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceRegion
	alert.TargetResourceRegion = genruntime.ClonePointerToString(source.TargetResourceRegion)

	// TargetResourceType
	alert.TargetResourceType = genruntime.ClonePointerToString(source.TargetResourceType)

	// WindowSize
	alert.WindowSize = genruntime.ClonePointerToString(source.WindowSize)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (alert *MetricAlert_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (alert *MetricAlert_Spec) SetAzureName(azureName string) { alert.AzureName = azureName }

type MetricAlert_STATUS struct {
	// Actions: the array of actions that are performed when the alert rule becomes active, and when an alert condition is
	// resolved.
	Actions []MetricAlertAction_STATUS `json:"actions,omitempty"`

	// AutoMitigate: the flag that indicates whether the alert should be auto resolved or not. The default is true.
	AutoMitigate *bool `json:"autoMitigate,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Criteria: defines the specific alert criteria information.
	Criteria *MetricAlertCriteria_STATUS `json:"criteria,omitempty"`

	// Description: the description of the metric alert that will be included in the alert email.
	Description *string `json:"description,omitempty"`

	// Enabled: the flag that indicates whether the metric alert is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// EvaluationFrequency: how often the metric alert is evaluated represented in ISO 8601 duration format.
	EvaluationFrequency *string `json:"evaluationFrequency,omitempty"`

	// Id: Azure resource Id
	Id *string `json:"id,omitempty"`

	// IsMigrated: the value indicating whether this alert rule is migrated.
	IsMigrated *bool `json:"isMigrated,omitempty"`

	// LastUpdatedTime: Last time the rule was updated in ISO8601 format.
	LastUpdatedTime *string `json:"lastUpdatedTime,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: Azure resource name
	Name *string `json:"name,omitempty"`

	// Scopes: the list of resource id's that this metric alert is scoped to.
	Scopes []string `json:"scopes,omitempty"`

	// Severity: Alert severity {0, 1, 2, 3, 4}
	Severity *int `json:"severity,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// TargetResourceRegion: the region of the target resource(s) on which the alert is created/updated. Mandatory if the scope
	// contains a subscription, resource group, or more than one resource.
	TargetResourceRegion *string `json:"targetResourceRegion,omitempty"`

	// TargetResourceType: the resource type of the target resource(s) on which the alert is created/updated. Mandatory if the
	// scope contains a subscription, resource group, or more than one resource.
	TargetResourceType *string `json:"targetResourceType,omitempty"`

	// Type: Azure resource type
	Type *string `json:"type,omitempty"`

	// WindowSize: the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the
	// threshold.
	WindowSize *string `json:"windowSize,omitempty"`
}

var _ genruntime.ConvertibleStatus = &MetricAlert_STATUS{}

// ConvertStatusFrom populates our MetricAlert_STATUS from the provided source
func (alert *MetricAlert_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20180301s.MetricAlert_STATUS)
	if ok {
		// Populate our instance from source
		return alert.AssignProperties_From_MetricAlert_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20180301s.MetricAlert_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = alert.AssignProperties_From_MetricAlert_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our MetricAlert_STATUS
func (alert *MetricAlert_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20180301s.MetricAlert_STATUS)
	if ok {
		// Populate destination from our instance
		return alert.AssignProperties_To_MetricAlert_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20180301s.MetricAlert_STATUS{}
	err := alert.AssignProperties_To_MetricAlert_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &MetricAlert_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (alert *MetricAlert_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlert_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (alert *MetricAlert_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlert_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlert_STATUS_ARM, got %T", armInput)
	}

	// Set property "Actions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Actions {
			var item1 MetricAlertAction_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			alert.Actions = append(alert.Actions, item1)
		}
	}

	// Set property "AutoMitigate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoMitigate != nil {
			autoMitigate := *typedInput.Properties.AutoMitigate
			alert.AutoMitigate = &autoMitigate
		}
	}

	// no assignment for property "Conditions"

	// Set property "Criteria":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Criteria != nil {
			var criteria1 MetricAlertCriteria_STATUS
			err := criteria1.PopulateFromARM(owner, *typedInput.Properties.Criteria)
			if err != nil {
				return err
			}
			criteria := criteria1
			alert.Criteria = &criteria
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			alert.Description = &description
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			alert.Enabled = &enabled
		}
	}

	// Set property "EvaluationFrequency":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvaluationFrequency != nil {
			evaluationFrequency := *typedInput.Properties.EvaluationFrequency
			alert.EvaluationFrequency = &evaluationFrequency
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		alert.Id = &id
	}

	// Set property "IsMigrated":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsMigrated != nil {
			isMigrated := *typedInput.Properties.IsMigrated
			alert.IsMigrated = &isMigrated
		}
	}

	// Set property "LastUpdatedTime":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastUpdatedTime != nil {
			lastUpdatedTime := *typedInput.Properties.LastUpdatedTime
			alert.LastUpdatedTime = &lastUpdatedTime
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		alert.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		alert.Name = &name
	}

	// Set property "Scopes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Scopes {
			alert.Scopes = append(alert.Scopes, item)
		}
	}

	// Set property "Severity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Severity != nil {
			severity := *typedInput.Properties.Severity
			alert.Severity = &severity
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		alert.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			alert.Tags[key] = value
		}
	}

	// Set property "TargetResourceRegion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceRegion != nil {
			targetResourceRegion := *typedInput.Properties.TargetResourceRegion
			alert.TargetResourceRegion = &targetResourceRegion
		}
	}

	// Set property "TargetResourceType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceType != nil {
			targetResourceType := *typedInput.Properties.TargetResourceType
			alert.TargetResourceType = &targetResourceType
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		alert.Type = &typeVar
	}

	// Set property "WindowSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowSize != nil {
			windowSize := *typedInput.Properties.WindowSize
			alert.WindowSize = &windowSize
		}
	}

	// No error
	return nil
}

// AssignProperties_From_MetricAlert_STATUS populates our MetricAlert_STATUS from the provided source MetricAlert_STATUS
func (alert *MetricAlert_STATUS) AssignProperties_From_MetricAlert_STATUS(source *v20180301s.MetricAlert_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]MetricAlertAction_STATUS, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action MetricAlertAction_STATUS
			err := action.AssignProperties_From_MetricAlertAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricAlertAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		alert.Actions = actionList
	} else {
		alert.Actions = nil
	}

	// AutoMitigate
	if source.AutoMitigate != nil {
		autoMitigate := *source.AutoMitigate
		alert.AutoMitigate = &autoMitigate
	} else {
		alert.AutoMitigate = nil
	}

	// Conditions
	alert.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Criteria
	if source.Criteria != nil {
		var criterion MetricAlertCriteria_STATUS
		err := criterion.AssignProperties_From_MetricAlertCriteria_STATUS(source.Criteria)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricAlertCriteria_STATUS() to populate field Criteria")
		}
		alert.Criteria = &criterion
	} else {
		alert.Criteria = nil
	}

	// Description
	alert.Description = genruntime.ClonePointerToString(source.Description)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		alert.Enabled = &enabled
	} else {
		alert.Enabled = nil
	}

	// EvaluationFrequency
	alert.EvaluationFrequency = genruntime.ClonePointerToString(source.EvaluationFrequency)

	// Id
	alert.Id = genruntime.ClonePointerToString(source.Id)

	// IsMigrated
	if source.IsMigrated != nil {
		isMigrated := *source.IsMigrated
		alert.IsMigrated = &isMigrated
	} else {
		alert.IsMigrated = nil
	}

	// LastUpdatedTime
	alert.LastUpdatedTime = genruntime.ClonePointerToString(source.LastUpdatedTime)

	// Location
	alert.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	alert.Name = genruntime.ClonePointerToString(source.Name)

	// Scopes
	alert.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// Severity
	alert.Severity = genruntime.ClonePointerToInt(source.Severity)

	// Tags
	alert.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceRegion
	alert.TargetResourceRegion = genruntime.ClonePointerToString(source.TargetResourceRegion)

	// TargetResourceType
	alert.TargetResourceType = genruntime.ClonePointerToString(source.TargetResourceType)

	// Type
	alert.Type = genruntime.ClonePointerToString(source.Type)

	// WindowSize
	alert.WindowSize = genruntime.ClonePointerToString(source.WindowSize)

	// No error
	return nil
}

// AssignProperties_To_MetricAlert_STATUS populates the provided destination MetricAlert_STATUS from our MetricAlert_STATUS
func (alert *MetricAlert_STATUS) AssignProperties_To_MetricAlert_STATUS(destination *v20180301s.MetricAlert_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if alert.Actions != nil {
		actionList := make([]v20180301s.MetricAlertAction_STATUS, len(alert.Actions))
		for actionIndex, actionItem := range alert.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20180301s.MetricAlertAction_STATUS
			err := actionItem.AssignProperties_To_MetricAlertAction_STATUS(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricAlertAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// AutoMitigate
	if alert.AutoMitigate != nil {
		autoMitigate := *alert.AutoMitigate
		destination.AutoMitigate = &autoMitigate
	} else {
		destination.AutoMitigate = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(alert.Conditions)

	// Criteria
	if alert.Criteria != nil {
		var criterion v20180301s.MetricAlertCriteria_STATUS
		err := alert.Criteria.AssignProperties_To_MetricAlertCriteria_STATUS(&criterion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricAlertCriteria_STATUS() to populate field Criteria")
		}
		destination.Criteria = &criterion
	} else {
		destination.Criteria = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(alert.Description)

	// Enabled
	if alert.Enabled != nil {
		enabled := *alert.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EvaluationFrequency
	destination.EvaluationFrequency = genruntime.ClonePointerToString(alert.EvaluationFrequency)

	// Id
	destination.Id = genruntime.ClonePointerToString(alert.Id)

	// IsMigrated
	if alert.IsMigrated != nil {
		isMigrated := *alert.IsMigrated
		destination.IsMigrated = &isMigrated
	} else {
		destination.IsMigrated = nil
	}

	// LastUpdatedTime
	destination.LastUpdatedTime = genruntime.ClonePointerToString(alert.LastUpdatedTime)

	// Location
	destination.Location = genruntime.ClonePointerToString(alert.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(alert.Name)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(alert.Scopes)

	// Severity
	destination.Severity = genruntime.ClonePointerToInt(alert.Severity)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(alert.Tags)

	// TargetResourceRegion
	destination.TargetResourceRegion = genruntime.ClonePointerToString(alert.TargetResourceRegion)

	// TargetResourceType
	destination.TargetResourceType = genruntime.ClonePointerToString(alert.TargetResourceType)

	// Type
	destination.Type = genruntime.ClonePointerToString(alert.Type)

	// WindowSize
	destination.WindowSize = genruntime.ClonePointerToString(alert.WindowSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An alert action.
type MetricAlertAction struct {
	// ActionGroupId: the id of the action group to use.
	ActionGroupId *string `json:"actionGroupId,omitempty"`

	// WebHookProperties: This field allows specifying custom properties, which would be appended to the alert payload sent as
	// input to the webhook.
	WebHookProperties map[string]string `json:"webHookProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricAlertAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *MetricAlertAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &MetricAlertAction_ARM{}

	// Set property "ActionGroupId":
	if action.ActionGroupId != nil {
		actionGroupId := *action.ActionGroupId
		result.ActionGroupId = &actionGroupId
	}

	// Set property "WebHookProperties":
	if action.WebHookProperties != nil {
		result.WebHookProperties = make(map[string]string, len(action.WebHookProperties))
		for key, value := range action.WebHookProperties {
			result.WebHookProperties[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *MetricAlertAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *MetricAlertAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertAction_ARM, got %T", armInput)
	}

	// Set property "ActionGroupId":
	if typedInput.ActionGroupId != nil {
		actionGroupId := *typedInput.ActionGroupId
		action.ActionGroupId = &actionGroupId
	}

	// Set property "WebHookProperties":
	if typedInput.WebHookProperties != nil {
		action.WebHookProperties = make(map[string]string, len(typedInput.WebHookProperties))
		for key, value := range typedInput.WebHookProperties {
			action.WebHookProperties[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_MetricAlertAction populates our MetricAlertAction from the provided source MetricAlertAction
func (action *MetricAlertAction) AssignProperties_From_MetricAlertAction(source *v20180301s.MetricAlertAction) error {

	// ActionGroupId
	action.ActionGroupId = genruntime.ClonePointerToString(source.ActionGroupId)

	// WebHookProperties
	action.WebHookProperties = genruntime.CloneMapOfStringToString(source.WebHookProperties)

	// No error
	return nil
}

// AssignProperties_To_MetricAlertAction populates the provided destination MetricAlertAction from our MetricAlertAction
func (action *MetricAlertAction) AssignProperties_To_MetricAlertAction(destination *v20180301s.MetricAlertAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionGroupId
	destination.ActionGroupId = genruntime.ClonePointerToString(action.ActionGroupId)

	// WebHookProperties
	destination.WebHookProperties = genruntime.CloneMapOfStringToString(action.WebHookProperties)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricAlertAction_STATUS populates our MetricAlertAction from the provided source MetricAlertAction_STATUS
func (action *MetricAlertAction) Initialize_From_MetricAlertAction_STATUS(source *MetricAlertAction_STATUS) error {

	// ActionGroupId
	action.ActionGroupId = genruntime.ClonePointerToString(source.ActionGroupId)

	// WebHookProperties
	action.WebHookProperties = genruntime.CloneMapOfStringToString(source.WebHookProperties)

	// No error
	return nil
}

// An alert action.
type MetricAlertAction_STATUS struct {
	// ActionGroupId: the id of the action group to use.
	ActionGroupId *string `json:"actionGroupId,omitempty"`

	// WebHookProperties: This field allows specifying custom properties, which would be appended to the alert payload sent as
	// input to the webhook.
	WebHookProperties map[string]string `json:"webHookProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricAlertAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *MetricAlertAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *MetricAlertAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "ActionGroupId":
	if typedInput.ActionGroupId != nil {
		actionGroupId := *typedInput.ActionGroupId
		action.ActionGroupId = &actionGroupId
	}

	// Set property "WebHookProperties":
	if typedInput.WebHookProperties != nil {
		action.WebHookProperties = make(map[string]string, len(typedInput.WebHookProperties))
		for key, value := range typedInput.WebHookProperties {
			action.WebHookProperties[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_MetricAlertAction_STATUS populates our MetricAlertAction_STATUS from the provided source MetricAlertAction_STATUS
func (action *MetricAlertAction_STATUS) AssignProperties_From_MetricAlertAction_STATUS(source *v20180301s.MetricAlertAction_STATUS) error {

	// ActionGroupId
	action.ActionGroupId = genruntime.ClonePointerToString(source.ActionGroupId)

	// WebHookProperties
	action.WebHookProperties = genruntime.CloneMapOfStringToString(source.WebHookProperties)

	// No error
	return nil
}

// AssignProperties_To_MetricAlertAction_STATUS populates the provided destination MetricAlertAction_STATUS from our MetricAlertAction_STATUS
func (action *MetricAlertAction_STATUS) AssignProperties_To_MetricAlertAction_STATUS(destination *v20180301s.MetricAlertAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionGroupId
	destination.ActionGroupId = genruntime.ClonePointerToString(action.ActionGroupId)

	// WebHookProperties
	destination.WebHookProperties = genruntime.CloneMapOfStringToString(action.WebHookProperties)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MetricAlertCriteria struct {
	// MicrosoftAzureMonitorMultipleResourceMultipleMetric: Mutually exclusive with all other properties
	MicrosoftAzureMonitorMultipleResourceMultipleMetric *MetricAlertMultipleResourceMultipleMetricCriteria `json:"microsoftAzureMonitorMultipleResourceMultipleMetricCriteria,omitempty"`

	// MicrosoftAzureMonitorSingleResourceMultipleMetric: Mutually exclusive with all other properties
	MicrosoftAzureMonitorSingleResourceMultipleMetric *MetricAlertSingleResourceMultipleMetricCriteria `json:"microsoftAzureMonitorSingleResourceMultipleMetricCriteria,omitempty"`

	// MicrosoftAzureMonitorWebtestLocationAvailability: Mutually exclusive with all other properties
	MicrosoftAzureMonitorWebtestLocationAvailability *WebtestLocationAvailabilityCriteria `json:"microsoftAzureMonitorWebtestLocationAvailabilityCriteria,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricAlertCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *MetricAlertCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &MetricAlertCriteria_ARM{}

	// Set property "MicrosoftAzureMonitorMultipleResourceMultipleMetric":
	if criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		microsoftAzureMonitorMultipleResourceMultipleMetric_ARM, err := (*criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		microsoftAzureMonitorMultipleResourceMultipleMetric := *microsoftAzureMonitorMultipleResourceMultipleMetric_ARM.(*MetricAlertMultipleResourceMultipleMetricCriteria_ARM)
		result.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	}

	// Set property "MicrosoftAzureMonitorSingleResourceMultipleMetric":
	if criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		microsoftAzureMonitorSingleResourceMultipleMetric_ARM, err := (*criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		microsoftAzureMonitorSingleResourceMultipleMetric := *microsoftAzureMonitorSingleResourceMultipleMetric_ARM.(*MetricAlertSingleResourceMultipleMetricCriteria_ARM)
		result.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	}

	// Set property "MicrosoftAzureMonitorWebtestLocationAvailability":
	if criteria.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		microsoftAzureMonitorWebtestLocationAvailability_ARM, err := (*criteria.MicrosoftAzureMonitorWebtestLocationAvailability).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		microsoftAzureMonitorWebtestLocationAvailability := *microsoftAzureMonitorWebtestLocationAvailability_ARM.(*WebtestLocationAvailabilityCriteria_ARM)
		result.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricAlertCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricAlertCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertCriteria_ARM, got %T", armInput)
	}

	// Set property "MicrosoftAzureMonitorMultipleResourceMultipleMetric":
	if typedInput.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric1 MetricAlertMultipleResourceMultipleMetricCriteria
		err := microsoftAzureMonitorMultipleResourceMultipleMetric1.PopulateFromARM(owner, *typedInput.MicrosoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return err
		}
		microsoftAzureMonitorMultipleResourceMultipleMetric := microsoftAzureMonitorMultipleResourceMultipleMetric1
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	}

	// Set property "MicrosoftAzureMonitorSingleResourceMultipleMetric":
	if typedInput.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric1 MetricAlertSingleResourceMultipleMetricCriteria
		err := microsoftAzureMonitorSingleResourceMultipleMetric1.PopulateFromARM(owner, *typedInput.MicrosoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return err
		}
		microsoftAzureMonitorSingleResourceMultipleMetric := microsoftAzureMonitorSingleResourceMultipleMetric1
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	}

	// Set property "MicrosoftAzureMonitorWebtestLocationAvailability":
	if typedInput.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability1 WebtestLocationAvailabilityCriteria
		err := microsoftAzureMonitorWebtestLocationAvailability1.PopulateFromARM(owner, *typedInput.MicrosoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return err
		}
		microsoftAzureMonitorWebtestLocationAvailability := microsoftAzureMonitorWebtestLocationAvailability1
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	}

	// No error
	return nil
}

// AssignProperties_From_MetricAlertCriteria populates our MetricAlertCriteria from the provided source MetricAlertCriteria
func (criteria *MetricAlertCriteria) AssignProperties_From_MetricAlertCriteria(source *v20180301s.MetricAlertCriteria) error {

	// MicrosoftAzureMonitorMultipleResourceMultipleMetric
	if source.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric MetricAlertMultipleResourceMultipleMetricCriteria
		err := microsoftAzureMonitorMultipleResourceMultipleMetric.AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria(source.MicrosoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria() to populate field MicrosoftAzureMonitorMultipleResourceMultipleMetric")
		}
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	} else {
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorSingleResourceMultipleMetric
	if source.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric MetricAlertSingleResourceMultipleMetricCriteria
		err := microsoftAzureMonitorSingleResourceMultipleMetric.AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria(source.MicrosoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria() to populate field MicrosoftAzureMonitorSingleResourceMultipleMetric")
		}
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	} else {
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorWebtestLocationAvailability
	if source.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability WebtestLocationAvailabilityCriteria
		err := microsoftAzureMonitorWebtestLocationAvailability.AssignProperties_From_WebtestLocationAvailabilityCriteria(source.MicrosoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WebtestLocationAvailabilityCriteria() to populate field MicrosoftAzureMonitorWebtestLocationAvailability")
		}
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	} else {
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricAlertCriteria populates the provided destination MetricAlertCriteria from our MetricAlertCriteria
func (criteria *MetricAlertCriteria) AssignProperties_To_MetricAlertCriteria(destination *v20180301s.MetricAlertCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MicrosoftAzureMonitorMultipleResourceMultipleMetric
	if criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric v20180301s.MetricAlertMultipleResourceMultipleMetricCriteria
		err := criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric.AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria(&microsoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria() to populate field MicrosoftAzureMonitorMultipleResourceMultipleMetric")
		}
		destination.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	} else {
		destination.MicrosoftAzureMonitorMultipleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorSingleResourceMultipleMetric
	if criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric v20180301s.MetricAlertSingleResourceMultipleMetricCriteria
		err := criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric.AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria(&microsoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria() to populate field MicrosoftAzureMonitorSingleResourceMultipleMetric")
		}
		destination.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	} else {
		destination.MicrosoftAzureMonitorSingleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorWebtestLocationAvailability
	if criteria.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability v20180301s.WebtestLocationAvailabilityCriteria
		err := criteria.MicrosoftAzureMonitorWebtestLocationAvailability.AssignProperties_To_WebtestLocationAvailabilityCriteria(&microsoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WebtestLocationAvailabilityCriteria() to populate field MicrosoftAzureMonitorWebtestLocationAvailability")
		}
		destination.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	} else {
		destination.MicrosoftAzureMonitorWebtestLocationAvailability = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricAlertCriteria_STATUS populates our MetricAlertCriteria from the provided source MetricAlertCriteria_STATUS
func (criteria *MetricAlertCriteria) Initialize_From_MetricAlertCriteria_STATUS(source *MetricAlertCriteria_STATUS) error {

	// MicrosoftAzureMonitorMultipleResourceMultipleMetric
	if source.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric MetricAlertMultipleResourceMultipleMetricCriteria
		err := microsoftAzureMonitorMultipleResourceMultipleMetric.Initialize_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(source.MicrosoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS() to populate field MicrosoftAzureMonitorMultipleResourceMultipleMetric")
		}
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	} else {
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorSingleResourceMultipleMetric
	if source.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric MetricAlertSingleResourceMultipleMetricCriteria
		err := microsoftAzureMonitorSingleResourceMultipleMetric.Initialize_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(source.MicrosoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS() to populate field MicrosoftAzureMonitorSingleResourceMultipleMetric")
		}
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	} else {
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorWebtestLocationAvailability
	if source.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability WebtestLocationAvailabilityCriteria
		err := microsoftAzureMonitorWebtestLocationAvailability.Initialize_From_WebtestLocationAvailabilityCriteria_STATUS(source.MicrosoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WebtestLocationAvailabilityCriteria_STATUS() to populate field MicrosoftAzureMonitorWebtestLocationAvailability")
		}
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	} else {
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = nil
	}

	// No error
	return nil
}

type MetricAlertCriteria_STATUS struct {
	// MicrosoftAzureMonitorMultipleResourceMultipleMetric: Mutually exclusive with all other properties
	MicrosoftAzureMonitorMultipleResourceMultipleMetric *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS `json:"microsoftAzureMonitorMultipleResourceMultipleMetricCriteria,omitempty"`

	// MicrosoftAzureMonitorSingleResourceMultipleMetric: Mutually exclusive with all other properties
	MicrosoftAzureMonitorSingleResourceMultipleMetric *MetricAlertSingleResourceMultipleMetricCriteria_STATUS `json:"microsoftAzureMonitorSingleResourceMultipleMetricCriteria,omitempty"`

	// MicrosoftAzureMonitorWebtestLocationAvailability: Mutually exclusive with all other properties
	MicrosoftAzureMonitorWebtestLocationAvailability *WebtestLocationAvailabilityCriteria_STATUS `json:"microsoftAzureMonitorWebtestLocationAvailabilityCriteria,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricAlertCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricAlertCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricAlertCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "MicrosoftAzureMonitorMultipleResourceMultipleMetric":
	if typedInput.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric1 MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
		err := microsoftAzureMonitorMultipleResourceMultipleMetric1.PopulateFromARM(owner, *typedInput.MicrosoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return err
		}
		microsoftAzureMonitorMultipleResourceMultipleMetric := microsoftAzureMonitorMultipleResourceMultipleMetric1
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	}

	// Set property "MicrosoftAzureMonitorSingleResourceMultipleMetric":
	if typedInput.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric1 MetricAlertSingleResourceMultipleMetricCriteria_STATUS
		err := microsoftAzureMonitorSingleResourceMultipleMetric1.PopulateFromARM(owner, *typedInput.MicrosoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return err
		}
		microsoftAzureMonitorSingleResourceMultipleMetric := microsoftAzureMonitorSingleResourceMultipleMetric1
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	}

	// Set property "MicrosoftAzureMonitorWebtestLocationAvailability":
	if typedInput.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability1 WebtestLocationAvailabilityCriteria_STATUS
		err := microsoftAzureMonitorWebtestLocationAvailability1.PopulateFromARM(owner, *typedInput.MicrosoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return err
		}
		microsoftAzureMonitorWebtestLocationAvailability := microsoftAzureMonitorWebtestLocationAvailability1
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	}

	// No error
	return nil
}

// AssignProperties_From_MetricAlertCriteria_STATUS populates our MetricAlertCriteria_STATUS from the provided source MetricAlertCriteria_STATUS
func (criteria *MetricAlertCriteria_STATUS) AssignProperties_From_MetricAlertCriteria_STATUS(source *v20180301s.MetricAlertCriteria_STATUS) error {

	// MicrosoftAzureMonitorMultipleResourceMultipleMetric
	if source.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
		err := microsoftAzureMonitorMultipleResourceMultipleMetric.AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(source.MicrosoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS() to populate field MicrosoftAzureMonitorMultipleResourceMultipleMetric")
		}
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	} else {
		criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorSingleResourceMultipleMetric
	if source.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric MetricAlertSingleResourceMultipleMetricCriteria_STATUS
		err := microsoftAzureMonitorSingleResourceMultipleMetric.AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(source.MicrosoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS() to populate field MicrosoftAzureMonitorSingleResourceMultipleMetric")
		}
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	} else {
		criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorWebtestLocationAvailability
	if source.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability WebtestLocationAvailabilityCriteria_STATUS
		err := microsoftAzureMonitorWebtestLocationAvailability.AssignProperties_From_WebtestLocationAvailabilityCriteria_STATUS(source.MicrosoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WebtestLocationAvailabilityCriteria_STATUS() to populate field MicrosoftAzureMonitorWebtestLocationAvailability")
		}
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	} else {
		criteria.MicrosoftAzureMonitorWebtestLocationAvailability = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricAlertCriteria_STATUS populates the provided destination MetricAlertCriteria_STATUS from our MetricAlertCriteria_STATUS
func (criteria *MetricAlertCriteria_STATUS) AssignProperties_To_MetricAlertCriteria_STATUS(destination *v20180301s.MetricAlertCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MicrosoftAzureMonitorMultipleResourceMultipleMetric
	if criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric != nil {
		var microsoftAzureMonitorMultipleResourceMultipleMetric v20180301s.MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
		err := criteria.MicrosoftAzureMonitorMultipleResourceMultipleMetric.AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(&microsoftAzureMonitorMultipleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS() to populate field MicrosoftAzureMonitorMultipleResourceMultipleMetric")
		}
		destination.MicrosoftAzureMonitorMultipleResourceMultipleMetric = &microsoftAzureMonitorMultipleResourceMultipleMetric
	} else {
		destination.MicrosoftAzureMonitorMultipleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorSingleResourceMultipleMetric
	if criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric != nil {
		var microsoftAzureMonitorSingleResourceMultipleMetric v20180301s.MetricAlertSingleResourceMultipleMetricCriteria_STATUS
		err := criteria.MicrosoftAzureMonitorSingleResourceMultipleMetric.AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(&microsoftAzureMonitorSingleResourceMultipleMetric)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria_STATUS() to populate field MicrosoftAzureMonitorSingleResourceMultipleMetric")
		}
		destination.MicrosoftAzureMonitorSingleResourceMultipleMetric = &microsoftAzureMonitorSingleResourceMultipleMetric
	} else {
		destination.MicrosoftAzureMonitorSingleResourceMultipleMetric = nil
	}

	// MicrosoftAzureMonitorWebtestLocationAvailability
	if criteria.MicrosoftAzureMonitorWebtestLocationAvailability != nil {
		var microsoftAzureMonitorWebtestLocationAvailability v20180301s.WebtestLocationAvailabilityCriteria_STATUS
		err := criteria.MicrosoftAzureMonitorWebtestLocationAvailability.AssignProperties_To_WebtestLocationAvailabilityCriteria_STATUS(&microsoftAzureMonitorWebtestLocationAvailability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WebtestLocationAvailabilityCriteria_STATUS() to populate field MicrosoftAzureMonitorWebtestLocationAvailability")
		}
		destination.MicrosoftAzureMonitorWebtestLocationAvailability = &microsoftAzureMonitorWebtestLocationAvailability
	} else {
		destination.MicrosoftAzureMonitorWebtestLocationAvailability = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MetricAlertMultipleResourceMultipleMetricCriteria struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// AllOf: the list of multiple metric criteria for this 'all of' operation.
	AllOf []MultiMetricCriteria `json:"allOf,omitempty"`

	// +kubebuilder:validation:Required
	// OdataType: specifies the type of the alert criteria.
	OdataType *MetricAlertMultipleResourceMultipleMetricCriteria_OdataType `json:"odata.type,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricAlertMultipleResourceMultipleMetricCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &MetricAlertMultipleResourceMultipleMetricCriteria_ARM{}

	// Set property "AdditionalProperties":
	if criteria.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for key, value := range criteria.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AllOf":
	for _, item := range criteria.AllOf {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AllOf = append(result.AllOf, *item_ARM.(*MultiMetricCriteria_ARM))
	}

	// Set property "OdataType":
	if criteria.OdataType != nil {
		result.OdataType = *criteria.OdataType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertMultipleResourceMultipleMetricCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertMultipleResourceMultipleMetricCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertMultipleResourceMultipleMetricCriteria_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AllOf":
	for _, item := range typedInput.AllOf {
		var item1 MultiMetricCriteria
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.AllOf = append(criteria.AllOf, item1)
	}

	// Set property "OdataType":
	criteria.OdataType = &typedInput.OdataType

	// No error
	return nil
}

// AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria populates our MetricAlertMultipleResourceMultipleMetricCriteria from the provided source MetricAlertMultipleResourceMultipleMetricCriteria
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria) AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria(source *v20180301s.MetricAlertMultipleResourceMultipleMetricCriteria) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]MultiMetricCriteria, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf MultiMetricCriteria
			err := allOf.AssignProperties_From_MultiMetricCriteria(&allOfItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MultiMetricCriteria() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		criteria.AllOf = allOfList
	} else {
		criteria.AllOf = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := MetricAlertMultipleResourceMultipleMetricCriteria_OdataType(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria populates the provided destination MetricAlertMultipleResourceMultipleMetricCriteria from our MetricAlertMultipleResourceMultipleMetricCriteria
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria) AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria(destination *v20180301s.MetricAlertMultipleResourceMultipleMetricCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AllOf
	if criteria.AllOf != nil {
		allOfList := make([]v20180301s.MultiMetricCriteria, len(criteria.AllOf))
		for allOfIndex, allOfItem := range criteria.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf v20180301s.MultiMetricCriteria
			err := allOfItem.AssignProperties_To_MultiMetricCriteria(&allOf)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MultiMetricCriteria() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		destination.AllOf = allOfList
	} else {
		destination.AllOf = nil
	}

	// OdataType
	if criteria.OdataType != nil {
		odataType := string(*criteria.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS populates our MetricAlertMultipleResourceMultipleMetricCriteria from the provided source MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria) Initialize_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(source *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]MultiMetricCriteria, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf MultiMetricCriteria
			err := allOf.Initialize_From_MultiMetricCriteria_STATUS(&allOfItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MultiMetricCriteria_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		criteria.AllOf = allOfList
	} else {
		criteria.AllOf = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := MetricAlertMultipleResourceMultipleMetricCriteria_OdataType(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// No error
	return nil
}

type MetricAlertMultipleResourceMultipleMetricCriteria_STATUS struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// AllOf: the list of multiple metric criteria for this 'all of' operation.
	AllOf []MultiMetricCriteria_STATUS `json:"allOf,omitempty"`

	// OdataType: specifies the type of the alert criteria.
	OdataType *MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_STATUS `json:"odata.type,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricAlertMultipleResourceMultipleMetricCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertMultipleResourceMultipleMetricCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertMultipleResourceMultipleMetricCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertMultipleResourceMultipleMetricCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AllOf":
	for _, item := range typedInput.AllOf {
		var item1 MultiMetricCriteria_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.AllOf = append(criteria.AllOf, item1)
	}

	// Set property "OdataType":
	criteria.OdataType = &typedInput.OdataType

	// No error
	return nil
}

// AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS populates our MetricAlertMultipleResourceMultipleMetricCriteria_STATUS from the provided source MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(source *v20180301s.MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]MultiMetricCriteria_STATUS, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf MultiMetricCriteria_STATUS
			err := allOf.AssignProperties_From_MultiMetricCriteria_STATUS(&allOfItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MultiMetricCriteria_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		criteria.AllOf = allOfList
	} else {
		criteria.AllOf = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_STATUS(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS populates the provided destination MetricAlertMultipleResourceMultipleMetricCriteria_STATUS from our MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
func (criteria *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(destination *v20180301s.MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AllOf
	if criteria.AllOf != nil {
		allOfList := make([]v20180301s.MultiMetricCriteria_STATUS, len(criteria.AllOf))
		for allOfIndex, allOfItem := range criteria.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf v20180301s.MultiMetricCriteria_STATUS
			err := allOfItem.AssignProperties_To_MultiMetricCriteria_STATUS(&allOf)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MultiMetricCriteria_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		destination.AllOf = allOfList
	} else {
		destination.AllOf = nil
	}

	// OdataType
	if criteria.OdataType != nil {
		odataType := string(*criteria.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MetricAlertSingleResourceMultipleMetricCriteria struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// AllOf: The list of metric criteria for this 'all of' operation.
	AllOf []MetricCriteria `json:"allOf,omitempty"`

	// +kubebuilder:validation:Required
	// OdataType: specifies the type of the alert criteria.
	OdataType *MetricAlertSingleResourceMultipleMetricCriteria_OdataType `json:"odata.type,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricAlertSingleResourceMultipleMetricCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &MetricAlertSingleResourceMultipleMetricCriteria_ARM{}

	// Set property "AdditionalProperties":
	if criteria.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for key, value := range criteria.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AllOf":
	for _, item := range criteria.AllOf {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AllOf = append(result.AllOf, *item_ARM.(*MetricCriteria_ARM))
	}

	// Set property "OdataType":
	if criteria.OdataType != nil {
		result.OdataType = *criteria.OdataType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertSingleResourceMultipleMetricCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertSingleResourceMultipleMetricCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertSingleResourceMultipleMetricCriteria_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AllOf":
	for _, item := range typedInput.AllOf {
		var item1 MetricCriteria
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.AllOf = append(criteria.AllOf, item1)
	}

	// Set property "OdataType":
	criteria.OdataType = &typedInput.OdataType

	// No error
	return nil
}

// AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria populates our MetricAlertSingleResourceMultipleMetricCriteria from the provided source MetricAlertSingleResourceMultipleMetricCriteria
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria) AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria(source *v20180301s.MetricAlertSingleResourceMultipleMetricCriteria) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]MetricCriteria, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf MetricCriteria
			err := allOf.AssignProperties_From_MetricCriteria(&allOfItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricCriteria() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		criteria.AllOf = allOfList
	} else {
		criteria.AllOf = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := MetricAlertSingleResourceMultipleMetricCriteria_OdataType(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria populates the provided destination MetricAlertSingleResourceMultipleMetricCriteria from our MetricAlertSingleResourceMultipleMetricCriteria
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria) AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria(destination *v20180301s.MetricAlertSingleResourceMultipleMetricCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AllOf
	if criteria.AllOf != nil {
		allOfList := make([]v20180301s.MetricCriteria, len(criteria.AllOf))
		for allOfIndex, allOfItem := range criteria.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf v20180301s.MetricCriteria
			err := allOfItem.AssignProperties_To_MetricCriteria(&allOf)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricCriteria() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		destination.AllOf = allOfList
	} else {
		destination.AllOf = nil
	}

	// OdataType
	if criteria.OdataType != nil {
		odataType := string(*criteria.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS populates our MetricAlertSingleResourceMultipleMetricCriteria from the provided source MetricAlertSingleResourceMultipleMetricCriteria_STATUS
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria) Initialize_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(source *MetricAlertSingleResourceMultipleMetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]MetricCriteria, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf MetricCriteria
			err := allOf.Initialize_From_MetricCriteria_STATUS(&allOfItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MetricCriteria_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		criteria.AllOf = allOfList
	} else {
		criteria.AllOf = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := MetricAlertSingleResourceMultipleMetricCriteria_OdataType(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// No error
	return nil
}

type MetricAlertSingleResourceMultipleMetricCriteria_STATUS struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// AllOf: The list of metric criteria for this 'all of' operation.
	AllOf []MetricCriteria_STATUS `json:"allOf,omitempty"`

	// OdataType: specifies the type of the alert criteria.
	OdataType *MetricAlertSingleResourceMultipleMetricCriteria_OdataType_STATUS `json:"odata.type,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricAlertSingleResourceMultipleMetricCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricAlertSingleResourceMultipleMetricCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricAlertSingleResourceMultipleMetricCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricAlertSingleResourceMultipleMetricCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AllOf":
	for _, item := range typedInput.AllOf {
		var item1 MetricCriteria_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.AllOf = append(criteria.AllOf, item1)
	}

	// Set property "OdataType":
	criteria.OdataType = &typedInput.OdataType

	// No error
	return nil
}

// AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS populates our MetricAlertSingleResourceMultipleMetricCriteria_STATUS from the provided source MetricAlertSingleResourceMultipleMetricCriteria_STATUS
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria_STATUS) AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(source *v20180301s.MetricAlertSingleResourceMultipleMetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]MetricCriteria_STATUS, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf MetricCriteria_STATUS
			err := allOf.AssignProperties_From_MetricCriteria_STATUS(&allOfItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricCriteria_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		criteria.AllOf = allOfList
	} else {
		criteria.AllOf = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := MetricAlertSingleResourceMultipleMetricCriteria_OdataType_STATUS(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria_STATUS populates the provided destination MetricAlertSingleResourceMultipleMetricCriteria_STATUS from our MetricAlertSingleResourceMultipleMetricCriteria_STATUS
func (criteria *MetricAlertSingleResourceMultipleMetricCriteria_STATUS) AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(destination *v20180301s.MetricAlertSingleResourceMultipleMetricCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AllOf
	if criteria.AllOf != nil {
		allOfList := make([]v20180301s.MetricCriteria_STATUS, len(criteria.AllOf))
		for allOfIndex, allOfItem := range criteria.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf v20180301s.MetricCriteria_STATUS
			err := allOfItem.AssignProperties_To_MetricCriteria_STATUS(&allOf)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricCriteria_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		destination.AllOf = allOfList
	} else {
		destination.AllOf = nil
	}

	// OdataType
	if criteria.OdataType != nil {
		odataType := string(*criteria.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WebtestLocationAvailabilityCriteria struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// +kubebuilder:validation:Required
	// ComponentReference: The Application Insights resource Id.
	ComponentReference *genruntime.ResourceReference `armReference:"ComponentId" json:"componentReference,omitempty"`

	// +kubebuilder:validation:Required
	// FailedLocationCount: The number of failed locations.
	FailedLocationCount *float64 `json:"failedLocationCount,omitempty"`

	// +kubebuilder:validation:Required
	// OdataType: specifies the type of the alert criteria.
	OdataType *WebtestLocationAvailabilityCriteria_OdataType `json:"odata.type,omitempty"`

	// +kubebuilder:validation:Required
	// WebTestId: The Application Insights web test Id.
	WebTestId *string `json:"webTestId,omitempty"`
}

var _ genruntime.ARMTransformer = &WebtestLocationAvailabilityCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *WebtestLocationAvailabilityCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &WebtestLocationAvailabilityCriteria_ARM{}

	// Set property "AdditionalProperties":
	if criteria.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for key, value := range criteria.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "ComponentId":
	if criteria.ComponentReference != nil {
		componentReferenceARMID, err := resolved.ResolvedReferences.Lookup(*criteria.ComponentReference)
		if err != nil {
			return nil, err
		}
		componentReference := componentReferenceARMID
		result.ComponentId = &componentReference
	}

	// Set property "FailedLocationCount":
	if criteria.FailedLocationCount != nil {
		failedLocationCount := *criteria.FailedLocationCount
		result.FailedLocationCount = &failedLocationCount
	}

	// Set property "OdataType":
	if criteria.OdataType != nil {
		result.OdataType = *criteria.OdataType
	}

	// Set property "WebTestId":
	if criteria.WebTestId != nil {
		webTestId := *criteria.WebTestId
		result.WebTestId = &webTestId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *WebtestLocationAvailabilityCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WebtestLocationAvailabilityCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *WebtestLocationAvailabilityCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WebtestLocationAvailabilityCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WebtestLocationAvailabilityCriteria_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// no assignment for property "ComponentReference"

	// Set property "FailedLocationCount":
	if typedInput.FailedLocationCount != nil {
		failedLocationCount := *typedInput.FailedLocationCount
		criteria.FailedLocationCount = &failedLocationCount
	}

	// Set property "OdataType":
	criteria.OdataType = &typedInput.OdataType

	// Set property "WebTestId":
	if typedInput.WebTestId != nil {
		webTestId := *typedInput.WebTestId
		criteria.WebTestId = &webTestId
	}

	// No error
	return nil
}

// AssignProperties_From_WebtestLocationAvailabilityCriteria populates our WebtestLocationAvailabilityCriteria from the provided source WebtestLocationAvailabilityCriteria
func (criteria *WebtestLocationAvailabilityCriteria) AssignProperties_From_WebtestLocationAvailabilityCriteria(source *v20180301s.WebtestLocationAvailabilityCriteria) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// ComponentReference
	if source.ComponentReference != nil {
		componentReference := source.ComponentReference.Copy()
		criteria.ComponentReference = &componentReference
	} else {
		criteria.ComponentReference = nil
	}

	// FailedLocationCount
	if source.FailedLocationCount != nil {
		failedLocationCount := *source.FailedLocationCount
		criteria.FailedLocationCount = &failedLocationCount
	} else {
		criteria.FailedLocationCount = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := WebtestLocationAvailabilityCriteria_OdataType(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// WebTestId
	criteria.WebTestId = genruntime.ClonePointerToString(source.WebTestId)

	// No error
	return nil
}

// AssignProperties_To_WebtestLocationAvailabilityCriteria populates the provided destination WebtestLocationAvailabilityCriteria from our WebtestLocationAvailabilityCriteria
func (criteria *WebtestLocationAvailabilityCriteria) AssignProperties_To_WebtestLocationAvailabilityCriteria(destination *v20180301s.WebtestLocationAvailabilityCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// ComponentReference
	if criteria.ComponentReference != nil {
		componentReference := criteria.ComponentReference.Copy()
		destination.ComponentReference = &componentReference
	} else {
		destination.ComponentReference = nil
	}

	// FailedLocationCount
	if criteria.FailedLocationCount != nil {
		failedLocationCount := *criteria.FailedLocationCount
		destination.FailedLocationCount = &failedLocationCount
	} else {
		destination.FailedLocationCount = nil
	}

	// OdataType
	if criteria.OdataType != nil {
		odataType := string(*criteria.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// WebTestId
	destination.WebTestId = genruntime.ClonePointerToString(criteria.WebTestId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WebtestLocationAvailabilityCriteria_STATUS populates our WebtestLocationAvailabilityCriteria from the provided source WebtestLocationAvailabilityCriteria_STATUS
func (criteria *WebtestLocationAvailabilityCriteria) Initialize_From_WebtestLocationAvailabilityCriteria_STATUS(source *WebtestLocationAvailabilityCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// ComponentReference
	if source.ComponentId != nil {
		componentReference := genruntime.CreateResourceReferenceFromARMID(*source.ComponentId)
		criteria.ComponentReference = &componentReference
	} else {
		criteria.ComponentReference = nil
	}

	// FailedLocationCount
	if source.FailedLocationCount != nil {
		failedLocationCount := *source.FailedLocationCount
		criteria.FailedLocationCount = &failedLocationCount
	} else {
		criteria.FailedLocationCount = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := WebtestLocationAvailabilityCriteria_OdataType(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// WebTestId
	criteria.WebTestId = genruntime.ClonePointerToString(source.WebTestId)

	// No error
	return nil
}

type WebtestLocationAvailabilityCriteria_STATUS struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// ComponentId: The Application Insights resource Id.
	ComponentId *string `json:"componentId,omitempty"`

	// FailedLocationCount: The number of failed locations.
	FailedLocationCount *float64 `json:"failedLocationCount,omitempty"`

	// OdataType: specifies the type of the alert criteria.
	OdataType *WebtestLocationAvailabilityCriteria_OdataType_STATUS `json:"odata.type,omitempty"`

	// WebTestId: The Application Insights web test Id.
	WebTestId *string `json:"webTestId,omitempty"`
}

var _ genruntime.FromARMConverter = &WebtestLocationAvailabilityCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *WebtestLocationAvailabilityCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WebtestLocationAvailabilityCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *WebtestLocationAvailabilityCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WebtestLocationAvailabilityCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WebtestLocationAvailabilityCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "ComponentId":
	if typedInput.ComponentId != nil {
		componentId := *typedInput.ComponentId
		criteria.ComponentId = &componentId
	}

	// Set property "FailedLocationCount":
	if typedInput.FailedLocationCount != nil {
		failedLocationCount := *typedInput.FailedLocationCount
		criteria.FailedLocationCount = &failedLocationCount
	}

	// Set property "OdataType":
	criteria.OdataType = &typedInput.OdataType

	// Set property "WebTestId":
	if typedInput.WebTestId != nil {
		webTestId := *typedInput.WebTestId
		criteria.WebTestId = &webTestId
	}

	// No error
	return nil
}

// AssignProperties_From_WebtestLocationAvailabilityCriteria_STATUS populates our WebtestLocationAvailabilityCriteria_STATUS from the provided source WebtestLocationAvailabilityCriteria_STATUS
func (criteria *WebtestLocationAvailabilityCriteria_STATUS) AssignProperties_From_WebtestLocationAvailabilityCriteria_STATUS(source *v20180301s.WebtestLocationAvailabilityCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// ComponentId
	criteria.ComponentId = genruntime.ClonePointerToString(source.ComponentId)

	// FailedLocationCount
	if source.FailedLocationCount != nil {
		failedLocationCount := *source.FailedLocationCount
		criteria.FailedLocationCount = &failedLocationCount
	} else {
		criteria.FailedLocationCount = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := WebtestLocationAvailabilityCriteria_OdataType_STATUS(*source.OdataType)
		criteria.OdataType = &odataType
	} else {
		criteria.OdataType = nil
	}

	// WebTestId
	criteria.WebTestId = genruntime.ClonePointerToString(source.WebTestId)

	// No error
	return nil
}

// AssignProperties_To_WebtestLocationAvailabilityCriteria_STATUS populates the provided destination WebtestLocationAvailabilityCriteria_STATUS from our WebtestLocationAvailabilityCriteria_STATUS
func (criteria *WebtestLocationAvailabilityCriteria_STATUS) AssignProperties_To_WebtestLocationAvailabilityCriteria_STATUS(destination *v20180301s.WebtestLocationAvailabilityCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// ComponentId
	destination.ComponentId = genruntime.ClonePointerToString(criteria.ComponentId)

	// FailedLocationCount
	if criteria.FailedLocationCount != nil {
		failedLocationCount := *criteria.FailedLocationCount
		destination.FailedLocationCount = &failedLocationCount
	} else {
		destination.FailedLocationCount = nil
	}

	// OdataType
	if criteria.OdataType != nil {
		odataType := string(*criteria.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// WebTestId
	destination.WebTestId = genruntime.ClonePointerToString(criteria.WebTestId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria"}
type MetricAlertMultipleResourceMultipleMetricCriteria_OdataType string

const MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_MicrosoftAzureMonitorMultipleResourceMultipleMetricCriteria = MetricAlertMultipleResourceMultipleMetricCriteria_OdataType("Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria")

type MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_STATUS string

const MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_STATUS_MicrosoftAzureMonitorMultipleResourceMultipleMetricCriteria = MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_STATUS("Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria")

// +kubebuilder:validation:Enum={"Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria"}
type MetricAlertSingleResourceMultipleMetricCriteria_OdataType string

const MetricAlertSingleResourceMultipleMetricCriteria_OdataType_MicrosoftAzureMonitorSingleResourceMultipleMetricCriteria = MetricAlertSingleResourceMultipleMetricCriteria_OdataType("Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria")

type MetricAlertSingleResourceMultipleMetricCriteria_OdataType_STATUS string

const MetricAlertSingleResourceMultipleMetricCriteria_OdataType_STATUS_MicrosoftAzureMonitorSingleResourceMultipleMetricCriteria = MetricAlertSingleResourceMultipleMetricCriteria_OdataType_STATUS("Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria")

type MetricCriteria struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// +kubebuilder:validation:Required
	// CriterionType: Specifies the type of threshold criteria
	CriterionType *MetricCriteria_CriterionType `json:"criterionType,omitempty"`

	// Dimensions: List of dimension conditions.
	Dimensions []MetricDimension `json:"dimensions,omitempty"`

	// +kubebuilder:validation:Required
	// MetricName: Name of the metric.
	MetricName *string `json:"metricName,omitempty"`

	// MetricNamespace: Namespace of the metric.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Name of the criteria.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: the criteria operator.
	Operator *MetricCriteria_Operator `json:"operator,omitempty"`

	// SkipMetricValidation: Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric
	// validation to be skipped.
	SkipMetricValidation *bool `json:"skipMetricValidation,omitempty"`

	// +kubebuilder:validation:Required
	// Threshold: the criteria threshold value that activates the alert.
	Threshold *float64 `json:"threshold,omitempty"`

	// +kubebuilder:validation:Required
	// TimeAggregation: the criteria time aggregation types.
	TimeAggregation *MetricCriteria_TimeAggregation `json:"timeAggregation,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *MetricCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &MetricCriteria_ARM{}

	// Set property "AdditionalProperties":
	if criteria.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for key, value := range criteria.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "CriterionType":
	if criteria.CriterionType != nil {
		result.CriterionType = *criteria.CriterionType
	}

	// Set property "Dimensions":
	for _, item := range criteria.Dimensions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Dimensions = append(result.Dimensions, *item_ARM.(*MetricDimension_ARM))
	}

	// Set property "MetricName":
	if criteria.MetricName != nil {
		metricName := *criteria.MetricName
		result.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if criteria.MetricNamespace != nil {
		metricNamespace := *criteria.MetricNamespace
		result.MetricNamespace = &metricNamespace
	}

	// Set property "Name":
	if criteria.Name != nil {
		name := *criteria.Name
		result.Name = &name
	}

	// Set property "Operator":
	if criteria.Operator != nil {
		operator := *criteria.Operator
		result.Operator = &operator
	}

	// Set property "SkipMetricValidation":
	if criteria.SkipMetricValidation != nil {
		skipMetricValidation := *criteria.SkipMetricValidation
		result.SkipMetricValidation = &skipMetricValidation
	}

	// Set property "Threshold":
	if criteria.Threshold != nil {
		threshold := *criteria.Threshold
		result.Threshold = &threshold
	}

	// Set property "TimeAggregation":
	if criteria.TimeAggregation != nil {
		timeAggregation := *criteria.TimeAggregation
		result.TimeAggregation = &timeAggregation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricCriteria_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "CriterionType":
	criteria.CriterionType = &typedInput.CriterionType

	// Set property "Dimensions":
	for _, item := range typedInput.Dimensions {
		var item1 MetricDimension
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Dimensions = append(criteria.Dimensions, item1)
	}

	// Set property "MetricName":
	if typedInput.MetricName != nil {
		metricName := *typedInput.MetricName
		criteria.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if typedInput.MetricNamespace != nil {
		metricNamespace := *typedInput.MetricNamespace
		criteria.MetricNamespace = &metricNamespace
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		criteria.Name = &name
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		criteria.Operator = &operator
	}

	// Set property "SkipMetricValidation":
	if typedInput.SkipMetricValidation != nil {
		skipMetricValidation := *typedInput.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	}

	// Set property "Threshold":
	if typedInput.Threshold != nil {
		threshold := *typedInput.Threshold
		criteria.Threshold = &threshold
	}

	// Set property "TimeAggregation":
	if typedInput.TimeAggregation != nil {
		timeAggregation := *typedInput.TimeAggregation
		criteria.TimeAggregation = &timeAggregation
	}

	// No error
	return nil
}

// AssignProperties_From_MetricCriteria populates our MetricCriteria from the provided source MetricCriteria
func (criteria *MetricCriteria) AssignProperties_From_MetricCriteria(source *v20180301s.MetricCriteria) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// CriterionType
	if source.CriterionType != nil {
		criterionType := MetricCriteria_CriterionType(*source.CriterionType)
		criteria.CriterionType = &criterionType
	} else {
		criteria.CriterionType = nil
	}

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]MetricDimension, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension MetricDimension
			err := dimension.AssignProperties_From_MetricDimension(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricDimension() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		criteria.Dimensions = dimensionList
	} else {
		criteria.Dimensions = nil
	}

	// MetricName
	criteria.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	criteria.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// Name
	criteria.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	if source.Operator != nil {
		operator := MetricCriteria_Operator(*source.Operator)
		criteria.Operator = &operator
	} else {
		criteria.Operator = nil
	}

	// SkipMetricValidation
	if source.SkipMetricValidation != nil {
		skipMetricValidation := *source.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	} else {
		criteria.SkipMetricValidation = nil
	}

	// Threshold
	if source.Threshold != nil {
		threshold := *source.Threshold
		criteria.Threshold = &threshold
	} else {
		criteria.Threshold = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := MetricCriteria_TimeAggregation(*source.TimeAggregation)
		criteria.TimeAggregation = &timeAggregation
	} else {
		criteria.TimeAggregation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricCriteria populates the provided destination MetricCriteria from our MetricCriteria
func (criteria *MetricCriteria) AssignProperties_To_MetricCriteria(destination *v20180301s.MetricCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// CriterionType
	if criteria.CriterionType != nil {
		criterionType := string(*criteria.CriterionType)
		destination.CriterionType = &criterionType
	} else {
		destination.CriterionType = nil
	}

	// Dimensions
	if criteria.Dimensions != nil {
		dimensionList := make([]v20180301s.MetricDimension, len(criteria.Dimensions))
		for dimensionIndex, dimensionItem := range criteria.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension v20180301s.MetricDimension
			err := dimensionItem.AssignProperties_To_MetricDimension(&dimension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricDimension() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		destination.Dimensions = dimensionList
	} else {
		destination.Dimensions = nil
	}

	// MetricName
	destination.MetricName = genruntime.ClonePointerToString(criteria.MetricName)

	// MetricNamespace
	destination.MetricNamespace = genruntime.ClonePointerToString(criteria.MetricNamespace)

	// Name
	destination.Name = genruntime.ClonePointerToString(criteria.Name)

	// Operator
	if criteria.Operator != nil {
		operator := string(*criteria.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// SkipMetricValidation
	if criteria.SkipMetricValidation != nil {
		skipMetricValidation := *criteria.SkipMetricValidation
		destination.SkipMetricValidation = &skipMetricValidation
	} else {
		destination.SkipMetricValidation = nil
	}

	// Threshold
	if criteria.Threshold != nil {
		threshold := *criteria.Threshold
		destination.Threshold = &threshold
	} else {
		destination.Threshold = nil
	}

	// TimeAggregation
	if criteria.TimeAggregation != nil {
		timeAggregation := string(*criteria.TimeAggregation)
		destination.TimeAggregation = &timeAggregation
	} else {
		destination.TimeAggregation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricCriteria_STATUS populates our MetricCriteria from the provided source MetricCriteria_STATUS
func (criteria *MetricCriteria) Initialize_From_MetricCriteria_STATUS(source *MetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// CriterionType
	if source.CriterionType != nil {
		criterionType := MetricCriteria_CriterionType(*source.CriterionType)
		criteria.CriterionType = &criterionType
	} else {
		criteria.CriterionType = nil
	}

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]MetricDimension, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension MetricDimension
			err := dimension.Initialize_From_MetricDimension_STATUS(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		criteria.Dimensions = dimensionList
	} else {
		criteria.Dimensions = nil
	}

	// MetricName
	criteria.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	criteria.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// Name
	criteria.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	if source.Operator != nil {
		operator := MetricCriteria_Operator(*source.Operator)
		criteria.Operator = &operator
	} else {
		criteria.Operator = nil
	}

	// SkipMetricValidation
	if source.SkipMetricValidation != nil {
		skipMetricValidation := *source.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	} else {
		criteria.SkipMetricValidation = nil
	}

	// Threshold
	if source.Threshold != nil {
		threshold := *source.Threshold
		criteria.Threshold = &threshold
	} else {
		criteria.Threshold = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := MetricCriteria_TimeAggregation(*source.TimeAggregation)
		criteria.TimeAggregation = &timeAggregation
	} else {
		criteria.TimeAggregation = nil
	}

	// No error
	return nil
}

type MetricCriteria_STATUS struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// CriterionType: Specifies the type of threshold criteria
	CriterionType *MetricCriteria_CriterionType_STATUS `json:"criterionType,omitempty"`

	// Dimensions: List of dimension conditions.
	Dimensions []MetricDimension_STATUS `json:"dimensions,omitempty"`

	// MetricName: Name of the metric.
	MetricName *string `json:"metricName,omitempty"`

	// MetricNamespace: Namespace of the metric.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// Name: Name of the criteria.
	Name *string `json:"name,omitempty"`

	// Operator: the criteria operator.
	Operator *MetricCriteria_Operator_STATUS `json:"operator,omitempty"`

	// SkipMetricValidation: Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric
	// validation to be skipped.
	SkipMetricValidation *bool `json:"skipMetricValidation,omitempty"`

	// Threshold: the criteria threshold value that activates the alert.
	Threshold *float64 `json:"threshold,omitempty"`

	// TimeAggregation: the criteria time aggregation types.
	TimeAggregation *MetricCriteria_TimeAggregation_STATUS `json:"timeAggregation,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MetricCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MetricCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "CriterionType":
	criteria.CriterionType = &typedInput.CriterionType

	// Set property "Dimensions":
	for _, item := range typedInput.Dimensions {
		var item1 MetricDimension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Dimensions = append(criteria.Dimensions, item1)
	}

	// Set property "MetricName":
	if typedInput.MetricName != nil {
		metricName := *typedInput.MetricName
		criteria.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if typedInput.MetricNamespace != nil {
		metricNamespace := *typedInput.MetricNamespace
		criteria.MetricNamespace = &metricNamespace
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		criteria.Name = &name
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		criteria.Operator = &operator
	}

	// Set property "SkipMetricValidation":
	if typedInput.SkipMetricValidation != nil {
		skipMetricValidation := *typedInput.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	}

	// Set property "Threshold":
	if typedInput.Threshold != nil {
		threshold := *typedInput.Threshold
		criteria.Threshold = &threshold
	}

	// Set property "TimeAggregation":
	if typedInput.TimeAggregation != nil {
		timeAggregation := *typedInput.TimeAggregation
		criteria.TimeAggregation = &timeAggregation
	}

	// No error
	return nil
}

// AssignProperties_From_MetricCriteria_STATUS populates our MetricCriteria_STATUS from the provided source MetricCriteria_STATUS
func (criteria *MetricCriteria_STATUS) AssignProperties_From_MetricCriteria_STATUS(source *v20180301s.MetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// CriterionType
	if source.CriterionType != nil {
		criterionType := MetricCriteria_CriterionType_STATUS(*source.CriterionType)
		criteria.CriterionType = &criterionType
	} else {
		criteria.CriterionType = nil
	}

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]MetricDimension_STATUS, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension MetricDimension_STATUS
			err := dimension.AssignProperties_From_MetricDimension_STATUS(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		criteria.Dimensions = dimensionList
	} else {
		criteria.Dimensions = nil
	}

	// MetricName
	criteria.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	criteria.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// Name
	criteria.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	if source.Operator != nil {
		operator := MetricCriteria_Operator_STATUS(*source.Operator)
		criteria.Operator = &operator
	} else {
		criteria.Operator = nil
	}

	// SkipMetricValidation
	if source.SkipMetricValidation != nil {
		skipMetricValidation := *source.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	} else {
		criteria.SkipMetricValidation = nil
	}

	// Threshold
	if source.Threshold != nil {
		threshold := *source.Threshold
		criteria.Threshold = &threshold
	} else {
		criteria.Threshold = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := MetricCriteria_TimeAggregation_STATUS(*source.TimeAggregation)
		criteria.TimeAggregation = &timeAggregation
	} else {
		criteria.TimeAggregation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MetricCriteria_STATUS populates the provided destination MetricCriteria_STATUS from our MetricCriteria_STATUS
func (criteria *MetricCriteria_STATUS) AssignProperties_To_MetricCriteria_STATUS(destination *v20180301s.MetricCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// CriterionType
	if criteria.CriterionType != nil {
		criterionType := string(*criteria.CriterionType)
		destination.CriterionType = &criterionType
	} else {
		destination.CriterionType = nil
	}

	// Dimensions
	if criteria.Dimensions != nil {
		dimensionList := make([]v20180301s.MetricDimension_STATUS, len(criteria.Dimensions))
		for dimensionIndex, dimensionItem := range criteria.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension v20180301s.MetricDimension_STATUS
			err := dimensionItem.AssignProperties_To_MetricDimension_STATUS(&dimension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		destination.Dimensions = dimensionList
	} else {
		destination.Dimensions = nil
	}

	// MetricName
	destination.MetricName = genruntime.ClonePointerToString(criteria.MetricName)

	// MetricNamespace
	destination.MetricNamespace = genruntime.ClonePointerToString(criteria.MetricNamespace)

	// Name
	destination.Name = genruntime.ClonePointerToString(criteria.Name)

	// Operator
	if criteria.Operator != nil {
		operator := string(*criteria.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// SkipMetricValidation
	if criteria.SkipMetricValidation != nil {
		skipMetricValidation := *criteria.SkipMetricValidation
		destination.SkipMetricValidation = &skipMetricValidation
	} else {
		destination.SkipMetricValidation = nil
	}

	// Threshold
	if criteria.Threshold != nil {
		threshold := *criteria.Threshold
		destination.Threshold = &threshold
	} else {
		destination.Threshold = nil
	}

	// TimeAggregation
	if criteria.TimeAggregation != nil {
		timeAggregation := string(*criteria.TimeAggregation)
		destination.TimeAggregation = &timeAggregation
	} else {
		destination.TimeAggregation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MultiMetricCriteria struct {
	// Dynamic: Mutually exclusive with all other properties
	Dynamic *DynamicMetricCriteria `json:"dynamicThresholdCriterion,omitempty"`

	// Static: Mutually exclusive with all other properties
	Static *MetricCriteria `json:"staticThresholdCriterion,omitempty"`
}

var _ genruntime.ARMTransformer = &MultiMetricCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *MultiMetricCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &MultiMetricCriteria_ARM{}

	// Set property "Dynamic":
	if criteria.Dynamic != nil {
		dynamic_ARM, err := (*criteria.Dynamic).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dynamic := *dynamic_ARM.(*DynamicMetricCriteria_ARM)
		result.Dynamic = &dynamic
	}

	// Set property "Static":
	if criteria.Static != nil {
		static_ARM, err := (*criteria.Static).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		static := *static_ARM.(*MetricCriteria_ARM)
		result.Static = &static
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MultiMetricCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MultiMetricCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MultiMetricCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MultiMetricCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MultiMetricCriteria_ARM, got %T", armInput)
	}

	// Set property "Dynamic":
	if typedInput.Dynamic != nil {
		var dynamic1 DynamicMetricCriteria
		err := dynamic1.PopulateFromARM(owner, *typedInput.Dynamic)
		if err != nil {
			return err
		}
		dynamic := dynamic1
		criteria.Dynamic = &dynamic
	}

	// Set property "Static":
	if typedInput.Static != nil {
		var static1 MetricCriteria
		err := static1.PopulateFromARM(owner, *typedInput.Static)
		if err != nil {
			return err
		}
		static := static1
		criteria.Static = &static
	}

	// No error
	return nil
}

// AssignProperties_From_MultiMetricCriteria populates our MultiMetricCriteria from the provided source MultiMetricCriteria
func (criteria *MultiMetricCriteria) AssignProperties_From_MultiMetricCriteria(source *v20180301s.MultiMetricCriteria) error {

	// Dynamic
	if source.Dynamic != nil {
		var dynamic DynamicMetricCriteria
		err := dynamic.AssignProperties_From_DynamicMetricCriteria(source.Dynamic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DynamicMetricCriteria() to populate field Dynamic")
		}
		criteria.Dynamic = &dynamic
	} else {
		criteria.Dynamic = nil
	}

	// Static
	if source.Static != nil {
		var static MetricCriteria
		err := static.AssignProperties_From_MetricCriteria(source.Static)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricCriteria() to populate field Static")
		}
		criteria.Static = &static
	} else {
		criteria.Static = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MultiMetricCriteria populates the provided destination MultiMetricCriteria from our MultiMetricCriteria
func (criteria *MultiMetricCriteria) AssignProperties_To_MultiMetricCriteria(destination *v20180301s.MultiMetricCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Dynamic
	if criteria.Dynamic != nil {
		var dynamic v20180301s.DynamicMetricCriteria
		err := criteria.Dynamic.AssignProperties_To_DynamicMetricCriteria(&dynamic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DynamicMetricCriteria() to populate field Dynamic")
		}
		destination.Dynamic = &dynamic
	} else {
		destination.Dynamic = nil
	}

	// Static
	if criteria.Static != nil {
		var static v20180301s.MetricCriteria
		err := criteria.Static.AssignProperties_To_MetricCriteria(&static)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricCriteria() to populate field Static")
		}
		destination.Static = &static
	} else {
		destination.Static = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MultiMetricCriteria_STATUS populates our MultiMetricCriteria from the provided source MultiMetricCriteria_STATUS
func (criteria *MultiMetricCriteria) Initialize_From_MultiMetricCriteria_STATUS(source *MultiMetricCriteria_STATUS) error {

	// Dynamic
	if source.Dynamic != nil {
		var dynamic DynamicMetricCriteria
		err := dynamic.Initialize_From_DynamicMetricCriteria_STATUS(source.Dynamic)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DynamicMetricCriteria_STATUS() to populate field Dynamic")
		}
		criteria.Dynamic = &dynamic
	} else {
		criteria.Dynamic = nil
	}

	// Static
	if source.Static != nil {
		var static MetricCriteria
		err := static.Initialize_From_MetricCriteria_STATUS(source.Static)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MetricCriteria_STATUS() to populate field Static")
		}
		criteria.Static = &static
	} else {
		criteria.Static = nil
	}

	// No error
	return nil
}

type MultiMetricCriteria_STATUS struct {
	// Dynamic: Mutually exclusive with all other properties
	Dynamic *DynamicMetricCriteria_STATUS `json:"dynamicThresholdCriterion,omitempty"`

	// Static: Mutually exclusive with all other properties
	Static *MetricCriteria_STATUS `json:"staticThresholdCriterion,omitempty"`
}

var _ genruntime.FromARMConverter = &MultiMetricCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *MultiMetricCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MultiMetricCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *MultiMetricCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MultiMetricCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MultiMetricCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "Dynamic":
	if typedInput.Dynamic != nil {
		var dynamic1 DynamicMetricCriteria_STATUS
		err := dynamic1.PopulateFromARM(owner, *typedInput.Dynamic)
		if err != nil {
			return err
		}
		dynamic := dynamic1
		criteria.Dynamic = &dynamic
	}

	// Set property "Static":
	if typedInput.Static != nil {
		var static1 MetricCriteria_STATUS
		err := static1.PopulateFromARM(owner, *typedInput.Static)
		if err != nil {
			return err
		}
		static := static1
		criteria.Static = &static
	}

	// No error
	return nil
}

// AssignProperties_From_MultiMetricCriteria_STATUS populates our MultiMetricCriteria_STATUS from the provided source MultiMetricCriteria_STATUS
func (criteria *MultiMetricCriteria_STATUS) AssignProperties_From_MultiMetricCriteria_STATUS(source *v20180301s.MultiMetricCriteria_STATUS) error {

	// Dynamic
	if source.Dynamic != nil {
		var dynamic DynamicMetricCriteria_STATUS
		err := dynamic.AssignProperties_From_DynamicMetricCriteria_STATUS(source.Dynamic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DynamicMetricCriteria_STATUS() to populate field Dynamic")
		}
		criteria.Dynamic = &dynamic
	} else {
		criteria.Dynamic = nil
	}

	// Static
	if source.Static != nil {
		var static MetricCriteria_STATUS
		err := static.AssignProperties_From_MetricCriteria_STATUS(source.Static)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricCriteria_STATUS() to populate field Static")
		}
		criteria.Static = &static
	} else {
		criteria.Static = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MultiMetricCriteria_STATUS populates the provided destination MultiMetricCriteria_STATUS from our MultiMetricCriteria_STATUS
func (criteria *MultiMetricCriteria_STATUS) AssignProperties_To_MultiMetricCriteria_STATUS(destination *v20180301s.MultiMetricCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Dynamic
	if criteria.Dynamic != nil {
		var dynamic v20180301s.DynamicMetricCriteria_STATUS
		err := criteria.Dynamic.AssignProperties_To_DynamicMetricCriteria_STATUS(&dynamic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DynamicMetricCriteria_STATUS() to populate field Dynamic")
		}
		destination.Dynamic = &dynamic
	} else {
		destination.Dynamic = nil
	}

	// Static
	if criteria.Static != nil {
		var static v20180301s.MetricCriteria_STATUS
		err := criteria.Static.AssignProperties_To_MetricCriteria_STATUS(&static)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricCriteria_STATUS() to populate field Static")
		}
		destination.Static = &static
	} else {
		destination.Static = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria"}
type WebtestLocationAvailabilityCriteria_OdataType string

const WebtestLocationAvailabilityCriteria_OdataType_MicrosoftAzureMonitorWebtestLocationAvailabilityCriteria = WebtestLocationAvailabilityCriteria_OdataType("Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria")

type WebtestLocationAvailabilityCriteria_OdataType_STATUS string

const WebtestLocationAvailabilityCriteria_OdataType_STATUS_MicrosoftAzureMonitorWebtestLocationAvailabilityCriteria = WebtestLocationAvailabilityCriteria_OdataType_STATUS("Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria")

type DynamicMetricCriteria struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// +kubebuilder:validation:Required
	// AlertSensitivity: The extent of deviation required to trigger an alert. This will affect how tight the threshold is to
	// the metric series pattern.
	AlertSensitivity *DynamicMetricCriteria_AlertSensitivity `json:"alertSensitivity,omitempty"`

	// +kubebuilder:validation:Required
	// CriterionType: Specifies the type of threshold criteria
	CriterionType *DynamicMetricCriteria_CriterionType `json:"criterionType,omitempty"`

	// Dimensions: List of dimension conditions.
	Dimensions []MetricDimension `json:"dimensions,omitempty"`

	// +kubebuilder:validation:Required
	// FailingPeriods: The minimum number of violations required within the selected lookback time window required to raise an
	// alert.
	FailingPeriods *DynamicThresholdFailingPeriods `json:"failingPeriods,omitempty"`

	// IgnoreDataBefore: Use this option to set the date from which to start learning the metric historical data and calculate
	// the dynamic thresholds (in ISO8601 format)
	IgnoreDataBefore *string `json:"ignoreDataBefore,omitempty"`

	// +kubebuilder:validation:Required
	// MetricName: Name of the metric.
	MetricName *string `json:"metricName,omitempty"`

	// MetricNamespace: Namespace of the metric.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Name of the criteria.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: The operator used to compare the metric value against the threshold.
	Operator *DynamicMetricCriteria_Operator `json:"operator,omitempty"`

	// SkipMetricValidation: Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric
	// validation to be skipped.
	SkipMetricValidation *bool `json:"skipMetricValidation,omitempty"`

	// +kubebuilder:validation:Required
	// TimeAggregation: the criteria time aggregation types.
	TimeAggregation *DynamicMetricCriteria_TimeAggregation `json:"timeAggregation,omitempty"`
}

var _ genruntime.ARMTransformer = &DynamicMetricCriteria{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (criteria *DynamicMetricCriteria) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if criteria == nil {
		return nil, nil
	}
	result := &DynamicMetricCriteria_ARM{}

	// Set property "AdditionalProperties":
	if criteria.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for key, value := range criteria.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AlertSensitivity":
	if criteria.AlertSensitivity != nil {
		alertSensitivity := *criteria.AlertSensitivity
		result.AlertSensitivity = &alertSensitivity
	}

	// Set property "CriterionType":
	if criteria.CriterionType != nil {
		result.CriterionType = *criteria.CriterionType
	}

	// Set property "Dimensions":
	for _, item := range criteria.Dimensions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Dimensions = append(result.Dimensions, *item_ARM.(*MetricDimension_ARM))
	}

	// Set property "FailingPeriods":
	if criteria.FailingPeriods != nil {
		failingPeriods_ARM, err := (*criteria.FailingPeriods).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		failingPeriods := *failingPeriods_ARM.(*DynamicThresholdFailingPeriods_ARM)
		result.FailingPeriods = &failingPeriods
	}

	// Set property "IgnoreDataBefore":
	if criteria.IgnoreDataBefore != nil {
		ignoreDataBefore := *criteria.IgnoreDataBefore
		result.IgnoreDataBefore = &ignoreDataBefore
	}

	// Set property "MetricName":
	if criteria.MetricName != nil {
		metricName := *criteria.MetricName
		result.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if criteria.MetricNamespace != nil {
		metricNamespace := *criteria.MetricNamespace
		result.MetricNamespace = &metricNamespace
	}

	// Set property "Name":
	if criteria.Name != nil {
		name := *criteria.Name
		result.Name = &name
	}

	// Set property "Operator":
	if criteria.Operator != nil {
		operator := *criteria.Operator
		result.Operator = &operator
	}

	// Set property "SkipMetricValidation":
	if criteria.SkipMetricValidation != nil {
		skipMetricValidation := *criteria.SkipMetricValidation
		result.SkipMetricValidation = &skipMetricValidation
	}

	// Set property "TimeAggregation":
	if criteria.TimeAggregation != nil {
		timeAggregation := *criteria.TimeAggregation
		result.TimeAggregation = &timeAggregation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *DynamicMetricCriteria) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DynamicMetricCriteria_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *DynamicMetricCriteria) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DynamicMetricCriteria_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DynamicMetricCriteria_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AlertSensitivity":
	if typedInput.AlertSensitivity != nil {
		alertSensitivity := *typedInput.AlertSensitivity
		criteria.AlertSensitivity = &alertSensitivity
	}

	// Set property "CriterionType":
	criteria.CriterionType = &typedInput.CriterionType

	// Set property "Dimensions":
	for _, item := range typedInput.Dimensions {
		var item1 MetricDimension
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Dimensions = append(criteria.Dimensions, item1)
	}

	// Set property "FailingPeriods":
	if typedInput.FailingPeriods != nil {
		var failingPeriods1 DynamicThresholdFailingPeriods
		err := failingPeriods1.PopulateFromARM(owner, *typedInput.FailingPeriods)
		if err != nil {
			return err
		}
		failingPeriods := failingPeriods1
		criteria.FailingPeriods = &failingPeriods
	}

	// Set property "IgnoreDataBefore":
	if typedInput.IgnoreDataBefore != nil {
		ignoreDataBefore := *typedInput.IgnoreDataBefore
		criteria.IgnoreDataBefore = &ignoreDataBefore
	}

	// Set property "MetricName":
	if typedInput.MetricName != nil {
		metricName := *typedInput.MetricName
		criteria.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if typedInput.MetricNamespace != nil {
		metricNamespace := *typedInput.MetricNamespace
		criteria.MetricNamespace = &metricNamespace
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		criteria.Name = &name
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		criteria.Operator = &operator
	}

	// Set property "SkipMetricValidation":
	if typedInput.SkipMetricValidation != nil {
		skipMetricValidation := *typedInput.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	}

	// Set property "TimeAggregation":
	if typedInput.TimeAggregation != nil {
		timeAggregation := *typedInput.TimeAggregation
		criteria.TimeAggregation = &timeAggregation
	}

	// No error
	return nil
}

// AssignProperties_From_DynamicMetricCriteria populates our DynamicMetricCriteria from the provided source DynamicMetricCriteria
func (criteria *DynamicMetricCriteria) AssignProperties_From_DynamicMetricCriteria(source *v20180301s.DynamicMetricCriteria) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AlertSensitivity
	if source.AlertSensitivity != nil {
		alertSensitivity := DynamicMetricCriteria_AlertSensitivity(*source.AlertSensitivity)
		criteria.AlertSensitivity = &alertSensitivity
	} else {
		criteria.AlertSensitivity = nil
	}

	// CriterionType
	if source.CriterionType != nil {
		criterionType := DynamicMetricCriteria_CriterionType(*source.CriterionType)
		criteria.CriterionType = &criterionType
	} else {
		criteria.CriterionType = nil
	}

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]MetricDimension, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension MetricDimension
			err := dimension.AssignProperties_From_MetricDimension(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricDimension() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		criteria.Dimensions = dimensionList
	} else {
		criteria.Dimensions = nil
	}

	// FailingPeriods
	if source.FailingPeriods != nil {
		var failingPeriod DynamicThresholdFailingPeriods
		err := failingPeriod.AssignProperties_From_DynamicThresholdFailingPeriods(source.FailingPeriods)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DynamicThresholdFailingPeriods() to populate field FailingPeriods")
		}
		criteria.FailingPeriods = &failingPeriod
	} else {
		criteria.FailingPeriods = nil
	}

	// IgnoreDataBefore
	criteria.IgnoreDataBefore = genruntime.ClonePointerToString(source.IgnoreDataBefore)

	// MetricName
	criteria.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	criteria.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// Name
	criteria.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	if source.Operator != nil {
		operator := DynamicMetricCriteria_Operator(*source.Operator)
		criteria.Operator = &operator
	} else {
		criteria.Operator = nil
	}

	// SkipMetricValidation
	if source.SkipMetricValidation != nil {
		skipMetricValidation := *source.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	} else {
		criteria.SkipMetricValidation = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := DynamicMetricCriteria_TimeAggregation(*source.TimeAggregation)
		criteria.TimeAggregation = &timeAggregation
	} else {
		criteria.TimeAggregation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DynamicMetricCriteria populates the provided destination DynamicMetricCriteria from our DynamicMetricCriteria
func (criteria *DynamicMetricCriteria) AssignProperties_To_DynamicMetricCriteria(destination *v20180301s.DynamicMetricCriteria) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AlertSensitivity
	if criteria.AlertSensitivity != nil {
		alertSensitivity := string(*criteria.AlertSensitivity)
		destination.AlertSensitivity = &alertSensitivity
	} else {
		destination.AlertSensitivity = nil
	}

	// CriterionType
	if criteria.CriterionType != nil {
		criterionType := string(*criteria.CriterionType)
		destination.CriterionType = &criterionType
	} else {
		destination.CriterionType = nil
	}

	// Dimensions
	if criteria.Dimensions != nil {
		dimensionList := make([]v20180301s.MetricDimension, len(criteria.Dimensions))
		for dimensionIndex, dimensionItem := range criteria.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension v20180301s.MetricDimension
			err := dimensionItem.AssignProperties_To_MetricDimension(&dimension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricDimension() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		destination.Dimensions = dimensionList
	} else {
		destination.Dimensions = nil
	}

	// FailingPeriods
	if criteria.FailingPeriods != nil {
		var failingPeriod v20180301s.DynamicThresholdFailingPeriods
		err := criteria.FailingPeriods.AssignProperties_To_DynamicThresholdFailingPeriods(&failingPeriod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DynamicThresholdFailingPeriods() to populate field FailingPeriods")
		}
		destination.FailingPeriods = &failingPeriod
	} else {
		destination.FailingPeriods = nil
	}

	// IgnoreDataBefore
	destination.IgnoreDataBefore = genruntime.ClonePointerToString(criteria.IgnoreDataBefore)

	// MetricName
	destination.MetricName = genruntime.ClonePointerToString(criteria.MetricName)

	// MetricNamespace
	destination.MetricNamespace = genruntime.ClonePointerToString(criteria.MetricNamespace)

	// Name
	destination.Name = genruntime.ClonePointerToString(criteria.Name)

	// Operator
	if criteria.Operator != nil {
		operator := string(*criteria.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// SkipMetricValidation
	if criteria.SkipMetricValidation != nil {
		skipMetricValidation := *criteria.SkipMetricValidation
		destination.SkipMetricValidation = &skipMetricValidation
	} else {
		destination.SkipMetricValidation = nil
	}

	// TimeAggregation
	if criteria.TimeAggregation != nil {
		timeAggregation := string(*criteria.TimeAggregation)
		destination.TimeAggregation = &timeAggregation
	} else {
		destination.TimeAggregation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DynamicMetricCriteria_STATUS populates our DynamicMetricCriteria from the provided source DynamicMetricCriteria_STATUS
func (criteria *DynamicMetricCriteria) Initialize_From_DynamicMetricCriteria_STATUS(source *DynamicMetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AlertSensitivity
	if source.AlertSensitivity != nil {
		alertSensitivity := DynamicMetricCriteria_AlertSensitivity(*source.AlertSensitivity)
		criteria.AlertSensitivity = &alertSensitivity
	} else {
		criteria.AlertSensitivity = nil
	}

	// CriterionType
	if source.CriterionType != nil {
		criterionType := DynamicMetricCriteria_CriterionType(*source.CriterionType)
		criteria.CriterionType = &criterionType
	} else {
		criteria.CriterionType = nil
	}

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]MetricDimension, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension MetricDimension
			err := dimension.Initialize_From_MetricDimension_STATUS(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		criteria.Dimensions = dimensionList
	} else {
		criteria.Dimensions = nil
	}

	// FailingPeriods
	if source.FailingPeriods != nil {
		var failingPeriod DynamicThresholdFailingPeriods
		err := failingPeriod.Initialize_From_DynamicThresholdFailingPeriods_STATUS(source.FailingPeriods)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DynamicThresholdFailingPeriods_STATUS() to populate field FailingPeriods")
		}
		criteria.FailingPeriods = &failingPeriod
	} else {
		criteria.FailingPeriods = nil
	}

	// IgnoreDataBefore
	criteria.IgnoreDataBefore = genruntime.ClonePointerToString(source.IgnoreDataBefore)

	// MetricName
	criteria.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	criteria.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// Name
	criteria.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	if source.Operator != nil {
		operator := DynamicMetricCriteria_Operator(*source.Operator)
		criteria.Operator = &operator
	} else {
		criteria.Operator = nil
	}

	// SkipMetricValidation
	if source.SkipMetricValidation != nil {
		skipMetricValidation := *source.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	} else {
		criteria.SkipMetricValidation = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := DynamicMetricCriteria_TimeAggregation(*source.TimeAggregation)
		criteria.TimeAggregation = &timeAggregation
	} else {
		criteria.TimeAggregation = nil
	}

	// No error
	return nil
}

type DynamicMetricCriteria_STATUS struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// AlertSensitivity: The extent of deviation required to trigger an alert. This will affect how tight the threshold is to
	// the metric series pattern.
	AlertSensitivity *DynamicMetricCriteria_AlertSensitivity_STATUS `json:"alertSensitivity,omitempty"`

	// CriterionType: Specifies the type of threshold criteria
	CriterionType *DynamicMetricCriteria_CriterionType_STATUS `json:"criterionType,omitempty"`

	// Dimensions: List of dimension conditions.
	Dimensions []MetricDimension_STATUS `json:"dimensions,omitempty"`

	// FailingPeriods: The minimum number of violations required within the selected lookback time window required to raise an
	// alert.
	FailingPeriods *DynamicThresholdFailingPeriods_STATUS `json:"failingPeriods,omitempty"`

	// IgnoreDataBefore: Use this option to set the date from which to start learning the metric historical data and calculate
	// the dynamic thresholds (in ISO8601 format)
	IgnoreDataBefore *string `json:"ignoreDataBefore,omitempty"`

	// MetricName: Name of the metric.
	MetricName *string `json:"metricName,omitempty"`

	// MetricNamespace: Namespace of the metric.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// Name: Name of the criteria.
	Name *string `json:"name,omitempty"`

	// Operator: The operator used to compare the metric value against the threshold.
	Operator *DynamicMetricCriteria_Operator_STATUS `json:"operator,omitempty"`

	// SkipMetricValidation: Allows creating an alert rule on a custom metric that isn't yet emitted, by causing the metric
	// validation to be skipped.
	SkipMetricValidation *bool `json:"skipMetricValidation,omitempty"`

	// TimeAggregation: the criteria time aggregation types.
	TimeAggregation *DynamicMetricCriteria_TimeAggregation_STATUS `json:"timeAggregation,omitempty"`
}

var _ genruntime.FromARMConverter = &DynamicMetricCriteria_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (criteria *DynamicMetricCriteria_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DynamicMetricCriteria_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (criteria *DynamicMetricCriteria_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DynamicMetricCriteria_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DynamicMetricCriteria_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		criteria.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			criteria.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AlertSensitivity":
	if typedInput.AlertSensitivity != nil {
		alertSensitivity := *typedInput.AlertSensitivity
		criteria.AlertSensitivity = &alertSensitivity
	}

	// Set property "CriterionType":
	criteria.CriterionType = &typedInput.CriterionType

	// Set property "Dimensions":
	for _, item := range typedInput.Dimensions {
		var item1 MetricDimension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		criteria.Dimensions = append(criteria.Dimensions, item1)
	}

	// Set property "FailingPeriods":
	if typedInput.FailingPeriods != nil {
		var failingPeriods1 DynamicThresholdFailingPeriods_STATUS
		err := failingPeriods1.PopulateFromARM(owner, *typedInput.FailingPeriods)
		if err != nil {
			return err
		}
		failingPeriods := failingPeriods1
		criteria.FailingPeriods = &failingPeriods
	}

	// Set property "IgnoreDataBefore":
	if typedInput.IgnoreDataBefore != nil {
		ignoreDataBefore := *typedInput.IgnoreDataBefore
		criteria.IgnoreDataBefore = &ignoreDataBefore
	}

	// Set property "MetricName":
	if typedInput.MetricName != nil {
		metricName := *typedInput.MetricName
		criteria.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if typedInput.MetricNamespace != nil {
		metricNamespace := *typedInput.MetricNamespace
		criteria.MetricNamespace = &metricNamespace
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		criteria.Name = &name
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		criteria.Operator = &operator
	}

	// Set property "SkipMetricValidation":
	if typedInput.SkipMetricValidation != nil {
		skipMetricValidation := *typedInput.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	}

	// Set property "TimeAggregation":
	if typedInput.TimeAggregation != nil {
		timeAggregation := *typedInput.TimeAggregation
		criteria.TimeAggregation = &timeAggregation
	}

	// No error
	return nil
}

// AssignProperties_From_DynamicMetricCriteria_STATUS populates our DynamicMetricCriteria_STATUS from the provided source DynamicMetricCriteria_STATUS
func (criteria *DynamicMetricCriteria_STATUS) AssignProperties_From_DynamicMetricCriteria_STATUS(source *v20180301s.DynamicMetricCriteria_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		criteria.AdditionalProperties = additionalPropertyMap
	} else {
		criteria.AdditionalProperties = nil
	}

	// AlertSensitivity
	if source.AlertSensitivity != nil {
		alertSensitivity := DynamicMetricCriteria_AlertSensitivity_STATUS(*source.AlertSensitivity)
		criteria.AlertSensitivity = &alertSensitivity
	} else {
		criteria.AlertSensitivity = nil
	}

	// CriterionType
	if source.CriterionType != nil {
		criterionType := DynamicMetricCriteria_CriterionType_STATUS(*source.CriterionType)
		criteria.CriterionType = &criterionType
	} else {
		criteria.CriterionType = nil
	}

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]MetricDimension_STATUS, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension MetricDimension_STATUS
			err := dimension.AssignProperties_From_MetricDimension_STATUS(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		criteria.Dimensions = dimensionList
	} else {
		criteria.Dimensions = nil
	}

	// FailingPeriods
	if source.FailingPeriods != nil {
		var failingPeriod DynamicThresholdFailingPeriods_STATUS
		err := failingPeriod.AssignProperties_From_DynamicThresholdFailingPeriods_STATUS(source.FailingPeriods)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DynamicThresholdFailingPeriods_STATUS() to populate field FailingPeriods")
		}
		criteria.FailingPeriods = &failingPeriod
	} else {
		criteria.FailingPeriods = nil
	}

	// IgnoreDataBefore
	criteria.IgnoreDataBefore = genruntime.ClonePointerToString(source.IgnoreDataBefore)

	// MetricName
	criteria.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	criteria.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// Name
	criteria.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	if source.Operator != nil {
		operator := DynamicMetricCriteria_Operator_STATUS(*source.Operator)
		criteria.Operator = &operator
	} else {
		criteria.Operator = nil
	}

	// SkipMetricValidation
	if source.SkipMetricValidation != nil {
		skipMetricValidation := *source.SkipMetricValidation
		criteria.SkipMetricValidation = &skipMetricValidation
	} else {
		criteria.SkipMetricValidation = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := DynamicMetricCriteria_TimeAggregation_STATUS(*source.TimeAggregation)
		criteria.TimeAggregation = &timeAggregation
	} else {
		criteria.TimeAggregation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DynamicMetricCriteria_STATUS populates the provided destination DynamicMetricCriteria_STATUS from our DynamicMetricCriteria_STATUS
func (criteria *DynamicMetricCriteria_STATUS) AssignProperties_To_DynamicMetricCriteria_STATUS(destination *v20180301s.DynamicMetricCriteria_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if criteria.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(criteria.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range criteria.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AlertSensitivity
	if criteria.AlertSensitivity != nil {
		alertSensitivity := string(*criteria.AlertSensitivity)
		destination.AlertSensitivity = &alertSensitivity
	} else {
		destination.AlertSensitivity = nil
	}

	// CriterionType
	if criteria.CriterionType != nil {
		criterionType := string(*criteria.CriterionType)
		destination.CriterionType = &criterionType
	} else {
		destination.CriterionType = nil
	}

	// Dimensions
	if criteria.Dimensions != nil {
		dimensionList := make([]v20180301s.MetricDimension_STATUS, len(criteria.Dimensions))
		for dimensionIndex, dimensionItem := range criteria.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension v20180301s.MetricDimension_STATUS
			err := dimensionItem.AssignProperties_To_MetricDimension_STATUS(&dimension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		destination.Dimensions = dimensionList
	} else {
		destination.Dimensions = nil
	}

	// FailingPeriods
	if criteria.FailingPeriods != nil {
		var failingPeriod v20180301s.DynamicThresholdFailingPeriods_STATUS
		err := criteria.FailingPeriods.AssignProperties_To_DynamicThresholdFailingPeriods_STATUS(&failingPeriod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DynamicThresholdFailingPeriods_STATUS() to populate field FailingPeriods")
		}
		destination.FailingPeriods = &failingPeriod
	} else {
		destination.FailingPeriods = nil
	}

	// IgnoreDataBefore
	destination.IgnoreDataBefore = genruntime.ClonePointerToString(criteria.IgnoreDataBefore)

	// MetricName
	destination.MetricName = genruntime.ClonePointerToString(criteria.MetricName)

	// MetricNamespace
	destination.MetricNamespace = genruntime.ClonePointerToString(criteria.MetricNamespace)

	// Name
	destination.Name = genruntime.ClonePointerToString(criteria.Name)

	// Operator
	if criteria.Operator != nil {
		operator := string(*criteria.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// SkipMetricValidation
	if criteria.SkipMetricValidation != nil {
		skipMetricValidation := *criteria.SkipMetricValidation
		destination.SkipMetricValidation = &skipMetricValidation
	} else {
		destination.SkipMetricValidation = nil
	}

	// TimeAggregation
	if criteria.TimeAggregation != nil {
		timeAggregation := string(*criteria.TimeAggregation)
		destination.TimeAggregation = &timeAggregation
	} else {
		destination.TimeAggregation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"StaticThresholdCriterion"}
type MetricCriteria_CriterionType string

const MetricCriteria_CriterionType_StaticThresholdCriterion = MetricCriteria_CriterionType("StaticThresholdCriterion")

type MetricCriteria_CriterionType_STATUS string

const MetricCriteria_CriterionType_STATUS_StaticThresholdCriterion = MetricCriteria_CriterionType_STATUS("StaticThresholdCriterion")

// +kubebuilder:validation:Enum={"Equals","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual"}
type MetricCriteria_Operator string

const (
	MetricCriteria_Operator_Equals             = MetricCriteria_Operator("Equals")
	MetricCriteria_Operator_GreaterThan        = MetricCriteria_Operator("GreaterThan")
	MetricCriteria_Operator_GreaterThanOrEqual = MetricCriteria_Operator("GreaterThanOrEqual")
	MetricCriteria_Operator_LessThan           = MetricCriteria_Operator("LessThan")
	MetricCriteria_Operator_LessThanOrEqual    = MetricCriteria_Operator("LessThanOrEqual")
)

type MetricCriteria_Operator_STATUS string

const (
	MetricCriteria_Operator_STATUS_Equals             = MetricCriteria_Operator_STATUS("Equals")
	MetricCriteria_Operator_STATUS_GreaterThan        = MetricCriteria_Operator_STATUS("GreaterThan")
	MetricCriteria_Operator_STATUS_GreaterThanOrEqual = MetricCriteria_Operator_STATUS("GreaterThanOrEqual")
	MetricCriteria_Operator_STATUS_LessThan           = MetricCriteria_Operator_STATUS("LessThan")
	MetricCriteria_Operator_STATUS_LessThanOrEqual    = MetricCriteria_Operator_STATUS("LessThanOrEqual")
)

// +kubebuilder:validation:Enum={"Average","Count","Maximum","Minimum","Total"}
type MetricCriteria_TimeAggregation string

const (
	MetricCriteria_TimeAggregation_Average = MetricCriteria_TimeAggregation("Average")
	MetricCriteria_TimeAggregation_Count   = MetricCriteria_TimeAggregation("Count")
	MetricCriteria_TimeAggregation_Maximum = MetricCriteria_TimeAggregation("Maximum")
	MetricCriteria_TimeAggregation_Minimum = MetricCriteria_TimeAggregation("Minimum")
	MetricCriteria_TimeAggregation_Total   = MetricCriteria_TimeAggregation("Total")
)

type MetricCriteria_TimeAggregation_STATUS string

const (
	MetricCriteria_TimeAggregation_STATUS_Average = MetricCriteria_TimeAggregation_STATUS("Average")
	MetricCriteria_TimeAggregation_STATUS_Count   = MetricCriteria_TimeAggregation_STATUS("Count")
	MetricCriteria_TimeAggregation_STATUS_Maximum = MetricCriteria_TimeAggregation_STATUS("Maximum")
	MetricCriteria_TimeAggregation_STATUS_Minimum = MetricCriteria_TimeAggregation_STATUS("Minimum")
	MetricCriteria_TimeAggregation_STATUS_Total   = MetricCriteria_TimeAggregation_STATUS("Total")
)

// Specifies a metric dimension.
type MetricDimension struct {
	// +kubebuilder:validation:Required
	// Name: Name of the dimension.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: the dimension operator. Only 'Include' and 'Exclude' are supported
	Operator *string `json:"operator,omitempty"`

	// +kubebuilder:validation:Required
	// Values: list of dimension values.
	Values []string `json:"values,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricDimension{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (dimension *MetricDimension) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if dimension == nil {
		return nil, nil
	}
	result := &MetricDimension_ARM{}

	// Set property "Name":
	if dimension.Name != nil {
		name := *dimension.Name
		result.Name = &name
	}

	// Set property "Operator":
	if dimension.Operator != nil {
		operator := *dimension.Operator
		result.Operator = &operator
	}

	// Set property "Values":
	for _, item := range dimension.Values {
		result.Values = append(result.Values, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dimension *MetricDimension) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricDimension_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dimension *MetricDimension) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricDimension_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricDimension_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		dimension.Name = &name
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		dimension.Operator = &operator
	}

	// Set property "Values":
	for _, item := range typedInput.Values {
		dimension.Values = append(dimension.Values, item)
	}

	// No error
	return nil
}

// AssignProperties_From_MetricDimension populates our MetricDimension from the provided source MetricDimension
func (dimension *MetricDimension) AssignProperties_From_MetricDimension(source *v20180301s.MetricDimension) error {

	// Name
	dimension.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	dimension.Operator = genruntime.ClonePointerToString(source.Operator)

	// Values
	dimension.Values = genruntime.CloneSliceOfString(source.Values)

	// No error
	return nil
}

// AssignProperties_To_MetricDimension populates the provided destination MetricDimension from our MetricDimension
func (dimension *MetricDimension) AssignProperties_To_MetricDimension(destination *v20180301s.MetricDimension) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(dimension.Name)

	// Operator
	destination.Operator = genruntime.ClonePointerToString(dimension.Operator)

	// Values
	destination.Values = genruntime.CloneSliceOfString(dimension.Values)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricDimension_STATUS populates our MetricDimension from the provided source MetricDimension_STATUS
func (dimension *MetricDimension) Initialize_From_MetricDimension_STATUS(source *MetricDimension_STATUS) error {

	// Name
	dimension.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	dimension.Operator = genruntime.ClonePointerToString(source.Operator)

	// Values
	dimension.Values = genruntime.CloneSliceOfString(source.Values)

	// No error
	return nil
}

// Specifies a metric dimension.
type MetricDimension_STATUS struct {
	// Name: Name of the dimension.
	Name *string `json:"name,omitempty"`

	// Operator: the dimension operator. Only 'Include' and 'Exclude' are supported
	Operator *string `json:"operator,omitempty"`

	// Values: list of dimension values.
	Values []string `json:"values,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricDimension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dimension *MetricDimension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MetricDimension_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dimension *MetricDimension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MetricDimension_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MetricDimension_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		dimension.Name = &name
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		dimension.Operator = &operator
	}

	// Set property "Values":
	for _, item := range typedInput.Values {
		dimension.Values = append(dimension.Values, item)
	}

	// No error
	return nil
}

// AssignProperties_From_MetricDimension_STATUS populates our MetricDimension_STATUS from the provided source MetricDimension_STATUS
func (dimension *MetricDimension_STATUS) AssignProperties_From_MetricDimension_STATUS(source *v20180301s.MetricDimension_STATUS) error {

	// Name
	dimension.Name = genruntime.ClonePointerToString(source.Name)

	// Operator
	dimension.Operator = genruntime.ClonePointerToString(source.Operator)

	// Values
	dimension.Values = genruntime.CloneSliceOfString(source.Values)

	// No error
	return nil
}

// AssignProperties_To_MetricDimension_STATUS populates the provided destination MetricDimension_STATUS from our MetricDimension_STATUS
func (dimension *MetricDimension_STATUS) AssignProperties_To_MetricDimension_STATUS(destination *v20180301s.MetricDimension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(dimension.Name)

	// Operator
	destination.Operator = genruntime.ClonePointerToString(dimension.Operator)

	// Values
	destination.Values = genruntime.CloneSliceOfString(dimension.Values)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"High","Low","Medium"}
type DynamicMetricCriteria_AlertSensitivity string

const (
	DynamicMetricCriteria_AlertSensitivity_High   = DynamicMetricCriteria_AlertSensitivity("High")
	DynamicMetricCriteria_AlertSensitivity_Low    = DynamicMetricCriteria_AlertSensitivity("Low")
	DynamicMetricCriteria_AlertSensitivity_Medium = DynamicMetricCriteria_AlertSensitivity("Medium")
)

type DynamicMetricCriteria_AlertSensitivity_STATUS string

const (
	DynamicMetricCriteria_AlertSensitivity_STATUS_High   = DynamicMetricCriteria_AlertSensitivity_STATUS("High")
	DynamicMetricCriteria_AlertSensitivity_STATUS_Low    = DynamicMetricCriteria_AlertSensitivity_STATUS("Low")
	DynamicMetricCriteria_AlertSensitivity_STATUS_Medium = DynamicMetricCriteria_AlertSensitivity_STATUS("Medium")
)

// +kubebuilder:validation:Enum={"DynamicThresholdCriterion"}
type DynamicMetricCriteria_CriterionType string

const DynamicMetricCriteria_CriterionType_DynamicThresholdCriterion = DynamicMetricCriteria_CriterionType("DynamicThresholdCriterion")

type DynamicMetricCriteria_CriterionType_STATUS string

const DynamicMetricCriteria_CriterionType_STATUS_DynamicThresholdCriterion = DynamicMetricCriteria_CriterionType_STATUS("DynamicThresholdCriterion")

// +kubebuilder:validation:Enum={"GreaterOrLessThan","GreaterThan","LessThan"}
type DynamicMetricCriteria_Operator string

const (
	DynamicMetricCriteria_Operator_GreaterOrLessThan = DynamicMetricCriteria_Operator("GreaterOrLessThan")
	DynamicMetricCriteria_Operator_GreaterThan       = DynamicMetricCriteria_Operator("GreaterThan")
	DynamicMetricCriteria_Operator_LessThan          = DynamicMetricCriteria_Operator("LessThan")
)

type DynamicMetricCriteria_Operator_STATUS string

const (
	DynamicMetricCriteria_Operator_STATUS_GreaterOrLessThan = DynamicMetricCriteria_Operator_STATUS("GreaterOrLessThan")
	DynamicMetricCriteria_Operator_STATUS_GreaterThan       = DynamicMetricCriteria_Operator_STATUS("GreaterThan")
	DynamicMetricCriteria_Operator_STATUS_LessThan          = DynamicMetricCriteria_Operator_STATUS("LessThan")
)

// +kubebuilder:validation:Enum={"Average","Count","Maximum","Minimum","Total"}
type DynamicMetricCriteria_TimeAggregation string

const (
	DynamicMetricCriteria_TimeAggregation_Average = DynamicMetricCriteria_TimeAggregation("Average")
	DynamicMetricCriteria_TimeAggregation_Count   = DynamicMetricCriteria_TimeAggregation("Count")
	DynamicMetricCriteria_TimeAggregation_Maximum = DynamicMetricCriteria_TimeAggregation("Maximum")
	DynamicMetricCriteria_TimeAggregation_Minimum = DynamicMetricCriteria_TimeAggregation("Minimum")
	DynamicMetricCriteria_TimeAggregation_Total   = DynamicMetricCriteria_TimeAggregation("Total")
)

type DynamicMetricCriteria_TimeAggregation_STATUS string

const (
	DynamicMetricCriteria_TimeAggregation_STATUS_Average = DynamicMetricCriteria_TimeAggregation_STATUS("Average")
	DynamicMetricCriteria_TimeAggregation_STATUS_Count   = DynamicMetricCriteria_TimeAggregation_STATUS("Count")
	DynamicMetricCriteria_TimeAggregation_STATUS_Maximum = DynamicMetricCriteria_TimeAggregation_STATUS("Maximum")
	DynamicMetricCriteria_TimeAggregation_STATUS_Minimum = DynamicMetricCriteria_TimeAggregation_STATUS("Minimum")
	DynamicMetricCriteria_TimeAggregation_STATUS_Total   = DynamicMetricCriteria_TimeAggregation_STATUS("Total")
)

// The minimum number of violations required within the selected lookback time window required to raise an alert.
type DynamicThresholdFailingPeriods struct {
	// +kubebuilder:validation:Required
	// MinFailingPeriodsToAlert: The number of violations to trigger an alert. Should be smaller or equal to
	// numberOfEvaluationPeriods.
	MinFailingPeriodsToAlert *float64 `json:"minFailingPeriodsToAlert,omitempty"`

	// +kubebuilder:validation:Required
	// NumberOfEvaluationPeriods: The number of aggregated lookback points. The lookback time window is calculated based on the
	// aggregation granularity (windowSize) and the selected number of aggregated points.
	NumberOfEvaluationPeriods *float64 `json:"numberOfEvaluationPeriods,omitempty"`
}

var _ genruntime.ARMTransformer = &DynamicThresholdFailingPeriods{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (periods *DynamicThresholdFailingPeriods) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if periods == nil {
		return nil, nil
	}
	result := &DynamicThresholdFailingPeriods_ARM{}

	// Set property "MinFailingPeriodsToAlert":
	if periods.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *periods.MinFailingPeriodsToAlert
		result.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	}

	// Set property "NumberOfEvaluationPeriods":
	if periods.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriods := *periods.NumberOfEvaluationPeriods
		result.NumberOfEvaluationPeriods = &numberOfEvaluationPeriods
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (periods *DynamicThresholdFailingPeriods) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DynamicThresholdFailingPeriods_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (periods *DynamicThresholdFailingPeriods) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DynamicThresholdFailingPeriods_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DynamicThresholdFailingPeriods_ARM, got %T", armInput)
	}

	// Set property "MinFailingPeriodsToAlert":
	if typedInput.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *typedInput.MinFailingPeriodsToAlert
		periods.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	}

	// Set property "NumberOfEvaluationPeriods":
	if typedInput.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriods := *typedInput.NumberOfEvaluationPeriods
		periods.NumberOfEvaluationPeriods = &numberOfEvaluationPeriods
	}

	// No error
	return nil
}

// AssignProperties_From_DynamicThresholdFailingPeriods populates our DynamicThresholdFailingPeriods from the provided source DynamicThresholdFailingPeriods
func (periods *DynamicThresholdFailingPeriods) AssignProperties_From_DynamicThresholdFailingPeriods(source *v20180301s.DynamicThresholdFailingPeriods) error {

	// MinFailingPeriodsToAlert
	if source.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *source.MinFailingPeriodsToAlert
		periods.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	} else {
		periods.MinFailingPeriodsToAlert = nil
	}

	// NumberOfEvaluationPeriods
	if source.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriod := *source.NumberOfEvaluationPeriods
		periods.NumberOfEvaluationPeriods = &numberOfEvaluationPeriod
	} else {
		periods.NumberOfEvaluationPeriods = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DynamicThresholdFailingPeriods populates the provided destination DynamicThresholdFailingPeriods from our DynamicThresholdFailingPeriods
func (periods *DynamicThresholdFailingPeriods) AssignProperties_To_DynamicThresholdFailingPeriods(destination *v20180301s.DynamicThresholdFailingPeriods) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MinFailingPeriodsToAlert
	if periods.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *periods.MinFailingPeriodsToAlert
		destination.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	} else {
		destination.MinFailingPeriodsToAlert = nil
	}

	// NumberOfEvaluationPeriods
	if periods.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriod := *periods.NumberOfEvaluationPeriods
		destination.NumberOfEvaluationPeriods = &numberOfEvaluationPeriod
	} else {
		destination.NumberOfEvaluationPeriods = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DynamicThresholdFailingPeriods_STATUS populates our DynamicThresholdFailingPeriods from the provided source DynamicThresholdFailingPeriods_STATUS
func (periods *DynamicThresholdFailingPeriods) Initialize_From_DynamicThresholdFailingPeriods_STATUS(source *DynamicThresholdFailingPeriods_STATUS) error {

	// MinFailingPeriodsToAlert
	if source.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *source.MinFailingPeriodsToAlert
		periods.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	} else {
		periods.MinFailingPeriodsToAlert = nil
	}

	// NumberOfEvaluationPeriods
	if source.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriod := *source.NumberOfEvaluationPeriods
		periods.NumberOfEvaluationPeriods = &numberOfEvaluationPeriod
	} else {
		periods.NumberOfEvaluationPeriods = nil
	}

	// No error
	return nil
}

// The minimum number of violations required within the selected lookback time window required to raise an alert.
type DynamicThresholdFailingPeriods_STATUS struct {
	// MinFailingPeriodsToAlert: The number of violations to trigger an alert. Should be smaller or equal to
	// numberOfEvaluationPeriods.
	MinFailingPeriodsToAlert *float64 `json:"minFailingPeriodsToAlert,omitempty"`

	// NumberOfEvaluationPeriods: The number of aggregated lookback points. The lookback time window is calculated based on the
	// aggregation granularity (windowSize) and the selected number of aggregated points.
	NumberOfEvaluationPeriods *float64 `json:"numberOfEvaluationPeriods,omitempty"`
}

var _ genruntime.FromARMConverter = &DynamicThresholdFailingPeriods_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (periods *DynamicThresholdFailingPeriods_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DynamicThresholdFailingPeriods_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (periods *DynamicThresholdFailingPeriods_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DynamicThresholdFailingPeriods_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DynamicThresholdFailingPeriods_STATUS_ARM, got %T", armInput)
	}

	// Set property "MinFailingPeriodsToAlert":
	if typedInput.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *typedInput.MinFailingPeriodsToAlert
		periods.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	}

	// Set property "NumberOfEvaluationPeriods":
	if typedInput.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriods := *typedInput.NumberOfEvaluationPeriods
		periods.NumberOfEvaluationPeriods = &numberOfEvaluationPeriods
	}

	// No error
	return nil
}

// AssignProperties_From_DynamicThresholdFailingPeriods_STATUS populates our DynamicThresholdFailingPeriods_STATUS from the provided source DynamicThresholdFailingPeriods_STATUS
func (periods *DynamicThresholdFailingPeriods_STATUS) AssignProperties_From_DynamicThresholdFailingPeriods_STATUS(source *v20180301s.DynamicThresholdFailingPeriods_STATUS) error {

	// MinFailingPeriodsToAlert
	if source.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *source.MinFailingPeriodsToAlert
		periods.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	} else {
		periods.MinFailingPeriodsToAlert = nil
	}

	// NumberOfEvaluationPeriods
	if source.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriod := *source.NumberOfEvaluationPeriods
		periods.NumberOfEvaluationPeriods = &numberOfEvaluationPeriod
	} else {
		periods.NumberOfEvaluationPeriods = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DynamicThresholdFailingPeriods_STATUS populates the provided destination DynamicThresholdFailingPeriods_STATUS from our DynamicThresholdFailingPeriods_STATUS
func (periods *DynamicThresholdFailingPeriods_STATUS) AssignProperties_To_DynamicThresholdFailingPeriods_STATUS(destination *v20180301s.DynamicThresholdFailingPeriods_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MinFailingPeriodsToAlert
	if periods.MinFailingPeriodsToAlert != nil {
		minFailingPeriodsToAlert := *periods.MinFailingPeriodsToAlert
		destination.MinFailingPeriodsToAlert = &minFailingPeriodsToAlert
	} else {
		destination.MinFailingPeriodsToAlert = nil
	}

	// NumberOfEvaluationPeriods
	if periods.NumberOfEvaluationPeriods != nil {
		numberOfEvaluationPeriod := *periods.NumberOfEvaluationPeriods
		destination.NumberOfEvaluationPeriods = &numberOfEvaluationPeriod
	} else {
		destination.NumberOfEvaluationPeriods = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&MetricAlert{}, &MetricAlertList{})
}
